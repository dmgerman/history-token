multiline_comment|/*&n; * mm/rmap.c - physical to virtual reverse mappings&n; *&n; * Copyright 2001, Rik van Riel &lt;riel@conectiva.com.br&gt;&n; * Released under the General Public License (GPL).&n; *&n; *&n; * Simple, low overhead pte-based reverse mapping scheme.&n; * This is kept modular because we may want to experiment&n; * with object-based reverse mapping schemes. Please try&n; * to keep this thing as modular as possible.&n; */
multiline_comment|/*&n; * Locking:&n; * - the page-&gt;pte.chain is protected by the PG_maplock bit,&n; *   which nests within the the mm-&gt;page_table_lock,&n; *   which nests within the page lock.&n; * - because swapout locking is opposite to the locking order&n; *   in the page fault path, the swapout path uses trylocks&n; *   on the mm-&gt;page_table_lock&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/swapops.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/rmap.h&gt;
macro_line|#include &lt;linux/cache.h&gt;
macro_line|#include &lt;linux/percpu.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/rmap.h&gt;
macro_line|#include &lt;asm/tlb.h&gt;
macro_line|#include &lt;asm/tlbflush.h&gt;
multiline_comment|/*&n; * Something oopsable to put for now in the page-&gt;mapping&n; * of an anonymous page, to test that it is ignored.&n; */
DECL|macro|ANON_MAPPING_DEBUG
mdefine_line|#define ANON_MAPPING_DEBUG&t;((struct address_space *) 0)
DECL|function|clear_page_anon
r_static
r_inline
r_void
id|clear_page_anon
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|BUG_ON
c_func
(paren
id|page-&gt;mapping
op_ne
id|ANON_MAPPING_DEBUG
)paren
suffix:semicolon
id|page-&gt;mapping
op_assign
l_int|NULL
suffix:semicolon
id|ClearPageAnon
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Shared pages have a chain of pte_chain structures, used to locate&n; * all the mappings to this page. We only need a pointer to the pte&n; * here, the page struct for the page table page contains the process&n; * it belongs to and the offset within that process.&n; *&n; * We use an array of pte pointers in this structure to minimise cache misses&n; * while traversing reverse maps.&n; */
DECL|macro|NRPTE
mdefine_line|#define NRPTE ((L1_CACHE_BYTES - sizeof(unsigned long))/sizeof(pte_addr_t))
multiline_comment|/*&n; * next_and_idx encodes both the address of the next pte_chain and the&n; * offset of the lowest-index used pte in ptes[] (which is equal also&n; * to the offset of the highest-index unused pte in ptes[], plus one).&n; */
DECL|struct|pte_chain
r_struct
id|pte_chain
(brace
DECL|member|next_and_idx
r_int
r_int
id|next_and_idx
suffix:semicolon
DECL|member|ptes
id|pte_addr_t
id|ptes
(braket
id|NRPTE
)braket
suffix:semicolon
DECL|variable|____cacheline_aligned
)brace
id|____cacheline_aligned
suffix:semicolon
DECL|variable|pte_chain_cache
id|kmem_cache_t
op_star
id|pte_chain_cache
suffix:semicolon
DECL|function|pte_chain_next
r_static
r_inline
r_struct
id|pte_chain
op_star
id|pte_chain_next
c_func
(paren
r_struct
id|pte_chain
op_star
id|pte_chain
)paren
(brace
r_return
(paren
r_struct
id|pte_chain
op_star
)paren
(paren
id|pte_chain-&gt;next_and_idx
op_amp
op_complement
id|NRPTE
)paren
suffix:semicolon
)brace
DECL|function|pte_chain_ptr
r_static
r_inline
r_struct
id|pte_chain
op_star
id|pte_chain_ptr
c_func
(paren
r_int
r_int
id|pte_chain_addr
)paren
(brace
r_return
(paren
r_struct
id|pte_chain
op_star
)paren
(paren
id|pte_chain_addr
op_amp
op_complement
id|NRPTE
)paren
suffix:semicolon
)brace
DECL|function|pte_chain_idx
r_static
r_inline
r_int
id|pte_chain_idx
c_func
(paren
r_struct
id|pte_chain
op_star
id|pte_chain
)paren
(brace
r_return
id|pte_chain-&gt;next_and_idx
op_amp
id|NRPTE
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
DECL|function|pte_chain_encode
id|pte_chain_encode
c_func
(paren
r_struct
id|pte_chain
op_star
id|pte_chain
comma
r_int
id|idx
)paren
(brace
r_return
(paren
r_int
r_int
)paren
id|pte_chain
op_or
id|idx
suffix:semicolon
)brace
multiline_comment|/*&n; * pte_chain list management policy:&n; *&n; * - If a page has a pte_chain list then it is shared by at least two processes,&n; *   because a single sharing uses PageDirect. (Well, this isn&squot;t true yet,&n; *   coz this code doesn&squot;t collapse singletons back to PageDirect on the remove&n; *   path).&n; * - A pte_chain list has free space only in the head member - all succeeding&n; *   members are 100% full.&n; * - If the head element has free space, it occurs in its leading slots.&n; * - All free space in the pte_chain is at the start of the head member.&n; * - Insertion into the pte_chain puts a pte pointer in the last free slot of&n; *   the head member.&n; * - Removal from a pte chain moves the head pte of the head member onto the&n; *   victim pte and frees the head member if it became empty.&n; */
multiline_comment|/**&n; ** VM stuff below this comment&n; **/
multiline_comment|/*&n; * At what user virtual address is pgoff expected in file-backed vma?&n; */
r_static
r_inline
DECL|function|vma_address
r_int
r_int
id|vma_address
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
id|pgoff_t
id|pgoff
)paren
(brace
r_int
r_int
id|address
suffix:semicolon
id|address
op_assign
id|vma-&gt;vm_start
op_plus
(paren
(paren
id|pgoff
op_minus
id|vma-&gt;vm_pgoff
)paren
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
r_return
(paren
id|address
op_ge
id|vma-&gt;vm_start
op_logical_and
id|address
OL
id|vma-&gt;vm_end
)paren
ques
c_cond
id|address
suffix:colon
op_minus
id|EFAULT
suffix:semicolon
)brace
DECL|function|page_referenced_one
r_static
r_int
id|page_referenced_one
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|address
comma
r_int
r_int
op_star
id|mapcount
comma
r_int
op_star
id|failed
)paren
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
id|referenced
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * For debug we&squot;re currently warning if not all found,&n;&t;&t; * but in this case that&squot;s expected: suppress warning.&n;&t;&t; */
(paren
op_star
id|failed
)paren
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pgd_present
c_func
(paren
op_star
id|pgd
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmd_present
c_func
(paren
op_star
id|pmd
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|pte
op_assign
id|pte_offset_map
c_func
(paren
id|pmd
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte_present
c_func
(paren
op_star
id|pte
)paren
)paren
r_goto
id|out_unmap
suffix:semicolon
r_if
c_cond
(paren
id|page_to_pfn
c_func
(paren
id|page
)paren
op_ne
id|pte_pfn
c_func
(paren
op_star
id|pte
)paren
)paren
r_goto
id|out_unmap
suffix:semicolon
r_if
c_cond
(paren
id|ptep_test_and_clear_young
c_func
(paren
id|pte
)paren
)paren
id|referenced
op_increment
suffix:semicolon
(paren
op_star
id|mapcount
)paren
op_decrement
suffix:semicolon
id|out_unmap
suffix:colon
id|pte_unmap
c_func
(paren
id|pte
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_return
id|referenced
suffix:semicolon
)brace
multiline_comment|/**&n; * page_referenced_file - referenced check for object-based rmap&n; * @page: the page we&squot;re checking references on.&n; *&n; * For an object-based mapped page, find all the places it is mapped and&n; * check/clear the referenced flag.  This is done by following the page-&gt;mapping&n; * pointer, then walking the chain of vmas it holds.  It returns the number&n; * of references it found.&n; *&n; * This function is only called from page_referenced for object-based pages.&n; *&n; * The semaphore address_space-&gt;i_shared_sem is tried.  If it can&squot;t be gotten,&n; * assume a reference count of 0, so try_to_unmap will then have a go.&n; */
DECL|function|page_referenced_file
r_static
r_inline
r_int
id|page_referenced_file
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
r_int
id|mapcount
op_assign
id|page-&gt;pte.mapcount
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page-&gt;mapping
suffix:semicolon
id|pgoff_t
id|pgoff
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|PAGE_SHIFT
)paren
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
r_int
id|referenced
op_assign
l_int|0
suffix:semicolon
r_int
id|failed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|down_trylock
c_func
(paren
op_amp
id|mapping-&gt;i_shared_sem
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|vma
comma
op_amp
id|mapping-&gt;i_mmap
comma
id|shared
)paren
(brace
id|address
op_assign
id|vma_address
c_func
(paren
id|vma
comma
id|pgoff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|address
op_eq
op_minus
id|EFAULT
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vma-&gt;vm_flags
op_amp
(paren
id|VM_LOCKED
op_or
id|VM_MAYSHARE
)paren
)paren
op_eq
(paren
id|VM_LOCKED
op_or
id|VM_MAYSHARE
)paren
)paren
(brace
id|referenced
op_increment
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vma-&gt;vm_mm-&gt;rss
)paren
(brace
id|referenced
op_add_assign
id|page_referenced_one
c_func
(paren
id|page
comma
id|vma-&gt;vm_mm
comma
id|address
comma
op_amp
id|mapcount
comma
op_amp
id|failed
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mapcount
)paren
r_goto
id|out
suffix:semicolon
)brace
)brace
id|list_for_each_entry
c_func
(paren
id|vma
comma
op_amp
id|mapping-&gt;i_mmap_shared
comma
id|shared
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_NONLINEAR
)paren
)paren
(brace
id|failed
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|address
op_assign
id|vma_address
c_func
(paren
id|vma
comma
id|pgoff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|address
op_eq
op_minus
id|EFAULT
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
(paren
id|VM_LOCKED
op_or
id|VM_RESERVED
)paren
)paren
(brace
id|referenced
op_increment
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vma-&gt;vm_mm-&gt;rss
)paren
(brace
id|referenced
op_add_assign
id|page_referenced_one
c_func
(paren
id|page
comma
id|vma-&gt;vm_mm
comma
id|address
comma
op_amp
id|mapcount
comma
op_amp
id|failed
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mapcount
)paren
r_goto
id|out
suffix:semicolon
)brace
)brace
id|WARN_ON
c_func
(paren
op_logical_neg
id|failed
)paren
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|mapping-&gt;i_shared_sem
)paren
suffix:semicolon
r_return
id|referenced
suffix:semicolon
)brace
multiline_comment|/**&n; * page_referenced - test if the page was referenced&n; * @page: the page to test&n; *&n; * Quick test_and_clear_referenced for all mappings to a page,&n; * returns the number of processes which referenced the page.&n; * Caller needs to hold the rmap lock.&n; *&n; * If the page has a single-entry pte_chain, collapse that back to a PageDirect&n; * representation.  This way, it&squot;s only done under memory pressure.&n; */
DECL|function|page_referenced
r_int
id|fastcall
id|page_referenced
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|pte_chain
op_star
id|pc
suffix:semicolon
r_int
id|referenced
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|page_test_and_clear_young
c_func
(paren
id|page
)paren
)paren
id|referenced
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|TestClearPageReferenced
c_func
(paren
id|page
)paren
)paren
id|referenced
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageAnon
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
id|page_mapped
c_func
(paren
id|page
)paren
op_logical_and
id|page-&gt;mapping
)paren
id|referenced
op_add_assign
id|page_referenced_file
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PageDirect
c_func
(paren
id|page
)paren
)paren
(brace
id|pte_t
op_star
id|pte
op_assign
id|rmap_ptep_map
c_func
(paren
id|page-&gt;pte.direct
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptep_test_and_clear_young
c_func
(paren
id|pte
)paren
)paren
id|referenced
op_increment
suffix:semicolon
id|rmap_ptep_unmap
c_func
(paren
id|pte
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|nr_chains
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Check all the page tables mapping this page. */
r_for
c_loop
(paren
id|pc
op_assign
id|page-&gt;pte.chain
suffix:semicolon
id|pc
suffix:semicolon
id|pc
op_assign
id|pte_chain_next
c_func
(paren
id|pc
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|pte_chain_idx
c_func
(paren
id|pc
)paren
suffix:semicolon
id|i
OL
id|NRPTE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pte_addr_t
id|pte_paddr
op_assign
id|pc-&gt;ptes
(braket
id|i
)braket
suffix:semicolon
id|pte_t
op_star
id|p
suffix:semicolon
id|p
op_assign
id|rmap_ptep_map
c_func
(paren
id|pte_paddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptep_test_and_clear_young
c_func
(paren
id|p
)paren
)paren
id|referenced
op_increment
suffix:semicolon
id|rmap_ptep_unmap
c_func
(paren
id|p
)paren
suffix:semicolon
id|nr_chains
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|nr_chains
op_eq
l_int|1
)paren
(brace
id|pc
op_assign
id|page-&gt;pte.chain
suffix:semicolon
id|page-&gt;pte.direct
op_assign
id|pc-&gt;ptes
(braket
id|NRPTE
op_minus
l_int|1
)braket
suffix:semicolon
id|SetPageDirect
c_func
(paren
id|page
)paren
suffix:semicolon
id|pc-&gt;ptes
(braket
id|NRPTE
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|__pte_chain_free
c_func
(paren
id|pc
)paren
suffix:semicolon
)brace
)brace
r_return
id|referenced
suffix:semicolon
)brace
multiline_comment|/**&n; * page_add_rmap - add reverse mapping entry to an anonymous page&n; * @page: the page to add the mapping to&n; * @ptep: the page table entry mapping this page&n; *&n; * Add a new pte reverse mapping to a page.&n; * The caller needs to hold the mm-&gt;page_table_lock.&n; */
r_struct
id|pte_chain
op_star
id|fastcall
DECL|function|page_add_rmap
id|page_add_rmap
c_func
(paren
r_struct
id|page
op_star
id|page
comma
id|pte_t
op_star
id|ptep
comma
r_struct
id|pte_chain
op_star
id|pte_chain
)paren
(brace
id|pte_addr_t
id|pte_paddr
op_assign
id|ptep_to_paddr
c_func
(paren
id|ptep
)paren
suffix:semicolon
r_struct
id|pte_chain
op_star
id|cur_pte_chain
suffix:semicolon
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|page
)paren
)paren
r_return
id|pte_chain
suffix:semicolon
id|page_map_lock
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;pte.direct
op_eq
l_int|0
)paren
(brace
id|page-&gt;pte.direct
op_assign
id|pte_paddr
suffix:semicolon
id|SetPageDirect
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageAnon
c_func
(paren
id|page
)paren
suffix:semicolon
id|page-&gt;mapping
op_assign
id|ANON_MAPPING_DEBUG
suffix:semicolon
id|inc_page_state
c_func
(paren
id|nr_mapped
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PageDirect
c_func
(paren
id|page
)paren
)paren
(brace
multiline_comment|/* Convert a direct pointer into a pte_chain */
id|ClearPageDirect
c_func
(paren
id|page
)paren
suffix:semicolon
id|pte_chain-&gt;ptes
(braket
id|NRPTE
op_minus
l_int|1
)braket
op_assign
id|page-&gt;pte.direct
suffix:semicolon
id|pte_chain-&gt;ptes
(braket
id|NRPTE
op_minus
l_int|2
)braket
op_assign
id|pte_paddr
suffix:semicolon
id|pte_chain-&gt;next_and_idx
op_assign
id|pte_chain_encode
c_func
(paren
l_int|NULL
comma
id|NRPTE
op_minus
l_int|2
)paren
suffix:semicolon
id|page-&gt;pte.direct
op_assign
l_int|0
suffix:semicolon
id|page-&gt;pte.chain
op_assign
id|pte_chain
suffix:semicolon
id|pte_chain
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* We consumed it */
r_goto
id|out
suffix:semicolon
)brace
id|cur_pte_chain
op_assign
id|page-&gt;pte.chain
suffix:semicolon
r_if
c_cond
(paren
id|cur_pte_chain-&gt;ptes
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* It&squot;s full */
id|pte_chain-&gt;next_and_idx
op_assign
id|pte_chain_encode
c_func
(paren
id|cur_pte_chain
comma
id|NRPTE
op_minus
l_int|1
)paren
suffix:semicolon
id|page-&gt;pte.chain
op_assign
id|pte_chain
suffix:semicolon
id|pte_chain-&gt;ptes
(braket
id|NRPTE
op_minus
l_int|1
)braket
op_assign
id|pte_paddr
suffix:semicolon
id|pte_chain
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* We consumed it */
r_goto
id|out
suffix:semicolon
)brace
id|cur_pte_chain-&gt;ptes
(braket
id|pte_chain_idx
c_func
(paren
id|cur_pte_chain
)paren
op_minus
l_int|1
)braket
op_assign
id|pte_paddr
suffix:semicolon
id|cur_pte_chain-&gt;next_and_idx
op_decrement
suffix:semicolon
id|out
suffix:colon
id|page_map_unlock
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|pte_chain
suffix:semicolon
)brace
multiline_comment|/**&n; * page_add_file_rmap - add pte mapping to a file page&n; * @page: the page to add the mapping to&n; *&n; * The caller needs to hold the mm-&gt;page_table_lock.&n; */
DECL|function|page_add_file_rmap
r_void
id|fastcall
id|page_add_file_rmap
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|BUG_ON
c_func
(paren
id|PageAnon
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pfn_valid
c_func
(paren
id|page_to_pfn
c_func
(paren
id|page
)paren
)paren
op_logical_or
id|PageReserved
c_func
(paren
id|page
)paren
)paren
r_return
suffix:semicolon
id|page_map_lock
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_mapped
c_func
(paren
id|page
)paren
)paren
id|inc_page_state
c_func
(paren
id|nr_mapped
)paren
suffix:semicolon
id|page-&gt;pte.mapcount
op_increment
suffix:semicolon
id|page_map_unlock
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * page_remove_rmap - take down reverse mapping to a page&n; * @page: page to remove mapping from&n; * @ptep: page table entry to remove&n; *&n; * Removes the reverse mapping from the pte_chain of the page,&n; * after that the caller can clear the page table entry and free&n; * the page.&n; * Caller needs to hold the mm-&gt;page_table_lock.&n; */
DECL|function|page_remove_rmap
r_void
id|fastcall
id|page_remove_rmap
c_func
(paren
r_struct
id|page
op_star
id|page
comma
id|pte_t
op_star
id|ptep
)paren
(brace
id|pte_addr_t
id|pte_paddr
op_assign
id|ptep_to_paddr
c_func
(paren
id|ptep
)paren
suffix:semicolon
r_struct
id|pte_chain
op_star
id|pc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pfn_valid
c_func
(paren
id|page_to_pfn
c_func
(paren
id|page
)paren
)paren
op_logical_or
id|PageReserved
c_func
(paren
id|page
)paren
)paren
r_return
suffix:semicolon
id|page_map_lock
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_mapped
c_func
(paren
id|page
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/* remap_page_range() from a driver? */
r_if
c_cond
(paren
op_logical_neg
id|PageAnon
c_func
(paren
id|page
)paren
)paren
(brace
id|page-&gt;pte.mapcount
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PageDirect
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
id|page-&gt;pte.direct
op_eq
id|pte_paddr
)paren
(brace
id|page-&gt;pte.direct
op_assign
l_int|0
suffix:semicolon
id|ClearPageDirect
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
(brace
r_struct
id|pte_chain
op_star
id|start
op_assign
id|page-&gt;pte.chain
suffix:semicolon
r_struct
id|pte_chain
op_star
id|next
suffix:semicolon
r_int
id|victim_i
op_assign
id|pte_chain_idx
c_func
(paren
id|start
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pc
op_assign
id|start
suffix:semicolon
id|pc
suffix:semicolon
id|pc
op_assign
id|next
)paren
(brace
r_int
id|i
suffix:semicolon
id|next
op_assign
id|pte_chain_next
c_func
(paren
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
id|prefetch
c_func
(paren
id|next
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|pte_chain_idx
c_func
(paren
id|pc
)paren
suffix:semicolon
id|i
OL
id|NRPTE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pte_addr_t
id|pa
op_assign
id|pc-&gt;ptes
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pa
op_ne
id|pte_paddr
)paren
r_continue
suffix:semicolon
id|pc-&gt;ptes
(braket
id|i
)braket
op_assign
id|start-&gt;ptes
(braket
id|victim_i
)braket
suffix:semicolon
id|start-&gt;ptes
(braket
id|victim_i
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|victim_i
op_eq
id|NRPTE
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Emptied a pte_chain */
id|page-&gt;pte.chain
op_assign
id|pte_chain_next
c_func
(paren
id|start
)paren
suffix:semicolon
id|__pte_chain_free
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
r_else
(brace
id|start-&gt;next_and_idx
op_increment
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
)brace
)brace
id|out
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|page_mapped
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
id|page_test_and_clear_dirty
c_func
(paren
id|page
)paren
)paren
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageAnon
c_func
(paren
id|page
)paren
)paren
id|clear_page_anon
c_func
(paren
id|page
)paren
suffix:semicolon
id|dec_page_state
c_func
(paren
id|nr_mapped
)paren
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|page_map_unlock
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * try_to_unmap_anon_one - worker function for try_to_unmap&n; * @page: page to unmap&n; * @ptep: page table entry to unmap from page&n; *&n; * Internal helper function for try_to_unmap, called for each page&n; * table entry mapping a page. Because locking order here is opposite&n; * to the locking order used by the page fault path, we use trylocks.&n; * Locking:&n; *&t;    page lock&t;&t;&t;shrink_list(), trylock&n; *&t;&t;rmap lock&t;&t;shrink_list()&n; *&t;&t;    mm-&gt;page_table_lock&t;try_to_unmap_one(), trylock&n; */
DECL|function|try_to_unmap_anon_one
r_static
r_int
id|fastcall
id|try_to_unmap_anon_one
c_func
(paren
r_struct
id|page
op_star
id|page
comma
id|pte_addr_t
id|paddr
)paren
(brace
id|pte_t
op_star
id|ptep
op_assign
id|rmap_ptep_map
c_func
(paren
id|paddr
)paren
suffix:semicolon
r_int
r_int
id|address
op_assign
id|ptep_to_address
c_func
(paren
id|ptep
)paren
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|ptep_to_mm
c_func
(paren
id|ptep
)paren
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
id|pte_t
id|pte
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mm
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We need the page_table_lock to protect us from page faults,&n;&t; * munmap, fork, etc...&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
)paren
(brace
id|rmap_ptep_unmap
c_func
(paren
id|ptep
)paren
suffix:semicolon
r_return
id|SWAP_AGAIN
suffix:semicolon
)brace
multiline_comment|/* unmap_vmas drops page_table_lock with vma unlinked */
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
(brace
id|ret
op_assign
id|SWAP_FAIL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* The page is mlock()d, we cannot swap it out. */
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_LOCKED
)paren
(brace
id|ret
op_assign
id|SWAP_FAIL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* Nuke the page table entry. */
id|flush_cache_page
c_func
(paren
id|vma
comma
id|address
)paren
suffix:semicolon
id|pte
op_assign
id|ptep_clear_flush
c_func
(paren
id|vma
comma
id|address
comma
id|ptep
)paren
suffix:semicolon
(brace
id|swp_entry_t
id|entry
op_assign
(brace
dot
id|val
op_assign
id|page
op_member_access_from_pointer
r_private
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Store the swap location in the pte.&n;&t;&t; * See handle_pte_fault() ...&n;&t;&t; */
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|swap_duplicate
c_func
(paren
id|entry
)paren
suffix:semicolon
id|set_pte
c_func
(paren
id|ptep
comma
id|swp_entry_to_pte
c_func
(paren
id|entry
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|pte_file
c_func
(paren
op_star
id|ptep
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Move the dirty bit to the physical page now the pte is gone. */
r_if
c_cond
(paren
id|pte_dirty
c_func
(paren
id|pte
)paren
)paren
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|mm-&gt;rss
op_decrement
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|ret
op_assign
id|SWAP_SUCCESS
suffix:semicolon
id|out_unlock
suffix:colon
id|rmap_ptep_unmap
c_func
(paren
id|ptep
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|try_to_unmap_one
r_static
r_int
id|try_to_unmap_one
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|address
comma
r_int
r_int
op_star
id|mapcount
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
id|pte_t
id|pteval
suffix:semicolon
r_int
id|ret
op_assign
id|SWAP_AGAIN
suffix:semicolon
multiline_comment|/*&n;&t; * We need the page_table_lock to protect us from page faults,&n;&t; * munmap, fork, etc...&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
)paren
r_goto
id|out
suffix:semicolon
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pgd_present
c_func
(paren
op_star
id|pgd
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmd_present
c_func
(paren
op_star
id|pmd
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|pte
op_assign
id|pte_offset_map
c_func
(paren
id|pmd
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte_present
c_func
(paren
op_star
id|pte
)paren
)paren
r_goto
id|out_unmap
suffix:semicolon
r_if
c_cond
(paren
id|page_to_pfn
c_func
(paren
id|page
)paren
op_ne
id|pte_pfn
c_func
(paren
op_star
id|pte
)paren
)paren
r_goto
id|out_unmap
suffix:semicolon
(paren
op_star
id|mapcount
)paren
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t; * If the page is mlock()d, we cannot swap it out.&n;&t; * If it&squot;s recently referenced (perhaps page_referenced&n;&t; * skipped over this mm) then we should reactivate it.&n;&t; */
r_if
c_cond
(paren
(paren
id|vma-&gt;vm_flags
op_amp
(paren
id|VM_LOCKED
op_or
id|VM_RESERVED
)paren
)paren
op_logical_or
id|ptep_test_and_clear_young
c_func
(paren
id|pte
)paren
)paren
(brace
id|ret
op_assign
id|SWAP_FAIL
suffix:semicolon
r_goto
id|out_unmap
suffix:semicolon
)brace
multiline_comment|/* Nuke the page table entry. */
id|flush_cache_page
c_func
(paren
id|vma
comma
id|address
)paren
suffix:semicolon
id|pteval
op_assign
id|ptep_clear_flush
c_func
(paren
id|vma
comma
id|address
comma
id|pte
)paren
suffix:semicolon
multiline_comment|/* Move the dirty bit to the physical page now the pte is gone. */
r_if
c_cond
(paren
id|pte_dirty
c_func
(paren
id|pteval
)paren
)paren
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|mm-&gt;rss
op_decrement
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|page-&gt;pte.mapcount
)paren
suffix:semicolon
id|page-&gt;pte.mapcount
op_decrement
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|out_unmap
suffix:colon
id|pte_unmap
c_func
(paren
id|pte
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * objrmap doesn&squot;t work for nonlinear VMAs because the assumption that&n; * offset-into-file correlates with offset-into-virtual-addresses does not hold.&n; * Consequently, given a particular page and its -&gt;index, we cannot locate the&n; * ptes which are mapping that page without an exhaustive linear search.&n; *&n; * So what this code does is a mini &quot;virtual scan&quot; of each nonlinear VMA which&n; * maps the file to which the target page belongs.  The -&gt;vm_private_data field&n; * holds the current cursor into that scan.  Successive searches will circulate&n; * around the vma&squot;s virtual address space.&n; *&n; * So as more replacement pressure is applied to the pages in a nonlinear VMA,&n; * more scanning pressure is placed against them as well.   Eventually pages&n; * will become fully unmapped and are eligible for eviction.&n; *&n; * For very sparsely populated VMAs this is a little inefficient - chances are&n; * there there won&squot;t be many ptes located within the scan cluster.  In this case&n; * maybe we could scan further - to the end of the pte page, perhaps.&n; */
DECL|macro|CLUSTER_SIZE
mdefine_line|#define CLUSTER_SIZE&t;(32 * PAGE_SIZE)
macro_line|#if     CLUSTER_SIZE  &gt;&t;PMD_SIZE
DECL|macro|CLUSTER_SIZE
macro_line|#undef  CLUSTER_SIZE
DECL|macro|CLUSTER_SIZE
mdefine_line|#define CLUSTER_SIZE&t;PMD_SIZE
macro_line|#endif
DECL|macro|CLUSTER_MASK
mdefine_line|#define CLUSTER_MASK&t;(~(CLUSTER_SIZE - 1))
DECL|function|try_to_unmap_cluster
r_static
r_int
id|try_to_unmap_cluster
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|cursor
comma
r_int
r_int
op_star
id|mapcount
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
id|pte_t
id|pteval
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
r_int
r_int
id|pfn
suffix:semicolon
multiline_comment|/*&n;&t; * We need the page_table_lock to protect us from page faults,&n;&t; * munmap, fork, etc...&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
)paren
r_return
id|SWAP_FAIL
suffix:semicolon
id|address
op_assign
(paren
id|vma-&gt;vm_start
op_plus
id|cursor
)paren
op_amp
id|CLUSTER_MASK
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|CLUSTER_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|address
OL
id|vma-&gt;vm_start
)paren
id|address
op_assign
id|vma-&gt;vm_start
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|vma-&gt;vm_end
)paren
id|end
op_assign
id|vma-&gt;vm_end
suffix:semicolon
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pgd_present
c_func
(paren
op_star
id|pgd
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmd_present
c_func
(paren
op_star
id|pmd
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
r_for
c_loop
(paren
id|pte
op_assign
id|pte_offset_map
c_func
(paren
id|pmd
comma
id|address
)paren
suffix:semicolon
id|address
OL
id|end
suffix:semicolon
id|pte
op_increment
comma
id|address
op_add_assign
id|PAGE_SIZE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pte_present
c_func
(paren
op_star
id|pte
)paren
)paren
r_continue
suffix:semicolon
id|pfn
op_assign
id|pte_pfn
c_func
(paren
op_star
id|pte
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pfn_valid
c_func
(paren
id|pfn
)paren
)paren
r_continue
suffix:semicolon
id|page
op_assign
id|pfn_to_page
c_func
(paren
id|pfn
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|PageAnon
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|page
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ptep_test_and_clear_young
c_func
(paren
id|pte
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Nuke the page table entry. */
id|flush_cache_page
c_func
(paren
id|vma
comma
id|address
)paren
suffix:semicolon
id|pteval
op_assign
id|ptep_clear_flush
c_func
(paren
id|vma
comma
id|address
comma
id|pte
)paren
suffix:semicolon
multiline_comment|/* If nonlinear, store the file page offset in the pte. */
r_if
c_cond
(paren
id|page-&gt;index
op_ne
id|linear_page_index
c_func
(paren
id|vma
comma
id|address
)paren
)paren
id|set_pte
c_func
(paren
id|pte
comma
id|pgoff_to_pte
c_func
(paren
id|page-&gt;index
)paren
)paren
suffix:semicolon
multiline_comment|/* Move the dirty bit to the physical page now the pte is gone. */
r_if
c_cond
(paren
id|pte_dirty
c_func
(paren
id|pteval
)paren
)paren
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_remove_rmap
c_func
(paren
id|page
comma
id|pte
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|mm-&gt;rss
op_decrement
suffix:semicolon
(paren
op_star
id|mapcount
)paren
op_decrement
suffix:semicolon
)brace
id|pte_unmap
c_func
(paren
id|pte
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_return
id|SWAP_AGAIN
suffix:semicolon
)brace
multiline_comment|/**&n; * try_to_unmap_file - unmap file page using the object-based rmap method&n; * @page: the page to unmap&n; *&n; * Find all the mappings of a page using the mapping pointer and the vma chains&n; * contained in the address_space struct it points to.&n; *&n; * This function is only called from try_to_unmap for object-based pages.&n; *&n; * The semaphore address_space-&gt;i_shared_sem is tried.  If it can&squot;t be gotten,&n; * return a temporary error.&n; */
DECL|function|try_to_unmap_file
r_static
r_inline
r_int
id|try_to_unmap_file
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
r_int
id|mapcount
op_assign
id|page-&gt;pte.mapcount
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page-&gt;mapping
suffix:semicolon
id|pgoff_t
id|pgoff
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|PAGE_SHIFT
)paren
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
r_int
id|ret
op_assign
id|SWAP_AGAIN
suffix:semicolon
r_int
r_int
id|cursor
suffix:semicolon
r_int
r_int
id|max_nl_cursor
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|max_nl_size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|down_trylock
c_func
(paren
op_amp
id|mapping-&gt;i_shared_sem
)paren
)paren
r_return
id|ret
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|vma
comma
op_amp
id|mapping-&gt;i_mmap
comma
id|shared
)paren
(brace
r_if
c_cond
(paren
id|vma-&gt;vm_mm-&gt;rss
)paren
(brace
id|address
op_assign
id|vma_address
c_func
(paren
id|vma
comma
id|pgoff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|address
op_eq
op_minus
id|EFAULT
)paren
r_continue
suffix:semicolon
id|ret
op_assign
id|try_to_unmap_one
c_func
(paren
id|page
comma
id|vma-&gt;vm_mm
comma
id|address
comma
op_amp
id|mapcount
comma
id|vma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|SWAP_FAIL
op_logical_or
op_logical_neg
id|mapcount
)paren
r_goto
id|out
suffix:semicolon
)brace
)brace
id|list_for_each_entry
c_func
(paren
id|vma
comma
op_amp
id|mapping-&gt;i_mmap_shared
comma
id|shared
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_NONLINEAR
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Defer unmapping nonlinear to the next loop,&n;&t;&t;&t; * but take notes while we&squot;re here e.g. don&squot;t&n;&t;&t;&t; * want to loop again when no nonlinear vmas.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
(paren
id|VM_LOCKED
op_or
id|VM_RESERVED
)paren
)paren
r_continue
suffix:semicolon
id|cursor
op_assign
(paren
r_int
r_int
)paren
id|vma-&gt;vm_private_data
suffix:semicolon
r_if
c_cond
(paren
id|cursor
OG
id|max_nl_cursor
)paren
id|max_nl_cursor
op_assign
id|cursor
suffix:semicolon
id|cursor
op_assign
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
suffix:semicolon
r_if
c_cond
(paren
id|cursor
OG
id|max_nl_size
)paren
id|max_nl_size
op_assign
id|cursor
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vma-&gt;vm_mm-&gt;rss
)paren
(brace
id|address
op_assign
id|vma_address
c_func
(paren
id|vma
comma
id|pgoff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|address
op_eq
op_minus
id|EFAULT
)paren
r_continue
suffix:semicolon
id|ret
op_assign
id|try_to_unmap_one
c_func
(paren
id|page
comma
id|vma-&gt;vm_mm
comma
id|address
comma
op_amp
id|mapcount
comma
id|vma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|SWAP_FAIL
op_logical_or
op_logical_neg
id|mapcount
)paren
r_goto
id|out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|max_nl_size
op_eq
l_int|0
)paren
multiline_comment|/* no nonlinear vmas of this file */
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * We don&squot;t try to search for this page in the nonlinear vmas,&n;&t; * and page_referenced wouldn&squot;t have found it anyway.  Instead&n;&t; * just walk the nonlinear vmas trying to age and unmap some.&n;&t; * The mapcount of the page we came in with is irrelevant,&n;&t; * but even so use it as a guide to how hard we should try?&n;&t; */
id|page_map_unlock
c_func
(paren
id|page
)paren
suffix:semicolon
id|max_nl_size
op_assign
(paren
id|max_nl_size
op_plus
id|CLUSTER_SIZE
op_minus
l_int|1
)paren
op_amp
id|CLUSTER_MASK
suffix:semicolon
r_if
c_cond
(paren
id|max_nl_cursor
op_eq
l_int|0
)paren
id|max_nl_cursor
op_assign
id|CLUSTER_SIZE
suffix:semicolon
r_do
(brace
id|list_for_each_entry
c_func
(paren
id|vma
comma
op_amp
id|mapping-&gt;i_mmap_shared
comma
id|shared
)paren
(brace
r_if
c_cond
(paren
id|VM_NONLINEAR
op_ne
(paren
id|vma-&gt;vm_flags
op_amp
(paren
id|VM_NONLINEAR
op_or
id|VM_LOCKED
op_or
id|VM_RESERVED
)paren
)paren
)paren
r_continue
suffix:semicolon
id|cursor
op_assign
(paren
r_int
r_int
)paren
id|vma-&gt;vm_private_data
suffix:semicolon
r_while
c_loop
(paren
id|vma-&gt;vm_mm-&gt;rss
op_logical_and
id|cursor
OL
id|max_nl_cursor
op_logical_and
id|cursor
OL
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
)paren
(brace
id|ret
op_assign
id|try_to_unmap_cluster
c_func
(paren
id|vma-&gt;vm_mm
comma
id|cursor
comma
op_amp
id|mapcount
comma
id|vma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|SWAP_FAIL
)paren
r_break
suffix:semicolon
id|cursor
op_add_assign
id|CLUSTER_SIZE
suffix:semicolon
id|vma-&gt;vm_private_data
op_assign
(paren
r_void
op_star
)paren
id|cursor
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|mapcount
op_le
l_int|0
)paren
r_goto
id|relock
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_ne
id|SWAP_FAIL
)paren
id|vma-&gt;vm_private_data
op_assign
(paren
r_void
op_star
)paren
id|max_nl_cursor
suffix:semicolon
id|ret
op_assign
id|SWAP_AGAIN
suffix:semicolon
)brace
id|max_nl_cursor
op_add_assign
id|CLUSTER_SIZE
suffix:semicolon
)brace
r_while
c_loop
(paren
id|max_nl_cursor
op_le
id|max_nl_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t loop forever (perhaps all the remaining pages are&n;&t; * in locked vmas).  Reset cursor on all unreserved nonlinear&n;&t; * vmas, now forgetting on which ones it had fallen behind.&n;&t; */
id|list_for_each_entry
c_func
(paren
id|vma
comma
op_amp
id|mapping-&gt;i_mmap_shared
comma
id|shared
)paren
(brace
r_if
c_cond
(paren
(paren
id|vma-&gt;vm_flags
op_amp
(paren
id|VM_NONLINEAR
op_or
id|VM_RESERVED
)paren
)paren
op_eq
id|VM_NONLINEAR
)paren
id|vma-&gt;vm_private_data
op_assign
l_int|0
suffix:semicolon
)brace
id|relock
suffix:colon
id|page_map_lock
c_func
(paren
id|page
)paren
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|mapping-&gt;i_shared_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * try_to_unmap - try to remove all page table mappings to a page&n; * @page: the page to get unmapped&n; *&n; * Tries to remove all the page table entries which are mapping this&n; * page, used in the pageout path.  Caller must hold the page lock&n; * and its rmap lock.  Return values are:&n; *&n; * SWAP_SUCCESS&t;- we succeeded in removing all mappings&n; * SWAP_AGAIN&t;- we missed a trylock, try again later&n; * SWAP_FAIL&t;- the page is unswappable&n; */
DECL|function|try_to_unmap
r_int
id|fastcall
id|try_to_unmap
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|pte_chain
op_star
id|pc
comma
op_star
id|next_pc
comma
op_star
id|start
suffix:semicolon
r_int
id|ret
op_assign
id|SWAP_SUCCESS
suffix:semicolon
r_int
id|victim_i
suffix:semicolon
id|BUG_ON
c_func
(paren
id|PageReserved
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|page_mapped
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageAnon
c_func
(paren
id|page
)paren
)paren
(brace
id|ret
op_assign
id|try_to_unmap_file
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PageDirect
c_func
(paren
id|page
)paren
)paren
(brace
id|ret
op_assign
id|try_to_unmap_anon_one
c_func
(paren
id|page
comma
id|page-&gt;pte.direct
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|SWAP_SUCCESS
)paren
(brace
id|page-&gt;pte.direct
op_assign
l_int|0
suffix:semicolon
id|ClearPageDirect
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
id|start
op_assign
id|page-&gt;pte.chain
suffix:semicolon
id|victim_i
op_assign
id|pte_chain_idx
c_func
(paren
id|start
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pc
op_assign
id|start
suffix:semicolon
id|pc
suffix:semicolon
id|pc
op_assign
id|next_pc
)paren
(brace
r_int
id|i
suffix:semicolon
id|next_pc
op_assign
id|pte_chain_next
c_func
(paren
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next_pc
)paren
id|prefetch
c_func
(paren
id|next_pc
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|pte_chain_idx
c_func
(paren
id|pc
)paren
suffix:semicolon
id|i
OL
id|NRPTE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pte_addr_t
id|pte_paddr
op_assign
id|pc-&gt;ptes
(braket
id|i
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|try_to_unmap_anon_one
c_func
(paren
id|page
comma
id|pte_paddr
)paren
)paren
(brace
r_case
id|SWAP_SUCCESS
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Release a slot.  If we&squot;re releasing the&n;&t;&t;&t;&t; * first pte in the first pte_chain then&n;&t;&t;&t;&t; * pc-&gt;ptes[i] and start-&gt;ptes[victim_i] both&n;&t;&t;&t;&t; * refer to the same thing.  It works out.&n;&t;&t;&t;&t; */
id|pc-&gt;ptes
(braket
id|i
)braket
op_assign
id|start-&gt;ptes
(braket
id|victim_i
)braket
suffix:semicolon
id|start-&gt;ptes
(braket
id|victim_i
)braket
op_assign
l_int|0
suffix:semicolon
id|victim_i
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|victim_i
op_eq
id|NRPTE
)paren
(brace
id|page-&gt;pte.chain
op_assign
id|pte_chain_next
c_func
(paren
id|start
)paren
suffix:semicolon
id|__pte_chain_free
c_func
(paren
id|start
)paren
suffix:semicolon
id|start
op_assign
id|page-&gt;pte.chain
suffix:semicolon
id|victim_i
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|start-&gt;next_and_idx
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SWAP_AGAIN
suffix:colon
multiline_comment|/* Skip this pte, remembering status. */
id|ret
op_assign
id|SWAP_AGAIN
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|SWAP_FAIL
suffix:colon
id|ret
op_assign
id|SWAP_FAIL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
)brace
id|out
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|page_mapped
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
id|page_test_and_clear_dirty
c_func
(paren
id|page
)paren
)paren
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageAnon
c_func
(paren
id|page
)paren
)paren
id|clear_page_anon
c_func
(paren
id|page
)paren
suffix:semicolon
id|dec_page_state
c_func
(paren
id|nr_mapped
)paren
suffix:semicolon
id|ret
op_assign
id|SWAP_SUCCESS
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; ** No more VM stuff below this comment, only pte_chain helper&n; ** functions.&n; **/
DECL|function|pte_chain_ctor
r_static
r_void
id|pte_chain_ctor
c_func
(paren
r_void
op_star
id|p
comma
id|kmem_cache_t
op_star
id|cachep
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|pte_chain
op_star
id|pc
op_assign
id|p
suffix:semicolon
id|memset
c_func
(paren
id|pc
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|pc
)paren
)paren
suffix:semicolon
)brace
id|DEFINE_PER_CPU
c_func
(paren
r_struct
id|pte_chain
op_star
comma
id|local_pte_chain
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/**&n; * __pte_chain_free - free pte_chain structure&n; * @pte_chain: pte_chain struct to free&n; */
DECL|function|__pte_chain_free
r_void
id|__pte_chain_free
c_func
(paren
r_struct
id|pte_chain
op_star
id|pte_chain
)paren
(brace
r_struct
id|pte_chain
op_star
op_star
id|pte_chainp
suffix:semicolon
id|pte_chainp
op_assign
op_amp
id|get_cpu_var
c_func
(paren
id|local_pte_chain
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_chain-&gt;next_and_idx
)paren
id|pte_chain-&gt;next_and_idx
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pte_chainp
)paren
id|kmem_cache_free
c_func
(paren
id|pte_chain_cache
comma
op_star
id|pte_chainp
)paren
suffix:semicolon
op_star
id|pte_chainp
op_assign
id|pte_chain
suffix:semicolon
id|put_cpu_var
c_func
(paren
id|local_pte_chain
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pte_chain_alloc(): allocate a pte_chain structure for use by page_add_rmap().&n; *&n; * The caller of page_add_rmap() must perform the allocation because&n; * page_add_rmap() is invariably called under spinlock.  Often, page_add_rmap()&n; * will not actually use the pte_chain, because there is space available in one&n; * of the existing pte_chains which are attached to the page.  So the case of&n; * allocating and then freeing a single pte_chain is specially optimised here,&n; * with a one-deep per-cpu cache.&n; */
DECL|function|pte_chain_alloc
r_struct
id|pte_chain
op_star
id|pte_chain_alloc
c_func
(paren
r_int
id|gfp_flags
)paren
(brace
r_struct
id|pte_chain
op_star
id|ret
suffix:semicolon
r_struct
id|pte_chain
op_star
op_star
id|pte_chainp
suffix:semicolon
id|might_sleep_if
c_func
(paren
id|gfp_flags
op_amp
id|__GFP_WAIT
)paren
suffix:semicolon
id|pte_chainp
op_assign
op_amp
id|get_cpu_var
c_func
(paren
id|local_pte_chain
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pte_chainp
)paren
(brace
id|ret
op_assign
op_star
id|pte_chainp
suffix:semicolon
op_star
id|pte_chainp
op_assign
l_int|NULL
suffix:semicolon
id|put_cpu_var
c_func
(paren
id|local_pte_chain
)paren
suffix:semicolon
)brace
r_else
(brace
id|put_cpu_var
c_func
(paren
id|local_pte_chain
)paren
suffix:semicolon
id|ret
op_assign
id|kmem_cache_alloc
c_func
(paren
id|pte_chain_cache
comma
id|gfp_flags
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|pte_chain_init
r_void
id|__init
id|pte_chain_init
c_func
(paren
r_void
)paren
(brace
id|pte_chain_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;pte_chain&quot;
comma
r_sizeof
(paren
r_struct
id|pte_chain
)paren
comma
r_sizeof
(paren
r_struct
id|pte_chain
)paren
comma
l_int|0
comma
id|pte_chain_ctor
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte_chain_cache
)paren
id|panic
c_func
(paren
l_string|&quot;failed to create pte_chain cache!&bslash;n&quot;
)paren
suffix:semicolon
)brace
eof
