multiline_comment|/*&n; * mm/rmap.c - physical to virtual reverse mappings&n; *&n; * Copyright 2001, Rik van Riel &lt;riel@conectiva.com.br&gt;&n; * Released under the General Public License (GPL).&n; *&n; *&n; * Simple, low overhead pte-based reverse mapping scheme.&n; * This is kept modular because we may want to experiment&n; * with object-based reverse mapping schemes. Please try&n; * to keep this thing as modular as possible.&n; */
multiline_comment|/*&n; * Locking:&n; * - the page-&gt;pte.chain is protected by the PG_chainlock bit,&n; *   which nests within the pagemap_lru_lock, then the&n; *   mm-&gt;page_table_lock, and then the page lock.&n; * - because swapout locking is opposite to the locking order&n; *   in the page fault path, the swapout path uses trylocks&n; *   on the mm-&gt;page_table_lock&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/swapops.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/rmap.h&gt;
macro_line|#include &lt;asm/smplock.h&gt;
macro_line|#include &lt;asm/tlb.h&gt;
macro_line|#include &lt;asm/tlbflush.h&gt;
multiline_comment|/* #define DEBUG_RMAP */
multiline_comment|/*&n; * Shared pages have a chain of pte_chain structures, used to locate&n; * all the mappings to this page. We only need a pointer to the pte&n; * here, the page struct for the page table page contains the process&n; * it belongs to and the offset within that process.&n; *&n; * A singly linked list should be fine for most, if not all, workloads.&n; * On fork-after-exec the mapping we&squot;ll be removing will still be near&n; * the start of the list, on mixed application systems the short-lived&n; * processes will have their mappings near the start of the list and&n; * in systems with long-lived applications the relative overhead of&n; * exit() will be lower since the applications are long-lived.&n; */
DECL|struct|pte_chain
r_struct
id|pte_chain
(brace
DECL|member|next
r_struct
id|pte_chain
op_star
id|next
suffix:semicolon
DECL|member|ptep
id|pte_t
op_star
id|ptep
suffix:semicolon
)brace
suffix:semicolon
r_static
r_inline
r_struct
id|pte_chain
op_star
id|pte_chain_alloc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_inline
r_void
id|pte_chain_free
c_func
(paren
r_struct
id|pte_chain
op_star
comma
r_struct
id|pte_chain
op_star
comma
r_struct
id|page
op_star
)paren
suffix:semicolon
r_static
r_void
id|alloc_new_pte_chains
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/**&n; * page_referenced - test if the page was referenced&n; * @page: the page to test&n; *&n; * Quick test_and_clear_referenced for all mappings to a page,&n; * returns the number of processes which referenced the page.&n; * Caller needs to hold the pte_chain_lock.&n; */
DECL|function|page_referenced
r_int
id|page_referenced
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|pte_chain
op_star
id|pc
suffix:semicolon
r_int
id|referenced
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|TestClearPageReferenced
c_func
(paren
id|page
)paren
)paren
id|referenced
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|PageDirect
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
id|ptep_test_and_clear_young
c_func
(paren
id|page-&gt;pte.direct
)paren
)paren
id|referenced
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Check all the page tables mapping this page. */
r_for
c_loop
(paren
id|pc
op_assign
id|page-&gt;pte.chain
suffix:semicolon
id|pc
suffix:semicolon
id|pc
op_assign
id|pc-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|ptep_test_and_clear_young
c_func
(paren
id|pc-&gt;ptep
)paren
)paren
id|referenced
op_increment
suffix:semicolon
)brace
)brace
r_return
id|referenced
suffix:semicolon
)brace
multiline_comment|/**&n; * page_add_rmap - add reverse mapping entry to a page&n; * @page: the page to add the mapping to&n; * @ptep: the page table entry mapping this page&n; *&n; * Add a new pte reverse mapping to a page.&n; * The caller needs to hold the mm-&gt;page_table_lock.&n; */
DECL|function|page_add_rmap
r_void
id|page_add_rmap
c_func
(paren
r_struct
id|page
op_star
id|page
comma
id|pte_t
op_star
id|ptep
)paren
(brace
r_struct
id|pte_chain
op_star
id|pte_chain
suffix:semicolon
r_int
r_int
id|pfn
op_assign
id|pte_pfn
c_func
(paren
op_star
id|ptep
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_RMAP
r_if
c_cond
(paren
op_logical_neg
id|page
op_logical_or
op_logical_neg
id|ptep
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte_present
c_func
(paren
op_star
id|ptep
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptep_to_mm
c_func
(paren
id|ptep
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|pfn_valid
c_func
(paren
id|pfn
)paren
op_logical_or
id|PageReserved
c_func
(paren
id|page
)paren
)paren
r_return
suffix:semicolon
macro_line|#ifdef DEBUG_RMAP
id|pte_chain_lock
c_func
(paren
id|page
)paren
suffix:semicolon
(brace
r_struct
id|pte_chain
op_star
id|pc
suffix:semicolon
r_if
c_cond
(paren
id|PageDirect
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
id|page-&gt;pte.direct
op_eq
id|ptep
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|pc
op_assign
id|page-&gt;pte.chain
suffix:semicolon
id|pc
suffix:semicolon
id|pc
op_assign
id|pc-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|pc-&gt;ptep
op_eq
id|ptep
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
id|pte_chain_unlock
c_func
(paren
id|page
)paren
suffix:semicolon
macro_line|#endif
id|pte_chain_lock
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageDirect
c_func
(paren
id|page
)paren
)paren
(brace
multiline_comment|/* Convert a direct pointer into a pte_chain */
id|pte_chain
op_assign
id|pte_chain_alloc
c_func
(paren
)paren
suffix:semicolon
id|pte_chain-&gt;ptep
op_assign
id|page-&gt;pte.direct
suffix:semicolon
id|pte_chain-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|page-&gt;pte.chain
op_assign
id|pte_chain
suffix:semicolon
id|ClearPageDirect
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page-&gt;pte.chain
)paren
(brace
multiline_comment|/* Hook up the pte_chain to the page. */
id|pte_chain
op_assign
id|pte_chain_alloc
c_func
(paren
)paren
suffix:semicolon
id|pte_chain-&gt;ptep
op_assign
id|ptep
suffix:semicolon
id|pte_chain-&gt;next
op_assign
id|page-&gt;pte.chain
suffix:semicolon
id|page-&gt;pte.chain
op_assign
id|pte_chain
suffix:semicolon
)brace
r_else
(brace
id|page-&gt;pte.direct
op_assign
id|ptep
suffix:semicolon
id|SetPageDirect
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|pte_chain_unlock
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * page_remove_rmap - take down reverse mapping to a page&n; * @page: page to remove mapping from&n; * @ptep: page table entry to remove&n; *&n; * Removes the reverse mapping from the pte_chain of the page,&n; * after that the caller can clear the page table entry and free&n; * the page.&n; * Caller needs to hold the mm-&gt;page_table_lock.&n; */
DECL|function|page_remove_rmap
r_void
id|page_remove_rmap
c_func
(paren
r_struct
id|page
op_star
id|page
comma
id|pte_t
op_star
id|ptep
)paren
(brace
r_struct
id|pte_chain
op_star
id|pc
comma
op_star
id|prev_pc
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|pfn
op_assign
id|pte_pfn
c_func
(paren
op_star
id|ptep
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
op_logical_or
op_logical_neg
id|ptep
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pfn_valid
c_func
(paren
id|pfn
)paren
op_logical_or
id|PageReserved
c_func
(paren
id|page
)paren
)paren
r_return
suffix:semicolon
id|pte_chain_lock
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageDirect
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
id|page-&gt;pte.direct
op_eq
id|ptep
)paren
(brace
id|page-&gt;pte.direct
op_assign
l_int|NULL
suffix:semicolon
id|ClearPageDirect
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|pc
op_assign
id|page-&gt;pte.chain
suffix:semicolon
id|pc
suffix:semicolon
id|prev_pc
op_assign
id|pc
comma
id|pc
op_assign
id|pc-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|pc-&gt;ptep
op_eq
id|ptep
)paren
(brace
id|pte_chain_free
c_func
(paren
id|pc
comma
id|prev_pc
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* Check whether we can convert to direct */
id|pc
op_assign
id|page-&gt;pte.chain
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pc-&gt;next
)paren
(brace
id|page-&gt;pte.direct
op_assign
id|pc-&gt;ptep
suffix:semicolon
id|SetPageDirect
c_func
(paren
id|page
)paren
suffix:semicolon
id|pte_chain_free
c_func
(paren
id|pc
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef DEBUG_RMAP
multiline_comment|/* Not found. This should NEVER happen! */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;page_remove_rmap: pte_chain %p not present.&bslash;n&quot;
comma
id|ptep
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;page_remove_rmap: only found: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageDirect
c_func
(paren
id|page
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%p &quot;
comma
id|page-&gt;pte.direct
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|pc
op_assign
id|page-&gt;pte.chain
suffix:semicolon
id|pc
suffix:semicolon
id|pc
op_assign
id|pc-&gt;next
)paren
id|printk
c_func
(paren
l_string|&quot;%p &quot;
comma
id|pc-&gt;ptep
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;page_remove_rmap: driver cleared PG_reserved ?&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|out
suffix:colon
id|pte_chain_unlock
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * try_to_unmap_one - worker function for try_to_unmap&n; * @page: page to unmap&n; * @ptep: page table entry to unmap from page&n; *&n; * Internal helper function for try_to_unmap, called for each page&n; * table entry mapping a page. Because locking order here is opposite&n; * to the locking order used by the page fault path, we use trylocks.&n; * Locking:&n; *&t;pagemap_lru_lock&t;&t;page_launder()&n; *&t;    page lock&t;&t;&t;page_launder(), trylock&n; *&t;&t;pte_chain_lock&t;&t;page_launder()&n; *&t;&t;    mm-&gt;page_table_lock&t;try_to_unmap_one(), trylock&n; */
r_static
r_int
id|FASTCALL
c_func
(paren
id|try_to_unmap_one
c_func
(paren
r_struct
id|page
op_star
comma
id|pte_t
op_star
)paren
)paren
suffix:semicolon
DECL|function|try_to_unmap_one
r_static
r_int
id|try_to_unmap_one
c_func
(paren
r_struct
id|page
op_star
id|page
comma
id|pte_t
op_star
id|ptep
)paren
(brace
r_int
r_int
id|address
op_assign
id|ptep_to_address
c_func
(paren
id|ptep
)paren
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|ptep_to_mm
c_func
(paren
id|ptep
)paren
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
id|pte_t
id|pte
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mm
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We need the page_table_lock to protect us from page faults,&n;&t; * munmap, fork, etc...&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
)paren
r_return
id|SWAP_AGAIN
suffix:semicolon
multiline_comment|/* During mremap, it&squot;s possible pages are not in a VMA. */
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
(brace
id|ret
op_assign
id|SWAP_FAIL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* The page is mlock()d, we cannot swap it out. */
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_LOCKED
)paren
(brace
id|ret
op_assign
id|SWAP_FAIL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* Nuke the page table entry. */
id|pte
op_assign
id|ptep_get_and_clear
c_func
(paren
id|ptep
)paren
suffix:semicolon
id|flush_tlb_page
c_func
(paren
id|vma
comma
id|address
)paren
suffix:semicolon
id|flush_cache_page
c_func
(paren
id|vma
comma
id|address
)paren
suffix:semicolon
multiline_comment|/* Store the swap location in the pte. See handle_pte_fault() ... */
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
(brace
id|swp_entry_t
id|entry
suffix:semicolon
id|entry.val
op_assign
id|page-&gt;index
suffix:semicolon
id|swap_duplicate
c_func
(paren
id|entry
)paren
suffix:semicolon
id|set_pte
c_func
(paren
id|ptep
comma
id|swp_entry_to_pte
c_func
(paren
id|entry
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Move the dirty bit to the physical page now the pte is gone. */
r_if
c_cond
(paren
id|pte_dirty
c_func
(paren
id|pte
)paren
)paren
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|mm-&gt;rss
op_decrement
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|ret
op_assign
id|SWAP_SUCCESS
suffix:semicolon
id|out_unlock
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * try_to_unmap - try to remove all page table mappings to a page&n; * @page: the page to get unmapped&n; *&n; * Tries to remove all the page table entries which are mapping this&n; * page, used in the pageout path.  Caller must hold pagemap_lru_lock&n; * and the page lock.  Return values are:&n; *&n; * SWAP_SUCCESS&t;- we succeeded in removing all mappings&n; * SWAP_AGAIN&t;- we missed a trylock, try again later&n; * SWAP_FAIL&t;- the page is unswappable&n; * SWAP_ERROR&t;- an error occurred&n; */
DECL|function|try_to_unmap
r_int
id|try_to_unmap
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|pte_chain
op_star
id|pc
comma
op_star
id|next_pc
comma
op_star
id|prev_pc
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
op_assign
id|SWAP_SUCCESS
suffix:semicolon
multiline_comment|/* This page should not be on the pageout lists. */
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* We need backing store to swap out a page. */
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;mapping
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageDirect
c_func
(paren
id|page
)paren
)paren
(brace
id|ret
op_assign
id|try_to_unmap_one
c_func
(paren
id|page
comma
id|page-&gt;pte.direct
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|SWAP_SUCCESS
)paren
(brace
id|page-&gt;pte.direct
op_assign
l_int|NULL
suffix:semicolon
id|ClearPageDirect
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|pc
op_assign
id|page-&gt;pte.chain
suffix:semicolon
id|pc
suffix:semicolon
id|pc
op_assign
id|next_pc
)paren
(brace
id|next_pc
op_assign
id|pc-&gt;next
suffix:semicolon
r_switch
c_cond
(paren
id|try_to_unmap_one
c_func
(paren
id|page
comma
id|pc-&gt;ptep
)paren
)paren
(brace
r_case
id|SWAP_SUCCESS
suffix:colon
multiline_comment|/* Free the pte_chain struct. */
id|pte_chain_free
c_func
(paren
id|pc
comma
id|prev_pc
comma
id|page
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SWAP_AGAIN
suffix:colon
multiline_comment|/* Skip this pte, remembering status. */
id|prev_pc
op_assign
id|pc
suffix:semicolon
id|ret
op_assign
id|SWAP_AGAIN
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|SWAP_FAIL
suffix:colon
id|ret
op_assign
id|SWAP_FAIL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SWAP_ERROR
suffix:colon
id|ret
op_assign
id|SWAP_ERROR
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Check whether we can convert to direct pte pointer */
id|pc
op_assign
id|page-&gt;pte.chain
suffix:semicolon
r_if
c_cond
(paren
id|pc
op_logical_and
op_logical_neg
id|pc-&gt;next
)paren
(brace
id|page-&gt;pte.direct
op_assign
id|pc-&gt;ptep
suffix:semicolon
id|SetPageDirect
c_func
(paren
id|page
)paren
suffix:semicolon
id|pte_chain_free
c_func
(paren
id|pc
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; ** No more VM stuff below this comment, only pte_chain helper&n; ** functions.&n; **/
DECL|variable|pte_chain_freelist
r_struct
id|pte_chain
op_star
id|pte_chain_freelist
suffix:semicolon
DECL|variable|pte_chain_freelist_lock
id|spinlock_t
id|pte_chain_freelist_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* Maybe we should have standard ops for singly linked lists ... - Rik */
DECL|function|pte_chain_push
r_static
r_inline
r_void
id|pte_chain_push
c_func
(paren
r_struct
id|pte_chain
op_star
id|pte_chain
)paren
(brace
id|pte_chain-&gt;ptep
op_assign
l_int|NULL
suffix:semicolon
id|pte_chain-&gt;next
op_assign
id|pte_chain_freelist
suffix:semicolon
id|pte_chain_freelist
op_assign
id|pte_chain
suffix:semicolon
)brace
DECL|function|pte_chain_pop
r_static
r_inline
r_struct
id|pte_chain
op_star
id|pte_chain_pop
c_func
(paren
r_void
)paren
(brace
r_struct
id|pte_chain
op_star
id|pte_chain
suffix:semicolon
id|pte_chain
op_assign
id|pte_chain_freelist
suffix:semicolon
id|pte_chain_freelist
op_assign
id|pte_chain-&gt;next
suffix:semicolon
id|pte_chain-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_return
id|pte_chain
suffix:semicolon
)brace
multiline_comment|/**&n; * pte_chain_free - free pte_chain structure&n; * @pte_chain: pte_chain struct to free&n; * @prev_pte_chain: previous pte_chain on the list (may be NULL)&n; * @page: page this pte_chain hangs off (may be NULL)&n; *&n; * This function unlinks pte_chain from the singly linked list it&n; * may be on and adds the pte_chain to the free list. May also be&n; * called for new pte_chain structures which aren&squot;t on any list yet.&n; * Caller needs to hold the pte_chain_lock if the page is non-NULL.&n; */
DECL|function|pte_chain_free
r_static
r_inline
r_void
id|pte_chain_free
c_func
(paren
r_struct
id|pte_chain
op_star
id|pte_chain
comma
r_struct
id|pte_chain
op_star
id|prev_pte_chain
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|mod_page_state
c_func
(paren
id|used_pte_chains_bytes
comma
op_minus
r_sizeof
(paren
r_struct
id|pte_chain
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev_pte_chain
)paren
id|prev_pte_chain-&gt;next
op_assign
id|pte_chain-&gt;next
suffix:semicolon
r_else
r_if
c_cond
(paren
id|page
)paren
id|page-&gt;pte.chain
op_assign
id|pte_chain-&gt;next
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pte_chain_freelist_lock
)paren
suffix:semicolon
id|pte_chain_push
c_func
(paren
id|pte_chain
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pte_chain_freelist_lock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * pte_chain_alloc - allocate a pte_chain struct&n; *&n; * Returns a pointer to a fresh pte_chain structure. Allocates new&n; * pte_chain structures as required.&n; * Caller needs to hold the page&squot;s pte_chain_lock.&n; */
DECL|function|pte_chain_alloc
r_static
r_inline
r_struct
id|pte_chain
op_star
id|pte_chain_alloc
c_func
(paren
)paren
(brace
r_struct
id|pte_chain
op_star
id|pte_chain
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pte_chain_freelist_lock
)paren
suffix:semicolon
multiline_comment|/* Allocate new pte_chain structs as needed. */
r_if
c_cond
(paren
op_logical_neg
id|pte_chain_freelist
)paren
id|alloc_new_pte_chains
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Grab the first pte_chain from the freelist. */
id|pte_chain
op_assign
id|pte_chain_pop
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pte_chain_freelist_lock
)paren
suffix:semicolon
id|mod_page_state
c_func
(paren
id|used_pte_chains_bytes
comma
r_sizeof
(paren
r_struct
id|pte_chain
)paren
)paren
suffix:semicolon
r_return
id|pte_chain
suffix:semicolon
)brace
multiline_comment|/**&n; * alloc_new_pte_chains - convert a free page to pte_chain structures&n; *&n; * Grabs a free page and converts it to pte_chain structures. We really&n; * should pre-allocate these earlier in the pagefault path or come up&n; * with some other trick.&n; *&n; * Note that we cannot use the slab cache because the pte_chain structure&n; * is way smaller than the minimum size of a slab cache allocation.&n; * Caller needs to hold the pte_chain_freelist_lock&n; */
DECL|function|alloc_new_pte_chains
r_static
r_void
id|alloc_new_pte_chains
c_func
(paren
)paren
(brace
r_struct
id|pte_chain
op_star
id|pte_chain
op_assign
(paren
r_void
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_int
id|i
op_assign
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_struct
id|pte_chain
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_chain
)paren
(brace
id|inc_page_state
c_func
(paren
id|nr_pte_chain_pages
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
op_decrement
OG
l_int|0
suffix:semicolon
id|pte_chain
op_increment
)paren
id|pte_chain_push
c_func
(paren
id|pte_chain
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Yeah yeah, I&squot;ll fix the pte_chain allocation ... */
id|panic
c_func
(paren
l_string|&quot;Fix pte_chain allocation, you lazy bastard!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
eof
