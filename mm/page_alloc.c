multiline_comment|/*&n; *  linux/mm/page_alloc.c&n; *&n; *  Manages the free list, the system allocates free pages here.&n; *  Note that kmalloc() lives in slab.c&n; *&n; *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; *  Swap reorganised 29.12.95, Stephen Tweedie&n; *  Support of BIGMEM added by Gerhard Wichert, Siemens AG, July 1999&n; *  Reshaped it to be a zoned allocator, Ingo Molnar, Red Hat, 1999&n; *  Discontiguous memory support, Kanoj Sarcar, SGI, Nov 1999&n; *  Zone balancing, Kanoj Sarcar, SGI, Jan 2000&n; *  Per cpu hot/cold page lists, bulk allocation, Martin J. Bligh, Sept 2002&n; *          (lots of bits borrowed from Ingo Molnar &amp; Andrew Morton)&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;linux/pagevec.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/topology.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/cpu.h&gt;
macro_line|#include &lt;linux/nodemask.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;asm/tlbflush.h&gt;
macro_line|#include &quot;internal.h&quot;
multiline_comment|/* MCD - HACK: Find somewhere to initialize this EARLY, or make this initializer cleaner */
DECL|variable|node_online_map
id|nodemask_t
id|node_online_map
op_assign
(brace
(brace
(braket
l_int|0
)braket
op_assign
l_int|1UL
)brace
)brace
suffix:semicolon
DECL|variable|node_possible_map
id|nodemask_t
id|node_possible_map
op_assign
id|NODE_MASK_ALL
suffix:semicolon
DECL|variable|pgdat_list
r_struct
id|pglist_data
op_star
id|pgdat_list
suffix:semicolon
DECL|variable|totalram_pages
r_int
r_int
id|totalram_pages
suffix:semicolon
DECL|variable|totalhigh_pages
r_int
r_int
id|totalhigh_pages
suffix:semicolon
DECL|variable|nr_swap_pages
r_int
id|nr_swap_pages
suffix:semicolon
multiline_comment|/*&n; * results with 256, 32 in the lowmem_reserve sysctl:&n; *&t;1G machine -&gt; (16M dma, 800M-16M normal, 1G-800M high)&n; *&t;1G machine -&gt; (16M dma, 784M normal, 224M high)&n; *&t;NORMAL allocation will leave 784M/256 of ram reserved in the ZONE_DMA&n; *&t;HIGHMEM allocation will leave 224M/32 of ram reserved in ZONE_NORMAL&n; *&t;HIGHMEM allocation will (224M+784M)/256 of ram reserved in ZONE_DMA&n; */
DECL|variable|sysctl_lowmem_reserve_ratio
r_int
id|sysctl_lowmem_reserve_ratio
(braket
id|MAX_NR_ZONES
op_minus
l_int|1
)braket
op_assign
(brace
l_int|256
comma
l_int|32
)brace
suffix:semicolon
DECL|variable|totalram_pages
id|EXPORT_SYMBOL
c_func
(paren
id|totalram_pages
)paren
suffix:semicolon
DECL|variable|nr_swap_pages
id|EXPORT_SYMBOL
c_func
(paren
id|nr_swap_pages
)paren
suffix:semicolon
multiline_comment|/*&n; * Used by page_zone() to look up the address of the struct zone whose&n; * id is encoded in the upper bits of page-&gt;flags&n; */
DECL|variable|zone_table
r_struct
id|zone
op_star
id|zone_table
(braket
l_int|1
op_lshift
(paren
id|ZONES_SHIFT
op_plus
id|NODES_SHIFT
)paren
)braket
suffix:semicolon
DECL|variable|zone_table
id|EXPORT_SYMBOL
c_func
(paren
id|zone_table
)paren
suffix:semicolon
DECL|variable|zone_names
r_static
r_char
op_star
id|zone_names
(braket
id|MAX_NR_ZONES
)braket
op_assign
(brace
l_string|&quot;DMA&quot;
comma
l_string|&quot;Normal&quot;
comma
l_string|&quot;HighMem&quot;
)brace
suffix:semicolon
DECL|variable|min_free_kbytes
r_int
id|min_free_kbytes
op_assign
l_int|1024
suffix:semicolon
DECL|variable|nr_kernel_pages
r_int
r_int
id|__initdata
id|nr_kernel_pages
suffix:semicolon
DECL|variable|nr_all_pages
r_int
r_int
id|__initdata
id|nr_all_pages
suffix:semicolon
multiline_comment|/*&n; * Temporary debugging check for pages not lying within a given zone.&n; */
DECL|function|bad_range
r_static
r_int
id|bad_range
c_func
(paren
r_struct
id|zone
op_star
id|zone
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
id|page_to_pfn
c_func
(paren
id|page
)paren
op_ge
id|zone-&gt;zone_start_pfn
op_plus
id|zone-&gt;spanned_pages
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|page_to_pfn
c_func
(paren
id|page
)paren
OL
id|zone-&gt;zone_start_pfn
)paren
r_return
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_HOLES_IN_ZONE
r_if
c_cond
(paren
op_logical_neg
id|pfn_valid
c_func
(paren
id|page_to_pfn
c_func
(paren
id|page
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|zone
op_ne
id|page_zone
c_func
(paren
id|page
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bad_page
r_static
r_void
id|bad_page
c_func
(paren
r_const
r_char
op_star
id|function
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;Bad page state at %s (in process &squot;%s&squot;, page %p)&bslash;n&quot;
comma
id|function
comma
id|current-&gt;comm
comma
id|page
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;flags:0x%0*lx mapping:%p mapcount:%d count:%d&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
l_int|2
op_star
r_sizeof
(paren
id|page_flags_t
)paren
)paren
comma
(paren
r_int
r_int
)paren
id|page-&gt;flags
comma
id|page-&gt;mapping
comma
id|page_mapcount
c_func
(paren
id|page
)paren
comma
id|page_count
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;Backtrace:&bslash;n&quot;
)paren
suffix:semicolon
id|dump_stack
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;Trying to fix it up, but a reboot is needed&bslash;n&quot;
)paren
suffix:semicolon
id|page-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|PG_private
op_or
l_int|1
op_lshift
id|PG_locked
op_or
l_int|1
op_lshift
id|PG_lru
op_or
l_int|1
op_lshift
id|PG_active
op_or
l_int|1
op_lshift
id|PG_dirty
op_or
l_int|1
op_lshift
id|PG_swapcache
op_or
l_int|1
op_lshift
id|PG_writeback
)paren
suffix:semicolon
id|set_page_count
c_func
(paren
id|page
comma
l_int|0
)paren
suffix:semicolon
id|reset_page_mapcount
c_func
(paren
id|page
)paren
suffix:semicolon
id|page-&gt;mapping
op_assign
l_int|NULL
suffix:semicolon
id|tainted
op_or_assign
id|TAINT_BAD_PAGE
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_HUGETLB_PAGE
DECL|macro|prep_compound_page
mdefine_line|#define prep_compound_page(page, order) do { } while (0)
DECL|macro|destroy_compound_page
mdefine_line|#define destroy_compound_page(page, order) do { } while (0)
macro_line|#else
multiline_comment|/*&n; * Higher-order pages are called &quot;compound pages&quot;.  They are structured thusly:&n; *&n; * The first PAGE_SIZE page is called the &quot;head page&quot;.&n; *&n; * The remaining PAGE_SIZE pages are called &quot;tail pages&quot;.&n; *&n; * All pages have PG_compound set.  All pages have their -&gt;private pointing at&n; * the head page (even the head page has this).&n; *&n; * The first tail page&squot;s -&gt;mapping, if non-zero, holds the address of the&n; * compound page&squot;s put_page() function.&n; *&n; * The order of the allocation is stored in the first tail page&squot;s -&gt;index&n; * This is only for debug at present.  This usage means that zero-order pages&n; * may not be compound.&n; */
DECL|function|prep_compound_page
r_static
r_void
id|prep_compound_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|order
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|nr_pages
op_assign
l_int|1
op_lshift
id|order
suffix:semicolon
id|page
(braket
l_int|1
)braket
dot
id|mapping
op_assign
l_int|NULL
suffix:semicolon
id|page
(braket
l_int|1
)braket
dot
id|index
op_assign
id|order
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|page
op_star
id|p
op_assign
id|page
op_plus
id|i
suffix:semicolon
id|SetPageCompound
c_func
(paren
id|p
)paren
suffix:semicolon
id|p
op_member_access_from_pointer
r_private
op_assign
(paren
r_int
r_int
)paren
id|page
suffix:semicolon
)brace
)brace
DECL|function|destroy_compound_page
r_static
r_void
id|destroy_compound_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|order
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|nr_pages
op_assign
l_int|1
op_lshift
id|order
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageCompound
c_func
(paren
id|page
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|page
(braket
l_int|1
)braket
dot
id|index
op_ne
id|order
)paren
id|bad_page
c_func
(paren
id|__FUNCTION__
comma
id|page
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|page
op_star
id|p
op_assign
id|page
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageCompound
c_func
(paren
id|p
)paren
)paren
id|bad_page
c_func
(paren
id|__FUNCTION__
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_member_access_from_pointer
r_private
op_ne
(paren
r_int
r_int
)paren
id|page
)paren
id|bad_page
c_func
(paren
id|__FUNCTION__
comma
id|page
)paren
suffix:semicolon
id|ClearPageCompound
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;&t;/* CONFIG_HUGETLB_PAGE */
multiline_comment|/*&n; * function for dealing with page&squot;s order in buddy system.&n; * zone-&gt;lock is already acquired when we use these.&n; * So, we don&squot;t need atomic page-&gt;flags operations here.&n; */
DECL|function|page_order
r_static
r_inline
r_int
r_int
id|page_order
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_return
id|page
op_member_access_from_pointer
r_private
suffix:semicolon
)brace
DECL|function|set_page_order
r_static
r_inline
r_void
id|set_page_order
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|order
)paren
(brace
id|page
op_member_access_from_pointer
r_private
op_assign
id|order
suffix:semicolon
id|__SetPagePrivate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|function|rmv_page_order
r_static
r_inline
r_void
id|rmv_page_order
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|__ClearPagePrivate
c_func
(paren
id|page
)paren
suffix:semicolon
id|page
op_member_access_from_pointer
r_private
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function checks whether a page is free &amp;&amp; is the buddy&n; * we can do coalesce a page and its buddy if&n; * (a) the buddy is free &amp;&amp;&n; * (b) the buddy is on the buddy system &amp;&amp;&n; * (c) a page and its buddy have the same order.&n; * for recording page&squot;s order, we use page-&gt;private and PG_private.&n; *&n; */
DECL|function|page_is_buddy
r_static
r_inline
r_int
id|page_is_buddy
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|order
)paren
(brace
r_if
c_cond
(paren
id|PagePrivate
c_func
(paren
id|page
)paren
op_logical_and
(paren
id|page_order
c_func
(paren
id|page
)paren
op_eq
id|order
)paren
op_logical_and
op_logical_neg
id|PageReserved
c_func
(paren
id|page
)paren
op_logical_and
id|page_count
c_func
(paren
id|page
)paren
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Freeing function for a buddy system allocator.&n; *&n; * The concept of a buddy system is to maintain direct-mapped table&n; * (containing bit values) for memory blocks of various &quot;orders&quot;.&n; * The bottom level table contains the map for the smallest allocatable&n; * units of memory (here, pages), and each level above it describes&n; * pairs of units from the levels below, hence, &quot;buddies&quot;.&n; * At a high level, all that happens here is marking the table entry&n; * at the bottom level available, and propagating the changes upward&n; * as necessary, plus some accounting needed to play nicely with other&n; * parts of the VM system.&n; * At each level, we keep a list of pages, which are heads of continuous&n; * free pages of length of (1 &lt;&lt; order) and marked with PG_Private.Page&squot;s&n; * order is recorded in page-&gt;private field.&n; * So when we are allocating or freeing one, we can derive the state of the&n; * other.  That is, if we allocate a small block, and both were   &n; * free, the remainder of the region must be split into blocks.   &n; * If a block is freed, and its buddy is also free, then this&n; * triggers coalescing into a block of larger size.            &n; *&n; * -- wli&n; */
DECL|function|__free_pages_bulk
r_static
r_inline
r_void
id|__free_pages_bulk
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|page
op_star
id|base
comma
r_struct
id|zone
op_star
id|zone
comma
r_int
r_int
id|order
)paren
(brace
r_int
r_int
id|page_idx
suffix:semicolon
r_struct
id|page
op_star
id|coalesced
suffix:semicolon
r_int
id|order_size
op_assign
l_int|1
op_lshift
id|order
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|order
)paren
)paren
id|destroy_compound_page
c_func
(paren
id|page
comma
id|order
)paren
suffix:semicolon
id|page_idx
op_assign
id|page
op_minus
id|base
suffix:semicolon
id|BUG_ON
c_func
(paren
id|page_idx
op_amp
(paren
id|order_size
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|bad_range
c_func
(paren
id|zone
comma
id|page
)paren
)paren
suffix:semicolon
id|zone-&gt;free_pages
op_add_assign
id|order_size
suffix:semicolon
r_while
c_loop
(paren
id|order
OL
id|MAX_ORDER
op_minus
l_int|1
)paren
(brace
r_struct
id|free_area
op_star
id|area
suffix:semicolon
r_struct
id|page
op_star
id|buddy
suffix:semicolon
r_int
id|buddy_idx
suffix:semicolon
id|buddy_idx
op_assign
(paren
id|page_idx
op_xor
(paren
l_int|1
op_lshift
id|order
)paren
)paren
suffix:semicolon
id|buddy
op_assign
id|base
op_plus
id|buddy_idx
suffix:semicolon
r_if
c_cond
(paren
id|bad_range
c_func
(paren
id|zone
comma
id|buddy
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_is_buddy
c_func
(paren
id|buddy
comma
id|order
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Move the buddy up one level. */
id|list_del
c_func
(paren
op_amp
id|buddy-&gt;lru
)paren
suffix:semicolon
id|area
op_assign
id|zone-&gt;free_area
op_plus
id|order
suffix:semicolon
id|area-&gt;nr_free
op_decrement
suffix:semicolon
id|rmv_page_order
c_func
(paren
id|buddy
)paren
suffix:semicolon
id|page_idx
op_and_assign
id|buddy_idx
suffix:semicolon
id|order
op_increment
suffix:semicolon
)brace
id|coalesced
op_assign
id|base
op_plus
id|page_idx
suffix:semicolon
id|set_page_order
c_func
(paren
id|coalesced
comma
id|order
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|coalesced-&gt;lru
comma
op_amp
id|zone-&gt;free_area
(braket
id|order
)braket
dot
id|free_list
)paren
suffix:semicolon
id|zone-&gt;free_area
(braket
id|order
)braket
dot
id|nr_free
op_increment
suffix:semicolon
)brace
DECL|function|free_pages_check
r_static
r_inline
r_void
id|free_pages_check
c_func
(paren
r_const
r_char
op_star
id|function
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
id|page_mapped
c_func
(paren
id|page
)paren
op_logical_or
id|page-&gt;mapping
op_ne
l_int|NULL
op_logical_or
id|page_count
c_func
(paren
id|page
)paren
op_ne
l_int|0
op_logical_or
(paren
id|page-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|PG_lru
op_or
l_int|1
op_lshift
id|PG_private
op_or
l_int|1
op_lshift
id|PG_locked
op_or
l_int|1
op_lshift
id|PG_active
op_or
l_int|1
op_lshift
id|PG_reclaim
op_or
l_int|1
op_lshift
id|PG_slab
op_or
l_int|1
op_lshift
id|PG_swapcache
op_or
l_int|1
op_lshift
id|PG_writeback
)paren
)paren
)paren
id|bad_page
c_func
(paren
id|function
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageDirty
c_func
(paren
id|page
)paren
)paren
id|ClearPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Frees a list of pages. &n; * Assumes all pages on list are in same zone, and of same order.&n; * count is the number of pages to free, or 0 for all on the list.&n; *&n; * If the zone was previously in an &quot;all pages pinned&quot; state then look to&n; * see if this freeing clears that state.&n; *&n; * And clear the zone&squot;s pages_scanned counter, to hold off the &quot;all pages are&n; * pinned&quot; detection logic.&n; */
r_static
r_int
DECL|function|free_pages_bulk
id|free_pages_bulk
c_func
(paren
r_struct
id|zone
op_star
id|zone
comma
r_int
id|count
comma
r_struct
id|list_head
op_star
id|list
comma
r_int
r_int
id|order
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|page
op_star
id|base
comma
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|base
op_assign
id|zone-&gt;zone_mem_map
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|zone-&gt;all_unreclaimable
op_assign
l_int|0
suffix:semicolon
id|zone-&gt;pages_scanned
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|list
)paren
op_logical_and
id|count
op_decrement
)paren
(brace
id|page
op_assign
id|list_entry
c_func
(paren
id|list-&gt;prev
comma
r_struct
id|page
comma
id|lru
)paren
suffix:semicolon
multiline_comment|/* have to delete it as __free_pages_bulk list manipulates */
id|list_del
c_func
(paren
op_amp
id|page-&gt;lru
)paren
suffix:semicolon
id|__free_pages_bulk
c_func
(paren
id|page
comma
id|base
comma
id|zone
comma
id|order
)paren
suffix:semicolon
id|ret
op_increment
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|__free_pages_ok
r_void
id|__free_pages_ok
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|order
)paren
(brace
id|LIST_HEAD
c_func
(paren
id|list
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|arch_free_page
c_func
(paren
id|page
comma
id|order
)paren
suffix:semicolon
id|mod_page_state
c_func
(paren
id|pgfree
comma
l_int|1
op_lshift
id|order
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_MMU
r_if
c_cond
(paren
id|order
OG
l_int|0
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
(paren
l_int|1
op_lshift
id|order
)paren
suffix:semicolon
op_increment
id|i
)paren
id|__put_page
c_func
(paren
id|page
op_plus
id|i
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
l_int|1
op_lshift
id|order
)paren
suffix:semicolon
op_increment
id|i
)paren
id|free_pages_check
c_func
(paren
id|__FUNCTION__
comma
id|page
op_plus
id|i
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|page-&gt;lru
comma
op_amp
id|list
)paren
suffix:semicolon
id|kernel_map_pages
c_func
(paren
id|page
comma
l_int|1
op_lshift
id|order
comma
l_int|0
)paren
suffix:semicolon
id|free_pages_bulk
c_func
(paren
id|page_zone
c_func
(paren
id|page
)paren
comma
l_int|1
comma
op_amp
id|list
comma
id|order
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The order of subdivision here is critical for the IO subsystem.&n; * Please do not alter this order without good reasons and regression&n; * testing. Specifically, as large blocks of memory are subdivided,&n; * the order in which smaller blocks are delivered depends on the order&n; * they&squot;re subdivided in this function. This is the primary factor&n; * influencing the order in which pages are delivered to the IO&n; * subsystem according to empirical testing, and this is also justified&n; * by considering the behavior of a buddy system containing a single&n; * large block of memory acted on by a series of small allocations.&n; * This behavior is a critical factor in sglist merging&squot;s success.&n; *&n; * -- wli&n; */
r_static
r_inline
r_struct
id|page
op_star
DECL|function|expand
id|expand
c_func
(paren
r_struct
id|zone
op_star
id|zone
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|low
comma
r_int
id|high
comma
r_struct
id|free_area
op_star
id|area
)paren
(brace
r_int
r_int
id|size
op_assign
l_int|1
op_lshift
id|high
suffix:semicolon
r_while
c_loop
(paren
id|high
OG
id|low
)paren
(brace
id|area
op_decrement
suffix:semicolon
id|high
op_decrement
suffix:semicolon
id|size
op_rshift_assign
l_int|1
suffix:semicolon
id|BUG_ON
c_func
(paren
id|bad_range
c_func
(paren
id|zone
comma
op_amp
id|page
(braket
id|size
)braket
)paren
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|page
(braket
id|size
)braket
dot
id|lru
comma
op_amp
id|area-&gt;free_list
)paren
suffix:semicolon
id|area-&gt;nr_free
op_increment
suffix:semicolon
id|set_page_order
c_func
(paren
op_amp
id|page
(braket
id|size
)braket
comma
id|high
)paren
suffix:semicolon
)brace
r_return
id|page
suffix:semicolon
)brace
DECL|function|set_page_refs
r_void
id|set_page_refs
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|order
)paren
(brace
macro_line|#ifdef CONFIG_MMU
id|set_page_count
c_func
(paren
id|page
comma
l_int|1
)paren
suffix:semicolon
macro_line|#else
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * We need to reference all the pages for this order, otherwise if&n;&t; * anyone accesses one of the pages with (get/put) it will be freed.&n;&t; * - eg: access_process_vm()&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
l_int|1
op_lshift
id|order
)paren
suffix:semicolon
id|i
op_increment
)paren
id|set_page_count
c_func
(paren
id|page
op_plus
id|i
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_MMU */
)brace
multiline_comment|/*&n; * This page is about to be returned from the page allocator&n; */
DECL|function|prep_new_page
r_static
r_void
id|prep_new_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|order
)paren
(brace
r_if
c_cond
(paren
id|page-&gt;mapping
op_logical_or
id|page_mapped
c_func
(paren
id|page
)paren
op_logical_or
(paren
id|page-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|PG_private
op_or
l_int|1
op_lshift
id|PG_locked
op_or
l_int|1
op_lshift
id|PG_lru
op_or
l_int|1
op_lshift
id|PG_active
op_or
l_int|1
op_lshift
id|PG_dirty
op_or
l_int|1
op_lshift
id|PG_reclaim
op_or
l_int|1
op_lshift
id|PG_swapcache
op_or
l_int|1
op_lshift
id|PG_writeback
)paren
)paren
)paren
id|bad_page
c_func
(paren
id|__FUNCTION__
comma
id|page
)paren
suffix:semicolon
id|page-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|PG_uptodate
op_or
l_int|1
op_lshift
id|PG_error
op_or
l_int|1
op_lshift
id|PG_referenced
op_or
l_int|1
op_lshift
id|PG_arch_1
op_or
l_int|1
op_lshift
id|PG_checked
op_or
l_int|1
op_lshift
id|PG_mappedtodisk
)paren
suffix:semicolon
id|page
op_member_access_from_pointer
r_private
op_assign
l_int|0
suffix:semicolon
id|set_page_refs
c_func
(paren
id|page
comma
id|order
)paren
suffix:semicolon
id|kernel_map_pages
c_func
(paren
id|page
comma
l_int|1
op_lshift
id|order
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Do the hard work of removing an element from the buddy allocator.&n; * Call me with the zone-&gt;lock already held.&n; */
DECL|function|__rmqueue
r_static
r_struct
id|page
op_star
id|__rmqueue
c_func
(paren
r_struct
id|zone
op_star
id|zone
comma
r_int
r_int
id|order
)paren
(brace
r_struct
id|free_area
op_star
id|area
suffix:semicolon
r_int
r_int
id|current_order
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_for
c_loop
(paren
id|current_order
op_assign
id|order
suffix:semicolon
id|current_order
OL
id|MAX_ORDER
suffix:semicolon
op_increment
id|current_order
)paren
(brace
id|area
op_assign
id|zone-&gt;free_area
op_plus
id|current_order
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|area-&gt;free_list
)paren
)paren
r_continue
suffix:semicolon
id|page
op_assign
id|list_entry
c_func
(paren
id|area-&gt;free_list.next
comma
r_struct
id|page
comma
id|lru
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|page-&gt;lru
)paren
suffix:semicolon
id|rmv_page_order
c_func
(paren
id|page
)paren
suffix:semicolon
id|area-&gt;nr_free
op_decrement
suffix:semicolon
id|zone-&gt;free_pages
op_sub_assign
l_int|1UL
op_lshift
id|order
suffix:semicolon
r_return
id|expand
c_func
(paren
id|zone
comma
id|page
comma
id|order
comma
id|current_order
comma
id|area
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* &n; * Obtain a specified number of elements from the buddy allocator, all under&n; * a single hold of the lock, for efficiency.  Add them to the supplied list.&n; * Returns the number of new pages which were placed at *list.&n; */
DECL|function|rmqueue_bulk
r_static
r_int
id|rmqueue_bulk
c_func
(paren
r_struct
id|zone
op_star
id|zone
comma
r_int
r_int
id|order
comma
r_int
r_int
id|count
comma
r_struct
id|list_head
op_star
id|list
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|allocated
op_assign
l_int|0
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
op_increment
id|i
)paren
(brace
id|page
op_assign
id|__rmqueue
c_func
(paren
id|zone
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|allocated
op_increment
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|page-&gt;lru
comma
id|list
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|allocated
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_PM) || defined(CONFIG_HOTPLUG_CPU)
DECL|function|__drain_pages
r_static
r_void
id|__drain_pages
c_func
(paren
r_int
r_int
id|cpu
)paren
(brace
r_struct
id|zone
op_star
id|zone
suffix:semicolon
r_int
id|i
suffix:semicolon
id|for_each_zone
c_func
(paren
id|zone
)paren
(brace
r_struct
id|per_cpu_pageset
op_star
id|pset
suffix:semicolon
id|pset
op_assign
op_amp
id|zone-&gt;pageset
(braket
id|cpu
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|pset-&gt;pcp
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|per_cpu_pages
op_star
id|pcp
suffix:semicolon
id|pcp
op_assign
op_amp
id|pset-&gt;pcp
(braket
id|i
)braket
suffix:semicolon
id|pcp-&gt;count
op_sub_assign
id|free_pages_bulk
c_func
(paren
id|zone
comma
id|pcp-&gt;count
comma
op_amp
id|pcp-&gt;list
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* CONFIG_PM || CONFIG_HOTPLUG_CPU */
macro_line|#ifdef CONFIG_PM
DECL|function|mark_free_pages
r_void
id|mark_free_pages
c_func
(paren
r_struct
id|zone
op_star
id|zone
)paren
(brace
r_int
r_int
id|zone_pfn
comma
id|flags
suffix:semicolon
r_int
id|order
suffix:semicolon
r_struct
id|list_head
op_star
id|curr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zone-&gt;spanned_pages
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|zone_pfn
op_assign
l_int|0
suffix:semicolon
id|zone_pfn
OL
id|zone-&gt;spanned_pages
suffix:semicolon
op_increment
id|zone_pfn
)paren
id|ClearPageNosaveFree
c_func
(paren
id|pfn_to_page
c_func
(paren
id|zone_pfn
op_plus
id|zone-&gt;zone_start_pfn
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
id|MAX_ORDER
op_minus
l_int|1
suffix:semicolon
id|order
op_ge
l_int|0
suffix:semicolon
op_decrement
id|order
)paren
id|list_for_each
c_func
(paren
id|curr
comma
op_amp
id|zone-&gt;free_area
(braket
id|order
)braket
dot
id|free_list
)paren
(brace
r_int
r_int
id|start_pfn
comma
id|i
suffix:semicolon
id|start_pfn
op_assign
id|page_to_pfn
c_func
(paren
id|list_entry
c_func
(paren
id|curr
comma
r_struct
id|page
comma
id|lru
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
l_int|1
op_lshift
id|order
)paren
suffix:semicolon
id|i
op_increment
)paren
id|SetPageNosaveFree
c_func
(paren
id|pfn_to_page
c_func
(paren
id|start_pfn
op_plus
id|i
)paren
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Spill all of this CPU&squot;s per-cpu pages back into the buddy allocator.&n; */
DECL|function|drain_local_pages
r_void
id|drain_local_pages
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__drain_pages
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PM */
DECL|function|zone_statistics
r_static
r_void
id|zone_statistics
c_func
(paren
r_struct
id|zonelist
op_star
id|zonelist
comma
r_struct
id|zone
op_star
id|z
)paren
(brace
macro_line|#ifdef CONFIG_NUMA
r_int
r_int
id|flags
suffix:semicolon
r_int
id|cpu
suffix:semicolon
id|pg_data_t
op_star
id|pg
op_assign
id|z-&gt;zone_pgdat
suffix:semicolon
id|pg_data_t
op_star
id|orig
op_assign
id|zonelist-&gt;zones
(braket
l_int|0
)braket
op_member_access_from_pointer
id|zone_pgdat
suffix:semicolon
r_struct
id|per_cpu_pageset
op_star
id|p
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|p
op_assign
op_amp
id|z-&gt;pageset
(braket
id|cpu
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pg
op_eq
id|orig
)paren
(brace
id|z-&gt;pageset
(braket
id|cpu
)braket
dot
id|numa_hit
op_increment
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;numa_miss
op_increment
suffix:semicolon
id|zonelist-&gt;zones
(braket
l_int|0
)braket
op_member_access_from_pointer
id|pageset
(braket
id|cpu
)braket
dot
id|numa_foreign
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pg
op_eq
id|NODE_DATA
c_func
(paren
id|numa_node_id
c_func
(paren
)paren
)paren
)paren
id|p-&gt;local_node
op_increment
suffix:semicolon
r_else
id|p-&gt;other_node
op_increment
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Free a 0-order page&n; */
r_static
r_void
id|FASTCALL
c_func
(paren
id|free_hot_cold_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|cold
)paren
)paren
suffix:semicolon
DECL|function|free_hot_cold_page
r_static
r_void
id|fastcall
id|free_hot_cold_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|cold
)paren
(brace
r_struct
id|zone
op_star
id|zone
op_assign
id|page_zone
c_func
(paren
id|page
)paren
suffix:semicolon
r_struct
id|per_cpu_pages
op_star
id|pcp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|arch_free_page
c_func
(paren
id|page
comma
l_int|0
)paren
suffix:semicolon
id|kernel_map_pages
c_func
(paren
id|page
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|inc_page_state
c_func
(paren
id|pgfree
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageAnon
c_func
(paren
id|page
)paren
)paren
id|page-&gt;mapping
op_assign
l_int|NULL
suffix:semicolon
id|free_pages_check
c_func
(paren
id|__FUNCTION__
comma
id|page
)paren
suffix:semicolon
id|pcp
op_assign
op_amp
id|zone-&gt;pageset
(braket
id|get_cpu
c_func
(paren
)paren
)braket
dot
id|pcp
(braket
id|cold
)braket
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcp-&gt;count
op_ge
id|pcp-&gt;high
)paren
id|pcp-&gt;count
op_sub_assign
id|free_pages_bulk
c_func
(paren
id|zone
comma
id|pcp-&gt;batch
comma
op_amp
id|pcp-&gt;list
comma
l_int|0
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|page-&gt;lru
comma
op_amp
id|pcp-&gt;list
)paren
suffix:semicolon
id|pcp-&gt;count
op_increment
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|free_hot_page
r_void
id|fastcall
id|free_hot_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|free_hot_cold_page
c_func
(paren
id|page
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|free_cold_page
r_void
id|fastcall
id|free_cold_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|free_hot_cold_page
c_func
(paren
id|page
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|prep_zero_page
r_static
r_inline
r_void
id|prep_zero_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|order
comma
r_int
id|gfp_flags
)paren
(brace
r_int
id|i
suffix:semicolon
id|BUG_ON
c_func
(paren
(paren
id|gfp_flags
op_amp
(paren
id|__GFP_WAIT
op_or
id|__GFP_HIGHMEM
)paren
)paren
op_eq
id|__GFP_HIGHMEM
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
l_int|1
op_lshift
id|order
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|clear_highpage
c_func
(paren
id|page
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Really, prep_compound_page() should be called from __rmqueue_bulk().  But&n; * we cheat by calling it from here, in the order &gt; 0 path.  Saves a branch&n; * or two.&n; */
r_static
r_struct
id|page
op_star
DECL|function|buffered_rmqueue
id|buffered_rmqueue
c_func
(paren
r_struct
id|zone
op_star
id|zone
comma
r_int
id|order
comma
r_int
id|gfp_flags
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_int
id|cold
op_assign
op_logical_neg
op_logical_neg
(paren
id|gfp_flags
op_amp
id|__GFP_COLD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|order
op_eq
l_int|0
)paren
(brace
r_struct
id|per_cpu_pages
op_star
id|pcp
suffix:semicolon
id|pcp
op_assign
op_amp
id|zone-&gt;pageset
(braket
id|get_cpu
c_func
(paren
)paren
)braket
dot
id|pcp
(braket
id|cold
)braket
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcp-&gt;count
op_le
id|pcp-&gt;low
)paren
id|pcp-&gt;count
op_add_assign
id|rmqueue_bulk
c_func
(paren
id|zone
comma
l_int|0
comma
id|pcp-&gt;batch
comma
op_amp
id|pcp-&gt;list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcp-&gt;count
)paren
(brace
id|page
op_assign
id|list_entry
c_func
(paren
id|pcp-&gt;list.next
comma
r_struct
id|page
comma
id|lru
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|page-&gt;lru
)paren
suffix:semicolon
id|pcp-&gt;count
op_decrement
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page
op_eq
l_int|NULL
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|page
op_assign
id|__rmqueue
c_func
(paren
id|zone
comma
id|order
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page
op_ne
l_int|NULL
)paren
(brace
id|BUG_ON
c_func
(paren
id|bad_range
c_func
(paren
id|zone
comma
id|page
)paren
)paren
suffix:semicolon
id|mod_page_state_zone
c_func
(paren
id|zone
comma
id|pgalloc
comma
l_int|1
op_lshift
id|order
)paren
suffix:semicolon
id|prep_new_page
c_func
(paren
id|page
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gfp_flags
op_amp
id|__GFP_ZERO
)paren
id|prep_zero_page
c_func
(paren
id|page
comma
id|order
comma
id|gfp_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|order
op_logical_and
(paren
id|gfp_flags
op_amp
id|__GFP_COMP
)paren
)paren
id|prep_compound_page
c_func
(paren
id|page
comma
id|order
)paren
suffix:semicolon
)brace
r_return
id|page
suffix:semicolon
)brace
multiline_comment|/*&n; * Return 1 if free pages are above &squot;mark&squot;. This takes into account the order&n; * of the allocation.&n; */
DECL|function|zone_watermark_ok
r_int
id|zone_watermark_ok
c_func
(paren
r_struct
id|zone
op_star
id|z
comma
r_int
id|order
comma
r_int
r_int
id|mark
comma
r_int
id|classzone_idx
comma
r_int
id|can_try_harder
comma
r_int
id|gfp_high
)paren
(brace
multiline_comment|/* free_pages my go negative - that&squot;s OK */
r_int
id|min
op_assign
id|mark
comma
id|free_pages
op_assign
id|z-&gt;free_pages
op_minus
(paren
l_int|1
op_lshift
id|order
)paren
op_plus
l_int|1
suffix:semicolon
r_int
id|o
suffix:semicolon
r_if
c_cond
(paren
id|gfp_high
)paren
id|min
op_sub_assign
id|min
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|can_try_harder
)paren
id|min
op_sub_assign
id|min
op_div
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|free_pages
op_le
id|min
op_plus
id|z-&gt;lowmem_reserve
(braket
id|classzone_idx
)braket
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|o
op_assign
l_int|0
suffix:semicolon
id|o
OL
id|order
suffix:semicolon
id|o
op_increment
)paren
(brace
multiline_comment|/* At the next order, this order&squot;s pages become unavailable */
id|free_pages
op_sub_assign
id|z-&gt;free_area
(braket
id|o
)braket
dot
id|nr_free
op_lshift
id|o
suffix:semicolon
multiline_comment|/* Require fewer higher order pages to be free */
id|min
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|free_pages
op_le
id|min
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the &squot;heart&squot; of the zoned buddy allocator.&n; */
r_struct
id|page
op_star
id|fastcall
DECL|function|__alloc_pages
id|__alloc_pages
c_func
(paren
r_int
r_int
id|gfp_mask
comma
r_int
r_int
id|order
comma
r_struct
id|zonelist
op_star
id|zonelist
)paren
(brace
r_const
r_int
id|wait
op_assign
id|gfp_mask
op_amp
id|__GFP_WAIT
suffix:semicolon
r_struct
id|zone
op_star
op_star
id|zones
comma
op_star
id|z
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_struct
id|reclaim_state
id|reclaim_state
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
op_assign
id|current
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|classzone_idx
suffix:semicolon
r_int
id|do_retry
suffix:semicolon
r_int
id|can_try_harder
suffix:semicolon
id|might_sleep_if
c_func
(paren
id|wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The caller may dip into page reserves a bit more if the caller&n;&t; * cannot run direct reclaim, or is the caller has realtime scheduling&n;&t; * policy&n;&t; */
id|can_try_harder
op_assign
(paren
id|unlikely
c_func
(paren
id|rt_task
c_func
(paren
id|p
)paren
)paren
op_logical_and
op_logical_neg
id|in_interrupt
c_func
(paren
)paren
)paren
op_logical_or
op_logical_neg
id|wait
suffix:semicolon
id|zones
op_assign
id|zonelist-&gt;zones
suffix:semicolon
multiline_comment|/* the list of zones suitable for gfp_mask */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|zones
(braket
l_int|0
)braket
op_eq
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* Should this ever happen?? */
r_return
l_int|NULL
suffix:semicolon
)brace
id|classzone_idx
op_assign
id|zone_idx
c_func
(paren
id|zones
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* Go through the zonelist once, looking for a zone with enough free */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|z
op_assign
id|zones
(braket
id|i
)braket
)paren
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|zone_watermark_ok
c_func
(paren
id|z
comma
id|order
comma
id|z-&gt;pages_low
comma
id|classzone_idx
comma
l_int|0
comma
l_int|0
)paren
)paren
r_continue
suffix:semicolon
id|page
op_assign
id|buffered_rmqueue
c_func
(paren
id|z
comma
id|order
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
r_goto
id|got_pg
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|z
op_assign
id|zones
(braket
id|i
)braket
)paren
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
id|wakeup_kswapd
c_func
(paren
id|z
comma
id|order
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Go through the zonelist again. Let __GFP_HIGH and allocations&n;&t; * coming from realtime tasks to go deeper into reserves&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|z
op_assign
id|zones
(braket
id|i
)braket
)paren
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|zone_watermark_ok
c_func
(paren
id|z
comma
id|order
comma
id|z-&gt;pages_min
comma
id|classzone_idx
comma
id|can_try_harder
comma
id|gfp_mask
op_amp
id|__GFP_HIGH
)paren
)paren
r_continue
suffix:semicolon
id|page
op_assign
id|buffered_rmqueue
c_func
(paren
id|z
comma
id|order
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
r_goto
id|got_pg
suffix:semicolon
)brace
multiline_comment|/* This allocation should allow future memory freeing. */
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
(paren
id|PF_MEMALLOC
op_or
id|PF_MEMDIE
)paren
)paren
op_logical_and
op_logical_neg
id|in_interrupt
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* go through the zonelist yet again, ignoring mins */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|z
op_assign
id|zones
(braket
id|i
)braket
)paren
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
id|page
op_assign
id|buffered_rmqueue
c_func
(paren
id|z
comma
id|order
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
r_goto
id|got_pg
suffix:semicolon
)brace
r_goto
id|nopage
suffix:semicolon
)brace
multiline_comment|/* Atomic allocations - we can&squot;t balance anything */
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
r_goto
id|nopage
suffix:semicolon
id|rebalance
suffix:colon
multiline_comment|/* We now go into synchronous reclaim */
id|p-&gt;flags
op_or_assign
id|PF_MEMALLOC
suffix:semicolon
id|reclaim_state.reclaimed_slab
op_assign
l_int|0
suffix:semicolon
id|p-&gt;reclaim_state
op_assign
op_amp
id|reclaim_state
suffix:semicolon
id|try_to_free_pages
c_func
(paren
id|zones
comma
id|gfp_mask
comma
id|order
)paren
suffix:semicolon
id|p-&gt;reclaim_state
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;flags
op_and_assign
op_complement
id|PF_MEMALLOC
suffix:semicolon
multiline_comment|/* go through the zonelist yet one more time */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|z
op_assign
id|zones
(braket
id|i
)braket
)paren
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|zone_watermark_ok
c_func
(paren
id|z
comma
id|order
comma
id|z-&gt;pages_min
comma
id|classzone_idx
comma
id|can_try_harder
comma
id|gfp_mask
op_amp
id|__GFP_HIGH
)paren
)paren
r_continue
suffix:semicolon
id|page
op_assign
id|buffered_rmqueue
c_func
(paren
id|z
comma
id|order
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
r_goto
id|got_pg
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Don&squot;t let big-order allocations loop unless the caller explicitly&n;&t; * requests that.  Wait for some write requests to complete then retry.&n;&t; *&n;&t; * In this implementation, __GFP_REPEAT means __GFP_NOFAIL for order&n;&t; * &lt;= 3, but that may not be true in other implementations.&n;&t; */
id|do_retry
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|gfp_mask
op_amp
id|__GFP_NORETRY
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|order
op_le
l_int|3
)paren
op_logical_or
(paren
id|gfp_mask
op_amp
id|__GFP_REPEAT
)paren
)paren
id|do_retry
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|gfp_mask
op_amp
id|__GFP_NOFAIL
)paren
id|do_retry
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_retry
)paren
(brace
id|blk_congestion_wait
c_func
(paren
id|WRITE
comma
id|HZ
op_div
l_int|50
)paren
suffix:semicolon
r_goto
id|rebalance
suffix:semicolon
)brace
id|nopage
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|gfp_mask
op_amp
id|__GFP_NOWARN
)paren
op_logical_and
id|printk_ratelimit
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: page allocation failure.&quot;
l_string|&quot; order:%d, mode:0x%x&bslash;n&quot;
comma
id|p-&gt;comm
comma
id|order
comma
id|gfp_mask
)paren
suffix:semicolon
id|dump_stack
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
id|got_pg
suffix:colon
id|zone_statistics
c_func
(paren
id|zonelist
comma
id|z
)paren
suffix:semicolon
r_return
id|page
suffix:semicolon
)brace
DECL|variable|__alloc_pages
id|EXPORT_SYMBOL
c_func
(paren
id|__alloc_pages
)paren
suffix:semicolon
multiline_comment|/*&n; * Common helper functions.&n; */
DECL|function|__get_free_pages
id|fastcall
r_int
r_int
id|__get_free_pages
c_func
(paren
r_int
r_int
id|gfp_mask
comma
r_int
r_int
id|order
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
id|page
op_assign
id|alloc_pages
c_func
(paren
id|gfp_mask
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|variable|__get_free_pages
id|EXPORT_SYMBOL
c_func
(paren
id|__get_free_pages
)paren
suffix:semicolon
DECL|function|get_zeroed_page
id|fastcall
r_int
r_int
id|get_zeroed_page
c_func
(paren
r_int
r_int
id|gfp_mask
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
multiline_comment|/*&n;&t; * get_zeroed_page() returns a 32-bit address, which cannot represent&n;&t; * a highmem page&n;&t; */
id|BUG_ON
c_func
(paren
id|gfp_mask
op_amp
id|__GFP_HIGHMEM
)paren
suffix:semicolon
id|page
op_assign
id|alloc_pages
c_func
(paren
id|gfp_mask
op_or
id|__GFP_ZERO
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
r_return
(paren
r_int
r_int
)paren
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|get_zeroed_page
id|EXPORT_SYMBOL
c_func
(paren
id|get_zeroed_page
)paren
suffix:semicolon
DECL|function|__pagevec_free
r_void
id|__pagevec_free
c_func
(paren
r_struct
id|pagevec
op_star
id|pvec
)paren
(brace
r_int
id|i
op_assign
id|pagevec_count
c_func
(paren
id|pvec
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|i
op_ge
l_int|0
)paren
id|free_hot_cold_page
c_func
(paren
id|pvec-&gt;pages
(braket
id|i
)braket
comma
id|pvec-&gt;cold
)paren
suffix:semicolon
)brace
DECL|function|__free_pages
id|fastcall
r_void
id|__free_pages
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|order
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|PageReserved
c_func
(paren
id|page
)paren
op_logical_and
id|put_page_testzero
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
id|order
op_eq
l_int|0
)paren
id|free_hot_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_else
id|__free_pages_ok
c_func
(paren
id|page
comma
id|order
)paren
suffix:semicolon
)brace
)brace
DECL|variable|__free_pages
id|EXPORT_SYMBOL
c_func
(paren
id|__free_pages
)paren
suffix:semicolon
DECL|function|free_pages
id|fastcall
r_void
id|free_pages
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|order
)paren
(brace
r_if
c_cond
(paren
id|addr
op_ne
l_int|0
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|virt_addr_valid
c_func
(paren
(paren
r_void
op_star
)paren
id|addr
)paren
)paren
suffix:semicolon
id|__free_pages
c_func
(paren
id|virt_to_page
c_func
(paren
(paren
r_void
op_star
)paren
id|addr
)paren
comma
id|order
)paren
suffix:semicolon
)brace
)brace
DECL|variable|free_pages
id|EXPORT_SYMBOL
c_func
(paren
id|free_pages
)paren
suffix:semicolon
multiline_comment|/*&n; * Total amount of free (allocatable) RAM:&n; */
DECL|function|nr_free_pages
r_int
r_int
id|nr_free_pages
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|sum
op_assign
l_int|0
suffix:semicolon
r_struct
id|zone
op_star
id|zone
suffix:semicolon
id|for_each_zone
c_func
(paren
id|zone
)paren
id|sum
op_add_assign
id|zone-&gt;free_pages
suffix:semicolon
r_return
id|sum
suffix:semicolon
)brace
DECL|variable|nr_free_pages
id|EXPORT_SYMBOL
c_func
(paren
id|nr_free_pages
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NUMA
DECL|function|nr_free_pages_pgdat
r_int
r_int
id|nr_free_pages_pgdat
c_func
(paren
id|pg_data_t
op_star
id|pgdat
)paren
(brace
r_int
r_int
id|i
comma
id|sum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_ZONES
suffix:semicolon
id|i
op_increment
)paren
id|sum
op_add_assign
id|pgdat-&gt;node_zones
(braket
id|i
)braket
dot
id|free_pages
suffix:semicolon
r_return
id|sum
suffix:semicolon
)brace
macro_line|#endif
DECL|function|nr_free_zone_pages
r_static
r_int
r_int
id|nr_free_zone_pages
c_func
(paren
r_int
id|offset
)paren
(brace
id|pg_data_t
op_star
id|pgdat
suffix:semicolon
r_int
r_int
id|sum
op_assign
l_int|0
suffix:semicolon
id|for_each_pgdat
c_func
(paren
id|pgdat
)paren
(brace
r_struct
id|zonelist
op_star
id|zonelist
op_assign
id|pgdat-&gt;node_zonelists
op_plus
id|offset
suffix:semicolon
r_struct
id|zone
op_star
op_star
id|zonep
op_assign
id|zonelist-&gt;zones
suffix:semicolon
r_struct
id|zone
op_star
id|zone
suffix:semicolon
r_for
c_loop
(paren
id|zone
op_assign
op_star
id|zonep
op_increment
suffix:semicolon
id|zone
suffix:semicolon
id|zone
op_assign
op_star
id|zonep
op_increment
)paren
(brace
r_int
r_int
id|size
op_assign
id|zone-&gt;present_pages
suffix:semicolon
r_int
r_int
id|high
op_assign
id|zone-&gt;pages_high
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|high
)paren
id|sum
op_add_assign
id|size
op_minus
id|high
suffix:semicolon
)brace
)brace
r_return
id|sum
suffix:semicolon
)brace
multiline_comment|/*&n; * Amount of free RAM allocatable within ZONE_DMA and ZONE_NORMAL&n; */
DECL|function|nr_free_buffer_pages
r_int
r_int
id|nr_free_buffer_pages
c_func
(paren
r_void
)paren
(brace
r_return
id|nr_free_zone_pages
c_func
(paren
id|GFP_USER
op_amp
id|GFP_ZONEMASK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Amount of free RAM allocatable within all zones&n; */
DECL|function|nr_free_pagecache_pages
r_int
r_int
id|nr_free_pagecache_pages
c_func
(paren
r_void
)paren
(brace
r_return
id|nr_free_zone_pages
c_func
(paren
id|GFP_HIGHUSER
op_amp
id|GFP_ZONEMASK
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_HIGHMEM
DECL|function|nr_free_highpages
r_int
r_int
id|nr_free_highpages
(paren
r_void
)paren
(brace
id|pg_data_t
op_star
id|pgdat
suffix:semicolon
r_int
r_int
id|pages
op_assign
l_int|0
suffix:semicolon
id|for_each_pgdat
c_func
(paren
id|pgdat
)paren
id|pages
op_add_assign
id|pgdat-&gt;node_zones
(braket
id|ZONE_HIGHMEM
)braket
dot
id|free_pages
suffix:semicolon
r_return
id|pages
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_NUMA
DECL|function|show_node
r_static
r_void
id|show_node
c_func
(paren
r_struct
id|zone
op_star
id|zone
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Node %d &quot;
comma
id|zone-&gt;zone_pgdat-&gt;node_id
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|show_node
mdefine_line|#define show_node(zone)&t;do { } while (0)
macro_line|#endif
multiline_comment|/*&n; * Accumulate the page_state information across all CPUs.&n; * The result is unavoidably approximate - it can change&n; * during and after execution of this function.&n; */
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_struct
id|page_state
comma
id|page_states
)paren
op_assign
(brace
l_int|0
)brace
suffix:semicolon
DECL|variable|nr_pagecache
id|atomic_t
id|nr_pagecache
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|nr_pagecache
id|EXPORT_SYMBOL
c_func
(paren
id|nr_pagecache
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|DEFINE_PER_CPU
c_func
(paren
r_int
comma
id|nr_pagecache_local
)paren
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|function|__get_page_state
r_void
id|__get_page_state
c_func
(paren
r_struct
id|page_state
op_star
id|ret
comma
r_int
id|nr
)paren
(brace
r_int
id|cpu
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|ret
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ret
)paren
)paren
suffix:semicolon
id|cpu
op_assign
id|first_cpu
c_func
(paren
id|cpu_online_map
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cpu
OL
id|NR_CPUS
)paren
(brace
r_int
r_int
op_star
id|in
comma
op_star
id|out
comma
id|off
suffix:semicolon
id|in
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|per_cpu
c_func
(paren
id|page_states
comma
id|cpu
)paren
suffix:semicolon
id|cpu
op_assign
id|next_cpu
c_func
(paren
id|cpu
comma
id|cpu_online_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu
OL
id|NR_CPUS
)paren
id|prefetch
c_func
(paren
op_amp
id|per_cpu
c_func
(paren
id|page_states
comma
id|cpu
)paren
)paren
suffix:semicolon
id|out
op_assign
(paren
r_int
r_int
op_star
)paren
id|ret
suffix:semicolon
r_for
c_loop
(paren
id|off
op_assign
l_int|0
suffix:semicolon
id|off
OL
id|nr
suffix:semicolon
id|off
op_increment
)paren
op_star
id|out
op_increment
op_add_assign
op_star
id|in
op_increment
suffix:semicolon
)brace
)brace
DECL|function|get_page_state
r_void
id|get_page_state
c_func
(paren
r_struct
id|page_state
op_star
id|ret
)paren
(brace
r_int
id|nr
suffix:semicolon
id|nr
op_assign
m_offsetof
(paren
r_struct
id|page_state
comma
id|GET_PAGE_STATE_LAST
)paren
suffix:semicolon
id|nr
op_div_assign
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|__get_page_state
c_func
(paren
id|ret
comma
id|nr
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|get_full_page_state
r_void
id|get_full_page_state
c_func
(paren
r_struct
id|page_state
op_star
id|ret
)paren
(brace
id|__get_page_state
c_func
(paren
id|ret
comma
r_sizeof
(paren
op_star
id|ret
)paren
op_div
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
)brace
DECL|function|__read_page_state
r_int
r_int
id|__read_page_state
c_func
(paren
r_int
id|offset
)paren
(brace
r_int
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|cpu
suffix:semicolon
id|for_each_online_cpu
c_func
(paren
id|cpu
)paren
(brace
r_int
r_int
id|in
suffix:semicolon
id|in
op_assign
(paren
r_int
r_int
)paren
op_amp
id|per_cpu
c_func
(paren
id|page_states
comma
id|cpu
)paren
op_plus
id|offset
suffix:semicolon
id|ret
op_add_assign
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|in
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|__mod_page_state
r_void
id|__mod_page_state
c_func
(paren
r_int
id|offset
comma
r_int
r_int
id|delta
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_void
op_star
id|ptr
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|ptr
op_assign
op_amp
id|__get_cpu_var
c_func
(paren
id|page_states
)paren
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
(paren
id|ptr
op_plus
id|offset
)paren
op_add_assign
id|delta
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|__mod_page_state
id|EXPORT_SYMBOL
c_func
(paren
id|__mod_page_state
)paren
suffix:semicolon
DECL|function|__get_zone_counts
r_void
id|__get_zone_counts
c_func
(paren
r_int
r_int
op_star
id|active
comma
r_int
r_int
op_star
id|inactive
comma
r_int
r_int
op_star
id|free
comma
r_struct
id|pglist_data
op_star
id|pgdat
)paren
(brace
r_struct
id|zone
op_star
id|zones
op_assign
id|pgdat-&gt;node_zones
suffix:semicolon
r_int
id|i
suffix:semicolon
op_star
id|active
op_assign
l_int|0
suffix:semicolon
op_star
id|inactive
op_assign
l_int|0
suffix:semicolon
op_star
id|free
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_ZONES
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|active
op_add_assign
id|zones
(braket
id|i
)braket
dot
id|nr_active
suffix:semicolon
op_star
id|inactive
op_add_assign
id|zones
(braket
id|i
)braket
dot
id|nr_inactive
suffix:semicolon
op_star
id|free
op_add_assign
id|zones
(braket
id|i
)braket
dot
id|free_pages
suffix:semicolon
)brace
)brace
DECL|function|get_zone_counts
r_void
id|get_zone_counts
c_func
(paren
r_int
r_int
op_star
id|active
comma
r_int
r_int
op_star
id|inactive
comma
r_int
r_int
op_star
id|free
)paren
(brace
r_struct
id|pglist_data
op_star
id|pgdat
suffix:semicolon
op_star
id|active
op_assign
l_int|0
suffix:semicolon
op_star
id|inactive
op_assign
l_int|0
suffix:semicolon
op_star
id|free
op_assign
l_int|0
suffix:semicolon
id|for_each_pgdat
c_func
(paren
id|pgdat
)paren
(brace
r_int
r_int
id|l
comma
id|m
comma
id|n
suffix:semicolon
id|__get_zone_counts
c_func
(paren
op_amp
id|l
comma
op_amp
id|m
comma
op_amp
id|n
comma
id|pgdat
)paren
suffix:semicolon
op_star
id|active
op_add_assign
id|l
suffix:semicolon
op_star
id|inactive
op_add_assign
id|m
suffix:semicolon
op_star
id|free
op_add_assign
id|n
suffix:semicolon
)brace
)brace
DECL|function|si_meminfo
r_void
id|si_meminfo
c_func
(paren
r_struct
id|sysinfo
op_star
id|val
)paren
(brace
id|val-&gt;totalram
op_assign
id|totalram_pages
suffix:semicolon
id|val-&gt;sharedram
op_assign
l_int|0
suffix:semicolon
id|val-&gt;freeram
op_assign
id|nr_free_pages
c_func
(paren
)paren
suffix:semicolon
id|val-&gt;bufferram
op_assign
id|nr_blockdev_pages
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_HIGHMEM
id|val-&gt;totalhigh
op_assign
id|totalhigh_pages
suffix:semicolon
id|val-&gt;freehigh
op_assign
id|nr_free_highpages
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
id|val-&gt;totalhigh
op_assign
l_int|0
suffix:semicolon
id|val-&gt;freehigh
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|val-&gt;mem_unit
op_assign
id|PAGE_SIZE
suffix:semicolon
)brace
DECL|variable|si_meminfo
id|EXPORT_SYMBOL
c_func
(paren
id|si_meminfo
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NUMA
DECL|function|si_meminfo_node
r_void
id|si_meminfo_node
c_func
(paren
r_struct
id|sysinfo
op_star
id|val
comma
r_int
id|nid
)paren
(brace
id|pg_data_t
op_star
id|pgdat
op_assign
id|NODE_DATA
c_func
(paren
id|nid
)paren
suffix:semicolon
id|val-&gt;totalram
op_assign
id|pgdat-&gt;node_present_pages
suffix:semicolon
id|val-&gt;freeram
op_assign
id|nr_free_pages_pgdat
c_func
(paren
id|pgdat
)paren
suffix:semicolon
id|val-&gt;totalhigh
op_assign
id|pgdat-&gt;node_zones
(braket
id|ZONE_HIGHMEM
)braket
dot
id|present_pages
suffix:semicolon
id|val-&gt;freehigh
op_assign
id|pgdat-&gt;node_zones
(braket
id|ZONE_HIGHMEM
)braket
dot
id|free_pages
suffix:semicolon
id|val-&gt;mem_unit
op_assign
id|PAGE_SIZE
suffix:semicolon
)brace
macro_line|#endif
DECL|macro|K
mdefine_line|#define K(x) ((x) &lt;&lt; (PAGE_SHIFT-10))
multiline_comment|/*&n; * Show free area list (used inside shift_scroll-lock stuff)&n; * We also calculate the percentage fragmentation. We do this by counting the&n; * memory on each free list with the exception of the first item on the list.&n; */
DECL|function|show_free_areas
r_void
id|show_free_areas
c_func
(paren
r_void
)paren
(brace
r_struct
id|page_state
id|ps
suffix:semicolon
r_int
id|cpu
comma
id|temperature
suffix:semicolon
r_int
r_int
id|active
suffix:semicolon
r_int
r_int
id|inactive
suffix:semicolon
r_int
r_int
id|free
suffix:semicolon
r_struct
id|zone
op_star
id|zone
suffix:semicolon
id|for_each_zone
c_func
(paren
id|zone
)paren
(brace
id|show_node
c_func
(paren
id|zone
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s per-cpu:&quot;
comma
id|zone-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zone-&gt;present_pages
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; empty&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|NR_CPUS
suffix:semicolon
op_increment
id|cpu
)paren
(brace
r_struct
id|per_cpu_pageset
op_star
id|pageset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_possible
c_func
(paren
id|cpu
)paren
)paren
r_continue
suffix:semicolon
id|pageset
op_assign
id|zone-&gt;pageset
op_plus
id|cpu
suffix:semicolon
r_for
c_loop
(paren
id|temperature
op_assign
l_int|0
suffix:semicolon
id|temperature
OL
l_int|2
suffix:semicolon
id|temperature
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;cpu %d %s: low %d, high %d, batch %d&bslash;n&quot;
comma
id|cpu
comma
id|temperature
ques
c_cond
l_string|&quot;cold&quot;
suffix:colon
l_string|&quot;hot&quot;
comma
id|pageset-&gt;pcp
(braket
id|temperature
)braket
dot
id|low
comma
id|pageset-&gt;pcp
(braket
id|temperature
)braket
dot
id|high
comma
id|pageset-&gt;pcp
(braket
id|temperature
)braket
dot
id|batch
)paren
suffix:semicolon
)brace
)brace
id|get_page_state
c_func
(paren
op_amp
id|ps
)paren
suffix:semicolon
id|get_zone_counts
c_func
(paren
op_amp
id|active
comma
op_amp
id|inactive
comma
op_amp
id|free
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nFree pages: %11ukB (%ukB HighMem)&bslash;n&quot;
comma
id|K
c_func
(paren
id|nr_free_pages
c_func
(paren
)paren
)paren
comma
id|K
c_func
(paren
id|nr_free_highpages
c_func
(paren
)paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Active:%lu inactive:%lu dirty:%lu writeback:%lu &quot;
l_string|&quot;unstable:%lu free:%u slab:%lu mapped:%lu pagetables:%lu&bslash;n&quot;
comma
id|active
comma
id|inactive
comma
id|ps.nr_dirty
comma
id|ps.nr_writeback
comma
id|ps.nr_unstable
comma
id|nr_free_pages
c_func
(paren
)paren
comma
id|ps.nr_slab
comma
id|ps.nr_mapped
comma
id|ps.nr_page_table_pages
)paren
suffix:semicolon
id|for_each_zone
c_func
(paren
id|zone
)paren
(brace
r_int
id|i
suffix:semicolon
id|show_node
c_func
(paren
id|zone
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s&quot;
l_string|&quot; free:%lukB&quot;
l_string|&quot; min:%lukB&quot;
l_string|&quot; low:%lukB&quot;
l_string|&quot; high:%lukB&quot;
l_string|&quot; active:%lukB&quot;
l_string|&quot; inactive:%lukB&quot;
l_string|&quot; present:%lukB&quot;
l_string|&quot; pages_scanned:%lu&quot;
l_string|&quot; all_unreclaimable? %s&quot;
l_string|&quot;&bslash;n&quot;
comma
id|zone-&gt;name
comma
id|K
c_func
(paren
id|zone-&gt;free_pages
)paren
comma
id|K
c_func
(paren
id|zone-&gt;pages_min
)paren
comma
id|K
c_func
(paren
id|zone-&gt;pages_low
)paren
comma
id|K
c_func
(paren
id|zone-&gt;pages_high
)paren
comma
id|K
c_func
(paren
id|zone-&gt;nr_active
)paren
comma
id|K
c_func
(paren
id|zone-&gt;nr_inactive
)paren
comma
id|K
c_func
(paren
id|zone-&gt;present_pages
)paren
comma
id|zone-&gt;pages_scanned
comma
(paren
id|zone-&gt;all_unreclaimable
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;lowmem_reserve[]:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_ZONES
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %lu&quot;
comma
id|zone-&gt;lowmem_reserve
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|for_each_zone
c_func
(paren
id|zone
)paren
(brace
r_int
r_int
id|nr
comma
id|flags
comma
id|order
comma
id|total
op_assign
l_int|0
suffix:semicolon
id|show_node
c_func
(paren
id|zone
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: &quot;
comma
id|zone-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zone-&gt;present_pages
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;empty&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
l_int|0
suffix:semicolon
id|order
OL
id|MAX_ORDER
suffix:semicolon
id|order
op_increment
)paren
(brace
id|nr
op_assign
id|zone-&gt;free_area
(braket
id|order
)braket
dot
id|nr_free
suffix:semicolon
id|total
op_add_assign
id|nr
op_lshift
id|order
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%lu*%lukB &quot;
comma
id|nr
comma
id|K
c_func
(paren
l_int|1UL
)paren
op_lshift
id|order
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;= %lukB&bslash;n&quot;
comma
id|K
c_func
(paren
id|total
)paren
)paren
suffix:semicolon
)brace
id|show_swap_cache_info
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Builds allocation fallback zone lists.&n; */
DECL|function|build_zonelists_node
r_static
r_int
id|__init
id|build_zonelists_node
c_func
(paren
id|pg_data_t
op_star
id|pgdat
comma
r_struct
id|zonelist
op_star
id|zonelist
comma
r_int
id|j
comma
r_int
id|k
)paren
(brace
r_switch
c_cond
(paren
id|k
)paren
(brace
r_struct
id|zone
op_star
id|zone
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_case
id|ZONE_HIGHMEM
suffix:colon
id|zone
op_assign
id|pgdat-&gt;node_zones
op_plus
id|ZONE_HIGHMEM
suffix:semicolon
r_if
c_cond
(paren
id|zone-&gt;present_pages
)paren
(brace
macro_line|#ifndef CONFIG_HIGHMEM
id|BUG
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|zonelist-&gt;zones
(braket
id|j
op_increment
)braket
op_assign
id|zone
suffix:semicolon
)brace
r_case
id|ZONE_NORMAL
suffix:colon
id|zone
op_assign
id|pgdat-&gt;node_zones
op_plus
id|ZONE_NORMAL
suffix:semicolon
r_if
c_cond
(paren
id|zone-&gt;present_pages
)paren
id|zonelist-&gt;zones
(braket
id|j
op_increment
)braket
op_assign
id|zone
suffix:semicolon
r_case
id|ZONE_DMA
suffix:colon
id|zone
op_assign
id|pgdat-&gt;node_zones
op_plus
id|ZONE_DMA
suffix:semicolon
r_if
c_cond
(paren
id|zone-&gt;present_pages
)paren
id|zonelist-&gt;zones
(braket
id|j
op_increment
)braket
op_assign
id|zone
suffix:semicolon
)brace
r_return
id|j
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NUMA
DECL|macro|MAX_NODE_LOAD
mdefine_line|#define MAX_NODE_LOAD (num_online_nodes())
DECL|variable|node_load
r_static
r_int
id|__initdata
id|node_load
(braket
id|MAX_NUMNODES
)braket
suffix:semicolon
multiline_comment|/**&n; * find_next_best_node - find the next node that should appear in a given&n; *    node&squot;s fallback list&n; * @node: node whose fallback list we&squot;re appending&n; * @used_node_mask: nodemask_t of already used nodes&n; *&n; * We use a number of factors to determine which is the next node that should&n; * appear on a given node&squot;s fallback list.  The node should not have appeared&n; * already in @node&squot;s fallback list, and it should be the next closest node&n; * according to the distance array (which contains arbitrary distance values&n; * from each node to each node in the system), and should also prefer nodes&n; * with no CPUs, since presumably they&squot;ll have very little allocation pressure&n; * on them otherwise.&n; * It returns -1 if no node is found.&n; */
DECL|function|find_next_best_node
r_static
r_int
id|__init
id|find_next_best_node
c_func
(paren
r_int
id|node
comma
id|nodemask_t
op_star
id|used_node_mask
)paren
(brace
r_int
id|i
comma
id|n
comma
id|val
suffix:semicolon
r_int
id|min_val
op_assign
id|INT_MAX
suffix:semicolon
r_int
id|best_node
op_assign
op_minus
l_int|1
suffix:semicolon
id|for_each_online_node
c_func
(paren
id|i
)paren
(brace
id|cpumask_t
id|tmp
suffix:semicolon
multiline_comment|/* Start from local node */
id|n
op_assign
(paren
id|node
op_plus
id|i
)paren
op_mod
id|num_online_nodes
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t want a node to appear more than once */
r_if
c_cond
(paren
id|node_isset
c_func
(paren
id|n
comma
op_star
id|used_node_mask
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Use the local node if we haven&squot;t already */
r_if
c_cond
(paren
op_logical_neg
id|node_isset
c_func
(paren
id|node
comma
op_star
id|used_node_mask
)paren
)paren
(brace
id|best_node
op_assign
id|node
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Use the distance array to find the distance */
id|val
op_assign
id|node_distance
c_func
(paren
id|node
comma
id|n
)paren
suffix:semicolon
multiline_comment|/* Give preference to headless and unused nodes */
id|tmp
op_assign
id|node_to_cpumask
c_func
(paren
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpus_empty
c_func
(paren
id|tmp
)paren
)paren
id|val
op_add_assign
id|PENALTY_FOR_NODE_WITH_CPUS
suffix:semicolon
multiline_comment|/* Slight preference for less loaded node */
id|val
op_mul_assign
(paren
id|MAX_NODE_LOAD
op_star
id|MAX_NUMNODES
)paren
suffix:semicolon
id|val
op_add_assign
id|node_load
(braket
id|n
)braket
suffix:semicolon
r_if
c_cond
(paren
id|val
OL
id|min_val
)paren
(brace
id|min_val
op_assign
id|val
suffix:semicolon
id|best_node
op_assign
id|n
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|best_node
op_ge
l_int|0
)paren
id|node_set
c_func
(paren
id|best_node
comma
op_star
id|used_node_mask
)paren
suffix:semicolon
r_return
id|best_node
suffix:semicolon
)brace
DECL|function|build_zonelists
r_static
r_void
id|__init
id|build_zonelists
c_func
(paren
id|pg_data_t
op_star
id|pgdat
)paren
(brace
r_int
id|i
comma
id|j
comma
id|k
comma
id|node
comma
id|local_node
suffix:semicolon
r_int
id|prev_node
comma
id|load
suffix:semicolon
r_struct
id|zonelist
op_star
id|zonelist
suffix:semicolon
id|nodemask_t
id|used_mask
suffix:semicolon
multiline_comment|/* initialize zonelists */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|GFP_ZONETYPES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|zonelist
op_assign
id|pgdat-&gt;node_zonelists
op_plus
id|i
suffix:semicolon
id|memset
c_func
(paren
id|zonelist
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|zonelist
)paren
)paren
suffix:semicolon
id|zonelist-&gt;zones
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* NUMA-aware ordering of nodes */
id|local_node
op_assign
id|pgdat-&gt;node_id
suffix:semicolon
id|load
op_assign
id|num_online_nodes
c_func
(paren
)paren
suffix:semicolon
id|prev_node
op_assign
id|local_node
suffix:semicolon
id|nodes_clear
c_func
(paren
id|used_mask
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|node
op_assign
id|find_next_best_node
c_func
(paren
id|local_node
comma
op_amp
id|used_mask
)paren
)paren
op_ge
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * We don&squot;t want to pressure a particular node.&n;&t;&t; * So adding penalty to the first node in same&n;&t;&t; * distance group to make it round-robin.&n;&t;&t; */
r_if
c_cond
(paren
id|node_distance
c_func
(paren
id|local_node
comma
id|node
)paren
op_ne
id|node_distance
c_func
(paren
id|local_node
comma
id|prev_node
)paren
)paren
id|node_load
(braket
id|node
)braket
op_add_assign
id|load
suffix:semicolon
id|prev_node
op_assign
id|node
suffix:semicolon
id|load
op_decrement
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|GFP_ZONETYPES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|zonelist
op_assign
id|pgdat-&gt;node_zonelists
op_plus
id|i
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|zonelist-&gt;zones
(braket
id|j
)braket
op_ne
l_int|NULL
suffix:semicolon
id|j
op_increment
)paren
suffix:semicolon
id|k
op_assign
id|ZONE_NORMAL
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|__GFP_HIGHMEM
)paren
id|k
op_assign
id|ZONE_HIGHMEM
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|__GFP_DMA
)paren
id|k
op_assign
id|ZONE_DMA
suffix:semicolon
id|j
op_assign
id|build_zonelists_node
c_func
(paren
id|NODE_DATA
c_func
(paren
id|node
)paren
comma
id|zonelist
comma
id|j
comma
id|k
)paren
suffix:semicolon
id|zonelist-&gt;zones
(braket
id|j
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
macro_line|#else&t;/* CONFIG_NUMA */
DECL|function|build_zonelists
r_static
r_void
id|__init
id|build_zonelists
c_func
(paren
id|pg_data_t
op_star
id|pgdat
)paren
(brace
r_int
id|i
comma
id|j
comma
id|k
comma
id|node
comma
id|local_node
suffix:semicolon
id|local_node
op_assign
id|pgdat-&gt;node_id
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|GFP_ZONETYPES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|zonelist
op_star
id|zonelist
suffix:semicolon
id|zonelist
op_assign
id|pgdat-&gt;node_zonelists
op_plus
id|i
suffix:semicolon
id|memset
c_func
(paren
id|zonelist
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|zonelist
)paren
)paren
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
id|k
op_assign
id|ZONE_NORMAL
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|__GFP_HIGHMEM
)paren
id|k
op_assign
id|ZONE_HIGHMEM
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|__GFP_DMA
)paren
id|k
op_assign
id|ZONE_DMA
suffix:semicolon
id|j
op_assign
id|build_zonelists_node
c_func
(paren
id|pgdat
comma
id|zonelist
comma
id|j
comma
id|k
)paren
suffix:semicolon
multiline_comment|/*&n; &t;&t; * Now we build the zonelist so that it contains the zones&n; &t;&t; * of all the other nodes.&n; &t;&t; * We don&squot;t want to pressure a particular node, so when&n; &t;&t; * building the zones for node N, we make sure that the&n; &t;&t; * zones coming right after the local ones are those from&n; &t;&t; * node N+1 (modulo N)&n; &t;&t; */
r_for
c_loop
(paren
id|node
op_assign
id|local_node
op_plus
l_int|1
suffix:semicolon
id|node
OL
id|MAX_NUMNODES
suffix:semicolon
id|node
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|node_online
c_func
(paren
id|node
)paren
)paren
r_continue
suffix:semicolon
id|j
op_assign
id|build_zonelists_node
c_func
(paren
id|NODE_DATA
c_func
(paren
id|node
)paren
comma
id|zonelist
comma
id|j
comma
id|k
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|node
OL
id|local_node
suffix:semicolon
id|node
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|node_online
c_func
(paren
id|node
)paren
)paren
r_continue
suffix:semicolon
id|j
op_assign
id|build_zonelists_node
c_func
(paren
id|NODE_DATA
c_func
(paren
id|node
)paren
comma
id|zonelist
comma
id|j
comma
id|k
)paren
suffix:semicolon
)brace
id|zonelist-&gt;zones
(braket
id|j
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* CONFIG_NUMA */
DECL|function|build_all_zonelists
r_void
id|__init
id|build_all_zonelists
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|for_each_online_node
c_func
(paren
id|i
)paren
id|build_zonelists
c_func
(paren
id|NODE_DATA
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Built %i zonelists&bslash;n&quot;
comma
id|num_online_nodes
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Helper functions to size the waitqueue hash table.&n; * Essentially these want to choose hash table sizes sufficiently&n; * large so that collisions trying to wait on pages are rare.&n; * But in fact, the number of active page waitqueues on typical&n; * systems is ridiculously low, less than 200. So this is even&n; * conservative, even though it seems large.&n; *&n; * The constant PAGES_PER_WAITQUEUE specifies the ratio of pages to&n; * waitqueues, i.e. the size of the waitq table given the number of pages.&n; */
DECL|macro|PAGES_PER_WAITQUEUE
mdefine_line|#define PAGES_PER_WAITQUEUE&t;256
DECL|function|wait_table_size
r_static
r_inline
r_int
r_int
id|wait_table_size
c_func
(paren
r_int
r_int
id|pages
)paren
(brace
r_int
r_int
id|size
op_assign
l_int|1
suffix:semicolon
id|pages
op_div_assign
id|PAGES_PER_WAITQUEUE
suffix:semicolon
r_while
c_loop
(paren
id|size
OL
id|pages
)paren
id|size
op_lshift_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Once we have dozens or even hundreds of threads sleeping&n;&t; * on IO we&squot;ve got bigger problems than wait queue collision.&n;&t; * Limit the size of the wait table to a reasonable size.&n;&t; */
id|size
op_assign
id|min
c_func
(paren
id|size
comma
l_int|4096UL
)paren
suffix:semicolon
r_return
id|max
c_func
(paren
id|size
comma
l_int|4UL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is an integer logarithm so that shifts can be used later&n; * to extract the more random high bits from the multiplicative&n; * hash function before the remainder is taken.&n; */
DECL|function|wait_table_bits
r_static
r_inline
r_int
r_int
id|wait_table_bits
c_func
(paren
r_int
r_int
id|size
)paren
(brace
r_return
id|ffz
c_func
(paren
op_complement
id|size
)paren
suffix:semicolon
)brace
DECL|macro|LONG_ALIGN
mdefine_line|#define LONG_ALIGN(x) (((x)+(sizeof(long))-1)&amp;~((sizeof(long))-1))
DECL|function|calculate_zone_totalpages
r_static
r_void
id|__init
id|calculate_zone_totalpages
c_func
(paren
r_struct
id|pglist_data
op_star
id|pgdat
comma
r_int
r_int
op_star
id|zones_size
comma
r_int
r_int
op_star
id|zholes_size
)paren
(brace
r_int
r_int
id|realtotalpages
comma
id|totalpages
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_ZONES
suffix:semicolon
id|i
op_increment
)paren
id|totalpages
op_add_assign
id|zones_size
(braket
id|i
)braket
suffix:semicolon
id|pgdat-&gt;node_spanned_pages
op_assign
id|totalpages
suffix:semicolon
id|realtotalpages
op_assign
id|totalpages
suffix:semicolon
r_if
c_cond
(paren
id|zholes_size
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_ZONES
suffix:semicolon
id|i
op_increment
)paren
id|realtotalpages
op_sub_assign
id|zholes_size
(braket
id|i
)braket
suffix:semicolon
id|pgdat-&gt;node_present_pages
op_assign
id|realtotalpages
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;On node %d totalpages: %lu&bslash;n&quot;
comma
id|pgdat-&gt;node_id
comma
id|realtotalpages
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initially all pages are reserved - free ones are freed&n; * up by free_all_bootmem() once the early boot process is&n; * done. Non-atomic initialization, single-pass.&n; */
DECL|function|memmap_init_zone
r_void
id|__init
id|memmap_init_zone
c_func
(paren
r_int
r_int
id|size
comma
r_int
id|nid
comma
r_int
r_int
id|zone
comma
r_int
r_int
id|start_pfn
)paren
(brace
r_struct
id|page
op_star
id|start
op_assign
id|pfn_to_page
c_func
(paren
id|start_pfn
)paren
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|start
suffix:semicolon
id|page
OL
(paren
id|start
op_plus
id|size
)paren
suffix:semicolon
id|page
op_increment
)paren
(brace
id|set_page_zone
c_func
(paren
id|page
comma
id|NODEZONE
c_func
(paren
id|nid
comma
id|zone
)paren
)paren
suffix:semicolon
id|set_page_count
c_func
(paren
id|page
comma
l_int|0
)paren
suffix:semicolon
id|reset_page_mapcount
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageReserved
c_func
(paren
id|page
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|page-&gt;lru
)paren
suffix:semicolon
macro_line|#ifdef WANT_PAGE_VIRTUAL
multiline_comment|/* The shift won&squot;t overflow because ZONE_NORMAL is below 4G. */
r_if
c_cond
(paren
op_logical_neg
id|is_highmem_idx
c_func
(paren
id|zone
)paren
)paren
id|set_page_address
c_func
(paren
id|page
comma
id|__va
c_func
(paren
id|start_pfn
op_lshift
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
macro_line|#endif
id|start_pfn
op_increment
suffix:semicolon
)brace
)brace
DECL|function|zone_init_free_lists
r_void
id|zone_init_free_lists
c_func
(paren
r_struct
id|pglist_data
op_star
id|pgdat
comma
r_struct
id|zone
op_star
id|zone
comma
r_int
r_int
id|size
)paren
(brace
r_int
id|order
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
l_int|0
suffix:semicolon
id|order
OL
id|MAX_ORDER
suffix:semicolon
id|order
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|zone-&gt;free_area
(braket
id|order
)braket
dot
id|free_list
)paren
suffix:semicolon
id|zone-&gt;free_area
(braket
id|order
)braket
dot
id|nr_free
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#ifndef __HAVE_ARCH_MEMMAP_INIT
DECL|macro|memmap_init
mdefine_line|#define memmap_init(size, nid, zone, start_pfn) &bslash;&n;&t;memmap_init_zone((size), (nid), (zone), (start_pfn))
macro_line|#endif
multiline_comment|/*&n; * Set up the zone data structures:&n; *   - mark all pages reserved&n; *   - mark all memory queues empty&n; *   - clear the memory bitmaps&n; */
DECL|function|free_area_init_core
r_static
r_void
id|__init
id|free_area_init_core
c_func
(paren
r_struct
id|pglist_data
op_star
id|pgdat
comma
r_int
r_int
op_star
id|zones_size
comma
r_int
r_int
op_star
id|zholes_size
)paren
(brace
r_int
r_int
id|i
comma
id|j
suffix:semicolon
r_const
r_int
r_int
id|zone_required_alignment
op_assign
l_int|1UL
op_lshift
(paren
id|MAX_ORDER
op_minus
l_int|1
)paren
suffix:semicolon
r_int
id|cpu
comma
id|nid
op_assign
id|pgdat-&gt;node_id
suffix:semicolon
r_int
r_int
id|zone_start_pfn
op_assign
id|pgdat-&gt;node_start_pfn
suffix:semicolon
id|pgdat-&gt;nr_zones
op_assign
l_int|0
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|pgdat-&gt;kswapd_wait
)paren
suffix:semicolon
id|pgdat-&gt;kswapd_max_order
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|MAX_NR_ZONES
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|zone
op_star
id|zone
op_assign
id|pgdat-&gt;node_zones
op_plus
id|j
suffix:semicolon
r_int
r_int
id|size
comma
id|realsize
suffix:semicolon
r_int
r_int
id|batch
suffix:semicolon
id|zone_table
(braket
id|NODEZONE
c_func
(paren
id|nid
comma
id|j
)paren
)braket
op_assign
id|zone
suffix:semicolon
id|realsize
op_assign
id|size
op_assign
id|zones_size
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|zholes_size
)paren
id|realsize
op_sub_assign
id|zholes_size
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
id|ZONE_DMA
op_logical_or
id|j
op_eq
id|ZONE_NORMAL
)paren
id|nr_kernel_pages
op_add_assign
id|realsize
suffix:semicolon
id|nr_all_pages
op_add_assign
id|realsize
suffix:semicolon
id|zone-&gt;spanned_pages
op_assign
id|size
suffix:semicolon
id|zone-&gt;present_pages
op_assign
id|realsize
suffix:semicolon
id|zone-&gt;name
op_assign
id|zone_names
(braket
id|j
)braket
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|zone-&gt;lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
id|zone-&gt;zone_pgdat
op_assign
id|pgdat
suffix:semicolon
id|zone-&gt;free_pages
op_assign
l_int|0
suffix:semicolon
id|zone-&gt;temp_priority
op_assign
id|zone-&gt;prev_priority
op_assign
id|DEF_PRIORITY
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The per-cpu-pages pools are set to around 1000th of the&n;&t;&t; * size of the zone.  But no more than 1/4 of a meg - there&squot;s&n;&t;&t; * no point in going beyond the size of L2 cache.&n;&t;&t; *&n;&t;&t; * OK, so we don&squot;t know how big the cache is.  So guess.&n;&t;&t; */
id|batch
op_assign
id|zone-&gt;present_pages
op_div
l_int|1024
suffix:semicolon
r_if
c_cond
(paren
id|batch
op_star
id|PAGE_SIZE
OG
l_int|256
op_star
l_int|1024
)paren
id|batch
op_assign
(paren
l_int|256
op_star
l_int|1024
)paren
op_div
id|PAGE_SIZE
suffix:semicolon
id|batch
op_div_assign
l_int|4
suffix:semicolon
multiline_comment|/* We effectively *= 4 below */
r_if
c_cond
(paren
id|batch
OL
l_int|1
)paren
id|batch
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|NR_CPUS
suffix:semicolon
id|cpu
op_increment
)paren
(brace
r_struct
id|per_cpu_pages
op_star
id|pcp
suffix:semicolon
id|pcp
op_assign
op_amp
id|zone-&gt;pageset
(braket
id|cpu
)braket
dot
id|pcp
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* hot */
id|pcp-&gt;count
op_assign
l_int|0
suffix:semicolon
id|pcp-&gt;low
op_assign
l_int|2
op_star
id|batch
suffix:semicolon
id|pcp-&gt;high
op_assign
l_int|6
op_star
id|batch
suffix:semicolon
id|pcp-&gt;batch
op_assign
l_int|1
op_star
id|batch
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|pcp-&gt;list
)paren
suffix:semicolon
id|pcp
op_assign
op_amp
id|zone-&gt;pageset
(braket
id|cpu
)braket
dot
id|pcp
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* cold */
id|pcp-&gt;count
op_assign
l_int|0
suffix:semicolon
id|pcp-&gt;low
op_assign
l_int|0
suffix:semicolon
id|pcp-&gt;high
op_assign
l_int|2
op_star
id|batch
suffix:semicolon
id|pcp-&gt;batch
op_assign
l_int|1
op_star
id|batch
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|pcp-&gt;list
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;  %s zone: %lu pages, LIFO batch:%lu&bslash;n&quot;
comma
id|zone_names
(braket
id|j
)braket
comma
id|realsize
comma
id|batch
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|zone-&gt;active_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|zone-&gt;inactive_list
)paren
suffix:semicolon
id|zone-&gt;nr_scan_active
op_assign
l_int|0
suffix:semicolon
id|zone-&gt;nr_scan_inactive
op_assign
l_int|0
suffix:semicolon
id|zone-&gt;nr_active
op_assign
l_int|0
suffix:semicolon
id|zone-&gt;nr_inactive
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The per-page waitqueue mechanism uses hashed waitqueues&n;&t;&t; * per zone.&n;&t;&t; */
id|zone-&gt;wait_table_size
op_assign
id|wait_table_size
c_func
(paren
id|size
)paren
suffix:semicolon
id|zone-&gt;wait_table_bits
op_assign
id|wait_table_bits
c_func
(paren
id|zone-&gt;wait_table_size
)paren
suffix:semicolon
id|zone-&gt;wait_table
op_assign
(paren
id|wait_queue_head_t
op_star
)paren
id|alloc_bootmem_node
c_func
(paren
id|pgdat
comma
id|zone-&gt;wait_table_size
op_star
r_sizeof
(paren
id|wait_queue_head_t
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|zone-&gt;wait_table_size
suffix:semicolon
op_increment
id|i
)paren
(brace
id|init_waitqueue_head
c_func
(paren
id|zone-&gt;wait_table
op_plus
id|i
)paren
suffix:semicolon
)brace
id|pgdat-&gt;nr_zones
op_assign
id|j
op_plus
l_int|1
suffix:semicolon
id|zone-&gt;zone_mem_map
op_assign
id|pfn_to_page
c_func
(paren
id|zone_start_pfn
)paren
suffix:semicolon
id|zone-&gt;zone_start_pfn
op_assign
id|zone_start_pfn
suffix:semicolon
r_if
c_cond
(paren
(paren
id|zone_start_pfn
)paren
op_amp
(paren
id|zone_required_alignment
op_minus
l_int|1
)paren
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;BUG: wrong zone alignment, it will crash&bslash;n&quot;
)paren
suffix:semicolon
id|memmap_init
c_func
(paren
id|size
comma
id|nid
comma
id|j
comma
id|zone_start_pfn
)paren
suffix:semicolon
id|zone_start_pfn
op_add_assign
id|size
suffix:semicolon
id|zone_init_free_lists
c_func
(paren
id|pgdat
comma
id|zone
comma
id|zone-&gt;spanned_pages
)paren
suffix:semicolon
)brace
)brace
DECL|function|node_alloc_mem_map
r_void
id|__init
id|node_alloc_mem_map
c_func
(paren
r_struct
id|pglist_data
op_star
id|pgdat
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
id|size
op_assign
(paren
id|pgdat-&gt;node_spanned_pages
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|page
)paren
suffix:semicolon
id|pgdat-&gt;node_mem_map
op_assign
id|alloc_bootmem_node
c_func
(paren
id|pgdat
comma
id|size
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_DISCONTIGMEM
id|mem_map
op_assign
id|contig_page_data.node_mem_map
suffix:semicolon
macro_line|#endif
)brace
DECL|function|free_area_init_node
r_void
id|__init
id|free_area_init_node
c_func
(paren
r_int
id|nid
comma
r_struct
id|pglist_data
op_star
id|pgdat
comma
r_int
r_int
op_star
id|zones_size
comma
r_int
r_int
id|node_start_pfn
comma
r_int
r_int
op_star
id|zholes_size
)paren
(brace
id|pgdat-&gt;node_id
op_assign
id|nid
suffix:semicolon
id|pgdat-&gt;node_start_pfn
op_assign
id|node_start_pfn
suffix:semicolon
id|calculate_zone_totalpages
c_func
(paren
id|pgdat
comma
id|zones_size
comma
id|zholes_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pfn_to_page
c_func
(paren
id|node_start_pfn
)paren
)paren
id|node_alloc_mem_map
c_func
(paren
id|pgdat
)paren
suffix:semicolon
id|free_area_init_core
c_func
(paren
id|pgdat
comma
id|zones_size
comma
id|zholes_size
)paren
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_DISCONTIGMEM
DECL|variable|contig_bootmem_data
r_static
id|bootmem_data_t
id|contig_bootmem_data
suffix:semicolon
DECL|variable|contig_page_data
r_struct
id|pglist_data
id|contig_page_data
op_assign
(brace
dot
id|bdata
op_assign
op_amp
id|contig_bootmem_data
)brace
suffix:semicolon
DECL|variable|contig_page_data
id|EXPORT_SYMBOL
c_func
(paren
id|contig_page_data
)paren
suffix:semicolon
DECL|function|free_area_init
r_void
id|__init
id|free_area_init
c_func
(paren
r_int
r_int
op_star
id|zones_size
)paren
(brace
id|free_area_init_node
c_func
(paren
l_int|0
comma
op_amp
id|contig_page_data
comma
id|zones_size
comma
id|__pa
c_func
(paren
id|PAGE_OFFSET
)paren
op_rshift
id|PAGE_SHIFT
comma
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_PROC_FS
macro_line|#include &lt;linux/seq_file.h&gt;
DECL|function|frag_start
r_static
r_void
op_star
id|frag_start
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
id|loff_t
op_star
id|pos
)paren
(brace
id|pg_data_t
op_star
id|pgdat
suffix:semicolon
id|loff_t
id|node
op_assign
op_star
id|pos
suffix:semicolon
r_for
c_loop
(paren
id|pgdat
op_assign
id|pgdat_list
suffix:semicolon
id|pgdat
op_logical_and
id|node
suffix:semicolon
id|pgdat
op_assign
id|pgdat-&gt;pgdat_next
)paren
op_decrement
id|node
suffix:semicolon
r_return
id|pgdat
suffix:semicolon
)brace
DECL|function|frag_next
r_static
r_void
op_star
id|frag_next
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|arg
comma
id|loff_t
op_star
id|pos
)paren
(brace
id|pg_data_t
op_star
id|pgdat
op_assign
(paren
id|pg_data_t
op_star
)paren
id|arg
suffix:semicolon
(paren
op_star
id|pos
)paren
op_increment
suffix:semicolon
r_return
id|pgdat-&gt;pgdat_next
suffix:semicolon
)brace
DECL|function|frag_stop
r_static
r_void
id|frag_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|arg
)paren
(brace
)brace
multiline_comment|/* &n; * This walks the free areas for each zone.&n; */
DECL|function|frag_show
r_static
r_int
id|frag_show
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|arg
)paren
(brace
id|pg_data_t
op_star
id|pgdat
op_assign
(paren
id|pg_data_t
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|zone
op_star
id|zone
suffix:semicolon
r_struct
id|zone
op_star
id|node_zones
op_assign
id|pgdat-&gt;node_zones
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|order
suffix:semicolon
r_for
c_loop
(paren
id|zone
op_assign
id|node_zones
suffix:semicolon
id|zone
op_minus
id|node_zones
OL
id|MAX_NR_ZONES
suffix:semicolon
op_increment
id|zone
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|zone-&gt;present_pages
)paren
r_continue
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;Node %d, zone %8s &quot;
comma
id|pgdat-&gt;node_id
comma
id|zone-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
l_int|0
suffix:semicolon
id|order
OL
id|MAX_ORDER
suffix:semicolon
op_increment
id|order
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;%6lu &quot;
comma
id|zone-&gt;free_area
(braket
id|order
)braket
dot
id|nr_free
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|seq_putc
c_func
(paren
id|m
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|fragmentation_op
r_struct
id|seq_operations
id|fragmentation_op
op_assign
(brace
dot
id|start
op_assign
id|frag_start
comma
dot
id|next
op_assign
id|frag_next
comma
dot
id|stop
op_assign
id|frag_stop
comma
dot
id|show
op_assign
id|frag_show
comma
)brace
suffix:semicolon
DECL|variable|vmstat_text
r_static
r_char
op_star
id|vmstat_text
(braket
)braket
op_assign
(brace
l_string|&quot;nr_dirty&quot;
comma
l_string|&quot;nr_writeback&quot;
comma
l_string|&quot;nr_unstable&quot;
comma
l_string|&quot;nr_page_table_pages&quot;
comma
l_string|&quot;nr_mapped&quot;
comma
l_string|&quot;nr_slab&quot;
comma
l_string|&quot;pgpgin&quot;
comma
l_string|&quot;pgpgout&quot;
comma
l_string|&quot;pswpin&quot;
comma
l_string|&quot;pswpout&quot;
comma
l_string|&quot;pgalloc_high&quot;
comma
l_string|&quot;pgalloc_normal&quot;
comma
l_string|&quot;pgalloc_dma&quot;
comma
l_string|&quot;pgfree&quot;
comma
l_string|&quot;pgactivate&quot;
comma
l_string|&quot;pgdeactivate&quot;
comma
l_string|&quot;pgfault&quot;
comma
l_string|&quot;pgmajfault&quot;
comma
l_string|&quot;pgrefill_high&quot;
comma
l_string|&quot;pgrefill_normal&quot;
comma
l_string|&quot;pgrefill_dma&quot;
comma
l_string|&quot;pgsteal_high&quot;
comma
l_string|&quot;pgsteal_normal&quot;
comma
l_string|&quot;pgsteal_dma&quot;
comma
l_string|&quot;pgscan_kswapd_high&quot;
comma
l_string|&quot;pgscan_kswapd_normal&quot;
comma
l_string|&quot;pgscan_kswapd_dma&quot;
comma
l_string|&quot;pgscan_direct_high&quot;
comma
l_string|&quot;pgscan_direct_normal&quot;
comma
l_string|&quot;pgscan_direct_dma&quot;
comma
l_string|&quot;pginodesteal&quot;
comma
l_string|&quot;slabs_scanned&quot;
comma
l_string|&quot;kswapd_steal&quot;
comma
l_string|&quot;kswapd_inodesteal&quot;
comma
l_string|&quot;pageoutrun&quot;
comma
l_string|&quot;allocstall&quot;
comma
l_string|&quot;pgrotated&quot;
comma
)brace
suffix:semicolon
DECL|function|vmstat_start
r_static
r_void
op_star
id|vmstat_start
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|page_state
op_star
id|ps
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pos
op_ge
id|ARRAY_SIZE
c_func
(paren
id|vmstat_text
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|ps
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ps
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|m
op_member_access_from_pointer
r_private
op_assign
id|ps
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ps
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|get_full_page_state
c_func
(paren
id|ps
)paren
suffix:semicolon
id|ps-&gt;pgpgin
op_div_assign
l_int|2
suffix:semicolon
multiline_comment|/* sectors -&gt; kbytes */
id|ps-&gt;pgpgout
op_div_assign
l_int|2
suffix:semicolon
r_return
(paren
r_int
r_int
op_star
)paren
id|ps
op_plus
op_star
id|pos
suffix:semicolon
)brace
DECL|function|vmstat_next
r_static
r_void
op_star
id|vmstat_next
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|arg
comma
id|loff_t
op_star
id|pos
)paren
(brace
(paren
op_star
id|pos
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pos
op_ge
id|ARRAY_SIZE
c_func
(paren
id|vmstat_text
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
(paren
r_int
r_int
op_star
)paren
id|m
op_member_access_from_pointer
r_private
op_plus
op_star
id|pos
suffix:semicolon
)brace
DECL|function|vmstat_show
r_static
r_int
id|vmstat_show
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|arg
)paren
(brace
r_int
r_int
op_star
id|l
op_assign
id|arg
suffix:semicolon
r_int
r_int
id|off
op_assign
id|l
op_minus
(paren
r_int
r_int
op_star
)paren
id|m
op_member_access_from_pointer
r_private
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;%s %lu&bslash;n&quot;
comma
id|vmstat_text
(braket
id|off
)braket
comma
op_star
id|l
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vmstat_stop
r_static
r_void
id|vmstat_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|arg
)paren
(brace
id|kfree
c_func
(paren
id|m
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
id|m
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|variable|vmstat_op
r_struct
id|seq_operations
id|vmstat_op
op_assign
(brace
dot
id|start
op_assign
id|vmstat_start
comma
dot
id|next
op_assign
id|vmstat_next
comma
dot
id|stop
op_assign
id|vmstat_stop
comma
dot
id|show
op_assign
id|vmstat_show
comma
)brace
suffix:semicolon
macro_line|#endif /* CONFIG_PROC_FS */
macro_line|#ifdef CONFIG_HOTPLUG_CPU
DECL|function|page_alloc_cpu_notify
r_static
r_int
id|page_alloc_cpu_notify
c_func
(paren
r_struct
id|notifier_block
op_star
id|self
comma
r_int
r_int
id|action
comma
r_void
op_star
id|hcpu
)paren
(brace
r_int
id|cpu
op_assign
(paren
r_int
r_int
)paren
id|hcpu
suffix:semicolon
r_int
op_star
id|count
suffix:semicolon
r_int
r_int
op_star
id|src
comma
op_star
id|dest
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
id|CPU_DEAD
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Drain local pagecache count. */
id|count
op_assign
op_amp
id|per_cpu
c_func
(paren
id|nr_pagecache_local
comma
id|cpu
)paren
suffix:semicolon
id|atomic_add
c_func
(paren
op_star
id|count
comma
op_amp
id|nr_pagecache
)paren
suffix:semicolon
op_star
id|count
op_assign
l_int|0
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|__drain_pages
c_func
(paren
id|cpu
)paren
suffix:semicolon
multiline_comment|/* Add dead cpu&squot;s page_states to our own. */
id|dest
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|__get_cpu_var
c_func
(paren
id|page_states
)paren
suffix:semicolon
id|src
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|per_cpu
c_func
(paren
id|page_states
comma
id|cpu
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
r_struct
id|page_state
)paren
op_div
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dest
(braket
id|i
)braket
op_add_assign
id|src
(braket
id|i
)braket
suffix:semicolon
id|src
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|NOTIFY_OK
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_HOTPLUG_CPU */
DECL|function|page_alloc_init
r_void
id|__init
id|page_alloc_init
c_func
(paren
r_void
)paren
(brace
id|hotcpu_notifier
c_func
(paren
id|page_alloc_cpu_notify
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * setup_per_zone_lowmem_reserve - called whenever&n; *&t;sysctl_lower_zone_reserve_ratio changes.  Ensures that each zone&n; *&t;has a correct pages reserved value, so an adequate number of&n; *&t;pages are left in the zone after a successful __alloc_pages().&n; */
DECL|function|setup_per_zone_lowmem_reserve
r_static
r_void
id|setup_per_zone_lowmem_reserve
c_func
(paren
r_void
)paren
(brace
r_struct
id|pglist_data
op_star
id|pgdat
suffix:semicolon
r_int
id|j
comma
id|idx
suffix:semicolon
id|for_each_pgdat
c_func
(paren
id|pgdat
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|MAX_NR_ZONES
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|zone
op_star
id|zone
op_assign
id|pgdat-&gt;node_zones
op_plus
id|j
suffix:semicolon
r_int
r_int
id|present_pages
op_assign
id|zone-&gt;present_pages
suffix:semicolon
id|zone-&gt;lowmem_reserve
(braket
id|j
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
id|j
op_minus
l_int|1
suffix:semicolon
id|idx
op_ge
l_int|0
suffix:semicolon
id|idx
op_decrement
)paren
(brace
r_struct
id|zone
op_star
id|lower_zone
op_assign
id|pgdat-&gt;node_zones
op_plus
id|idx
suffix:semicolon
id|lower_zone-&gt;lowmem_reserve
(braket
id|j
)braket
op_assign
id|present_pages
op_div
id|sysctl_lowmem_reserve_ratio
(braket
id|idx
)braket
suffix:semicolon
id|present_pages
op_add_assign
id|lower_zone-&gt;present_pages
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * setup_per_zone_pages_min - called when min_free_kbytes changes.  Ensures &n; *&t;that the pages_{min,low,high} values for each zone are set correctly &n; *&t;with respect to min_free_kbytes.&n; */
DECL|function|setup_per_zone_pages_min
r_static
r_void
id|setup_per_zone_pages_min
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|pages_min
op_assign
id|min_free_kbytes
op_rshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
suffix:semicolon
r_int
r_int
id|lowmem_pages
op_assign
l_int|0
suffix:semicolon
r_struct
id|zone
op_star
id|zone
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Calculate total number of !ZONE_HIGHMEM pages */
id|for_each_zone
c_func
(paren
id|zone
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_highmem
c_func
(paren
id|zone
)paren
)paren
id|lowmem_pages
op_add_assign
id|zone-&gt;present_pages
suffix:semicolon
)brace
id|for_each_zone
c_func
(paren
id|zone
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|zone-&gt;lru_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_highmem
c_func
(paren
id|zone
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Often, highmem doesn&squot;t need to reserve any pages.&n;&t;&t;&t; * But the pages_min/low/high values are also used for&n;&t;&t;&t; * batching up page reclaim activity so we need a&n;&t;&t;&t; * decent value here.&n;&t;&t;&t; */
r_int
id|min_pages
suffix:semicolon
id|min_pages
op_assign
id|zone-&gt;present_pages
op_div
l_int|1024
suffix:semicolon
r_if
c_cond
(paren
id|min_pages
OL
id|SWAP_CLUSTER_MAX
)paren
id|min_pages
op_assign
id|SWAP_CLUSTER_MAX
suffix:semicolon
r_if
c_cond
(paren
id|min_pages
OG
l_int|128
)paren
id|min_pages
op_assign
l_int|128
suffix:semicolon
id|zone-&gt;pages_min
op_assign
id|min_pages
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* if it&squot;s a lowmem zone, reserve a number of pages &n;&t;&t;&t; * proportionate to the zone&squot;s size.&n;&t;&t;&t; */
id|zone-&gt;pages_min
op_assign
(paren
id|pages_min
op_star
id|zone-&gt;present_pages
)paren
op_div
id|lowmem_pages
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * When interpreting these watermarks, just keep in mind that:&n;&t;&t; * zone-&gt;pages_min == (zone-&gt;pages_min * 4) / 4;&n;&t;&t; */
id|zone-&gt;pages_low
op_assign
(paren
id|zone-&gt;pages_min
op_star
l_int|5
)paren
op_div
l_int|4
suffix:semicolon
id|zone-&gt;pages_high
op_assign
(paren
id|zone-&gt;pages_min
op_star
l_int|6
)paren
op_div
l_int|4
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|zone-&gt;lru_lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Initialise min_free_kbytes.&n; *&n; * For small machines we want it small (128k min).  For large machines&n; * we want it large (64MB max).  But it is not linear, because network&n; * bandwidth does not increase linearly with machine size.  We use&n; *&n; * &t;min_free_kbytes = 4 * sqrt(lowmem_kbytes), for better accuracy:&n; *&t;min_free_kbytes = sqrt(lowmem_kbytes * 16)&n; *&n; * which yields&n; *&n; * 16MB:&t;512k&n; * 32MB:&t;724k&n; * 64MB:&t;1024k&n; * 128MB:&t;1448k&n; * 256MB:&t;2048k&n; * 512MB:&t;2896k&n; * 1024MB:&t;4096k&n; * 2048MB:&t;5792k&n; * 4096MB:&t;8192k&n; * 8192MB:&t;11584k&n; * 16384MB:&t;16384k&n; */
DECL|function|init_per_zone_pages_min
r_static
r_int
id|__init
id|init_per_zone_pages_min
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|lowmem_kbytes
suffix:semicolon
id|lowmem_kbytes
op_assign
id|nr_free_buffer_pages
c_func
(paren
)paren
op_star
(paren
id|PAGE_SIZE
op_rshift
l_int|10
)paren
suffix:semicolon
id|min_free_kbytes
op_assign
id|int_sqrt
c_func
(paren
id|lowmem_kbytes
op_star
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|min_free_kbytes
OL
l_int|128
)paren
id|min_free_kbytes
op_assign
l_int|128
suffix:semicolon
r_if
c_cond
(paren
id|min_free_kbytes
OG
l_int|65536
)paren
id|min_free_kbytes
op_assign
l_int|65536
suffix:semicolon
id|setup_per_zone_pages_min
c_func
(paren
)paren
suffix:semicolon
id|setup_per_zone_lowmem_reserve
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|module_init
id|module_init
c_func
(paren
id|init_per_zone_pages_min
)paren
multiline_comment|/*&n; * min_free_kbytes_sysctl_handler - just a wrapper around proc_dointvec() so &n; *&t;that we can call two helper functions whenever min_free_kbytes&n; *&t;changes.&n; */
r_int
id|min_free_kbytes_sysctl_handler
c_func
(paren
id|ctl_table
op_star
id|table
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|file
comma
r_void
id|__user
op_star
id|buffer
comma
r_int
op_star
id|length
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|proc_dointvec
c_func
(paren
id|table
comma
id|write
comma
id|file
comma
id|buffer
comma
id|length
comma
id|ppos
)paren
suffix:semicolon
id|setup_per_zone_pages_min
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * lowmem_reserve_ratio_sysctl_handler - just a wrapper around&n; *&t;proc_dointvec() so that we can call setup_per_zone_lowmem_reserve()&n; *&t;whenever sysctl_lowmem_reserve_ratio changes.&n; *&n; * The reserve ratio obviously has absolutely no relation with the&n; * pages_min watermarks. The lowmem reserve ratio can only make sense&n; * if in function of the boot time zone sizes.&n; */
DECL|function|lowmem_reserve_ratio_sysctl_handler
r_int
id|lowmem_reserve_ratio_sysctl_handler
c_func
(paren
id|ctl_table
op_star
id|table
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|file
comma
r_void
id|__user
op_star
id|buffer
comma
r_int
op_star
id|length
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|proc_dointvec_minmax
c_func
(paren
id|table
comma
id|write
comma
id|file
comma
id|buffer
comma
id|length
comma
id|ppos
)paren
suffix:semicolon
id|setup_per_zone_lowmem_reserve
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|hashdist
id|__initdata
r_int
id|hashdist
op_assign
id|HASHDIST_DEFAULT
suffix:semicolon
macro_line|#ifdef CONFIG_NUMA
DECL|function|set_hashdist
r_static
r_int
id|__init
id|set_hashdist
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|str
)paren
r_return
l_int|0
suffix:semicolon
id|hashdist
op_assign
id|simple_strtoul
c_func
(paren
id|str
comma
op_amp
id|str
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;hashdist=&quot;
comma
id|set_hashdist
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * allocate a large system hash table from bootmem&n; * - it is assumed that the hash table must contain an exact power-of-2&n; *   quantity of entries&n; * - limit is the number of hash buckets, not the total allocation size&n; */
DECL|function|alloc_large_system_hash
r_void
op_star
id|__init
id|alloc_large_system_hash
c_func
(paren
r_const
r_char
op_star
id|tablename
comma
r_int
r_int
id|bucketsize
comma
r_int
r_int
id|numentries
comma
r_int
id|scale
comma
r_int
id|flags
comma
r_int
r_int
op_star
id|_hash_shift
comma
r_int
r_int
op_star
id|_hash_mask
comma
r_int
r_int
id|limit
)paren
(brace
r_int
r_int
r_int
id|max
op_assign
id|limit
suffix:semicolon
r_int
r_int
id|log2qty
comma
id|size
suffix:semicolon
r_void
op_star
id|table
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* allow the kernel cmdline to have a say */
r_if
c_cond
(paren
op_logical_neg
id|numentries
)paren
(brace
multiline_comment|/* round applicable memory size up to nearest megabyte */
id|numentries
op_assign
(paren
id|flags
op_amp
id|HASH_HIGHMEM
)paren
ques
c_cond
id|nr_all_pages
suffix:colon
id|nr_kernel_pages
suffix:semicolon
id|numentries
op_add_assign
(paren
l_int|1UL
op_lshift
(paren
l_int|20
op_minus
id|PAGE_SHIFT
)paren
)paren
op_minus
l_int|1
suffix:semicolon
id|numentries
op_rshift_assign
l_int|20
op_minus
id|PAGE_SHIFT
suffix:semicolon
id|numentries
op_lshift_assign
l_int|20
op_minus
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* limit to 1 bucket per 2^scale bytes of low memory */
r_if
c_cond
(paren
id|scale
OG
id|PAGE_SHIFT
)paren
id|numentries
op_rshift_assign
(paren
id|scale
op_minus
id|PAGE_SHIFT
)paren
suffix:semicolon
r_else
id|numentries
op_lshift_assign
(paren
id|PAGE_SHIFT
op_minus
id|scale
)paren
suffix:semicolon
)brace
multiline_comment|/* rounded up to nearest power of 2 in size */
id|numentries
op_assign
l_int|1UL
op_lshift
(paren
id|long_log2
c_func
(paren
id|numentries
)paren
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* limit allocation size to 1/16 total memory by default */
r_if
c_cond
(paren
id|max
op_eq
l_int|0
)paren
(brace
id|max
op_assign
(paren
(paren
r_int
r_int
r_int
)paren
id|nr_all_pages
op_lshift
id|PAGE_SHIFT
)paren
op_rshift
l_int|4
suffix:semicolon
id|do_div
c_func
(paren
id|max
comma
id|bucketsize
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|numentries
OG
id|max
)paren
id|numentries
op_assign
id|max
suffix:semicolon
id|log2qty
op_assign
id|long_log2
c_func
(paren
id|numentries
)paren
suffix:semicolon
r_do
(brace
id|size
op_assign
id|bucketsize
op_lshift
id|log2qty
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|HASH_EARLY
)paren
id|table
op_assign
id|alloc_bootmem
c_func
(paren
id|size
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hashdist
)paren
id|table
op_assign
id|__vmalloc
c_func
(paren
id|size
comma
id|GFP_ATOMIC
comma
id|PAGE_KERNEL
)paren
suffix:semicolon
r_else
(brace
r_int
r_int
id|order
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
l_int|0
suffix:semicolon
(paren
(paren
l_int|1UL
op_lshift
id|order
)paren
op_lshift
id|PAGE_SHIFT
)paren
OL
id|size
suffix:semicolon
id|order
op_increment
)paren
suffix:semicolon
id|table
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|order
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|table
op_logical_and
id|size
OG
id|PAGE_SIZE
op_logical_and
op_decrement
id|log2qty
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|table
)paren
id|panic
c_func
(paren
l_string|&quot;Failed to allocate %s hash table&bslash;n&quot;
comma
id|tablename
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s hash table entries: %d (order: %d, %lu bytes)&bslash;n&quot;
comma
id|tablename
comma
(paren
l_int|1U
op_lshift
id|log2qty
)paren
comma
id|long_log2
c_func
(paren
id|size
)paren
op_minus
id|PAGE_SHIFT
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_hash_shift
)paren
op_star
id|_hash_shift
op_assign
id|log2qty
suffix:semicolon
r_if
c_cond
(paren
id|_hash_mask
)paren
op_star
id|_hash_mask
op_assign
(paren
l_int|1
op_lshift
id|log2qty
)paren
op_minus
l_int|1
suffix:semicolon
r_return
id|table
suffix:semicolon
)brace
eof
