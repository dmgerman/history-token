multiline_comment|/*&n; *  linux/mm/page_alloc.c&n; *&n; *  Manages the free list, the system allocates free pages here.&n; *  Note that kmalloc() lives in slab.c&n; *&n; *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; *  Swap reorganised 29.12.95, Stephen Tweedie&n; *  Support of BIGMEM added by Gerhard Wichert, Siemens AG, July 1999&n; *  Reshaped it to be a zoned allocator, Ingo Molnar, Red Hat, 1999&n; *  Discontiguous memory support, Kanoj Sarcar, SGI, Nov 1999&n; *  Zone balancing, Kanoj Sarcar, SGI, Jan 2000&n; *  Per cpu hot/cold page lists, bulk allocation, Martin J. Bligh, Sept 2002&n; *          (lots of bits borrowed from Ingo Molnar &amp; Andrew Morton)&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;linux/pagevec.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/topology.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/cpu.h&gt;
id|DECLARE_BITMAP
c_func
(paren
id|node_online_map
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
id|DECLARE_BITMAP
c_func
(paren
id|memblk_online_map
comma
id|MAX_NR_MEMBLKS
)paren
suffix:semicolon
DECL|variable|pgdat_list
r_struct
id|pglist_data
op_star
id|pgdat_list
suffix:semicolon
DECL|variable|totalram_pages
r_int
r_int
id|totalram_pages
suffix:semicolon
DECL|variable|totalhigh_pages
r_int
r_int
id|totalhigh_pages
suffix:semicolon
DECL|variable|nr_swap_pages
r_int
id|nr_swap_pages
suffix:semicolon
DECL|variable|numnodes
r_int
id|numnodes
op_assign
l_int|1
suffix:semicolon
DECL|variable|sysctl_lower_zone_protection
r_int
id|sysctl_lower_zone_protection
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Used by page_zone() to look up the address of the struct zone whose&n; * id is encoded in the upper bits of page-&gt;flags&n; */
DECL|variable|zone_table
r_struct
id|zone
op_star
id|zone_table
(braket
id|MAX_NR_ZONES
op_star
id|MAX_NR_NODES
)braket
suffix:semicolon
DECL|variable|zone_table
id|EXPORT_SYMBOL
c_func
(paren
id|zone_table
)paren
suffix:semicolon
DECL|variable|zone_names
r_static
r_char
op_star
id|zone_names
(braket
id|MAX_NR_ZONES
)braket
op_assign
(brace
l_string|&quot;DMA&quot;
comma
l_string|&quot;Normal&quot;
comma
l_string|&quot;HighMem&quot;
)brace
suffix:semicolon
DECL|variable|min_free_kbytes
r_int
id|min_free_kbytes
op_assign
l_int|1024
suffix:semicolon
multiline_comment|/*&n; * Temporary debugging check for pages not lying within a given zone.&n; */
DECL|function|bad_range
r_static
r_int
id|bad_range
c_func
(paren
r_struct
id|zone
op_star
id|zone
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
id|page_to_pfn
c_func
(paren
id|page
)paren
op_ge
id|zone-&gt;zone_start_pfn
op_plus
id|zone-&gt;spanned_pages
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|page_to_pfn
c_func
(paren
id|page
)paren
OL
id|zone-&gt;zone_start_pfn
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|zone
op_ne
id|page_zone
c_func
(paren
id|page
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bad_page
r_static
r_void
id|bad_page
c_func
(paren
r_const
r_char
op_star
id|function
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bad page state at %s&bslash;n&quot;
comma
id|function
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;flags:0x%08lx mapping:%p mapped:%d count:%d&bslash;n&quot;
comma
id|page-&gt;flags
comma
id|page-&gt;mapping
comma
id|page_mapped
c_func
(paren
id|page
)paren
comma
id|page_count
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Backtrace:&bslash;n&quot;
)paren
suffix:semicolon
id|dump_stack
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Trying to fix it up, but a reboot is needed&bslash;n&quot;
)paren
suffix:semicolon
id|page-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|PG_private
op_or
l_int|1
op_lshift
id|PG_locked
op_or
l_int|1
op_lshift
id|PG_lru
op_or
l_int|1
op_lshift
id|PG_active
op_or
l_int|1
op_lshift
id|PG_dirty
op_or
l_int|1
op_lshift
id|PG_writeback
)paren
suffix:semicolon
id|set_page_count
c_func
(paren
id|page
comma
l_int|0
)paren
suffix:semicolon
id|page-&gt;mapping
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_HUGETLB_PAGE
DECL|macro|prep_compound_page
mdefine_line|#define prep_compound_page(page, order) do { } while (0)
DECL|macro|destroy_compound_page
mdefine_line|#define destroy_compound_page(page, order) do { } while (0)
macro_line|#else
multiline_comment|/*&n; * Higher-order pages are called &quot;compound pages&quot;.  They are structured thusly:&n; *&n; * The first PAGE_SIZE page is called the &quot;head page&quot;.&n; *&n; * The remaining PAGE_SIZE pages are called &quot;tail pages&quot;.&n; *&n; * All pages have PG_compound set.  All pages have their lru.next pointing at&n; * the head page (even the head page has this).&n; *&n; * The head page&squot;s lru.prev, if non-zero, holds the address of the compound&n; * page&squot;s put_page() function.&n; *&n; * The order of the allocation is stored in the first tail page&squot;s lru.prev.&n; * This is only for debug at present.  This usage means that zero-order pages&n; * may not be compound.&n; */
DECL|function|prep_compound_page
r_static
r_void
id|prep_compound_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|order
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|nr_pages
op_assign
l_int|1
op_lshift
id|order
suffix:semicolon
id|page-&gt;lru.prev
op_assign
l_int|NULL
suffix:semicolon
id|page
(braket
l_int|1
)braket
dot
id|lru.prev
op_assign
(paren
r_void
op_star
)paren
id|order
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|page
op_star
id|p
op_assign
id|page
op_plus
id|i
suffix:semicolon
id|SetPageCompound
c_func
(paren
id|p
)paren
suffix:semicolon
id|p-&gt;lru.next
op_assign
(paren
r_void
op_star
)paren
id|page
suffix:semicolon
)brace
)brace
DECL|function|destroy_compound_page
r_static
r_void
id|destroy_compound_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|order
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|nr_pages
op_assign
l_int|1
op_lshift
id|order
suffix:semicolon
r_if
c_cond
(paren
id|page
(braket
l_int|1
)braket
dot
id|lru.prev
op_ne
(paren
r_void
op_star
)paren
id|order
)paren
id|bad_page
c_func
(paren
id|__FUNCTION__
comma
id|page
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|page
op_star
id|p
op_assign
id|page
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageCompound
c_func
(paren
id|p
)paren
)paren
id|bad_page
c_func
(paren
id|__FUNCTION__
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;lru.next
op_ne
(paren
r_void
op_star
)paren
id|page
)paren
id|bad_page
c_func
(paren
id|__FUNCTION__
comma
id|page
)paren
suffix:semicolon
id|ClearPageCompound
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;&t;/* CONFIG_HUGETLB_PAGE */
multiline_comment|/*&n; * Freeing function for a buddy system allocator.&n; *&n; * The concept of a buddy system is to maintain direct-mapped table&n; * (containing bit values) for memory blocks of various &quot;orders&quot;.&n; * The bottom level table contains the map for the smallest allocatable&n; * units of memory (here, pages), and each level above it describes&n; * pairs of units from the levels below, hence, &quot;buddies&quot;.&n; * At a high level, all that happens here is marking the table entry&n; * at the bottom level available, and propagating the changes upward&n; * as necessary, plus some accounting needed to play nicely with other&n; * parts of the VM system.&n; * At each level, we keep one bit for each pair of blocks, which&n; * is set to 1 iff only one of the pair is allocated.  So when we&n; * are allocating or freeing one, we can derive the state of the&n; * other.  That is, if we allocate a small block, and both were   &n; * free, the remainder of the region must be split into blocks.   &n; * If a block is freed, and its buddy is also free, then this&n; * triggers coalescing into a block of larger size.            &n; *&n; * -- wli&n; */
DECL|function|__free_pages_bulk
r_static
r_inline
r_void
id|__free_pages_bulk
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|page
op_star
id|base
comma
r_struct
id|zone
op_star
id|zone
comma
r_struct
id|free_area
op_star
id|area
comma
r_int
r_int
id|mask
comma
r_int
r_int
id|order
)paren
(brace
r_int
r_int
id|page_idx
comma
id|index
suffix:semicolon
r_if
c_cond
(paren
id|order
)paren
id|destroy_compound_page
c_func
(paren
id|page
comma
id|order
)paren
suffix:semicolon
id|page_idx
op_assign
id|page
op_minus
id|base
suffix:semicolon
r_if
c_cond
(paren
id|page_idx
op_amp
op_complement
id|mask
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|index
op_assign
id|page_idx
op_rshift
(paren
l_int|1
op_plus
id|order
)paren
suffix:semicolon
id|zone-&gt;free_pages
op_sub_assign
id|mask
suffix:semicolon
r_while
c_loop
(paren
id|mask
op_plus
(paren
l_int|1
op_lshift
(paren
id|MAX_ORDER
op_minus
l_int|1
)paren
)paren
)paren
(brace
r_struct
id|page
op_star
id|buddy1
comma
op_star
id|buddy2
suffix:semicolon
id|BUG_ON
c_func
(paren
id|area
op_ge
id|zone-&gt;free_area
op_plus
id|MAX_ORDER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|__test_and_change_bit
c_func
(paren
id|index
comma
id|area-&gt;map
)paren
)paren
multiline_comment|/*&n;&t;&t;&t; * the buddy page is still allocated.&n;&t;&t;&t; */
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Move the buddy up one level.&n;&t;&t; * This code is taking advantage of the identity:&n;&t;&t; * &t;-mask = 1+~mask&n;&t;&t; */
id|buddy1
op_assign
id|base
op_plus
(paren
id|page_idx
op_xor
op_minus
id|mask
)paren
suffix:semicolon
id|buddy2
op_assign
id|base
op_plus
id|page_idx
suffix:semicolon
id|BUG_ON
c_func
(paren
id|bad_range
c_func
(paren
id|zone
comma
id|buddy1
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|bad_range
c_func
(paren
id|zone
comma
id|buddy2
)paren
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|buddy1-&gt;list
)paren
suffix:semicolon
id|mask
op_lshift_assign
l_int|1
suffix:semicolon
id|area
op_increment
suffix:semicolon
id|index
op_rshift_assign
l_int|1
suffix:semicolon
id|page_idx
op_and_assign
id|mask
suffix:semicolon
)brace
id|list_add
c_func
(paren
op_amp
(paren
id|base
op_plus
id|page_idx
)paren
op_member_access_from_pointer
id|list
comma
op_amp
id|area-&gt;free_list
)paren
suffix:semicolon
)brace
DECL|function|free_pages_check
r_static
r_inline
r_void
id|free_pages_check
c_func
(paren
r_const
r_char
op_star
id|function
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
id|page_mapped
c_func
(paren
id|page
)paren
op_logical_or
id|page-&gt;mapping
op_ne
l_int|NULL
op_logical_or
id|page_count
c_func
(paren
id|page
)paren
op_ne
l_int|0
op_logical_or
(paren
id|page-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|PG_lru
op_or
l_int|1
op_lshift
id|PG_private
op_or
l_int|1
op_lshift
id|PG_locked
op_or
l_int|1
op_lshift
id|PG_active
op_or
l_int|1
op_lshift
id|PG_reclaim
op_or
l_int|1
op_lshift
id|PG_writeback
)paren
)paren
)paren
id|bad_page
c_func
(paren
id|function
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageDirty
c_func
(paren
id|page
)paren
)paren
id|ClearPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Frees a list of pages. &n; * Assumes all pages on list are in same zone, and of same order.&n; * count is the number of pages to free, or 0 for all on the list.&n; *&n; * If the zone was previously in an &quot;all pages pinned&quot; state then look to&n; * see if this freeing clears that state.&n; *&n; * And clear the zone&squot;s pages_scanned counter, to hold off the &quot;all pages are&n; * pinned&quot; detection logic.&n; */
r_static
r_int
DECL|function|free_pages_bulk
id|free_pages_bulk
c_func
(paren
r_struct
id|zone
op_star
id|zone
comma
r_int
id|count
comma
r_struct
id|list_head
op_star
id|list
comma
r_int
r_int
id|order
)paren
(brace
r_int
r_int
id|mask
comma
id|flags
suffix:semicolon
r_struct
id|free_area
op_star
id|area
suffix:semicolon
r_struct
id|page
op_star
id|base
comma
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|mask
op_assign
(paren
op_complement
l_int|0UL
)paren
op_lshift
id|order
suffix:semicolon
id|base
op_assign
id|zone-&gt;zone_mem_map
suffix:semicolon
id|area
op_assign
id|zone-&gt;free_area
op_plus
id|order
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|zone-&gt;all_unreclaimable
op_assign
l_int|0
suffix:semicolon
id|zone-&gt;pages_scanned
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|list
)paren
op_logical_and
id|count
op_decrement
)paren
(brace
id|page
op_assign
id|list_entry
c_func
(paren
id|list-&gt;prev
comma
r_struct
id|page
comma
id|list
)paren
suffix:semicolon
multiline_comment|/* have to delete it as __free_pages_bulk list manipulates */
id|list_del
c_func
(paren
op_amp
id|page-&gt;list
)paren
suffix:semicolon
id|__free_pages_bulk
c_func
(paren
id|page
comma
id|base
comma
id|zone
comma
id|area
comma
id|mask
comma
id|order
)paren
suffix:semicolon
id|ret
op_increment
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|__free_pages_ok
r_void
id|__free_pages_ok
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|order
)paren
(brace
id|LIST_HEAD
c_func
(paren
id|list
)paren
suffix:semicolon
id|mod_page_state
c_func
(paren
id|pgfree
comma
l_int|1
op_lshift
id|order
)paren
suffix:semicolon
id|free_pages_check
c_func
(paren
id|__FUNCTION__
comma
id|page
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|page-&gt;list
comma
op_amp
id|list
)paren
suffix:semicolon
id|free_pages_bulk
c_func
(paren
id|page_zone
c_func
(paren
id|page
)paren
comma
l_int|1
comma
op_amp
id|list
comma
id|order
)paren
suffix:semicolon
)brace
DECL|macro|MARK_USED
mdefine_line|#define MARK_USED(index, order, area) &bslash;&n;&t;__change_bit((index) &gt;&gt; (1+(order)), (area)-&gt;map)
r_static
r_inline
r_struct
id|page
op_star
DECL|function|expand
id|expand
c_func
(paren
r_struct
id|zone
op_star
id|zone
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|index
comma
r_int
id|low
comma
r_int
id|high
comma
r_struct
id|free_area
op_star
id|area
)paren
(brace
r_int
r_int
id|size
op_assign
l_int|1
op_lshift
id|high
suffix:semicolon
r_while
c_loop
(paren
id|high
OG
id|low
)paren
(brace
id|BUG_ON
c_func
(paren
id|bad_range
c_func
(paren
id|zone
comma
id|page
)paren
)paren
suffix:semicolon
id|area
op_decrement
suffix:semicolon
id|high
op_decrement
suffix:semicolon
id|size
op_rshift_assign
l_int|1
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|page-&gt;list
comma
op_amp
id|area-&gt;free_list
)paren
suffix:semicolon
id|MARK_USED
c_func
(paren
id|index
comma
id|high
comma
id|area
)paren
suffix:semicolon
id|index
op_add_assign
id|size
suffix:semicolon
id|page
op_add_assign
id|size
suffix:semicolon
)brace
r_return
id|page
suffix:semicolon
)brace
DECL|function|set_page_refs
r_static
r_inline
r_void
id|set_page_refs
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|order
)paren
(brace
macro_line|#ifdef CONFIG_MMU
id|set_page_count
c_func
(paren
id|page
comma
l_int|1
)paren
suffix:semicolon
macro_line|#else
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * We need to reference all the pages for this order, otherwise if&n;&t; * anyone accesses one of the pages with (get/put) it will be freed.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
l_int|1
op_lshift
id|order
)paren
suffix:semicolon
id|i
op_increment
)paren
id|set_page_count
c_func
(paren
id|page
op_plus
id|i
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_MMU */
)brace
multiline_comment|/*&n; * This page is about to be returned from the page allocator&n; */
DECL|function|prep_new_page
r_static
r_void
id|prep_new_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|order
)paren
(brace
r_if
c_cond
(paren
id|page-&gt;mapping
op_logical_or
id|page_mapped
c_func
(paren
id|page
)paren
op_logical_or
(paren
id|page-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|PG_private
op_or
l_int|1
op_lshift
id|PG_locked
op_or
l_int|1
op_lshift
id|PG_lru
op_or
l_int|1
op_lshift
id|PG_active
op_or
l_int|1
op_lshift
id|PG_dirty
op_or
l_int|1
op_lshift
id|PG_reclaim
op_or
l_int|1
op_lshift
id|PG_writeback
)paren
)paren
)paren
id|bad_page
c_func
(paren
id|__FUNCTION__
comma
id|page
)paren
suffix:semicolon
id|page-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|PG_uptodate
op_or
l_int|1
op_lshift
id|PG_error
op_or
l_int|1
op_lshift
id|PG_referenced
op_or
l_int|1
op_lshift
id|PG_arch_1
op_or
l_int|1
op_lshift
id|PG_checked
op_or
l_int|1
op_lshift
id|PG_mappedtodisk
)paren
suffix:semicolon
id|set_page_refs
c_func
(paren
id|page
comma
id|order
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Do the hard work of removing an element from the buddy allocator.&n; * Call me with the zone-&gt;lock already held.&n; */
DECL|function|__rmqueue
r_static
r_struct
id|page
op_star
id|__rmqueue
c_func
(paren
r_struct
id|zone
op_star
id|zone
comma
r_int
r_int
id|order
)paren
(brace
r_struct
id|free_area
op_star
id|area
suffix:semicolon
r_int
r_int
id|current_order
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|index
suffix:semicolon
r_for
c_loop
(paren
id|current_order
op_assign
id|order
suffix:semicolon
id|current_order
OL
id|MAX_ORDER
suffix:semicolon
op_increment
id|current_order
)paren
(brace
id|area
op_assign
id|zone-&gt;free_area
op_plus
id|current_order
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|area-&gt;free_list
)paren
)paren
r_continue
suffix:semicolon
id|page
op_assign
id|list_entry
c_func
(paren
id|area-&gt;free_list.next
comma
r_struct
id|page
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|page-&gt;list
)paren
suffix:semicolon
id|index
op_assign
id|page
op_minus
id|zone-&gt;zone_mem_map
suffix:semicolon
r_if
c_cond
(paren
id|current_order
op_ne
id|MAX_ORDER
op_minus
l_int|1
)paren
id|MARK_USED
c_func
(paren
id|index
comma
id|current_order
comma
id|area
)paren
suffix:semicolon
id|zone-&gt;free_pages
op_sub_assign
l_int|1UL
op_lshift
id|order
suffix:semicolon
r_return
id|expand
c_func
(paren
id|zone
comma
id|page
comma
id|index
comma
id|order
comma
id|current_order
comma
id|area
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* &n; * Obtain a specified number of elements from the buddy allocator, all under&n; * a single hold of the lock, for efficiency.  Add them to the supplied list.&n; * Returns the number of new pages which were placed at *list.&n; */
DECL|function|rmqueue_bulk
r_static
r_int
id|rmqueue_bulk
c_func
(paren
r_struct
id|zone
op_star
id|zone
comma
r_int
r_int
id|order
comma
r_int
r_int
id|count
comma
r_struct
id|list_head
op_star
id|list
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|allocated
op_assign
l_int|0
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
op_increment
id|i
)paren
(brace
id|page
op_assign
id|__rmqueue
c_func
(paren
id|zone
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|allocated
op_increment
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|page-&gt;list
comma
id|list
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|allocated
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SOFTWARE_SUSPEND
DECL|function|is_head_of_free_region
r_int
id|is_head_of_free_region
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|zone
op_star
id|zone
op_assign
id|page_zone
c_func
(paren
id|page
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|order
suffix:semicolon
r_struct
id|list_head
op_star
id|curr
suffix:semicolon
multiline_comment|/*&n;&t; * Should not matter as we need quiescent system for&n;&t; * suspend anyway, but...&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
id|MAX_ORDER
op_minus
l_int|1
suffix:semicolon
id|order
op_ge
l_int|0
suffix:semicolon
op_decrement
id|order
)paren
id|list_for_each
c_func
(paren
id|curr
comma
op_amp
id|zone-&gt;free_area
(braket
id|order
)braket
dot
id|free_list
)paren
r_if
c_cond
(paren
id|page
op_eq
id|list_entry
c_func
(paren
id|curr
comma
r_struct
id|page
comma
id|list
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|1
op_lshift
id|order
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Spill all of this CPU&squot;s per-cpu pages back into the buddy allocator.&n; */
DECL|function|drain_local_pages
r_void
id|drain_local_pages
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|zone
op_star
id|zone
suffix:semicolon
r_int
id|i
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|for_each_zone
c_func
(paren
id|zone
)paren
(brace
r_struct
id|per_cpu_pageset
op_star
id|pset
suffix:semicolon
id|pset
op_assign
op_amp
id|zone-&gt;pageset
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|pset-&gt;pcp
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|per_cpu_pages
op_star
id|pcp
suffix:semicolon
id|pcp
op_assign
op_amp
id|pset-&gt;pcp
(braket
id|i
)braket
suffix:semicolon
id|pcp-&gt;count
op_sub_assign
id|free_pages_bulk
c_func
(paren
id|zone
comma
id|pcp-&gt;count
comma
op_amp
id|pcp-&gt;list
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SOFTWARE_SUSPEND */
multiline_comment|/*&n; * Free a 0-order page&n; */
r_static
r_void
id|FASTCALL
c_func
(paren
id|free_hot_cold_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|cold
)paren
)paren
suffix:semicolon
DECL|function|free_hot_cold_page
r_static
r_void
id|free_hot_cold_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|cold
)paren
(brace
r_struct
id|zone
op_star
id|zone
op_assign
id|page_zone
c_func
(paren
id|page
)paren
suffix:semicolon
r_struct
id|per_cpu_pages
op_star
id|pcp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|inc_page_state
c_func
(paren
id|pgfree
)paren
suffix:semicolon
id|free_pages_check
c_func
(paren
id|__FUNCTION__
comma
id|page
)paren
suffix:semicolon
id|pcp
op_assign
op_amp
id|zone-&gt;pageset
(braket
id|get_cpu
c_func
(paren
)paren
)braket
dot
id|pcp
(braket
id|cold
)braket
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcp-&gt;count
op_ge
id|pcp-&gt;high
)paren
id|pcp-&gt;count
op_sub_assign
id|free_pages_bulk
c_func
(paren
id|zone
comma
id|pcp-&gt;batch
comma
op_amp
id|pcp-&gt;list
comma
l_int|0
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|page-&gt;list
comma
op_amp
id|pcp-&gt;list
)paren
suffix:semicolon
id|pcp-&gt;count
op_increment
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|free_hot_page
r_void
id|free_hot_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|free_hot_cold_page
c_func
(paren
id|page
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|free_cold_page
r_void
id|free_cold_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|free_hot_cold_page
c_func
(paren
id|page
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Really, prep_compound_page() should be called from __rmqueue_bulk().  But&n; * we cheat by calling it from here, in the order &gt; 0 path.  Saves a branch&n; * or two.&n; */
DECL|function|buffered_rmqueue
r_static
r_struct
id|page
op_star
id|buffered_rmqueue
c_func
(paren
r_struct
id|zone
op_star
id|zone
comma
r_int
id|order
comma
r_int
id|cold
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|order
op_eq
l_int|0
)paren
(brace
r_struct
id|per_cpu_pages
op_star
id|pcp
suffix:semicolon
id|pcp
op_assign
op_amp
id|zone-&gt;pageset
(braket
id|get_cpu
c_func
(paren
)paren
)braket
dot
id|pcp
(braket
id|cold
)braket
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcp-&gt;count
op_le
id|pcp-&gt;low
)paren
id|pcp-&gt;count
op_add_assign
id|rmqueue_bulk
c_func
(paren
id|zone
comma
l_int|0
comma
id|pcp-&gt;batch
comma
op_amp
id|pcp-&gt;list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcp-&gt;count
)paren
(brace
id|page
op_assign
id|list_entry
c_func
(paren
id|pcp-&gt;list.next
comma
r_struct
id|page
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|page-&gt;list
)paren
suffix:semicolon
id|pcp-&gt;count
op_decrement
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page
op_eq
l_int|NULL
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|page
op_assign
id|__rmqueue
c_func
(paren
id|zone
comma
id|order
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|order
op_logical_and
id|page
)paren
id|prep_compound_page
c_func
(paren
id|page
comma
id|order
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page
op_ne
l_int|NULL
)paren
(brace
id|BUG_ON
c_func
(paren
id|bad_range
c_func
(paren
id|zone
comma
id|page
)paren
)paren
suffix:semicolon
id|mod_page_state
c_func
(paren
id|pgalloc
comma
l_int|1
op_lshift
id|order
)paren
suffix:semicolon
id|prep_new_page
c_func
(paren
id|page
comma
id|order
)paren
suffix:semicolon
)brace
r_return
id|page
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the &squot;heart&squot; of the zoned buddy allocator.&n; *&n; * Herein lies the mysterious &quot;incremental min&quot;.  That&squot;s the&n; *&n; *&t;min += z-&gt;pages_low;&n; *&n; * thing.  The intent here is to provide additional protection to low zones for&n; * allocation requests which _could_ use higher zones.  So a GFP_HIGHMEM&n; * request is not allowed to dip as deeply into the normal zone as a GFP_KERNEL&n; * request.  This preserves additional space in those lower zones for requests&n; * which really do need memory from those zones.  It means that on a decent&n; * sized machine, GFP_HIGHMEM and GFP_KERNEL requests basically leave the DMA&n; * zone untouched.&n; */
r_struct
id|page
op_star
DECL|function|__alloc_pages
id|__alloc_pages
c_func
(paren
r_int
r_int
id|gfp_mask
comma
r_int
r_int
id|order
comma
r_struct
id|zonelist
op_star
id|zonelist
)paren
(brace
r_const
r_int
id|wait
op_assign
id|gfp_mask
op_amp
id|__GFP_WAIT
suffix:semicolon
r_int
r_int
id|min
suffix:semicolon
r_struct
id|zone
op_star
op_star
id|zones
comma
op_star
id|classzone
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|cold
suffix:semicolon
r_int
id|do_retry
suffix:semicolon
r_struct
id|reclaim_state
id|reclaim_state
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
id|might_sleep
c_func
(paren
)paren
suffix:semicolon
id|cold
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|gfp_mask
op_amp
id|__GFP_COLD
)paren
id|cold
op_assign
l_int|1
suffix:semicolon
id|zones
op_assign
id|zonelist-&gt;zones
suffix:semicolon
multiline_comment|/* the list of zones suitable for gfp_mask */
id|classzone
op_assign
id|zones
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|classzone
op_eq
l_int|NULL
)paren
multiline_comment|/* no zones in the zonelist */
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Go through the zonelist once, looking for a zone with enough free */
id|min
op_assign
l_int|1UL
op_lshift
id|order
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|zones
(braket
id|i
)braket
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|zone
op_star
id|z
op_assign
id|zones
(braket
id|i
)braket
suffix:semicolon
id|min
op_add_assign
id|z-&gt;pages_low
suffix:semicolon
r_if
c_cond
(paren
id|z-&gt;free_pages
op_ge
id|min
op_logical_or
(paren
op_logical_neg
id|wait
op_logical_and
id|z-&gt;free_pages
op_ge
id|z-&gt;pages_high
)paren
)paren
(brace
id|page
op_assign
id|buffered_rmqueue
c_func
(paren
id|z
comma
id|order
comma
id|cold
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
r_return
id|page
suffix:semicolon
)brace
id|min
op_add_assign
id|z-&gt;pages_low
op_star
id|sysctl_lower_zone_protection
suffix:semicolon
)brace
multiline_comment|/* we&squot;re somewhat low on memory, failed to find what we needed */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|zones
(braket
id|i
)braket
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
id|wakeup_kswapd
c_func
(paren
id|zones
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* Go through the zonelist again, taking __GFP_HIGH into account */
id|min
op_assign
l_int|1UL
op_lshift
id|order
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|zones
(braket
id|i
)braket
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|local_min
suffix:semicolon
r_struct
id|zone
op_star
id|z
op_assign
id|zones
(braket
id|i
)braket
suffix:semicolon
id|local_min
op_assign
id|z-&gt;pages_min
suffix:semicolon
r_if
c_cond
(paren
id|gfp_mask
op_amp
id|__GFP_HIGH
)paren
id|local_min
op_rshift_assign
l_int|2
suffix:semicolon
id|min
op_add_assign
id|local_min
suffix:semicolon
r_if
c_cond
(paren
id|z-&gt;free_pages
op_ge
id|min
op_logical_or
(paren
op_logical_neg
id|wait
op_logical_and
id|z-&gt;free_pages
op_ge
id|z-&gt;pages_high
)paren
)paren
(brace
id|page
op_assign
id|buffered_rmqueue
c_func
(paren
id|z
comma
id|order
comma
id|cold
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
r_return
id|page
suffix:semicolon
)brace
id|min
op_add_assign
id|local_min
op_star
id|sysctl_lower_zone_protection
suffix:semicolon
)brace
multiline_comment|/* here we&squot;re in the low on memory slow path */
id|rebalance
suffix:colon
r_if
c_cond
(paren
(paren
id|current-&gt;flags
op_amp
(paren
id|PF_MEMALLOC
op_or
id|PF_MEMDIE
)paren
)paren
op_logical_and
op_logical_neg
id|in_interrupt
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* go through the zonelist yet again, ignoring mins */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|zones
(braket
id|i
)braket
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|zone
op_star
id|z
op_assign
id|zones
(braket
id|i
)braket
suffix:semicolon
id|page
op_assign
id|buffered_rmqueue
c_func
(paren
id|z
comma
id|order
comma
id|cold
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
r_return
id|page
suffix:semicolon
)brace
r_goto
id|nopage
suffix:semicolon
)brace
multiline_comment|/* Atomic allocations - we can&squot;t balance anything */
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
r_goto
id|nopage
suffix:semicolon
id|current-&gt;flags
op_or_assign
id|PF_MEMALLOC
suffix:semicolon
id|reclaim_state.reclaimed_slab
op_assign
l_int|0
suffix:semicolon
id|current-&gt;reclaim_state
op_assign
op_amp
id|reclaim_state
suffix:semicolon
id|try_to_free_pages
c_func
(paren
id|classzone
comma
id|gfp_mask
comma
id|order
)paren
suffix:semicolon
id|current-&gt;reclaim_state
op_assign
l_int|NULL
suffix:semicolon
id|current-&gt;flags
op_and_assign
op_complement
id|PF_MEMALLOC
suffix:semicolon
multiline_comment|/* go through the zonelist yet one more time */
id|min
op_assign
l_int|1UL
op_lshift
id|order
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|zones
(braket
id|i
)braket
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|zone
op_star
id|z
op_assign
id|zones
(braket
id|i
)braket
suffix:semicolon
id|min
op_add_assign
id|z-&gt;pages_min
suffix:semicolon
r_if
c_cond
(paren
id|z-&gt;free_pages
op_ge
id|min
op_logical_or
(paren
op_logical_neg
id|wait
op_logical_and
id|z-&gt;free_pages
op_ge
id|z-&gt;pages_high
)paren
)paren
(brace
id|page
op_assign
id|buffered_rmqueue
c_func
(paren
id|z
comma
id|order
comma
id|cold
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
r_return
id|page
suffix:semicolon
)brace
id|min
op_add_assign
id|z-&gt;pages_low
op_star
id|sysctl_lower_zone_protection
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Don&squot;t let big-order allocations loop unless the caller explicitly&n;&t; * requests that.  Wait for some write requests to complete then retry.&n;&t; *&n;&t; * In this implementation, __GFP_REPEAT means __GFP_NOFAIL, but that&n;&t; * may not be true in other implementations.&n;&t; */
id|do_retry
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|gfp_mask
op_amp
id|__GFP_NORETRY
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|order
op_le
l_int|3
)paren
op_logical_or
(paren
id|gfp_mask
op_amp
id|__GFP_REPEAT
)paren
)paren
id|do_retry
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|gfp_mask
op_amp
id|__GFP_NOFAIL
)paren
id|do_retry
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_retry
)paren
(brace
id|blk_congestion_wait
c_func
(paren
id|WRITE
comma
id|HZ
op_div
l_int|50
)paren
suffix:semicolon
r_goto
id|rebalance
suffix:semicolon
)brace
id|nopage
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|gfp_mask
op_amp
id|__GFP_NOWARN
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: page allocation failure.&quot;
l_string|&quot; order:%d, mode:0x%x&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|order
comma
id|gfp_mask
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Common helper functions.&n; */
DECL|function|__get_free_pages
r_int
r_int
id|__get_free_pages
c_func
(paren
r_int
r_int
id|gfp_mask
comma
r_int
r_int
id|order
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
id|page
op_assign
id|alloc_pages
c_func
(paren
id|gfp_mask
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|function|get_zeroed_page
r_int
r_int
id|get_zeroed_page
c_func
(paren
r_int
r_int
id|gfp_mask
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
multiline_comment|/*&n;&t; * get_zeroed_page() returns a 32-bit address, which cannot represent&n;&t; * a highmem page&n;&t; */
id|BUG_ON
c_func
(paren
id|gfp_mask
op_amp
id|__GFP_HIGHMEM
)paren
suffix:semicolon
id|page
op_assign
id|alloc_pages
c_func
(paren
id|gfp_mask
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
r_void
op_star
id|address
op_assign
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
id|clear_page
c_func
(paren
id|address
)paren
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|address
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__pagevec_free
r_void
id|__pagevec_free
c_func
(paren
r_struct
id|pagevec
op_star
id|pvec
)paren
(brace
r_int
id|i
op_assign
id|pagevec_count
c_func
(paren
id|pvec
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|i
op_ge
l_int|0
)paren
id|free_hot_cold_page
c_func
(paren
id|pvec-&gt;pages
(braket
id|i
)braket
comma
id|pvec-&gt;cold
)paren
suffix:semicolon
)brace
DECL|function|__free_pages
r_void
id|__free_pages
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|order
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|PageReserved
c_func
(paren
id|page
)paren
op_logical_and
id|put_page_testzero
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
id|order
op_eq
l_int|0
)paren
id|free_hot_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_else
id|__free_pages_ok
c_func
(paren
id|page
comma
id|order
)paren
suffix:semicolon
)brace
)brace
DECL|function|free_pages
r_void
id|free_pages
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|order
)paren
(brace
r_if
c_cond
(paren
id|addr
op_ne
l_int|0
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|virt_addr_valid
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
id|__free_pages
c_func
(paren
id|virt_to_page
c_func
(paren
id|addr
)paren
comma
id|order
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Total amount of free (allocatable) RAM:&n; */
DECL|function|nr_free_pages
r_int
r_int
id|nr_free_pages
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|sum
op_assign
l_int|0
suffix:semicolon
r_struct
id|zone
op_star
id|zone
suffix:semicolon
id|for_each_zone
c_func
(paren
id|zone
)paren
id|sum
op_add_assign
id|zone-&gt;free_pages
suffix:semicolon
r_return
id|sum
suffix:semicolon
)brace
DECL|function|nr_used_zone_pages
r_int
r_int
id|nr_used_zone_pages
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|pages
op_assign
l_int|0
suffix:semicolon
r_struct
id|zone
op_star
id|zone
suffix:semicolon
id|for_each_zone
c_func
(paren
id|zone
)paren
id|pages
op_add_assign
id|zone-&gt;nr_active
op_plus
id|zone-&gt;nr_inactive
suffix:semicolon
r_return
id|pages
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NUMA
DECL|function|nr_free_pages_pgdat
r_int
r_int
id|nr_free_pages_pgdat
c_func
(paren
id|pg_data_t
op_star
id|pgdat
)paren
(brace
r_int
r_int
id|i
comma
id|sum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_ZONES
suffix:semicolon
id|i
op_increment
)paren
id|sum
op_add_assign
id|pgdat-&gt;node_zones
(braket
id|i
)braket
dot
id|free_pages
suffix:semicolon
r_return
id|sum
suffix:semicolon
)brace
macro_line|#endif
DECL|function|nr_free_zone_pages
r_static
r_int
r_int
id|nr_free_zone_pages
c_func
(paren
r_int
id|offset
)paren
(brace
id|pg_data_t
op_star
id|pgdat
suffix:semicolon
r_int
r_int
id|sum
op_assign
l_int|0
suffix:semicolon
id|for_each_pgdat
c_func
(paren
id|pgdat
)paren
(brace
r_struct
id|zonelist
op_star
id|zonelist
op_assign
id|pgdat-&gt;node_zonelists
op_plus
id|offset
suffix:semicolon
r_struct
id|zone
op_star
op_star
id|zonep
op_assign
id|zonelist-&gt;zones
suffix:semicolon
r_struct
id|zone
op_star
id|zone
suffix:semicolon
r_for
c_loop
(paren
id|zone
op_assign
op_star
id|zonep
op_increment
suffix:semicolon
id|zone
suffix:semicolon
id|zone
op_assign
op_star
id|zonep
op_increment
)paren
(brace
r_int
r_int
id|size
op_assign
id|zone-&gt;present_pages
suffix:semicolon
r_int
r_int
id|high
op_assign
id|zone-&gt;pages_high
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|high
)paren
id|sum
op_add_assign
id|size
op_minus
id|high
suffix:semicolon
)brace
)brace
r_return
id|sum
suffix:semicolon
)brace
multiline_comment|/*&n; * Amount of free RAM allocatable within ZONE_DMA and ZONE_NORMAL&n; */
DECL|function|nr_free_buffer_pages
r_int
r_int
id|nr_free_buffer_pages
c_func
(paren
r_void
)paren
(brace
r_return
id|nr_free_zone_pages
c_func
(paren
id|GFP_USER
op_amp
id|GFP_ZONEMASK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Amount of free RAM allocatable within all zones&n; */
DECL|function|nr_free_pagecache_pages
r_int
r_int
id|nr_free_pagecache_pages
c_func
(paren
r_void
)paren
(brace
r_return
id|nr_free_zone_pages
c_func
(paren
id|GFP_HIGHUSER
op_amp
id|GFP_ZONEMASK
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_HIGHMEM
DECL|function|nr_free_highpages
r_int
r_int
id|nr_free_highpages
(paren
r_void
)paren
(brace
id|pg_data_t
op_star
id|pgdat
suffix:semicolon
r_int
r_int
id|pages
op_assign
l_int|0
suffix:semicolon
id|for_each_pgdat
c_func
(paren
id|pgdat
)paren
id|pages
op_add_assign
id|pgdat-&gt;node_zones
(braket
id|ZONE_HIGHMEM
)braket
dot
id|free_pages
suffix:semicolon
r_return
id|pages
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_NUMA
DECL|function|show_node
r_static
r_void
id|show_node
c_func
(paren
r_struct
id|zone
op_star
id|zone
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Node %d &quot;
comma
id|zone-&gt;zone_pgdat-&gt;node_id
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|show_node
mdefine_line|#define show_node(zone)&t;do { } while (0)
macro_line|#endif
multiline_comment|/*&n; * Accumulate the page_state information across all CPUs.&n; * The result is unavoidably approximate - it can change&n; * during and after execution of this function.&n; */
id|DEFINE_PER_CPU
c_func
(paren
r_struct
id|page_state
comma
id|page_states
)paren
op_assign
(brace
l_int|0
)brace
suffix:semicolon
DECL|variable|page_states
id|EXPORT_PER_CPU_SYMBOL
c_func
(paren
id|page_states
)paren
suffix:semicolon
DECL|variable|nr_pagecache
id|atomic_t
id|nr_pagecache
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|DEFINE_PER_CPU
c_func
(paren
r_int
comma
id|nr_pagecache_local
)paren
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|function|__get_page_state
r_void
id|__get_page_state
c_func
(paren
r_struct
id|page_state
op_star
id|ret
comma
r_int
id|nr
)paren
(brace
r_int
id|cpu
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|ret
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ret
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cpu
OL
id|NR_CPUS
)paren
(brace
r_int
r_int
op_star
id|in
comma
op_star
id|out
comma
id|off
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_online
c_func
(paren
id|cpu
)paren
)paren
(brace
id|cpu
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|in
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|per_cpu
c_func
(paren
id|page_states
comma
id|cpu
)paren
suffix:semicolon
id|cpu
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cpu
OL
id|NR_CPUS
op_logical_and
id|cpu_online
c_func
(paren
id|cpu
)paren
)paren
id|prefetch
c_func
(paren
op_amp
id|per_cpu
c_func
(paren
id|page_states
comma
id|cpu
)paren
)paren
suffix:semicolon
id|out
op_assign
(paren
r_int
r_int
op_star
)paren
id|ret
suffix:semicolon
r_for
c_loop
(paren
id|off
op_assign
l_int|0
suffix:semicolon
id|off
OL
id|nr
suffix:semicolon
id|off
op_increment
)paren
op_star
id|out
op_increment
op_add_assign
op_star
id|in
op_increment
suffix:semicolon
)brace
)brace
DECL|function|get_page_state
r_void
id|get_page_state
c_func
(paren
r_struct
id|page_state
op_star
id|ret
)paren
(brace
r_int
id|nr
suffix:semicolon
id|nr
op_assign
m_offsetof
(paren
r_struct
id|page_state
comma
id|GET_PAGE_STATE_LAST
)paren
suffix:semicolon
id|nr
op_div_assign
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|__get_page_state
c_func
(paren
id|ret
comma
id|nr
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|get_full_page_state
r_void
id|get_full_page_state
c_func
(paren
r_struct
id|page_state
op_star
id|ret
)paren
(brace
id|__get_page_state
c_func
(paren
id|ret
comma
r_sizeof
(paren
op_star
id|ret
)paren
op_div
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
)brace
DECL|function|get_zone_counts
r_void
id|get_zone_counts
c_func
(paren
r_int
r_int
op_star
id|active
comma
r_int
r_int
op_star
id|inactive
comma
r_int
r_int
op_star
id|free
)paren
(brace
r_struct
id|zone
op_star
id|zone
suffix:semicolon
op_star
id|active
op_assign
l_int|0
suffix:semicolon
op_star
id|inactive
op_assign
l_int|0
suffix:semicolon
op_star
id|free
op_assign
l_int|0
suffix:semicolon
id|for_each_zone
c_func
(paren
id|zone
)paren
(brace
op_star
id|active
op_add_assign
id|zone-&gt;nr_active
suffix:semicolon
op_star
id|inactive
op_add_assign
id|zone-&gt;nr_inactive
suffix:semicolon
op_star
id|free
op_add_assign
id|zone-&gt;free_pages
suffix:semicolon
)brace
)brace
DECL|function|si_meminfo
r_void
id|si_meminfo
c_func
(paren
r_struct
id|sysinfo
op_star
id|val
)paren
(brace
id|val-&gt;totalram
op_assign
id|totalram_pages
suffix:semicolon
id|val-&gt;sharedram
op_assign
l_int|0
suffix:semicolon
id|val-&gt;freeram
op_assign
id|nr_free_pages
c_func
(paren
)paren
suffix:semicolon
id|val-&gt;bufferram
op_assign
id|nr_blockdev_pages
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_HIGHMEM
id|val-&gt;totalhigh
op_assign
id|totalhigh_pages
suffix:semicolon
id|val-&gt;freehigh
op_assign
id|nr_free_highpages
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
id|val-&gt;totalhigh
op_assign
l_int|0
suffix:semicolon
id|val-&gt;freehigh
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|val-&gt;mem_unit
op_assign
id|PAGE_SIZE
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NUMA
DECL|function|si_meminfo_node
r_void
id|si_meminfo_node
c_func
(paren
r_struct
id|sysinfo
op_star
id|val
comma
r_int
id|nid
)paren
(brace
id|pg_data_t
op_star
id|pgdat
op_assign
id|NODE_DATA
c_func
(paren
id|nid
)paren
suffix:semicolon
id|val-&gt;totalram
op_assign
id|pgdat-&gt;node_size
suffix:semicolon
id|val-&gt;freeram
op_assign
id|nr_free_pages_pgdat
c_func
(paren
id|pgdat
)paren
suffix:semicolon
id|val-&gt;totalhigh
op_assign
id|pgdat-&gt;node_zones
(braket
id|ZONE_HIGHMEM
)braket
dot
id|spanned_pages
suffix:semicolon
id|val-&gt;freehigh
op_assign
id|pgdat-&gt;node_zones
(braket
id|ZONE_HIGHMEM
)braket
dot
id|free_pages
suffix:semicolon
id|val-&gt;mem_unit
op_assign
id|PAGE_SIZE
suffix:semicolon
)brace
macro_line|#endif
DECL|macro|K
mdefine_line|#define K(x) ((x) &lt;&lt; (PAGE_SHIFT-10))
multiline_comment|/*&n; * Show free area list (used inside shift_scroll-lock stuff)&n; * We also calculate the percentage fragmentation. We do this by counting the&n; * memory on each free list with the exception of the first item on the list.&n; */
DECL|function|show_free_areas
r_void
id|show_free_areas
c_func
(paren
r_void
)paren
(brace
r_struct
id|page_state
id|ps
suffix:semicolon
r_int
id|cpu
comma
id|temperature
suffix:semicolon
r_int
r_int
id|active
suffix:semicolon
r_int
r_int
id|inactive
suffix:semicolon
r_int
r_int
id|free
suffix:semicolon
r_struct
id|zone
op_star
id|zone
suffix:semicolon
id|for_each_zone
c_func
(paren
id|zone
)paren
(brace
id|show_node
c_func
(paren
id|zone
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s per-cpu:&quot;
comma
id|zone-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zone-&gt;present_pages
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; empty&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|NR_CPUS
suffix:semicolon
op_increment
id|cpu
)paren
(brace
r_struct
id|per_cpu_pageset
op_star
id|pageset
op_assign
id|zone-&gt;pageset
op_plus
id|cpu
suffix:semicolon
r_for
c_loop
(paren
id|temperature
op_assign
l_int|0
suffix:semicolon
id|temperature
OL
l_int|2
suffix:semicolon
id|temperature
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;cpu %d %s: low %d, high %d, batch %d&bslash;n&quot;
comma
id|cpu
comma
id|temperature
ques
c_cond
l_string|&quot;cold&quot;
suffix:colon
l_string|&quot;hot&quot;
comma
id|pageset-&gt;pcp
(braket
id|temperature
)braket
dot
id|low
comma
id|pageset-&gt;pcp
(braket
id|temperature
)braket
dot
id|high
comma
id|pageset-&gt;pcp
(braket
id|temperature
)braket
dot
id|batch
)paren
suffix:semicolon
)brace
)brace
id|get_page_state
c_func
(paren
op_amp
id|ps
)paren
suffix:semicolon
id|get_zone_counts
c_func
(paren
op_amp
id|active
comma
op_amp
id|inactive
comma
op_amp
id|free
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nFree pages: %11ukB (%ukB HighMem)&bslash;n&quot;
comma
id|K
c_func
(paren
id|nr_free_pages
c_func
(paren
)paren
)paren
comma
id|K
c_func
(paren
id|nr_free_highpages
c_func
(paren
)paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Active:%lu inactive:%lu dirty:%lu writeback:%lu &quot;
l_string|&quot;unstable:%lu free:%u&bslash;n&quot;
comma
id|active
comma
id|inactive
comma
id|ps.nr_dirty
comma
id|ps.nr_writeback
comma
id|ps.nr_unstable
comma
id|nr_free_pages
c_func
(paren
)paren
)paren
suffix:semicolon
id|for_each_zone
c_func
(paren
id|zone
)paren
(brace
id|show_node
c_func
(paren
id|zone
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s&quot;
l_string|&quot; free:%lukB&quot;
l_string|&quot; min:%lukB&quot;
l_string|&quot; low:%lukB&quot;
l_string|&quot; high:%lukB&quot;
l_string|&quot; active:%lukB&quot;
l_string|&quot; inactive:%lukB&quot;
l_string|&quot;&bslash;n&quot;
comma
id|zone-&gt;name
comma
id|K
c_func
(paren
id|zone-&gt;free_pages
)paren
comma
id|K
c_func
(paren
id|zone-&gt;pages_min
)paren
comma
id|K
c_func
(paren
id|zone-&gt;pages_low
)paren
comma
id|K
c_func
(paren
id|zone-&gt;pages_high
)paren
comma
id|K
c_func
(paren
id|zone-&gt;nr_active
)paren
comma
id|K
c_func
(paren
id|zone-&gt;nr_inactive
)paren
)paren
suffix:semicolon
)brace
id|for_each_zone
c_func
(paren
id|zone
)paren
(brace
r_struct
id|list_head
op_star
id|elem
suffix:semicolon
r_int
r_int
id|nr
comma
id|flags
comma
id|order
comma
id|total
op_assign
l_int|0
suffix:semicolon
id|show_node
c_func
(paren
id|zone
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: &quot;
comma
id|zone-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zone-&gt;present_pages
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;empty&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
l_int|0
suffix:semicolon
id|order
OL
id|MAX_ORDER
suffix:semicolon
id|order
op_increment
)paren
(brace
id|nr
op_assign
l_int|0
suffix:semicolon
id|list_for_each
c_func
(paren
id|elem
comma
op_amp
id|zone-&gt;free_area
(braket
id|order
)braket
dot
id|free_list
)paren
op_increment
id|nr
suffix:semicolon
id|total
op_add_assign
id|nr
op_lshift
id|order
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%lu*%lukB &quot;
comma
id|nr
comma
id|K
c_func
(paren
l_int|1UL
)paren
op_lshift
id|order
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;= %lukB&bslash;n&quot;
comma
id|K
c_func
(paren
id|total
)paren
)paren
suffix:semicolon
)brace
id|show_swap_cache_info
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Builds allocation fallback zone lists.&n; */
DECL|function|build_zonelists_node
r_static
r_int
id|__init
id|build_zonelists_node
c_func
(paren
id|pg_data_t
op_star
id|pgdat
comma
r_struct
id|zonelist
op_star
id|zonelist
comma
r_int
id|j
comma
r_int
id|k
)paren
(brace
r_switch
c_cond
(paren
id|k
)paren
(brace
r_struct
id|zone
op_star
id|zone
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_case
id|ZONE_HIGHMEM
suffix:colon
id|zone
op_assign
id|pgdat-&gt;node_zones
op_plus
id|ZONE_HIGHMEM
suffix:semicolon
r_if
c_cond
(paren
id|zone-&gt;present_pages
)paren
(brace
macro_line|#ifndef CONFIG_HIGHMEM
id|BUG
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|zonelist-&gt;zones
(braket
id|j
op_increment
)braket
op_assign
id|zone
suffix:semicolon
)brace
r_case
id|ZONE_NORMAL
suffix:colon
id|zone
op_assign
id|pgdat-&gt;node_zones
op_plus
id|ZONE_NORMAL
suffix:semicolon
r_if
c_cond
(paren
id|zone-&gt;present_pages
)paren
id|zonelist-&gt;zones
(braket
id|j
op_increment
)braket
op_assign
id|zone
suffix:semicolon
r_case
id|ZONE_DMA
suffix:colon
id|zone
op_assign
id|pgdat-&gt;node_zones
op_plus
id|ZONE_DMA
suffix:semicolon
r_if
c_cond
(paren
id|zone-&gt;present_pages
)paren
id|zonelist-&gt;zones
(braket
id|j
op_increment
)braket
op_assign
id|zone
suffix:semicolon
)brace
r_return
id|j
suffix:semicolon
)brace
DECL|function|build_zonelists
r_static
r_void
id|__init
id|build_zonelists
c_func
(paren
id|pg_data_t
op_star
id|pgdat
)paren
(brace
r_int
id|i
comma
id|j
comma
id|k
comma
id|node
comma
id|local_node
suffix:semicolon
id|local_node
op_assign
id|pgdat-&gt;node_id
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Building zonelist for node : %d&bslash;n&quot;
comma
id|local_node
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_ZONES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|zonelist
op_star
id|zonelist
suffix:semicolon
id|zonelist
op_assign
id|pgdat-&gt;node_zonelists
op_plus
id|i
suffix:semicolon
id|memset
c_func
(paren
id|zonelist
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|zonelist
)paren
)paren
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
id|k
op_assign
id|ZONE_NORMAL
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|__GFP_HIGHMEM
)paren
id|k
op_assign
id|ZONE_HIGHMEM
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|__GFP_DMA
)paren
id|k
op_assign
id|ZONE_DMA
suffix:semicolon
id|j
op_assign
id|build_zonelists_node
c_func
(paren
id|pgdat
comma
id|zonelist
comma
id|j
comma
id|k
)paren
suffix:semicolon
multiline_comment|/*&n; &t;&t; * Now we build the zonelist so that it contains the zones&n; &t;&t; * of all the other nodes.&n; &t;&t; * We don&squot;t want to pressure a particular node, so when&n; &t;&t; * building the zones for node N, we make sure that the&n; &t;&t; * zones coming right after the local ones are those from&n; &t;&t; * node N+1 (modulo N)&n; &t;&t; */
r_for
c_loop
(paren
id|node
op_assign
id|local_node
op_plus
l_int|1
suffix:semicolon
id|node
OL
id|numnodes
suffix:semicolon
id|node
op_increment
)paren
id|j
op_assign
id|build_zonelists_node
c_func
(paren
id|NODE_DATA
c_func
(paren
id|node
)paren
comma
id|zonelist
comma
id|j
comma
id|k
)paren
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|node
OL
id|local_node
suffix:semicolon
id|node
op_increment
)paren
id|j
op_assign
id|build_zonelists_node
c_func
(paren
id|NODE_DATA
c_func
(paren
id|node
)paren
comma
id|zonelist
comma
id|j
comma
id|k
)paren
suffix:semicolon
id|zonelist-&gt;zones
(braket
id|j
op_increment
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|build_all_zonelists
r_void
id|__init
id|build_all_zonelists
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numnodes
suffix:semicolon
id|i
op_increment
)paren
(brace
id|build_zonelists
c_func
(paren
id|NODE_DATA
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Helper functions to size the waitqueue hash table.&n; * Essentially these want to choose hash table sizes sufficiently&n; * large so that collisions trying to wait on pages are rare.&n; * But in fact, the number of active page waitqueues on typical&n; * systems is ridiculously low, less than 200. So this is even&n; * conservative, even though it seems large.&n; *&n; * The constant PAGES_PER_WAITQUEUE specifies the ratio of pages to&n; * waitqueues, i.e. the size of the waitq table given the number of pages.&n; */
DECL|macro|PAGES_PER_WAITQUEUE
mdefine_line|#define PAGES_PER_WAITQUEUE&t;256
DECL|function|wait_table_size
r_static
r_inline
r_int
r_int
id|wait_table_size
c_func
(paren
r_int
r_int
id|pages
)paren
(brace
r_int
r_int
id|size
op_assign
l_int|1
suffix:semicolon
id|pages
op_div_assign
id|PAGES_PER_WAITQUEUE
suffix:semicolon
r_while
c_loop
(paren
id|size
OL
id|pages
)paren
id|size
op_lshift_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Once we have dozens or even hundreds of threads sleeping&n;&t; * on IO we&squot;ve got bigger problems than wait queue collision.&n;&t; * Limit the size of the wait table to a reasonable size.&n;&t; */
id|size
op_assign
id|min
c_func
(paren
id|size
comma
l_int|4096UL
)paren
suffix:semicolon
r_return
id|max
c_func
(paren
id|size
comma
l_int|4UL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is an integer logarithm so that shifts can be used later&n; * to extract the more random high bits from the multiplicative&n; * hash function before the remainder is taken.&n; */
DECL|function|wait_table_bits
r_static
r_inline
r_int
r_int
id|wait_table_bits
c_func
(paren
r_int
r_int
id|size
)paren
(brace
r_return
id|ffz
c_func
(paren
op_complement
id|size
)paren
suffix:semicolon
)brace
DECL|macro|LONG_ALIGN
mdefine_line|#define LONG_ALIGN(x) (((x)+(sizeof(long))-1)&amp;~((sizeof(long))-1))
DECL|function|calculate_zone_totalpages
r_static
r_void
id|__init
id|calculate_zone_totalpages
c_func
(paren
r_struct
id|pglist_data
op_star
id|pgdat
comma
r_int
r_int
op_star
id|zones_size
comma
r_int
r_int
op_star
id|zholes_size
)paren
(brace
r_int
r_int
id|realtotalpages
comma
id|totalpages
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_ZONES
suffix:semicolon
id|i
op_increment
)paren
id|totalpages
op_add_assign
id|zones_size
(braket
id|i
)braket
suffix:semicolon
id|pgdat-&gt;node_size
op_assign
id|totalpages
suffix:semicolon
id|realtotalpages
op_assign
id|totalpages
suffix:semicolon
r_if
c_cond
(paren
id|zholes_size
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_ZONES
suffix:semicolon
id|i
op_increment
)paren
id|realtotalpages
op_sub_assign
id|zholes_size
(braket
id|i
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;On node %d totalpages: %lu&bslash;n&quot;
comma
id|pgdat-&gt;node_id
comma
id|realtotalpages
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get space for the valid bitmap.&n; */
DECL|function|calculate_zone_bitmap
r_static
r_void
id|__init
id|calculate_zone_bitmap
c_func
(paren
r_struct
id|pglist_data
op_star
id|pgdat
comma
r_int
r_int
op_star
id|zones_size
)paren
(brace
r_int
r_int
id|size
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_ZONES
suffix:semicolon
id|i
op_increment
)paren
id|size
op_add_assign
id|zones_size
(braket
id|i
)braket
suffix:semicolon
id|size
op_assign
id|LONG_ALIGN
c_func
(paren
(paren
id|size
op_plus
l_int|7
)paren
op_rshift
l_int|3
)paren
suffix:semicolon
id|pgdat-&gt;valid_addr_bitmap
op_assign
(paren
r_int
r_int
op_star
)paren
id|alloc_bootmem_node
c_func
(paren
id|pgdat
comma
id|size
)paren
suffix:semicolon
id|memset
c_func
(paren
id|pgdat-&gt;valid_addr_bitmap
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initially all pages are reserved - free ones are freed&n; * up by free_all_bootmem() once the early boot process is&n; * done. Non-atomic initialization, single-pass.&n; */
DECL|function|memmap_init_zone
r_void
id|__init
id|memmap_init_zone
c_func
(paren
r_struct
id|page
op_star
id|start
comma
r_int
r_int
id|size
comma
r_int
id|nid
comma
r_int
r_int
id|zone
comma
r_int
r_int
id|start_pfn
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|start
suffix:semicolon
id|page
OL
(paren
id|start
op_plus
id|size
)paren
suffix:semicolon
id|page
op_increment
)paren
(brace
id|set_page_zone
c_func
(paren
id|page
comma
id|nid
op_star
id|MAX_NR_ZONES
op_plus
id|zone
)paren
suffix:semicolon
id|set_page_count
c_func
(paren
id|page
comma
l_int|0
)paren
suffix:semicolon
id|SetPageReserved
c_func
(paren
id|page
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|page-&gt;list
)paren
suffix:semicolon
macro_line|#ifdef WANT_PAGE_VIRTUAL
multiline_comment|/* The shift won&squot;t overflow because ZONE_NORMAL is below 4G. */
r_if
c_cond
(paren
id|zone
op_ne
id|ZONE_HIGHMEM
)paren
id|set_page_address
c_func
(paren
id|page
comma
id|__va
c_func
(paren
id|start_pfn
op_lshift
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
macro_line|#endif
id|start_pfn
op_increment
suffix:semicolon
)brace
)brace
macro_line|#ifndef __HAVE_ARCH_MEMMAP_INIT
DECL|macro|memmap_init
mdefine_line|#define memmap_init(start, size, nid, zone, start_pfn) &bslash;&n;&t;memmap_init_zone((start), (size), (nid), (zone), (start_pfn))
macro_line|#endif
multiline_comment|/*&n; * Set up the zone data structures:&n; *   - mark all pages reserved&n; *   - mark all memory queues empty&n; *   - clear the memory bitmaps&n; */
DECL|function|free_area_init_core
r_static
r_void
id|__init
id|free_area_init_core
c_func
(paren
r_struct
id|pglist_data
op_star
id|pgdat
comma
r_int
r_int
op_star
id|zones_size
comma
r_int
r_int
op_star
id|zholes_size
)paren
(brace
r_int
r_int
id|i
comma
id|j
suffix:semicolon
r_const
r_int
r_int
id|zone_required_alignment
op_assign
l_int|1UL
op_lshift
(paren
id|MAX_ORDER
op_minus
l_int|1
)paren
suffix:semicolon
r_int
id|cpu
comma
id|nid
op_assign
id|pgdat-&gt;node_id
suffix:semicolon
r_struct
id|page
op_star
id|lmem_map
op_assign
id|pgdat-&gt;node_mem_map
suffix:semicolon
r_int
r_int
id|zone_start_pfn
op_assign
id|pgdat-&gt;node_start_pfn
suffix:semicolon
id|pgdat-&gt;nr_zones
op_assign
l_int|0
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|pgdat-&gt;kswapd_wait
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|MAX_NR_ZONES
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|zone
op_star
id|zone
op_assign
id|pgdat-&gt;node_zones
op_plus
id|j
suffix:semicolon
r_int
r_int
id|size
comma
id|realsize
suffix:semicolon
r_int
r_int
id|batch
suffix:semicolon
id|zone_table
(braket
id|nid
op_star
id|MAX_NR_ZONES
op_plus
id|j
)braket
op_assign
id|zone
suffix:semicolon
id|realsize
op_assign
id|size
op_assign
id|zones_size
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|zholes_size
)paren
id|realsize
op_sub_assign
id|zholes_size
(braket
id|j
)braket
suffix:semicolon
id|zone-&gt;spanned_pages
op_assign
id|size
suffix:semicolon
id|zone-&gt;present_pages
op_assign
id|realsize
suffix:semicolon
id|zone-&gt;name
op_assign
id|zone_names
(braket
id|j
)braket
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|zone-&gt;lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
id|zone-&gt;zone_pgdat
op_assign
id|pgdat
suffix:semicolon
id|zone-&gt;free_pages
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The per-cpu-pages pools are set to around 1000th of the&n;&t;&t; * size of the zone.  But no more than 1/4 of a meg - there&squot;s&n;&t;&t; * no point in going beyond the size of L2 cache.&n;&t;&t; *&n;&t;&t; * OK, so we don&squot;t know how big the cache is.  So guess.&n;&t;&t; */
id|batch
op_assign
id|zone-&gt;present_pages
op_div
l_int|1024
suffix:semicolon
r_if
c_cond
(paren
id|batch
op_star
id|PAGE_SIZE
OG
l_int|256
op_star
l_int|1024
)paren
id|batch
op_assign
(paren
l_int|256
op_star
l_int|1024
)paren
op_div
id|PAGE_SIZE
suffix:semicolon
id|batch
op_div_assign
l_int|4
suffix:semicolon
multiline_comment|/* We effectively *= 4 below */
r_if
c_cond
(paren
id|batch
OL
l_int|1
)paren
id|batch
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|NR_CPUS
suffix:semicolon
id|cpu
op_increment
)paren
(brace
r_struct
id|per_cpu_pages
op_star
id|pcp
suffix:semicolon
id|pcp
op_assign
op_amp
id|zone-&gt;pageset
(braket
id|cpu
)braket
dot
id|pcp
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* hot */
id|pcp-&gt;count
op_assign
l_int|0
suffix:semicolon
id|pcp-&gt;low
op_assign
l_int|2
op_star
id|batch
suffix:semicolon
id|pcp-&gt;high
op_assign
l_int|6
op_star
id|batch
suffix:semicolon
id|pcp-&gt;batch
op_assign
l_int|1
op_star
id|batch
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|pcp-&gt;list
)paren
suffix:semicolon
id|pcp
op_assign
op_amp
id|zone-&gt;pageset
(braket
id|cpu
)braket
dot
id|pcp
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* cold */
id|pcp-&gt;count
op_assign
l_int|0
suffix:semicolon
id|pcp-&gt;low
op_assign
l_int|0
suffix:semicolon
id|pcp-&gt;high
op_assign
l_int|2
op_star
id|batch
suffix:semicolon
id|pcp-&gt;batch
op_assign
l_int|1
op_star
id|batch
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|pcp-&gt;list
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  %s zone: %lu pages, LIFO batch:%lu&bslash;n&quot;
comma
id|zone_names
(braket
id|j
)braket
comma
id|realsize
comma
id|batch
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|zone-&gt;active_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|zone-&gt;inactive_list
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|zone-&gt;refill_counter
comma
l_int|0
)paren
suffix:semicolon
id|zone-&gt;nr_active
op_assign
l_int|0
suffix:semicolon
id|zone-&gt;nr_inactive
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The per-page waitqueue mechanism uses hashed waitqueues&n;&t;&t; * per zone.&n;&t;&t; */
id|zone-&gt;wait_table_size
op_assign
id|wait_table_size
c_func
(paren
id|size
)paren
suffix:semicolon
id|zone-&gt;wait_table_bits
op_assign
id|wait_table_bits
c_func
(paren
id|zone-&gt;wait_table_size
)paren
suffix:semicolon
id|zone-&gt;wait_table
op_assign
(paren
id|wait_queue_head_t
op_star
)paren
id|alloc_bootmem_node
c_func
(paren
id|pgdat
comma
id|zone-&gt;wait_table_size
op_star
r_sizeof
(paren
id|wait_queue_head_t
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|zone-&gt;wait_table_size
suffix:semicolon
op_increment
id|i
)paren
(brace
id|init_waitqueue_head
c_func
(paren
id|zone-&gt;wait_table
op_plus
id|i
)paren
suffix:semicolon
)brace
id|pgdat-&gt;nr_zones
op_assign
id|j
op_plus
l_int|1
suffix:semicolon
id|zone-&gt;zone_mem_map
op_assign
id|lmem_map
suffix:semicolon
id|zone-&gt;zone_start_pfn
op_assign
id|zone_start_pfn
suffix:semicolon
r_if
c_cond
(paren
(paren
id|zone_start_pfn
)paren
op_amp
(paren
id|zone_required_alignment
op_minus
l_int|1
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;BUG: wrong zone alignment, it will crash&bslash;n&quot;
)paren
suffix:semicolon
id|memmap_init
c_func
(paren
id|lmem_map
comma
id|size
comma
id|nid
comma
id|j
comma
id|zone_start_pfn
)paren
suffix:semicolon
id|zone_start_pfn
op_add_assign
id|size
suffix:semicolon
id|lmem_map
op_add_assign
id|size
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|bitmap_size
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|zone-&gt;free_area
(braket
id|i
)braket
dot
id|free_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|MAX_ORDER
op_minus
l_int|1
)paren
(brace
id|zone-&gt;free_area
(braket
id|i
)braket
dot
id|map
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Page buddy system uses &quot;index &gt;&gt; (i+1)&quot;,&n;&t;&t;&t; * where &quot;index&quot; is at most &quot;size-1&quot;.&n;&t;&t;&t; *&n;&t;&t;&t; * The extra &quot;+3&quot; is to round down to byte&n;&t;&t;&t; * size (8 bits per byte assumption). Thus&n;&t;&t;&t; * we get &quot;(size-1) &gt;&gt; (i+4)&quot; as the last byte&n;&t;&t;&t; * we can access.&n;&t;&t;&t; *&n;&t;&t;&t; * The &quot;+1&quot; is because we want to round the&n;&t;&t;&t; * byte allocation up rather than down. So&n;&t;&t;&t; * we should have had a &quot;+7&quot; before we shifted&n;&t;&t;&t; * down by three. Also, we have to add one as&n;&t;&t;&t; * we actually _use_ the last bit (it&squot;s [0,n]&n;&t;&t;&t; * inclusive, not [0,n[).&n;&t;&t;&t; *&n;&t;&t;&t; * So we actually had +7+1 before we shift&n;&t;&t;&t; * down by 3. But (n+8) &gt;&gt; 3 == (n &gt;&gt; 3) + 1&n;&t;&t;&t; * (modulo overflows, which we do not have).&n;&t;&t;&t; *&n;&t;&t;&t; * Finally, we LONG_ALIGN because all bitmap&n;&t;&t;&t; * operations are on longs.&n;&t;&t;&t; */
id|bitmap_size
op_assign
(paren
id|size
op_minus
l_int|1
)paren
op_rshift
(paren
id|i
op_plus
l_int|4
)paren
suffix:semicolon
id|bitmap_size
op_assign
id|LONG_ALIGN
c_func
(paren
id|bitmap_size
op_plus
l_int|1
)paren
suffix:semicolon
id|zone-&gt;free_area
(braket
id|i
)braket
dot
id|map
op_assign
(paren
r_int
r_int
op_star
)paren
id|alloc_bootmem_node
c_func
(paren
id|pgdat
comma
id|bitmap_size
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|free_area_init_node
r_void
id|__init
id|free_area_init_node
c_func
(paren
r_int
id|nid
comma
r_struct
id|pglist_data
op_star
id|pgdat
comma
r_struct
id|page
op_star
id|node_mem_map
comma
r_int
r_int
op_star
id|zones_size
comma
r_int
r_int
id|node_start_pfn
comma
r_int
r_int
op_star
id|zholes_size
)paren
(brace
r_int
r_int
id|size
suffix:semicolon
id|pgdat-&gt;node_id
op_assign
id|nid
suffix:semicolon
id|pgdat-&gt;node_start_pfn
op_assign
id|node_start_pfn
suffix:semicolon
id|calculate_zone_totalpages
c_func
(paren
id|pgdat
comma
id|zones_size
comma
id|zholes_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node_mem_map
)paren
(brace
id|size
op_assign
(paren
id|pgdat-&gt;node_size
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|page
)paren
suffix:semicolon
id|node_mem_map
op_assign
id|alloc_bootmem_node
c_func
(paren
id|pgdat
comma
id|size
)paren
suffix:semicolon
)brace
id|pgdat-&gt;node_mem_map
op_assign
id|node_mem_map
suffix:semicolon
id|free_area_init_core
c_func
(paren
id|pgdat
comma
id|zones_size
comma
id|zholes_size
)paren
suffix:semicolon
id|memblk_set_online
c_func
(paren
id|node_to_memblk
c_func
(paren
id|nid
)paren
)paren
suffix:semicolon
id|calculate_zone_bitmap
c_func
(paren
id|pgdat
comma
id|zones_size
)paren
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_DISCONTIGMEM
DECL|variable|contig_bootmem_data
r_static
id|bootmem_data_t
id|contig_bootmem_data
suffix:semicolon
DECL|variable|contig_page_data
r_struct
id|pglist_data
id|contig_page_data
op_assign
(brace
dot
id|bdata
op_assign
op_amp
id|contig_bootmem_data
)brace
suffix:semicolon
DECL|function|free_area_init
r_void
id|__init
id|free_area_init
c_func
(paren
r_int
r_int
op_star
id|zones_size
)paren
(brace
id|free_area_init_node
c_func
(paren
l_int|0
comma
op_amp
id|contig_page_data
comma
l_int|NULL
comma
id|zones_size
comma
id|__pa
c_func
(paren
id|PAGE_OFFSET
)paren
op_rshift
id|PAGE_SHIFT
comma
l_int|NULL
)paren
suffix:semicolon
id|mem_map
op_assign
id|contig_page_data.node_mem_map
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_PROC_FS
macro_line|#include &lt;linux/seq_file.h&gt;
DECL|function|frag_start
r_static
r_void
op_star
id|frag_start
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
id|loff_t
op_star
id|pos
)paren
(brace
id|pg_data_t
op_star
id|pgdat
suffix:semicolon
id|loff_t
id|node
op_assign
op_star
id|pos
suffix:semicolon
r_for
c_loop
(paren
id|pgdat
op_assign
id|pgdat_list
suffix:semicolon
id|pgdat
op_logical_and
id|node
suffix:semicolon
id|pgdat
op_assign
id|pgdat-&gt;pgdat_next
)paren
op_decrement
id|node
suffix:semicolon
r_return
id|pgdat
suffix:semicolon
)brace
DECL|function|frag_next
r_static
r_void
op_star
id|frag_next
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|arg
comma
id|loff_t
op_star
id|pos
)paren
(brace
id|pg_data_t
op_star
id|pgdat
op_assign
(paren
id|pg_data_t
op_star
)paren
id|arg
suffix:semicolon
(paren
op_star
id|pos
)paren
op_increment
suffix:semicolon
r_return
id|pgdat-&gt;pgdat_next
suffix:semicolon
)brace
DECL|function|frag_stop
r_static
r_void
id|frag_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|arg
)paren
(brace
)brace
multiline_comment|/* &n; * This walks the freelist for each zone. Whilst this is slow, I&squot;d rather &n; * be slow here than slow down the fast path by keeping stats - mjbligh&n; */
DECL|function|frag_show
r_static
r_int
id|frag_show
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|arg
)paren
(brace
id|pg_data_t
op_star
id|pgdat
op_assign
(paren
id|pg_data_t
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|zone
op_star
id|zone
suffix:semicolon
r_struct
id|zone
op_star
id|node_zones
op_assign
id|pgdat-&gt;node_zones
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|order
suffix:semicolon
r_for
c_loop
(paren
id|zone
op_assign
id|node_zones
suffix:semicolon
id|zone
op_minus
id|node_zones
OL
id|MAX_NR_ZONES
suffix:semicolon
op_increment
id|zone
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|zone-&gt;present_pages
)paren
r_continue
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;Node %d, zone %8s &quot;
comma
id|pgdat-&gt;node_id
comma
id|zone-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
l_int|0
suffix:semicolon
id|order
OL
id|MAX_ORDER
suffix:semicolon
op_increment
id|order
)paren
(brace
r_int
r_int
id|nr_bufs
op_assign
l_int|0
suffix:semicolon
r_struct
id|list_head
op_star
id|elem
suffix:semicolon
id|list_for_each
c_func
(paren
id|elem
comma
op_amp
(paren
id|zone-&gt;free_area
(braket
id|order
)braket
dot
id|free_list
)paren
)paren
op_increment
id|nr_bufs
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;%6lu &quot;
comma
id|nr_bufs
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|zone-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|seq_putc
c_func
(paren
id|m
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|fragmentation_op
r_struct
id|seq_operations
id|fragmentation_op
op_assign
(brace
dot
id|start
op_assign
id|frag_start
comma
dot
id|next
op_assign
id|frag_next
comma
dot
id|stop
op_assign
id|frag_stop
comma
dot
id|show
op_assign
id|frag_show
comma
)brace
suffix:semicolon
DECL|variable|vmstat_text
r_static
r_char
op_star
id|vmstat_text
(braket
)braket
op_assign
(brace
l_string|&quot;nr_dirty&quot;
comma
l_string|&quot;nr_writeback&quot;
comma
l_string|&quot;nr_unstable&quot;
comma
l_string|&quot;nr_page_table_pages&quot;
comma
l_string|&quot;nr_mapped&quot;
comma
l_string|&quot;nr_slab&quot;
comma
l_string|&quot;pgpgin&quot;
comma
l_string|&quot;pgpgout&quot;
comma
l_string|&quot;pswpin&quot;
comma
l_string|&quot;pswpout&quot;
comma
l_string|&quot;pgalloc&quot;
comma
l_string|&quot;pgfree&quot;
comma
l_string|&quot;pgactivate&quot;
comma
l_string|&quot;pgdeactivate&quot;
comma
l_string|&quot;pgfault&quot;
comma
l_string|&quot;pgmajfault&quot;
comma
l_string|&quot;pgscan&quot;
comma
l_string|&quot;pgrefill&quot;
comma
l_string|&quot;pgsteal&quot;
comma
l_string|&quot;pginodesteal&quot;
comma
l_string|&quot;kswapd_steal&quot;
comma
l_string|&quot;kswapd_inodesteal&quot;
comma
l_string|&quot;pageoutrun&quot;
comma
l_string|&quot;allocstall&quot;
comma
l_string|&quot;pgrotated&quot;
comma
)brace
suffix:semicolon
DECL|function|vmstat_start
r_static
r_void
op_star
id|vmstat_start
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|page_state
op_star
id|ps
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pos
op_ge
id|ARRAY_SIZE
c_func
(paren
id|vmstat_text
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|ps
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ps
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|m
op_member_access_from_pointer
r_private
op_assign
id|ps
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ps
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|get_full_page_state
c_func
(paren
id|ps
)paren
suffix:semicolon
id|ps-&gt;pgpgin
op_div_assign
l_int|2
suffix:semicolon
multiline_comment|/* sectors -&gt; kbytes */
id|ps-&gt;pgpgout
op_div_assign
l_int|2
suffix:semicolon
r_return
(paren
r_int
r_int
op_star
)paren
id|ps
op_plus
op_star
id|pos
suffix:semicolon
)brace
DECL|function|vmstat_next
r_static
r_void
op_star
id|vmstat_next
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|arg
comma
id|loff_t
op_star
id|pos
)paren
(brace
(paren
op_star
id|pos
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pos
op_ge
id|ARRAY_SIZE
c_func
(paren
id|vmstat_text
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
(paren
r_int
r_int
op_star
)paren
id|m
op_member_access_from_pointer
r_private
op_plus
op_star
id|pos
suffix:semicolon
)brace
DECL|function|vmstat_show
r_static
r_int
id|vmstat_show
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|arg
)paren
(brace
r_int
r_int
op_star
id|l
op_assign
id|arg
suffix:semicolon
r_int
r_int
id|off
op_assign
id|l
op_minus
(paren
r_int
r_int
op_star
)paren
id|m
op_member_access_from_pointer
r_private
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;%s %lu&bslash;n&quot;
comma
id|vmstat_text
(braket
id|off
)braket
comma
op_star
id|l
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vmstat_stop
r_static
r_void
id|vmstat_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|arg
)paren
(brace
id|kfree
c_func
(paren
id|m
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
id|m
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|variable|vmstat_op
r_struct
id|seq_operations
id|vmstat_op
op_assign
(brace
dot
id|start
op_assign
id|vmstat_start
comma
dot
id|next
op_assign
id|vmstat_next
comma
dot
id|stop
op_assign
id|vmstat_stop
comma
dot
id|show
op_assign
id|vmstat_show
comma
)brace
suffix:semicolon
macro_line|#endif /* CONFIG_PROC_FS */
DECL|function|init_page_alloc_cpu
r_static
r_void
id|__devinit
id|init_page_alloc_cpu
c_func
(paren
r_int
id|cpu
)paren
(brace
r_struct
id|page_state
op_star
id|ps
op_assign
op_amp
id|per_cpu
c_func
(paren
id|page_states
comma
id|cpu
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ps
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ps
)paren
)paren
suffix:semicolon
)brace
DECL|function|page_alloc_cpu_notify
r_static
r_int
id|__devinit
id|page_alloc_cpu_notify
c_func
(paren
r_struct
id|notifier_block
op_star
id|self
comma
r_int
r_int
id|action
comma
r_void
op_star
id|hcpu
)paren
(brace
r_int
id|cpu
op_assign
(paren
r_int
r_int
)paren
id|hcpu
suffix:semicolon
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
id|CPU_UP_PREPARE
suffix:colon
id|init_page_alloc_cpu
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|NOTIFY_OK
suffix:semicolon
)brace
DECL|variable|page_alloc_nb
r_static
r_struct
id|notifier_block
id|__devinitdata
id|page_alloc_nb
op_assign
(brace
dot
id|notifier_call
op_assign
id|page_alloc_cpu_notify
comma
)brace
suffix:semicolon
DECL|function|page_alloc_init
r_void
id|__init
id|page_alloc_init
c_func
(paren
r_void
)paren
(brace
id|init_page_alloc_cpu
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|register_cpu_notifier
c_func
(paren
op_amp
id|page_alloc_nb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * setup_per_zone_pages_min - called when min_free_kbytes changes.  Ensures &n; *&t;that the pages_{min,low,high} values for each zone are set correctly &n; *&t;with respect to min_free_kbytes.&n; */
DECL|function|setup_per_zone_pages_min
r_void
id|setup_per_zone_pages_min
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|pages_min
op_assign
id|min_free_kbytes
op_rshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
suffix:semicolon
r_int
r_int
id|lowmem_pages
op_assign
l_int|0
suffix:semicolon
r_struct
id|zone
op_star
id|zone
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Calculate total number of !ZONE_HIGHMEM pages */
id|for_each_zone
c_func
(paren
id|zone
)paren
r_if
c_cond
(paren
op_logical_neg
id|is_highmem
c_func
(paren
id|zone
)paren
)paren
id|lowmem_pages
op_add_assign
id|zone-&gt;present_pages
suffix:semicolon
id|for_each_zone
c_func
(paren
id|zone
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|zone-&gt;lru_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_highmem
c_func
(paren
id|zone
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Often, highmem doesn&squot;t need to reserve any pages.&n;&t;&t;&t; * But the pages_min/low/high values are also used for&n;&t;&t;&t; * batching up page reclaim activity so we need a&n;&t;&t;&t; * decent value here.&n;&t;&t;&t; */
r_int
id|min_pages
suffix:semicolon
id|min_pages
op_assign
id|zone-&gt;present_pages
op_div
l_int|1024
suffix:semicolon
r_if
c_cond
(paren
id|min_pages
OL
id|SWAP_CLUSTER_MAX
)paren
id|min_pages
op_assign
id|SWAP_CLUSTER_MAX
suffix:semicolon
r_if
c_cond
(paren
id|min_pages
OG
l_int|128
)paren
id|min_pages
op_assign
l_int|128
suffix:semicolon
id|zone-&gt;pages_min
op_assign
id|min_pages
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* if it&squot;s a lowmem zone, reserve a number of pages &n;&t;&t;&t; * proportionate to the zone&squot;s size.&n;&t;&t;&t; */
id|zone-&gt;pages_min
op_assign
(paren
id|pages_min
op_star
id|zone-&gt;present_pages
)paren
op_div
id|lowmem_pages
suffix:semicolon
)brace
id|zone-&gt;pages_low
op_assign
id|zone-&gt;pages_min
op_star
l_int|2
suffix:semicolon
id|zone-&gt;pages_high
op_assign
id|zone-&gt;pages_min
op_star
l_int|3
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|zone-&gt;lru_lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * min_free_kbytes_sysctl_handler - just a wrapper around proc_dointvec() so &n; *&t;that we can call setup_per_zone_pages_min() whenever min_free_kbytes &n; *&t;changes.&n; */
DECL|function|min_free_kbytes_sysctl_handler
r_int
id|min_free_kbytes_sysctl_handler
c_func
(paren
id|ctl_table
op_star
id|table
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|file
comma
r_void
op_star
id|buffer
comma
r_int
op_star
id|length
)paren
(brace
id|proc_dointvec
c_func
(paren
id|table
comma
id|write
comma
id|file
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
id|setup_per_zone_pages_min
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
