multiline_comment|/*&n; *  linux/mm/mempool.c&n; *&n; *  memory buffer pool support. Such pools are mostly used&n; *  for guaranteed, deadlock-free memory allocations during&n; *  extreme VM load.&n; *&n; *  started by Ingo Molnar, Copyright (C) 2001&n; */
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/mempool.h&gt;
multiline_comment|/**&n; * mempool_create - create a memory pool&n; * @min_nr:    the minimum number of elements guaranteed to be&n; *             allocated for this pool.&n; * @alloc_fn:  user-defined element-allocation function.&n; * @free_fn:   user-defined element-freeing function.&n; * @pool_data: optional private data available to the user-defined functions.&n; *&n; * this function creates and allocates a guaranteed size, preallocated&n; * memory pool. The pool can be used from the mempool_alloc and mempool_free&n; * functions. This function might sleep. Both the alloc_fn() and the free_fn()&n; * functions might sleep - as long as the mempool_alloc function is not called&n; * from IRQ contexts. The element allocated by alloc_fn() must be able to&n; * hold a struct list_head. (8 bytes on x86.)&n; */
DECL|function|mempool_create
id|mempool_t
op_star
id|mempool_create
c_func
(paren
r_int
id|min_nr
comma
id|mempool_alloc_t
op_star
id|alloc_fn
comma
id|mempool_free_t
op_star
id|free_fn
comma
r_void
op_star
id|pool_data
)paren
(brace
id|mempool_t
op_star
id|pool
suffix:semicolon
r_int
id|i
suffix:semicolon
id|pool
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|pool
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pool
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|pool
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|pool
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|pool-&gt;lock
)paren
suffix:semicolon
id|pool-&gt;min_nr
op_assign
id|min_nr
suffix:semicolon
id|pool-&gt;pool_data
op_assign
id|pool_data
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|pool-&gt;elements
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|pool-&gt;wait
)paren
suffix:semicolon
id|pool-&gt;alloc
op_assign
id|alloc_fn
suffix:semicolon
id|pool-&gt;free
op_assign
id|free_fn
suffix:semicolon
multiline_comment|/*&n;&t; * First pre-allocate the guaranteed number of buffers.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|min_nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_void
op_star
id|element
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|element
op_assign
id|pool
op_member_access_from_pointer
id|alloc
c_func
(paren
id|GFP_KERNEL
comma
id|pool-&gt;pool_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|element
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Not enough memory - free the allocated ones&n;&t;&t;&t; * and return:&n;&t;&t;&t; */
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|pool-&gt;elements
)paren
(brace
id|element
op_assign
id|tmp
suffix:semicolon
id|pool
op_member_access_from_pointer
id|free
c_func
(paren
id|element
comma
id|pool-&gt;pool_data
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|pool
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|tmp
op_assign
id|element
suffix:semicolon
id|list_add
c_func
(paren
id|tmp
comma
op_amp
id|pool-&gt;elements
)paren
suffix:semicolon
id|pool-&gt;curr_nr
op_increment
suffix:semicolon
)brace
r_return
id|pool
suffix:semicolon
)brace
multiline_comment|/**&n; * mempool_resize - resize an existing memory pool&n; * @pool:       pointer to the memory pool which was allocated via&n; *              mempool_create().&n; * @new_min_nr: the new minimum number of elements guaranteed to be&n; *              allocated for this pool.&n; * @gfp_mask:   the usual allocation bitmask.&n; *&n; * This function shrinks/grows the pool. In the case of growing,&n; * it cannot be guaranteed that the pool will be grown to the new&n; * size immediately, but new mempool_free() calls will refill it.&n; *&n; * Note, the caller must guarantee that no mempool_destroy is called&n; * while this function is running. mempool_alloc() &amp; mempool_free()&n; * might be called (eg. from IRQ contexts) while this function executes.&n; */
DECL|function|mempool_resize
r_void
id|mempool_resize
c_func
(paren
id|mempool_t
op_star
id|pool
comma
r_int
id|new_min_nr
comma
r_int
id|gfp_mask
)paren
(brace
r_int
id|delta
suffix:semicolon
r_void
op_star
id|element
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|new_min_nr
op_le
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_min_nr
OL
id|pool-&gt;min_nr
)paren
(brace
id|pool-&gt;min_nr
op_assign
id|new_min_nr
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Free possible excess elements.&n;&t;&t; */
r_while
c_loop
(paren
id|pool-&gt;curr_nr
OG
id|pool-&gt;min_nr
)paren
(brace
id|tmp
op_assign
id|pool-&gt;elements.next
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
op_amp
id|pool-&gt;elements
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|element
op_assign
id|tmp
suffix:semicolon
id|pool-&gt;curr_nr
op_decrement
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|pool
op_member_access_from_pointer
id|free
c_func
(paren
id|element
comma
id|pool-&gt;pool_data
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|delta
op_assign
id|new_min_nr
op_minus
id|pool-&gt;min_nr
suffix:semicolon
id|pool-&gt;min_nr
op_assign
id|new_min_nr
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We refill the pool up to the new treshold - but we dont&n;&t; * (cannot) guarantee that the refill succeeds.&n;&t; */
r_while
c_loop
(paren
id|delta
)paren
(brace
id|element
op_assign
id|pool
op_member_access_from_pointer
id|alloc
c_func
(paren
id|gfp_mask
comma
id|pool-&gt;pool_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|element
)paren
r_break
suffix:semicolon
id|mempool_free
c_func
(paren
id|element
comma
id|pool
)paren
suffix:semicolon
id|delta
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * mempool_destroy - deallocate a memory pool&n; * @pool:      pointer to the memory pool which was allocated via&n; *             mempool_create().&n; *&n; * this function only sleeps if the free_fn() function sleeps. The caller&n; * has to guarantee that no mempool_alloc() nor mempool_free() happens in&n; * this pool when calling this function.&n; */
DECL|function|mempool_destroy
r_void
id|mempool_destroy
c_func
(paren
id|mempool_t
op_star
id|pool
)paren
(brace
r_void
op_star
id|element
suffix:semicolon
r_struct
id|list_head
op_star
id|head
comma
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pool
)paren
r_return
suffix:semicolon
id|head
op_assign
op_amp
id|pool-&gt;elements
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|head-&gt;next
suffix:semicolon
id|tmp
op_ne
id|head
suffix:semicolon
)paren
(brace
id|element
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
id|pool
op_member_access_from_pointer
id|free
c_func
(paren
id|element
comma
id|pool-&gt;pool_data
)paren
suffix:semicolon
id|pool-&gt;curr_nr
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pool-&gt;curr_nr
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pool
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * mempool_alloc - allocate an element from a specific memory pool&n; * @pool:      pointer to the memory pool which was allocated via&n; *             mempool_create().&n; * @gfp_mask:  the usual allocation bitmask.&n; *&n; * this function only sleeps if the alloc_fn function sleeps or&n; * returns NULL. Note that due to preallocation, this function&n; * *never* fails when called from process contexts. (it might&n; * fail if called from an IRQ context.)&n; */
DECL|function|mempool_alloc
r_void
op_star
id|mempool_alloc
c_func
(paren
id|mempool_t
op_star
id|pool
comma
r_int
id|gfp_mask
)paren
(brace
r_void
op_star
id|element
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_int
id|curr_nr
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
id|gfp_nowait
op_assign
id|gfp_mask
op_amp
op_complement
(paren
id|__GFP_WAIT
op_or
id|__GFP_IO
)paren
suffix:semicolon
id|repeat_alloc
suffix:colon
id|element
op_assign
id|pool
op_member_access_from_pointer
id|alloc
c_func
(paren
id|gfp_nowait
comma
id|pool-&gt;pool_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|element
op_ne
l_int|NULL
)paren
)paren
r_return
id|element
suffix:semicolon
multiline_comment|/*&n;&t; * If the pool is less than 50% full then try harder&n;&t; * to allocate an element:&n;&t; */
r_if
c_cond
(paren
(paren
id|gfp_mask
op_ne
id|gfp_nowait
)paren
op_logical_and
(paren
id|pool-&gt;curr_nr
op_le
id|pool-&gt;min_nr
op_div
l_int|2
)paren
)paren
(brace
id|element
op_assign
id|pool
op_member_access_from_pointer
id|alloc
c_func
(paren
id|gfp_mask
comma
id|pool-&gt;pool_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|element
op_ne
l_int|NULL
)paren
)paren
r_return
id|element
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Kick the VM at this point.&n;&t; */
id|wakeup_bdflush
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|pool-&gt;curr_nr
)paren
)paren
(brace
id|tmp
op_assign
id|pool-&gt;elements.next
suffix:semicolon
id|list_del
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|element
op_assign
id|tmp
suffix:semicolon
id|pool-&gt;curr_nr
op_decrement
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|element
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* We must not sleep in the GFP_ATOMIC case */
r_if
c_cond
(paren
id|gfp_mask
op_eq
id|gfp_nowait
)paren
r_return
l_int|NULL
suffix:semicolon
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|pool-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|current
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|curr_nr
op_assign
id|pool-&gt;curr_nr
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|curr_nr
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|pool-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_goto
id|repeat_alloc
suffix:semicolon
)brace
multiline_comment|/**&n; * mempool_free - return an element to the pool.&n; * @element:   pool element pointer.&n; * @pool:      pointer to the memory pool which was allocated via&n; *             mempool_create().&n; *&n; * this function only sleeps if the free_fn() function sleeps.&n; */
DECL|function|mempool_free
r_void
id|mempool_free
c_func
(paren
r_void
op_star
id|element
comma
id|mempool_t
op_star
id|pool
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|pool-&gt;curr_nr
OL
id|pool-&gt;min_nr
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pool-&gt;curr_nr
OL
id|pool-&gt;min_nr
)paren
(brace
id|list_add
c_func
(paren
id|element
comma
op_amp
id|pool-&gt;elements
)paren
suffix:semicolon
id|pool-&gt;curr_nr
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|pool-&gt;wait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|pool
op_member_access_from_pointer
id|free
c_func
(paren
id|element
comma
id|pool-&gt;pool_data
)paren
suffix:semicolon
)brace
DECL|variable|mempool_create
id|EXPORT_SYMBOL
c_func
(paren
id|mempool_create
)paren
suffix:semicolon
DECL|variable|mempool_resize
id|EXPORT_SYMBOL
c_func
(paren
id|mempool_resize
)paren
suffix:semicolon
DECL|variable|mempool_destroy
id|EXPORT_SYMBOL
c_func
(paren
id|mempool_destroy
)paren
suffix:semicolon
DECL|variable|mempool_alloc
id|EXPORT_SYMBOL
c_func
(paren
id|mempool_alloc
)paren
suffix:semicolon
DECL|variable|mempool_free
id|EXPORT_SYMBOL
c_func
(paren
id|mempool_free
)paren
suffix:semicolon
eof
