multiline_comment|/*&n; *  linux/mm/nommu.c&n; *&n; *  Replacement code for mm functions to support CPU&squot;s that don&squot;t&n; *  have any form of memory management unit (thus no virtual memory).&n; *&n; *  See Documentation/nommu-mmap.txt&n; *&n; *  Copyright (c) 2004-2005 David Howells &lt;dhowells@redhat.com&gt;&n; *  Copyright (c) 2000-2003 David McCullough &lt;davidm@snapgear.com&gt;&n; *  Copyright (c) 2000-2001 D Jeff Dionne &lt;jeff@uClinux.org&gt;&n; *  Copyright (c) 2002      Greg Ungerer &lt;gerg@snapgear.com&gt;&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/backing-dev.h&gt;
macro_line|#include &lt;linux/mount.h&gt;
macro_line|#include &lt;linux/personality.h&gt;
macro_line|#include &lt;linux/security.h&gt;
macro_line|#include &lt;linux/syscalls.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/tlb.h&gt;
macro_line|#include &lt;asm/tlbflush.h&gt;
DECL|variable|high_memory
r_void
op_star
id|high_memory
suffix:semicolon
DECL|variable|mem_map
r_struct
id|page
op_star
id|mem_map
suffix:semicolon
DECL|variable|max_mapnr
r_int
r_int
id|max_mapnr
suffix:semicolon
DECL|variable|num_physpages
r_int
r_int
id|num_physpages
suffix:semicolon
DECL|variable|askedalloc
DECL|variable|realalloc
r_int
r_int
id|askedalloc
comma
id|realalloc
suffix:semicolon
DECL|variable|vm_committed_space
id|atomic_t
id|vm_committed_space
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|sysctl_overcommit_memory
r_int
id|sysctl_overcommit_memory
op_assign
id|OVERCOMMIT_GUESS
suffix:semicolon
multiline_comment|/* heuristic overcommit */
DECL|variable|sysctl_overcommit_ratio
r_int
id|sysctl_overcommit_ratio
op_assign
l_int|50
suffix:semicolon
multiline_comment|/* default is 50% */
DECL|variable|sysctl_max_map_count
r_int
id|sysctl_max_map_count
op_assign
id|DEFAULT_MAX_MAP_COUNT
suffix:semicolon
DECL|variable|heap_stack_gap
r_int
id|heap_stack_gap
op_assign
l_int|0
suffix:semicolon
DECL|variable|mem_map
id|EXPORT_SYMBOL
c_func
(paren
id|mem_map
)paren
suffix:semicolon
DECL|variable|sysctl_max_map_count
id|EXPORT_SYMBOL
c_func
(paren
id|sysctl_max_map_count
)paren
suffix:semicolon
DECL|variable|sysctl_overcommit_memory
id|EXPORT_SYMBOL
c_func
(paren
id|sysctl_overcommit_memory
)paren
suffix:semicolon
DECL|variable|sysctl_overcommit_ratio
id|EXPORT_SYMBOL
c_func
(paren
id|sysctl_overcommit_ratio
)paren
suffix:semicolon
DECL|variable|vm_committed_space
id|EXPORT_SYMBOL
c_func
(paren
id|vm_committed_space
)paren
suffix:semicolon
DECL|variable|__vm_enough_memory
id|EXPORT_SYMBOL
c_func
(paren
id|__vm_enough_memory
)paren
suffix:semicolon
multiline_comment|/* list of shareable VMAs */
DECL|variable|nommu_vma_tree
r_struct
id|rb_root
id|nommu_vma_tree
op_assign
id|RB_ROOT
suffix:semicolon
DECL|variable|nommu_vma_sem
id|DECLARE_RWSEM
c_func
(paren
id|nommu_vma_sem
)paren
suffix:semicolon
DECL|variable|generic_file_vm_ops
r_struct
id|vm_operations_struct
id|generic_file_vm_ops
op_assign
(brace
)brace
suffix:semicolon
multiline_comment|/*&n; * Handle all mappings that got truncated by a &quot;truncate()&quot;&n; * system call.&n; *&n; * NOTE! We have to be ready to update the memory sharing&n; * between the file and the memory map for a potential last&n; * incomplete page.  Ugly, but necessary.&n; */
DECL|function|vmtruncate
r_int
id|vmtruncate
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|loff_t
id|offset
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
r_int
r_int
id|limit
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_size
OL
id|offset
)paren
r_goto
id|do_expand
suffix:semicolon
id|i_size_write
c_func
(paren
id|inode
comma
id|offset
)paren
suffix:semicolon
id|truncate_inode_pages
c_func
(paren
id|mapping
comma
id|offset
)paren
suffix:semicolon
r_goto
id|out_truncate
suffix:semicolon
id|do_expand
suffix:colon
id|limit
op_assign
id|current-&gt;signal-&gt;rlim
(braket
id|RLIMIT_FSIZE
)braket
dot
id|rlim_cur
suffix:semicolon
r_if
c_cond
(paren
id|limit
op_ne
id|RLIM_INFINITY
op_logical_and
id|offset
OG
id|limit
)paren
r_goto
id|out_sig
suffix:semicolon
r_if
c_cond
(paren
id|offset
OG
id|inode-&gt;i_sb-&gt;s_maxbytes
)paren
r_goto
id|out
suffix:semicolon
id|i_size_write
c_func
(paren
id|inode
comma
id|offset
)paren
suffix:semicolon
id|out_truncate
suffix:colon
r_if
c_cond
(paren
id|inode-&gt;i_op
op_logical_and
id|inode-&gt;i_op-&gt;truncate
)paren
id|inode-&gt;i_op
op_member_access_from_pointer
id|truncate
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_sig
suffix:colon
id|send_sig
c_func
(paren
id|SIGXFSZ
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
id|out
suffix:colon
r_return
op_minus
id|EFBIG
suffix:semicolon
)brace
DECL|variable|vmtruncate
id|EXPORT_SYMBOL
c_func
(paren
id|vmtruncate
)paren
suffix:semicolon
multiline_comment|/*&n; * Return the total memory allocated for this pointer, not&n; * just what the caller asked for.&n; *&n; * Doesn&squot;t have to be accurate, i.e. may have races.&n; */
DECL|function|kobjsize
r_int
r_int
id|kobjsize
c_func
(paren
r_const
r_void
op_star
id|objp
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|objp
op_logical_or
op_logical_neg
(paren
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
id|objp
)paren
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|PageSlab
c_func
(paren
id|page
)paren
)paren
r_return
id|ksize
c_func
(paren
id|objp
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|page-&gt;index
OL
l_int|0
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|page-&gt;index
op_ge
id|MAX_ORDER
)paren
suffix:semicolon
r_return
(paren
id|PAGE_SIZE
op_lshift
id|page-&gt;index
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The nommu dodgy version :-)&n; */
DECL|function|get_user_pages
r_int
id|get_user_pages
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
id|len
comma
r_int
id|write
comma
r_int
id|force
comma
r_struct
id|page
op_star
op_star
id|pages
comma
r_struct
id|vm_area_struct
op_star
op_star
id|vmas
)paren
(brace
r_int
id|i
suffix:semicolon
r_static
r_struct
id|vm_area_struct
id|dummy_vma
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pages
)paren
(brace
id|pages
(braket
id|i
)braket
op_assign
id|virt_to_page
c_func
(paren
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pages
(braket
id|i
)braket
)paren
id|page_cache_get
c_func
(paren
id|pages
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vmas
)paren
id|vmas
(braket
id|i
)braket
op_assign
op_amp
id|dummy_vma
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
DECL|variable|vmlist_lock
id|DEFINE_RWLOCK
c_func
(paren
id|vmlist_lock
)paren
suffix:semicolon
DECL|variable|vmlist
r_struct
id|vm_struct
op_star
id|vmlist
suffix:semicolon
DECL|function|vfree
r_void
id|vfree
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
id|kfree
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
DECL|function|__vmalloc
r_void
op_star
id|__vmalloc
c_func
(paren
r_int
r_int
id|size
comma
r_int
id|gfp_mask
comma
id|pgprot_t
id|prot
)paren
(brace
multiline_comment|/*&n;&t; * kmalloc doesn&squot;t like __GFP_HIGHMEM for some reason&n;&t; */
r_return
id|kmalloc
c_func
(paren
id|size
comma
id|gfp_mask
op_amp
op_complement
id|__GFP_HIGHMEM
)paren
suffix:semicolon
)brace
DECL|function|vmalloc_to_page
r_struct
id|page
op_star
id|vmalloc_to_page
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
r_return
id|virt_to_page
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
DECL|function|vmalloc_to_pfn
r_int
r_int
id|vmalloc_to_pfn
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
r_return
id|page_to_pfn
c_func
(paren
id|virt_to_page
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
)brace
DECL|function|vread
r_int
id|vread
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
id|addr
comma
r_int
r_int
id|count
)paren
(brace
id|memcpy
c_func
(paren
id|buf
comma
id|addr
comma
id|count
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|vwrite
r_int
id|vwrite
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
id|addr
comma
r_int
r_int
id|count
)paren
(brace
multiline_comment|/* Don&squot;t allow overflow */
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|addr
op_plus
id|count
OL
id|count
)paren
id|count
op_assign
op_minus
(paren
r_int
r_int
)paren
id|addr
suffix:semicolon
id|memcpy
c_func
(paren
id|addr
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;vmalloc  -  allocate virtually continguos memory&n; *&n; *&t;@size:&t;&t;allocation size&n; *&n; *&t;Allocate enough pages to cover @size from the page level&n; *&t;allocator and map them into continguos kernel virtual space.&n; *&n; *&t;For tight cotrol over page level allocator and protection flags&n; *&t;use __vmalloc() instead.&n; */
DECL|function|vmalloc
r_void
op_star
id|vmalloc
c_func
(paren
r_int
r_int
id|size
)paren
(brace
r_return
id|__vmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
op_or
id|__GFP_HIGHMEM
comma
id|PAGE_KERNEL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;vmalloc_32  -  allocate virtually continguos memory (32bit addressable)&n; *&n; *&t;@size:&t;&t;allocation size&n; *&n; *&t;Allocate enough 32bit PA addressable pages to cover @size from the&n; *&t;page level allocator and map them into continguos kernel virtual space.&n; */
DECL|function|vmalloc_32
r_void
op_star
id|vmalloc_32
c_func
(paren
r_int
r_int
id|size
)paren
(brace
r_return
id|__vmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
comma
id|PAGE_KERNEL
)paren
suffix:semicolon
)brace
DECL|function|vmap
r_void
op_star
id|vmap
c_func
(paren
r_struct
id|page
op_star
op_star
id|pages
comma
r_int
r_int
id|count
comma
r_int
r_int
id|flags
comma
id|pgprot_t
id|prot
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|vunmap
r_void
id|vunmap
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  sys_brk() for the most part doesn&squot;t need the global kernel&n; *  lock, except when an application is doing something nasty&n; *  like trying to un-brk an area that has already been mapped&n; *  to a regular file.  in this case, the unmapping will need&n; *  to invoke file system routines that need the global lock.&n; */
DECL|function|sys_brk
id|asmlinkage
r_int
r_int
id|sys_brk
c_func
(paren
r_int
r_int
id|brk
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
r_if
c_cond
(paren
id|brk
template_param
id|mm-&gt;context.end_brk
)paren
r_return
id|mm-&gt;brk
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;brk
op_eq
id|brk
)paren
r_return
id|mm-&gt;brk
suffix:semicolon
multiline_comment|/*&n;&t; * Always allow shrinking brk&n;&t; */
r_if
c_cond
(paren
id|brk
op_le
id|mm-&gt;brk
)paren
(brace
id|mm-&gt;brk
op_assign
id|brk
suffix:semicolon
r_return
id|brk
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Ok, looks good - let it rip.&n;&t; */
r_return
id|mm-&gt;brk
op_assign
id|brk
suffix:semicolon
)brace
multiline_comment|/*&n; * Combine the mmap &quot;prot&quot; and &quot;flags&quot; argument into one &quot;vm_flags&quot; used&n; * internally. Essentially, translate the &quot;PROT_xxx&quot; and &quot;MAP_xxx&quot; bits&n; * into &quot;VM_xxx&quot;.&n; */
DECL|function|calc_vm_flags
r_static
r_inline
r_int
r_int
id|calc_vm_flags
c_func
(paren
r_int
r_int
id|prot
comma
r_int
r_int
id|flags
)paren
(brace
DECL|macro|_trans
mdefine_line|#define _trans(x,bit1,bit2) &bslash;&n;((bit1==bit2)?(x&amp;bit1):(x&amp;bit1)?bit2:0)
r_int
r_int
id|prot_bits
comma
id|flag_bits
suffix:semicolon
id|prot_bits
op_assign
id|_trans
c_func
(paren
id|prot
comma
id|PROT_READ
comma
id|VM_READ
)paren
op_or
id|_trans
c_func
(paren
id|prot
comma
id|PROT_WRITE
comma
id|VM_WRITE
)paren
op_or
id|_trans
c_func
(paren
id|prot
comma
id|PROT_EXEC
comma
id|VM_EXEC
)paren
suffix:semicolon
id|flag_bits
op_assign
id|_trans
c_func
(paren
id|flags
comma
id|MAP_GROWSDOWN
comma
id|VM_GROWSDOWN
)paren
op_or
id|_trans
c_func
(paren
id|flags
comma
id|MAP_DENYWRITE
comma
id|VM_DENYWRITE
)paren
op_or
id|_trans
c_func
(paren
id|flags
comma
id|MAP_EXECUTABLE
comma
id|VM_EXECUTABLE
)paren
suffix:semicolon
r_return
id|prot_bits
op_or
id|flag_bits
suffix:semicolon
DECL|macro|_trans
macro_line|#undef _trans
)brace
macro_line|#ifdef DEBUG
DECL|function|show_process_blocks
r_static
r_void
id|show_process_blocks
c_func
(paren
r_void
)paren
(brace
r_struct
id|vm_list_struct
op_star
id|vml
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Process blocks %d:&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_for
c_loop
(paren
id|vml
op_assign
op_amp
id|current-&gt;mm-&gt;context.vmlist
suffix:semicolon
id|vml
suffix:semicolon
id|vml
op_assign
id|vml-&gt;next
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %p: %p&quot;
comma
id|vml
comma
id|vml-&gt;vma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vml-&gt;vma
)paren
id|printk
c_func
(paren
l_string|&quot; (%d @%lx #%d)&quot;
comma
id|kobjsize
c_func
(paren
(paren
r_void
op_star
)paren
id|vml-&gt;vma-&gt;vm_start
)paren
comma
id|vml-&gt;vma-&gt;vm_start
comma
id|atomic_read
c_func
(paren
op_amp
id|vml-&gt;vma-&gt;vm_usage
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|vml-&gt;next
ques
c_cond
l_string|&quot; -&gt;&quot;
suffix:colon
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* DEBUG */
DECL|function|find_nommu_vma
r_static
r_inline
r_struct
id|vm_area_struct
op_star
id|find_nommu_vma
c_func
(paren
r_int
r_int
id|start
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_struct
id|rb_node
op_star
id|n
op_assign
id|nommu_vma_tree.rb_node
suffix:semicolon
r_while
c_loop
(paren
id|n
)paren
(brace
id|vma
op_assign
id|rb_entry
c_func
(paren
id|n
comma
r_struct
id|vm_area_struct
comma
id|vm_rb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
OL
id|vma-&gt;vm_start
)paren
id|n
op_assign
id|n-&gt;rb_left
suffix:semicolon
r_else
r_if
c_cond
(paren
id|start
OG
id|vma-&gt;vm_start
)paren
id|n
op_assign
id|n-&gt;rb_right
suffix:semicolon
r_else
r_return
id|vma
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|add_nommu_vma
r_static
r_void
id|add_nommu_vma
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|pvma
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
r_struct
id|rb_node
op_star
op_star
id|p
op_assign
op_amp
id|nommu_vma_tree.rb_node
suffix:semicolon
r_struct
id|rb_node
op_star
id|parent
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* add the VMA to the mapping */
r_if
c_cond
(paren
id|vma-&gt;vm_file
)paren
(brace
id|mapping
op_assign
id|vma-&gt;vm_file-&gt;f_mapping
suffix:semicolon
id|flush_dcache_mmap_lock
c_func
(paren
id|mapping
)paren
suffix:semicolon
id|vma_prio_tree_insert
c_func
(paren
id|vma
comma
op_amp
id|mapping-&gt;i_mmap
)paren
suffix:semicolon
id|flush_dcache_mmap_unlock
c_func
(paren
id|mapping
)paren
suffix:semicolon
)brace
multiline_comment|/* add the VMA to the master list */
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
id|parent
op_assign
op_star
id|p
suffix:semicolon
id|pvma
op_assign
id|rb_entry
c_func
(paren
id|parent
comma
r_struct
id|vm_area_struct
comma
id|vm_rb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_start
OL
id|pvma-&gt;vm_start
)paren
(brace
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|rb_left
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vma-&gt;vm_start
OG
id|pvma-&gt;vm_start
)paren
(brace
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|rb_right
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* mappings are at the same address - this can only&n;&t;&t;&t; * happen for shared-mem chardevs and shared file&n;&t;&t;&t; * mappings backed by ramfs/tmpfs */
id|BUG_ON
c_func
(paren
op_logical_neg
(paren
id|pvma-&gt;vm_flags
op_amp
id|VM_SHARED
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma
OL
id|pvma
)paren
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|rb_left
suffix:semicolon
r_else
r_if
c_cond
(paren
id|vma
OG
id|pvma
)paren
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|rb_right
suffix:semicolon
r_else
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|rb_link_node
c_func
(paren
op_amp
id|vma-&gt;vm_rb
comma
id|parent
comma
id|p
)paren
suffix:semicolon
id|rb_insert_color
c_func
(paren
op_amp
id|vma-&gt;vm_rb
comma
op_amp
id|nommu_vma_tree
)paren
suffix:semicolon
)brace
DECL|function|delete_nommu_vma
r_static
r_void
id|delete_nommu_vma
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
multiline_comment|/* remove the VMA from the mapping */
r_if
c_cond
(paren
id|vma-&gt;vm_file
)paren
(brace
id|mapping
op_assign
id|vma-&gt;vm_file-&gt;f_mapping
suffix:semicolon
id|flush_dcache_mmap_lock
c_func
(paren
id|mapping
)paren
suffix:semicolon
id|vma_prio_tree_remove
c_func
(paren
id|vma
comma
op_amp
id|mapping-&gt;i_mmap
)paren
suffix:semicolon
id|flush_dcache_mmap_unlock
c_func
(paren
id|mapping
)paren
suffix:semicolon
)brace
multiline_comment|/* remove from the master list */
id|rb_erase
c_func
(paren
op_amp
id|vma-&gt;vm_rb
comma
op_amp
id|nommu_vma_tree
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * handle mapping creation for uClinux&n; */
DECL|function|do_mmap_pgoff
r_int
r_int
id|do_mmap_pgoff
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|prot
comma
r_int
r_int
id|flags
comma
r_int
r_int
id|pgoff
)paren
(brace
r_struct
id|vm_list_struct
op_star
id|vml
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|rb_node
op_star
id|rb
suffix:semicolon
r_int
r_int
id|vm_flags
suffix:semicolon
r_void
op_star
id|result
suffix:semicolon
r_int
id|ret
comma
id|membacked
suffix:semicolon
multiline_comment|/* do the simple checks first */
r_if
c_cond
(paren
id|flags
op_amp
id|MAP_FIXED
op_logical_or
id|addr
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%d: Can&squot;t do fixed-address/overlay mmap of RAM&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PAGE_ALIGN
c_func
(paren
id|len
)paren
op_eq
l_int|0
)paren
r_return
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|TASK_SIZE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* offset overflow? */
r_if
c_cond
(paren
(paren
id|pgoff
op_plus
(paren
id|len
op_rshift
id|PAGE_SHIFT
)paren
)paren
OL
id|pgoff
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* validate file mapping requests */
id|membacked
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
multiline_comment|/* files must support mmap */
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;f_op
op_logical_or
op_logical_neg
id|file-&gt;f_op-&gt;mmap
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
(paren
id|prot
op_amp
id|PROT_EXEC
)paren
op_logical_and
(paren
id|file-&gt;f_vfsmnt-&gt;mnt_flags
op_amp
id|MNT_NOEXEC
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* work out if what we&squot;ve got could possibly be shared&n;&t;&t; * - we support chardevs that provide their own &quot;memory&quot;&n;&t;&t; * - we support files/blockdevs that are memory backed&n;&t;&t; */
r_if
c_cond
(paren
id|S_ISCHR
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_mode
)paren
)paren
(brace
id|membacked
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|file-&gt;f_mapping
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mapping
)paren
id|mapping
op_assign
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_mapping
suffix:semicolon
r_if
c_cond
(paren
id|mapping
op_logical_and
id|mapping-&gt;backing_dev_info
)paren
id|membacked
op_assign
id|mapping-&gt;backing_dev_info-&gt;memory_backed
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|MAP_SHARED
)paren
(brace
multiline_comment|/* do checks for writing, appending and locking */
r_if
c_cond
(paren
(paren
id|prot
op_amp
id|PROT_WRITE
)paren
op_logical_and
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
op_logical_and
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|locks_verify_locked
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|membacked
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;MAP_SHARED not completely supported on !MMU&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* we require greater support from the driver or&n;&t;&t;&t; * filesystem - we ask it to tell us what memory to&n;&t;&t;&t; * use */
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;f_op-&gt;get_unmapped_area
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we read private files into memory we allocate */
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;f_op-&gt;read
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
multiline_comment|/* handle PROT_EXEC implication by PROT_READ */
r_if
c_cond
(paren
(paren
id|prot
op_amp
id|PROT_READ
)paren
op_logical_and
(paren
id|current-&gt;personality
op_amp
id|READ_IMPLIES_EXEC
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|file
op_logical_and
(paren
id|file-&gt;f_vfsmnt-&gt;mnt_flags
op_amp
id|MNT_NOEXEC
)paren
)paren
)paren
id|prot
op_or_assign
id|PROT_EXEC
suffix:semicolon
multiline_comment|/* do simple checking here so the lower-level routines won&squot;t have&n;&t; * to. we assume access permissions have been handled by the open&n;&t; * of the memory object, so we don&squot;t do any here.&n;&t; */
id|vm_flags
op_assign
id|calc_vm_flags
c_func
(paren
id|prot
comma
id|flags
)paren
multiline_comment|/* | mm-&gt;def_flags */
op_or
id|VM_MAYREAD
op_or
id|VM_MAYWRITE
op_or
id|VM_MAYEXEC
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|membacked
)paren
(brace
multiline_comment|/* share any file segment that&squot;s mapped read-only */
r_if
c_cond
(paren
(paren
(paren
id|flags
op_amp
id|MAP_PRIVATE
)paren
op_logical_and
op_logical_neg
(paren
id|prot
op_amp
id|PROT_WRITE
)paren
op_logical_and
id|file
)paren
op_logical_or
(paren
(paren
id|flags
op_amp
id|MAP_SHARED
)paren
op_logical_and
op_logical_neg
(paren
id|prot
op_amp
id|PROT_WRITE
)paren
op_logical_and
id|file
)paren
)paren
id|vm_flags
op_or_assign
id|VM_MAYSHARE
suffix:semicolon
multiline_comment|/* refuse to let anyone share files with this process if it&squot;s being traced -&n;&t;&t; * otherwise breakpoints set in it may interfere with another untraced process&n;&t;&t; */
r_if
c_cond
(paren
id|current-&gt;ptrace
op_amp
id|PT_PTRACED
)paren
id|vm_flags
op_and_assign
op_complement
(paren
id|VM_SHARED
op_or
id|VM_MAYSHARE
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* permit sharing of character devices and ramfs files at any time for&n;&t;&t; * anything other than a privately writable mapping&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MAP_PRIVATE
)paren
op_logical_or
op_logical_neg
(paren
id|prot
op_amp
id|PROT_WRITE
)paren
)paren
(brace
id|vm_flags
op_or_assign
id|VM_MAYSHARE
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MAP_SHARED
)paren
id|vm_flags
op_or_assign
id|VM_SHARED
suffix:semicolon
)brace
)brace
multiline_comment|/* allow the security API to have its say */
id|ret
op_assign
id|security_file_mmap
c_func
(paren
id|file
comma
id|prot
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* we&squot;re going to need to record the mapping if it works */
id|vml
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|vm_list_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vml
)paren
r_goto
id|error_getting_vml
suffix:semicolon
id|memset
c_func
(paren
id|vml
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|vml
)paren
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|nommu_vma_sem
)paren
suffix:semicolon
multiline_comment|/* if we want to share, we need to search for VMAs created by another&n;&t; * mmap() call that overlap with our proposed mapping&n;&t; * - we can only share with an exact match on most regular files&n;&t; * - shared mappings on character devices and memory backed files are&n;&t; *   permitted to overlap inexactly as far as we are concerned for in&n;&t; *   these cases, sharing is handled in the driver or filesystem rather&n;&t; *   than here&n;&t; */
r_if
c_cond
(paren
id|vm_flags
op_amp
id|VM_MAYSHARE
)paren
(brace
r_int
r_int
id|pglen
op_assign
(paren
id|len
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_int
r_int
id|vmpglen
suffix:semicolon
r_for
c_loop
(paren
id|rb
op_assign
id|rb_first
c_func
(paren
op_amp
id|nommu_vma_tree
)paren
suffix:semicolon
id|rb
suffix:semicolon
id|rb
op_assign
id|rb_next
c_func
(paren
id|rb
)paren
)paren
(brace
id|vma
op_assign
id|rb_entry
c_func
(paren
id|rb
comma
r_struct
id|vm_area_struct
comma
id|vm_rb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_MAYSHARE
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* search for overlapping mappings on the same file */
r_if
c_cond
(paren
id|vma-&gt;vm_file-&gt;f_dentry-&gt;d_inode
op_ne
id|file-&gt;f_dentry-&gt;d_inode
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_pgoff
op_ge
id|pgoff
op_plus
id|pglen
)paren
r_continue
suffix:semicolon
id|vmpglen
op_assign
(paren
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|pgoff
op_ge
id|vma-&gt;vm_pgoff
op_plus
id|vmpglen
)paren
r_continue
suffix:semicolon
multiline_comment|/* handle inexact matches between mappings */
r_if
c_cond
(paren
id|vmpglen
op_ne
id|pglen
op_logical_or
id|vma-&gt;vm_pgoff
op_ne
id|pgoff
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|membacked
)paren
r_goto
id|sharing_violation
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* we&squot;ve found a VMA we can share */
id|atomic_inc
c_func
(paren
op_amp
id|vma-&gt;vm_usage
)paren
suffix:semicolon
id|vml-&gt;vma
op_assign
id|vma
suffix:semicolon
id|result
op_assign
(paren
r_void
op_star
)paren
id|vma-&gt;vm_start
suffix:semicolon
r_goto
id|shared
suffix:semicolon
)brace
)brace
id|vma
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* obtain the address to map to. we verify (or select) it and ensure&n;&t; * that it represents a valid section of the address space&n;&t; * - this is the hook for quasi-memory character devices&n;&t; */
r_if
c_cond
(paren
id|file
op_logical_and
id|file-&gt;f_op-&gt;get_unmapped_area
)paren
(brace
id|addr
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|get_unmapped_area
c_func
(paren
id|file
comma
id|addr
comma
id|len
comma
id|pgoff
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
(paren
r_void
op_star
)paren
id|addr
)paren
)paren
(brace
id|ret
op_assign
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
(paren
r_int
r_int
)paren
op_minus
id|ENOSYS
)paren
id|ret
op_assign
(paren
r_int
r_int
)paren
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
)brace
multiline_comment|/* we&squot;re going to need a VMA struct as well */
id|vma
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|vm_area_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_goto
id|error_getting_vma
suffix:semicolon
id|memset
c_func
(paren
id|vma
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|vma
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|vma-&gt;anon_vma_node
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|vma-&gt;vm_usage
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
id|get_file
c_func
(paren
id|file
)paren
suffix:semicolon
id|vma-&gt;vm_file
op_assign
id|file
suffix:semicolon
id|vma-&gt;vm_flags
op_assign
id|vm_flags
suffix:semicolon
id|vma-&gt;vm_start
op_assign
id|addr
suffix:semicolon
id|vma-&gt;vm_end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
id|vma-&gt;vm_pgoff
op_assign
id|pgoff
suffix:semicolon
id|vml-&gt;vma
op_assign
id|vma
suffix:semicolon
multiline_comment|/* determine the object being mapped and call the appropriate specific&n;&t; * mapper.&n;&t; */
r_if
c_cond
(paren
id|file
)paren
(brace
macro_line|#ifdef MAGIC_ROM_PTR
multiline_comment|/* First, try simpler routine designed to give us a ROM pointer. */
r_if
c_cond
(paren
id|file-&gt;f_op-&gt;romptr
op_logical_and
op_logical_neg
(paren
id|prot
op_amp
id|PROT_WRITE
)paren
)paren
(brace
id|ret
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|romptr
c_func
(paren
id|file
comma
id|vma
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;romptr mmap returned %d (st=%lx)&bslash;n&quot;
comma
id|ret
comma
id|vma-&gt;vm_start
)paren
suffix:semicolon
macro_line|#endif
id|result
op_assign
(paren
r_void
op_star
)paren
id|vma-&gt;vm_start
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
r_goto
id|done
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ret
op_ne
op_minus
id|ENOSYS
)paren
r_goto
id|error
suffix:semicolon
)brace
r_else
macro_line|#endif /* MAGIC_ROM_PTR */
multiline_comment|/* Then try full mmap routine, which might return a RAM&n;&t;&t; * pointer, or do something truly complicated&n;&t;&t; */
r_if
c_cond
(paren
id|file-&gt;f_op-&gt;mmap
)paren
(brace
id|ret
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|mmap
c_func
(paren
id|file
comma
id|vma
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;f_op-&gt;mmap() returned %d (st=%lx)&bslash;n&quot;
comma
id|ret
comma
id|vma-&gt;vm_start
)paren
suffix:semicolon
macro_line|#endif
id|result
op_assign
(paren
r_void
op_star
)paren
id|vma-&gt;vm_start
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
r_goto
id|done
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ret
op_ne
op_minus
id|ENOSYS
)paren
r_goto
id|error
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* No mapping operations defined */
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* An ENOSYS error indicates that mmap isn&squot;t possible (as&n;&t;&t; * opposed to tried but failed) so we&squot;ll fall through to the&n;&t;&t; * copy. */
)brace
multiline_comment|/* allocate some memory to hold the mapping&n;&t; * - note that this may not return a page-aligned address if the object&n;&t; *   we&squot;re allocating is smaller than a page&n;&t; */
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|result
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Allocation of length %lu from process %d failed&bslash;n&quot;
comma
id|len
comma
id|current-&gt;pid
)paren
suffix:semicolon
id|show_free_areas
c_func
(paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|vma-&gt;vm_start
op_assign
(paren
r_int
r_int
)paren
id|result
suffix:semicolon
id|vma-&gt;vm_end
op_assign
id|vma-&gt;vm_start
op_plus
id|len
suffix:semicolon
macro_line|#ifdef WARN_ON_SLACK
r_if
c_cond
(paren
id|len
op_plus
id|WARN_ON_SLACK
op_le
id|kobjsize
c_func
(paren
id|result
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;Allocation of %lu bytes from process %d has %lu bytes of slack&bslash;n&quot;
comma
id|len
comma
id|current-&gt;pid
comma
id|kobjsize
c_func
(paren
id|result
)paren
op_minus
id|len
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|file
)paren
(brace
id|mm_segment_t
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|loff_t
id|fpos
suffix:semicolon
id|fpos
op_assign
id|pgoff
suffix:semicolon
id|fpos
op_lshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|ret
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|file
comma
(paren
r_char
op_star
)paren
id|result
comma
id|len
comma
op_amp
id|fpos
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|old_fs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|error2
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
id|len
)paren
id|memset
c_func
(paren
id|result
op_plus
id|ret
comma
l_int|0
comma
id|len
op_minus
id|ret
)paren
suffix:semicolon
)brace
r_else
(brace
id|memset
c_func
(paren
id|result
comma
l_int|0
comma
id|len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prot
op_amp
id|PROT_EXEC
)paren
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|result
comma
(paren
r_int
r_int
)paren
id|result
op_plus
id|len
)paren
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_SHARED
)paren
)paren
(brace
id|realalloc
op_add_assign
id|kobjsize
c_func
(paren
id|result
)paren
suffix:semicolon
id|askedalloc
op_add_assign
id|len
suffix:semicolon
)brace
id|realalloc
op_add_assign
id|kobjsize
c_func
(paren
id|vma
)paren
suffix:semicolon
id|askedalloc
op_add_assign
r_sizeof
(paren
op_star
id|vma
)paren
suffix:semicolon
id|current-&gt;mm-&gt;total_vm
op_add_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|add_nommu_vma
c_func
(paren
id|vma
)paren
suffix:semicolon
id|shared
suffix:colon
id|realalloc
op_add_assign
id|kobjsize
c_func
(paren
id|vml
)paren
suffix:semicolon
id|askedalloc
op_add_assign
r_sizeof
(paren
op_star
id|vml
)paren
suffix:semicolon
id|vml-&gt;next
op_assign
id|current-&gt;mm-&gt;context.vmlist
suffix:semicolon
id|current-&gt;mm-&gt;context.vmlist
op_assign
id|vml
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|nommu_vma_sem
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;do_mmap:&bslash;n&quot;
)paren
suffix:semicolon
id|show_process_blocks
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
r_int
r_int
)paren
id|result
suffix:semicolon
id|error2
suffix:colon
id|kfree
c_func
(paren
id|result
)paren
suffix:semicolon
id|error
suffix:colon
id|up_write
c_func
(paren
op_amp
id|nommu_vma_sem
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|vml
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma
)paren
(brace
id|fput
c_func
(paren
id|vma-&gt;vm_file
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|vma
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
id|sharing_violation
suffix:colon
id|up_write
c_func
(paren
op_amp
id|nommu_vma_sem
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Attempt to share mismatched mappings&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|vml
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
id|error_getting_vma
suffix:colon
id|up_write
c_func
(paren
op_amp
id|nommu_vma_sem
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|vml
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Allocation of vml for %lu byte allocation from process %d failed&bslash;n&quot;
comma
id|len
comma
id|current-&gt;pid
)paren
suffix:semicolon
id|show_free_areas
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|error_getting_vml
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Allocation of vml for %lu byte allocation from process %d failed&bslash;n&quot;
comma
id|len
comma
id|current-&gt;pid
)paren
suffix:semicolon
id|show_free_areas
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * handle mapping disposal for uClinux&n; */
DECL|function|put_vma
r_static
r_void
id|put_vma
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_if
c_cond
(paren
id|vma
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|nommu_vma_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|vma-&gt;vm_usage
)paren
)paren
(brace
id|delete_nommu_vma
c_func
(paren
id|vma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_ops
op_logical_and
id|vma-&gt;vm_ops-&gt;close
)paren
id|vma-&gt;vm_ops
op_member_access_from_pointer
id|close
c_func
(paren
id|vma
)paren
suffix:semicolon
multiline_comment|/* IO memory and memory shared directly out of the pagecache from&n;&t;&t;&t; * ramfs/tmpfs mustn&squot;t be released here */
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma-&gt;vm_flags
op_amp
(paren
id|VM_IO
op_or
id|VM_SHARED
)paren
)paren
op_logical_and
id|vma-&gt;vm_start
)paren
(brace
id|realalloc
op_sub_assign
id|kobjsize
c_func
(paren
(paren
r_void
op_star
)paren
id|vma-&gt;vm_start
)paren
suffix:semicolon
id|askedalloc
op_sub_assign
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
suffix:semicolon
id|kfree
c_func
(paren
(paren
r_void
op_star
)paren
id|vma-&gt;vm_start
)paren
suffix:semicolon
)brace
id|realalloc
op_sub_assign
id|kobjsize
c_func
(paren
id|vma
)paren
suffix:semicolon
id|askedalloc
op_sub_assign
r_sizeof
(paren
op_star
id|vma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_file
)paren
id|fput
c_func
(paren
id|vma-&gt;vm_file
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|vma
)paren
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|nommu_vma_sem
)paren
suffix:semicolon
)brace
)brace
DECL|function|do_munmap
r_int
id|do_munmap
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
comma
r_int
id|len
)paren
(brace
r_struct
id|vm_list_struct
op_star
id|vml
comma
op_star
op_star
id|parent
suffix:semicolon
r_int
r_int
id|end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
macro_line|#ifdef MAGIC_ROM_PTR
multiline_comment|/* For efficiency&squot;s sake, if the pointer is obviously in ROM,&n;&t;   don&squot;t bother walking the lists to free it */
r_if
c_cond
(paren
id|is_in_rom
c_func
(paren
id|addr
)paren
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;do_munmap:&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|parent
op_assign
op_amp
id|mm-&gt;context.vmlist
suffix:semicolon
op_star
id|parent
suffix:semicolon
id|parent
op_assign
op_amp
(paren
op_star
id|parent
)paren
op_member_access_from_pointer
id|next
)paren
r_if
c_cond
(paren
(paren
op_star
id|parent
)paren
op_member_access_from_pointer
id|vma-&gt;vm_start
op_eq
id|addr
op_logical_and
(paren
op_star
id|parent
)paren
op_member_access_from_pointer
id|vma-&gt;vm_end
op_eq
id|end
)paren
r_goto
id|found
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;munmap of non-mmaped memory by process %d (%s): %p&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|current-&gt;comm
comma
(paren
r_void
op_star
)paren
id|addr
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
id|found
suffix:colon
id|vml
op_assign
op_star
id|parent
suffix:semicolon
id|put_vma
c_func
(paren
id|vml-&gt;vma
)paren
suffix:semicolon
op_star
id|parent
op_assign
id|vml-&gt;next
suffix:semicolon
id|realalloc
op_sub_assign
id|kobjsize
c_func
(paren
id|vml
)paren
suffix:semicolon
id|askedalloc
op_sub_assign
r_sizeof
(paren
op_star
id|vml
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|vml
)paren
suffix:semicolon
id|mm-&gt;total_vm
op_sub_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
macro_line|#ifdef DEBUG
id|show_process_blocks
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Release all mmaps. */
DECL|function|exit_mmap
r_void
id|exit_mmap
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|vm_list_struct
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|mm
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Exit_mmap:&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|mm-&gt;total_vm
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|mm-&gt;context.vmlist
)paren
)paren
(brace
id|mm-&gt;context.vmlist
op_assign
id|tmp-&gt;next
suffix:semicolon
id|put_vma
c_func
(paren
id|tmp-&gt;vma
)paren
suffix:semicolon
id|realalloc
op_sub_assign
id|kobjsize
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|askedalloc
op_sub_assign
r_sizeof
(paren
op_star
id|tmp
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|show_process_blocks
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
DECL|function|sys_munmap
id|asmlinkage
r_int
id|sys_munmap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
id|len
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|ret
op_assign
id|do_munmap
c_func
(paren
id|mm
comma
id|addr
comma
id|len
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|do_brk
r_int
r_int
id|do_brk
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|len
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Expand (or shrink) an existing mapping, potentially moving it at the&n; * same time (controlled by the MREMAP_MAYMOVE flag and available VM space)&n; *&n; * MREMAP_FIXED option added 5-Dec-1999 by Benjamin LaHaise&n; * This option implies MREMAP_MAYMOVE.&n; *&n; * on uClinux, we only permit changing a mapping&squot;s size, and only as long as it stays within the&n; * hole allocated by the kmalloc() call in do_mmap_pgoff() and the block is not shareable&n; */
DECL|function|do_mremap
r_int
r_int
id|do_mremap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|old_len
comma
r_int
r_int
id|new_len
comma
r_int
r_int
id|flags
comma
r_int
r_int
id|new_addr
)paren
(brace
r_struct
id|vm_list_struct
op_star
id|vml
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* insanity checks first */
r_if
c_cond
(paren
id|new_len
op_eq
l_int|0
)paren
r_return
(paren
r_int
r_int
)paren
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MREMAP_FIXED
op_logical_and
id|new_addr
op_ne
id|addr
)paren
r_return
(paren
r_int
r_int
)paren
op_minus
id|EINVAL
suffix:semicolon
r_for
c_loop
(paren
id|vml
op_assign
id|current-&gt;mm-&gt;context.vmlist
suffix:semicolon
id|vml
suffix:semicolon
id|vml
op_assign
id|vml-&gt;next
)paren
r_if
c_cond
(paren
id|vml-&gt;vma-&gt;vm_start
op_eq
id|addr
)paren
r_goto
id|found
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
op_minus
id|EINVAL
suffix:semicolon
id|found
suffix:colon
r_if
c_cond
(paren
id|vml-&gt;vma-&gt;vm_end
op_ne
id|vml-&gt;vma-&gt;vm_start
op_plus
id|old_len
)paren
r_return
(paren
r_int
r_int
)paren
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|vml-&gt;vma-&gt;vm_flags
op_amp
id|VM_MAYSHARE
)paren
r_return
(paren
r_int
r_int
)paren
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|new_len
OG
id|kobjsize
c_func
(paren
(paren
r_void
op_star
)paren
id|addr
)paren
)paren
r_return
(paren
r_int
r_int
)paren
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* all checks complete - do it */
id|vml-&gt;vma-&gt;vm_end
op_assign
id|vml-&gt;vma-&gt;vm_start
op_plus
id|new_len
suffix:semicolon
id|askedalloc
op_sub_assign
id|old_len
suffix:semicolon
id|askedalloc
op_add_assign
id|new_len
suffix:semicolon
r_return
id|vml-&gt;vma-&gt;vm_start
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up the first VMA which satisfies  addr &lt; vm_end,  NULL if none&n; */
DECL|function|find_vma
r_struct
id|vm_area_struct
op_star
id|find_vma
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
)paren
(brace
r_struct
id|vm_list_struct
op_star
id|vml
suffix:semicolon
r_for
c_loop
(paren
id|vml
op_assign
id|mm-&gt;context.vmlist
suffix:semicolon
id|vml
suffix:semicolon
id|vml
op_assign
id|vml-&gt;next
)paren
r_if
c_cond
(paren
id|addr
op_ge
id|vml-&gt;vma-&gt;vm_start
op_logical_and
id|addr
OL
id|vml-&gt;vma-&gt;vm_end
)paren
r_return
id|vml-&gt;vma
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|variable|find_vma
id|EXPORT_SYMBOL
c_func
(paren
id|find_vma
)paren
suffix:semicolon
DECL|function|follow_page
r_struct
id|page
op_star
id|follow_page
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
comma
r_int
id|write
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|find_extend_vma
r_struct
id|vm_area_struct
op_star
id|find_extend_vma
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|remap_pfn_range
r_int
id|remap_pfn_range
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|from
comma
r_int
r_int
id|to
comma
r_int
r_int
id|size
comma
id|pgprot_t
id|prot
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
DECL|function|swap_unplug_io_fn
r_void
id|swap_unplug_io_fn
c_func
(paren
r_struct
id|backing_dev_info
op_star
id|bdi
comma
r_struct
id|page
op_star
id|page
)paren
(brace
)brace
DECL|function|arch_get_unmapped_area
r_int
r_int
id|arch_get_unmapped_area
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|pgoff
comma
r_int
r_int
id|flags
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|function|arch_unmap_area
r_void
id|arch_unmap_area
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|area
)paren
(brace
)brace
DECL|function|update_mem_hiwater
r_void
id|update_mem_hiwater
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|tsk-&gt;mm
)paren
)paren
(brace
r_if
c_cond
(paren
id|tsk-&gt;mm-&gt;hiwater_rss
OL
id|tsk-&gt;mm-&gt;rss
)paren
id|tsk-&gt;mm-&gt;hiwater_rss
op_assign
id|tsk-&gt;mm-&gt;rss
suffix:semicolon
r_if
c_cond
(paren
id|tsk-&gt;mm-&gt;hiwater_vm
OL
id|tsk-&gt;mm-&gt;total_vm
)paren
id|tsk-&gt;mm-&gt;hiwater_vm
op_assign
id|tsk-&gt;mm-&gt;total_vm
suffix:semicolon
)brace
)brace
DECL|function|unmap_mapping_range
r_void
id|unmap_mapping_range
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
id|loff_t
r_const
id|holebegin
comma
id|loff_t
r_const
id|holelen
comma
r_int
id|even_cows
)paren
(brace
)brace
multiline_comment|/*&n; * Check that a process has enough memory to allocate a new virtual&n; * mapping. 0 means there is enough memory for the allocation to&n; * succeed and -ENOMEM implies there is not.&n; *&n; * We currently support three overcommit policies, which are set via the&n; * vm.overcommit_memory sysctl.  See Documentation/vm/overcommit-accounting&n; *&n; * Strict overcommit modes added 2002 Feb 26 by Alan Cox.&n; * Additional code 2002 Jul 20 by Robert Love.&n; *&n; * cap_sys_admin is 1 if the process has admin privileges, 0 otherwise.&n; *&n; * Note this is a helper function intended to be used by LSMs which&n; * wish to use this logic.&n; */
DECL|function|__vm_enough_memory
r_int
id|__vm_enough_memory
c_func
(paren
r_int
id|pages
comma
r_int
id|cap_sys_admin
)paren
(brace
r_int
r_int
id|free
comma
id|allowed
suffix:semicolon
id|vm_acct_memory
c_func
(paren
id|pages
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Sometimes we want to use more memory than we have&n;&t; */
r_if
c_cond
(paren
id|sysctl_overcommit_memory
op_eq
id|OVERCOMMIT_ALWAYS
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sysctl_overcommit_memory
op_eq
id|OVERCOMMIT_GUESS
)paren
(brace
r_int
r_int
id|n
suffix:semicolon
id|free
op_assign
id|get_page_cache_size
c_func
(paren
)paren
suffix:semicolon
id|free
op_add_assign
id|nr_swap_pages
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Any slabs which are created with the&n;&t;&t; * SLAB_RECLAIM_ACCOUNT flag claim to have contents&n;&t;&t; * which are reclaimable, under pressure.  The dentry&n;&t;&t; * cache and most inode caches should fall into this&n;&t;&t; */
id|free
op_add_assign
id|atomic_read
c_func
(paren
op_amp
id|slab_reclaim_pages
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Leave the last 3% for root&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cap_sys_admin
)paren
id|free
op_sub_assign
id|free
op_div
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|free
OG
id|pages
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * nr_free_pages() is very expensive on large systems,&n;&t;&t; * only call if we&squot;re about to fail.&n;&t;&t; */
id|n
op_assign
id|nr_free_pages
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cap_sys_admin
)paren
id|n
op_sub_assign
id|n
op_div
l_int|32
suffix:semicolon
id|free
op_add_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|free
OG
id|pages
)paren
r_return
l_int|0
suffix:semicolon
id|vm_unacct_memory
c_func
(paren
id|pages
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|allowed
op_assign
id|totalram_pages
op_star
id|sysctl_overcommit_ratio
op_div
l_int|100
suffix:semicolon
multiline_comment|/*&n;&t; * Leave the last 3% for root&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cap_sys_admin
)paren
id|allowed
op_sub_assign
id|allowed
op_div
l_int|32
suffix:semicolon
id|allowed
op_add_assign
id|total_swap_pages
suffix:semicolon
multiline_comment|/* Don&squot;t let a single process grow too big:&n;&t;   leave 3% of the size of this process for other processes */
id|allowed
op_sub_assign
id|current-&gt;mm-&gt;total_vm
op_div
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|vm_committed_space
)paren
OL
id|allowed
)paren
r_return
l_int|0
suffix:semicolon
id|vm_unacct_memory
c_func
(paren
id|pages
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
eof
