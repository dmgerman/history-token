multiline_comment|/*&n; * mm/page-writeback.c.&n; *&n; * Copyright (C) 2002, Linus Torvalds.&n; *&n; * Contains functions related to writing back dirty pages at the&n; * address_space level.&n; *&n; * 10Apr2002&t;akpm@zip.com.au&n; *&t;&t;Initial version&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/writeback.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/backing-dev.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/mpage.h&gt;
macro_line|#include &lt;linux/percpu.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/cpu.h&gt;
macro_line|#include &lt;linux/syscalls.h&gt;
multiline_comment|/*&n; * The maximum number of pages to writeout in a single bdflush/kupdate&n; * operation.  We do this so we don&squot;t hold I_LOCK against an inode for&n; * enormous amounts of time, which would block a userspace task which has&n; * been forced to throttle against that inode.  Also, the code reevaluates&n; * the dirty each time it has written this many pages.&n; */
DECL|macro|MAX_WRITEBACK_PAGES
mdefine_line|#define MAX_WRITEBACK_PAGES&t;1024
multiline_comment|/*&n; * After a CPU has dirtied this many pages, balance_dirty_pages_ratelimited&n; * will look to see if it needs to force writeback or throttling.&n; */
DECL|variable|ratelimit_pages
r_static
r_int
id|ratelimit_pages
op_assign
l_int|32
suffix:semicolon
DECL|variable|total_pages
r_static
r_int
id|total_pages
suffix:semicolon
multiline_comment|/* The total number of pages in the machine. */
DECL|variable|dirty_exceeded
r_static
r_int
id|dirty_exceeded
suffix:semicolon
multiline_comment|/* Dirty mem may be over limit */
multiline_comment|/*&n; * When balance_dirty_pages decides that the caller needs to perform some&n; * non-background writeback, this is how many pages it will attempt to write.&n; * It should be somewhat larger than RATELIMIT_PAGES to ensure that reasonably&n; * large amounts of I/O are submitted.&n; */
DECL|function|sync_writeback_pages
r_static
r_inline
r_int
id|sync_writeback_pages
c_func
(paren
r_void
)paren
(brace
r_return
id|ratelimit_pages
op_plus
id|ratelimit_pages
op_div
l_int|2
suffix:semicolon
)brace
multiline_comment|/* The following parameters are exported via /proc/sys/vm */
multiline_comment|/*&n; * Start background writeback (via pdflush) at this percentage&n; */
DECL|variable|dirty_background_ratio
r_int
id|dirty_background_ratio
op_assign
l_int|10
suffix:semicolon
multiline_comment|/*&n; * The generator of dirty data starts writeback at this percentage&n; */
DECL|variable|vm_dirty_ratio
r_int
id|vm_dirty_ratio
op_assign
l_int|40
suffix:semicolon
multiline_comment|/*&n; * The interval between `kupdate&squot;-style writebacks, in centiseconds&n; * (hundredths of a second)&n; */
DECL|variable|dirty_writeback_centisecs
r_int
id|dirty_writeback_centisecs
op_assign
l_int|5
op_star
l_int|100
suffix:semicolon
multiline_comment|/*&n; * The longest number of centiseconds for which data is allowed to remain dirty&n; */
DECL|variable|dirty_expire_centisecs
r_int
id|dirty_expire_centisecs
op_assign
l_int|30
op_star
l_int|100
suffix:semicolon
multiline_comment|/*&n; * Flag that makes the machine dump writes/reads and block dirtyings.&n; */
DECL|variable|block_dump
r_int
id|block_dump
suffix:semicolon
multiline_comment|/*&n; * Flag that puts the machine in &quot;laptop mode&quot;.&n; */
DECL|variable|laptop_mode
r_int
id|laptop_mode
suffix:semicolon
DECL|variable|laptop_mode
id|EXPORT_SYMBOL
c_func
(paren
id|laptop_mode
)paren
suffix:semicolon
multiline_comment|/* End of sysctl-exported parameters */
r_static
r_void
id|background_writeout
c_func
(paren
r_int
r_int
id|_min_pages
)paren
suffix:semicolon
DECL|struct|writeback_state
r_struct
id|writeback_state
(brace
DECL|member|nr_dirty
r_int
r_int
id|nr_dirty
suffix:semicolon
DECL|member|nr_unstable
r_int
r_int
id|nr_unstable
suffix:semicolon
DECL|member|nr_mapped
r_int
r_int
id|nr_mapped
suffix:semicolon
DECL|member|nr_writeback
r_int
r_int
id|nr_writeback
suffix:semicolon
)brace
suffix:semicolon
DECL|function|get_writeback_state
r_static
r_void
id|get_writeback_state
c_func
(paren
r_struct
id|writeback_state
op_star
id|wbs
)paren
(brace
id|wbs-&gt;nr_dirty
op_assign
id|read_page_state
c_func
(paren
id|nr_dirty
)paren
suffix:semicolon
id|wbs-&gt;nr_unstable
op_assign
id|read_page_state
c_func
(paren
id|nr_unstable
)paren
suffix:semicolon
id|wbs-&gt;nr_mapped
op_assign
id|read_page_state
c_func
(paren
id|nr_mapped
)paren
suffix:semicolon
id|wbs-&gt;nr_writeback
op_assign
id|read_page_state
c_func
(paren
id|nr_writeback
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Work out the current dirty-memory clamping and background writeout&n; * thresholds.&n; *&n; * The main aim here is to lower them aggressively if there is a lot of mapped&n; * memory around.  To avoid stressing page reclaim with lots of unreclaimable&n; * pages.  It is better to clamp down on writers than to start swapping, and&n; * performing lots of scanning.&n; *&n; * We only allow 1/2 of the currently-unmapped memory to be dirtied.&n; *&n; * We don&squot;t permit the clamping level to fall below 5% - that is getting rather&n; * excessive.&n; *&n; * We make sure that the background writeout level is below the adjusted&n; * clamping level.&n; */
r_static
r_void
DECL|function|get_dirty_limits
id|get_dirty_limits
c_func
(paren
r_struct
id|writeback_state
op_star
id|wbs
comma
r_int
op_star
id|pbackground
comma
r_int
op_star
id|pdirty
comma
r_struct
id|address_space
op_star
id|mapping
)paren
(brace
r_int
id|background_ratio
suffix:semicolon
multiline_comment|/* Percentages */
r_int
id|dirty_ratio
suffix:semicolon
r_int
id|unmapped_ratio
suffix:semicolon
r_int
id|background
suffix:semicolon
r_int
id|dirty
suffix:semicolon
r_int
r_int
id|available_memory
op_assign
id|total_pages
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
suffix:semicolon
id|get_writeback_state
c_func
(paren
id|wbs
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_HIGHMEM
multiline_comment|/*&n;&t; * If this mapping can only allocate from low memory,&n;&t; * we exclude high memory from our count.&n;&t; */
r_if
c_cond
(paren
id|mapping
op_logical_and
op_logical_neg
(paren
id|mapping_gfp_mask
c_func
(paren
id|mapping
)paren
op_amp
id|__GFP_HIGHMEM
)paren
)paren
id|available_memory
op_sub_assign
id|totalhigh_pages
suffix:semicolon
macro_line|#endif
id|unmapped_ratio
op_assign
l_int|100
op_minus
(paren
id|wbs-&gt;nr_mapped
op_star
l_int|100
)paren
op_div
id|total_pages
suffix:semicolon
id|dirty_ratio
op_assign
id|vm_dirty_ratio
suffix:semicolon
r_if
c_cond
(paren
id|dirty_ratio
OG
id|unmapped_ratio
op_div
l_int|2
)paren
id|dirty_ratio
op_assign
id|unmapped_ratio
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|dirty_ratio
OL
l_int|5
)paren
id|dirty_ratio
op_assign
l_int|5
suffix:semicolon
id|background_ratio
op_assign
id|dirty_background_ratio
suffix:semicolon
r_if
c_cond
(paren
id|background_ratio
op_ge
id|dirty_ratio
)paren
id|background_ratio
op_assign
id|dirty_ratio
op_div
l_int|2
suffix:semicolon
id|background
op_assign
(paren
id|background_ratio
op_star
id|available_memory
)paren
op_div
l_int|100
suffix:semicolon
id|dirty
op_assign
(paren
id|dirty_ratio
op_star
id|available_memory
)paren
op_div
l_int|100
suffix:semicolon
id|tsk
op_assign
id|current
suffix:semicolon
r_if
c_cond
(paren
id|tsk-&gt;flags
op_amp
id|PF_LESS_THROTTLE
op_logical_or
id|rt_task
c_func
(paren
id|tsk
)paren
)paren
(brace
id|background
op_add_assign
id|background
op_div
l_int|4
suffix:semicolon
id|dirty
op_add_assign
id|dirty
op_div
l_int|4
suffix:semicolon
)brace
op_star
id|pbackground
op_assign
id|background
suffix:semicolon
op_star
id|pdirty
op_assign
id|dirty
suffix:semicolon
)brace
multiline_comment|/*&n; * balance_dirty_pages() must be called by processes which are generating dirty&n; * data.  It looks at the number of dirty pages in the machine and will force&n; * the caller to perform writeback if the system is over `vm_dirty_ratio&squot;.&n; * If we&squot;re over `background_thresh&squot; then pdflush is woken to perform some&n; * writeout.&n; */
DECL|function|balance_dirty_pages
r_static
r_void
id|balance_dirty_pages
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
)paren
(brace
r_struct
id|writeback_state
id|wbs
suffix:semicolon
r_int
id|nr_reclaimable
suffix:semicolon
r_int
id|background_thresh
suffix:semicolon
r_int
id|dirty_thresh
suffix:semicolon
r_int
r_int
id|pages_written
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|write_chunk
op_assign
id|sync_writeback_pages
c_func
(paren
)paren
suffix:semicolon
r_struct
id|backing_dev_info
op_star
id|bdi
op_assign
id|mapping-&gt;backing_dev_info
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|writeback_control
id|wbc
op_assign
(brace
dot
id|bdi
op_assign
id|bdi
comma
dot
id|sync_mode
op_assign
id|WB_SYNC_NONE
comma
dot
id|older_than_this
op_assign
l_int|NULL
comma
dot
id|nr_to_write
op_assign
id|write_chunk
comma
)brace
suffix:semicolon
id|get_dirty_limits
c_func
(paren
op_amp
id|wbs
comma
op_amp
id|background_thresh
comma
op_amp
id|dirty_thresh
comma
id|mapping
)paren
suffix:semicolon
id|nr_reclaimable
op_assign
id|wbs.nr_dirty
op_plus
id|wbs.nr_unstable
suffix:semicolon
r_if
c_cond
(paren
id|nr_reclaimable
op_plus
id|wbs.nr_writeback
op_le
id|dirty_thresh
)paren
r_break
suffix:semicolon
id|dirty_exceeded
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Note: nr_reclaimable denotes nr_dirty + nr_unstable.&n;&t;&t; * Unstable writes are a feature of certain networked&n;&t;&t; * filesystems (i.e. NFS) in which data may have been&n;&t;&t; * written to the server&squot;s write cache, but has not yet&n;&t;&t; * been flushed to permanent storage.&n;&t;&t; */
r_if
c_cond
(paren
id|nr_reclaimable
)paren
(brace
id|writeback_inodes
c_func
(paren
op_amp
id|wbc
)paren
suffix:semicolon
id|get_dirty_limits
c_func
(paren
op_amp
id|wbs
comma
op_amp
id|background_thresh
comma
op_amp
id|dirty_thresh
comma
id|mapping
)paren
suffix:semicolon
id|nr_reclaimable
op_assign
id|wbs.nr_dirty
op_plus
id|wbs.nr_unstable
suffix:semicolon
r_if
c_cond
(paren
id|nr_reclaimable
op_plus
id|wbs.nr_writeback
op_le
id|dirty_thresh
)paren
r_break
suffix:semicolon
id|pages_written
op_add_assign
id|write_chunk
op_minus
id|wbc.nr_to_write
suffix:semicolon
r_if
c_cond
(paren
id|pages_written
op_ge
id|write_chunk
)paren
r_break
suffix:semicolon
multiline_comment|/* We&squot;ve done our duty */
)brace
id|blk_congestion_wait
c_func
(paren
id|WRITE
comma
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nr_reclaimable
op_plus
id|wbs.nr_writeback
op_le
id|dirty_thresh
)paren
id|dirty_exceeded
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|writeback_in_progress
c_func
(paren
id|bdi
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* pdflush is already working this queue */
multiline_comment|/*&n;&t; * In laptop mode, we wait until hitting the higher threshold before&n;&t; * starting background writeout, and then write out all the way down&n;&t; * to the lower threshold.  So slow writers cause minimal disk activity.&n;&t; *&n;&t; * In normal mode, we start background writeout at the lower&n;&t; * background_thresh, to keep the amount of dirty memory low.&n;&t; */
r_if
c_cond
(paren
(paren
id|laptop_mode
op_logical_and
id|pages_written
)paren
op_logical_or
(paren
op_logical_neg
id|laptop_mode
op_logical_and
(paren
id|nr_reclaimable
OG
id|background_thresh
)paren
)paren
)paren
id|pdflush_operation
c_func
(paren
id|background_writeout
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * balance_dirty_pages_ratelimited - balance dirty memory state&n; * @mapping - address_space which was dirtied&n; *&n; * Processes which are dirtying memory should call in here once for each page&n; * which was newly dirtied.  The function will periodically check the system&squot;s&n; * dirty state and will initiate writeback if needed.&n; *&n; * On really big machines, get_writeback_state is expensive, so try to avoid&n; * calling it too often (ratelimiting).  But once we&squot;re over the dirty memory&n; * limit we decrease the ratelimiting by a lot, to prevent individual processes&n; * from overshooting the limit by (ratelimit_pages) each.&n; */
DECL|function|balance_dirty_pages_ratelimited
r_void
id|balance_dirty_pages_ratelimited
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
)paren
(brace
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_int
comma
id|ratelimits
)paren
op_assign
l_int|0
suffix:semicolon
r_int
id|ratelimit
suffix:semicolon
id|ratelimit
op_assign
id|ratelimit_pages
suffix:semicolon
r_if
c_cond
(paren
id|dirty_exceeded
)paren
id|ratelimit
op_assign
l_int|8
suffix:semicolon
multiline_comment|/*&n;&t; * Check the rate limiting. Also, we do not want to throttle real-time&n;&t; * tasks in balance_dirty_pages(). Period.&n;&t; */
r_if
c_cond
(paren
id|get_cpu_var
c_func
(paren
id|ratelimits
)paren
op_increment
op_ge
id|ratelimit
)paren
(brace
id|__get_cpu_var
c_func
(paren
id|ratelimits
)paren
op_assign
l_int|0
suffix:semicolon
id|put_cpu_var
c_func
(paren
id|ratelimits
)paren
suffix:semicolon
id|balance_dirty_pages
c_func
(paren
id|mapping
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|put_cpu_var
c_func
(paren
id|ratelimits
)paren
suffix:semicolon
)brace
DECL|variable|balance_dirty_pages_ratelimited
id|EXPORT_SYMBOL
c_func
(paren
id|balance_dirty_pages_ratelimited
)paren
suffix:semicolon
multiline_comment|/*&n; * writeback at least _min_pages, and keep writing until the amount of dirty&n; * memory is less than the background threshold, or until we&squot;re all clean.&n; */
DECL|function|background_writeout
r_static
r_void
id|background_writeout
c_func
(paren
r_int
r_int
id|_min_pages
)paren
(brace
r_int
id|min_pages
op_assign
id|_min_pages
suffix:semicolon
r_struct
id|writeback_control
id|wbc
op_assign
(brace
dot
id|bdi
op_assign
l_int|NULL
comma
dot
id|sync_mode
op_assign
id|WB_SYNC_NONE
comma
dot
id|older_than_this
op_assign
l_int|NULL
comma
dot
id|nr_to_write
op_assign
l_int|0
comma
dot
id|nonblocking
op_assign
l_int|1
comma
)brace
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|writeback_state
id|wbs
suffix:semicolon
r_int
id|background_thresh
suffix:semicolon
r_int
id|dirty_thresh
suffix:semicolon
id|get_dirty_limits
c_func
(paren
op_amp
id|wbs
comma
op_amp
id|background_thresh
comma
op_amp
id|dirty_thresh
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wbs.nr_dirty
op_plus
id|wbs.nr_unstable
OL
id|background_thresh
op_logical_and
id|min_pages
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|wbc.encountered_congestion
op_assign
l_int|0
suffix:semicolon
id|wbc.nr_to_write
op_assign
id|MAX_WRITEBACK_PAGES
suffix:semicolon
id|wbc.pages_skipped
op_assign
l_int|0
suffix:semicolon
id|writeback_inodes
c_func
(paren
op_amp
id|wbc
)paren
suffix:semicolon
id|min_pages
op_sub_assign
id|MAX_WRITEBACK_PAGES
op_minus
id|wbc.nr_to_write
suffix:semicolon
r_if
c_cond
(paren
id|wbc.nr_to_write
OG
l_int|0
op_logical_or
id|wbc.pages_skipped
OG
l_int|0
)paren
(brace
multiline_comment|/* Wrote less than expected */
id|blk_congestion_wait
c_func
(paren
id|WRITE
comma
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wbc.encountered_congestion
)paren
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Start writeback of `nr_pages&squot; pages.  If `nr_pages&squot; is zero, write back&n; * the whole world.  Returns 0 if a pdflush thread was dispatched.  Returns&n; * -1 if all pdflush threads were busy.&n; */
DECL|function|wakeup_bdflush
r_int
id|wakeup_bdflush
c_func
(paren
r_int
id|nr_pages
)paren
(brace
r_if
c_cond
(paren
id|nr_pages
op_eq
l_int|0
)paren
(brace
r_struct
id|writeback_state
id|wbs
suffix:semicolon
id|get_writeback_state
c_func
(paren
op_amp
id|wbs
)paren
suffix:semicolon
id|nr_pages
op_assign
id|wbs.nr_dirty
op_plus
id|wbs.nr_unstable
suffix:semicolon
)brace
r_return
id|pdflush_operation
c_func
(paren
id|background_writeout
comma
id|nr_pages
)paren
suffix:semicolon
)brace
r_static
r_void
id|wb_timer_fn
c_func
(paren
r_int
r_int
id|unused
)paren
suffix:semicolon
r_static
r_void
id|laptop_timer_fn
c_func
(paren
r_int
r_int
id|unused
)paren
suffix:semicolon
DECL|variable|wb_timer
r_static
r_struct
id|timer_list
id|wb_timer
op_assign
id|TIMER_INITIALIZER
c_func
(paren
id|wb_timer_fn
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
DECL|variable|laptop_mode_wb_timer
r_static
r_struct
id|timer_list
id|laptop_mode_wb_timer
op_assign
id|TIMER_INITIALIZER
c_func
(paren
id|laptop_timer_fn
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n; * Periodic writeback of &quot;old&quot; data.&n; *&n; * Define &quot;old&quot;: the first time one of an inode&squot;s pages is dirtied, we mark the&n; * dirtying-time in the inode&squot;s address_space.  So this periodic writeback code&n; * just walks the superblock inode list, writing back any inodes which are&n; * older than a specific point in time.&n; *&n; * Try to run once per dirty_writeback_centisecs.  But if a writeback event&n; * takes longer than a dirty_writeback_centisecs interval, then leave a&n; * one-second gap.&n; *&n; * older_than_this takes precedence over nr_to_write.  So we&squot;ll only write back&n; * all dirty pages if they are all attached to &quot;old&quot; mappings.&n; */
DECL|function|wb_kupdate
r_static
r_void
id|wb_kupdate
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_int
r_int
id|oldest_jif
suffix:semicolon
r_int
r_int
id|start_jif
suffix:semicolon
r_int
r_int
id|next_jif
suffix:semicolon
r_int
id|nr_to_write
suffix:semicolon
r_struct
id|writeback_state
id|wbs
suffix:semicolon
r_struct
id|writeback_control
id|wbc
op_assign
(brace
dot
id|bdi
op_assign
l_int|NULL
comma
dot
id|sync_mode
op_assign
id|WB_SYNC_NONE
comma
dot
id|older_than_this
op_assign
op_amp
id|oldest_jif
comma
dot
id|nr_to_write
op_assign
l_int|0
comma
dot
id|nonblocking
op_assign
l_int|1
comma
dot
id|for_kupdate
op_assign
l_int|1
comma
)brace
suffix:semicolon
id|sync_supers
c_func
(paren
)paren
suffix:semicolon
id|get_writeback_state
c_func
(paren
op_amp
id|wbs
)paren
suffix:semicolon
id|oldest_jif
op_assign
id|jiffies
op_minus
(paren
id|dirty_expire_centisecs
op_star
id|HZ
)paren
op_div
l_int|100
suffix:semicolon
id|start_jif
op_assign
id|jiffies
suffix:semicolon
id|next_jif
op_assign
id|start_jif
op_plus
(paren
id|dirty_writeback_centisecs
op_star
id|HZ
)paren
op_div
l_int|100
suffix:semicolon
id|nr_to_write
op_assign
id|wbs.nr_dirty
op_plus
id|wbs.nr_unstable
op_plus
(paren
id|inodes_stat.nr_inodes
op_minus
id|inodes_stat.nr_unused
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nr_to_write
OG
l_int|0
)paren
(brace
id|wbc.encountered_congestion
op_assign
l_int|0
suffix:semicolon
id|wbc.nr_to_write
op_assign
id|MAX_WRITEBACK_PAGES
suffix:semicolon
id|writeback_inodes
c_func
(paren
op_amp
id|wbc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wbc.nr_to_write
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|wbc.encountered_congestion
)paren
id|blk_congestion_wait
c_func
(paren
id|WRITE
comma
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
r_else
r_break
suffix:semicolon
multiline_comment|/* All the old data is written */
)brace
id|nr_to_write
op_sub_assign
id|MAX_WRITEBACK_PAGES
op_minus
id|wbc.nr_to_write
suffix:semicolon
)brace
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|next_jif
comma
id|jiffies
op_plus
id|HZ
)paren
)paren
id|next_jif
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|dirty_writeback_centisecs
)paren
id|mod_timer
c_func
(paren
op_amp
id|wb_timer
comma
id|next_jif
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sysctl handler for /proc/sys/vm/dirty_writeback_centisecs&n; */
DECL|function|dirty_writeback_centisecs_handler
r_int
id|dirty_writeback_centisecs_handler
c_func
(paren
id|ctl_table
op_star
id|table
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|file
comma
r_void
id|__user
op_star
id|buffer
comma
r_int
op_star
id|length
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|proc_dointvec
c_func
(paren
id|table
comma
id|write
comma
id|file
comma
id|buffer
comma
id|length
comma
id|ppos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dirty_writeback_centisecs
)paren
(brace
id|mod_timer
c_func
(paren
op_amp
id|wb_timer
comma
id|jiffies
op_plus
(paren
id|dirty_writeback_centisecs
op_star
id|HZ
)paren
op_div
l_int|100
)paren
suffix:semicolon
)brace
r_else
(brace
id|del_timer
c_func
(paren
op_amp
id|wb_timer
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|wb_timer_fn
r_static
r_void
id|wb_timer_fn
c_func
(paren
r_int
r_int
id|unused
)paren
(brace
r_if
c_cond
(paren
id|pdflush_operation
c_func
(paren
id|wb_kupdate
comma
l_int|0
)paren
OL
l_int|0
)paren
id|mod_timer
c_func
(paren
op_amp
id|wb_timer
comma
id|jiffies
op_plus
id|HZ
)paren
suffix:semicolon
multiline_comment|/* delay 1 second */
)brace
DECL|function|laptop_flush
r_static
r_void
id|laptop_flush
c_func
(paren
r_int
r_int
id|unused
)paren
(brace
id|sys_sync
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|laptop_timer_fn
r_static
r_void
id|laptop_timer_fn
c_func
(paren
r_int
r_int
id|unused
)paren
(brace
id|pdflush_operation
c_func
(paren
id|laptop_flush
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We&squot;ve spun up the disk and we&squot;re in laptop mode: schedule writeback&n; * of all dirty data a few seconds from now.  If the flush is already scheduled&n; * then push it back - the user is still using the disk.&n; */
DECL|function|laptop_io_completion
r_void
id|laptop_io_completion
c_func
(paren
r_void
)paren
(brace
id|mod_timer
c_func
(paren
op_amp
id|laptop_mode_wb_timer
comma
id|jiffies
op_plus
id|laptop_mode
op_star
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We&squot;re in laptop mode and we&squot;ve just synced. The sync&squot;s writes will have&n; * caused another writeback to be scheduled by laptop_io_completion.&n; * Nothing needs to be written back anymore, so we unschedule the writeback.&n; */
DECL|function|laptop_sync_completion
r_void
id|laptop_sync_completion
c_func
(paren
r_void
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|laptop_mode_wb_timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * If ratelimit_pages is too high then we can get into dirty-data overload&n; * if a large number of processes all perform writes at the same time.&n; * If it is too low then SMP machines will call the (expensive)&n; * get_writeback_state too often.&n; *&n; * Here we set ratelimit_pages to a level which ensures that when all CPUs are&n; * dirtying in parallel, we cannot go more than 3% (1/32) over the dirty memory&n; * thresholds before writeback cuts in.&n; *&n; * But the limit should not be set too high.  Because it also controls the&n; * amount of memory which the balance_dirty_pages() caller has to write back.&n; * If this is too large then the caller will block on the IO queue all the&n; * time.  So limit it to four megabytes - the balance_dirty_pages() caller&n; * will write six megabyte chunks, max.&n; */
DECL|function|set_ratelimit
r_static
r_void
id|set_ratelimit
c_func
(paren
r_void
)paren
(brace
id|ratelimit_pages
op_assign
id|total_pages
op_div
(paren
id|num_online_cpus
c_func
(paren
)paren
op_star
l_int|32
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ratelimit_pages
OL
l_int|16
)paren
id|ratelimit_pages
op_assign
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|ratelimit_pages
op_star
id|PAGE_CACHE_SIZE
OG
l_int|4096
op_star
l_int|1024
)paren
id|ratelimit_pages
op_assign
(paren
l_int|4096
op_star
l_int|1024
)paren
op_div
id|PAGE_CACHE_SIZE
suffix:semicolon
)brace
r_static
r_int
DECL|function|ratelimit_handler
id|ratelimit_handler
c_func
(paren
r_struct
id|notifier_block
op_star
id|self
comma
r_int
r_int
id|u
comma
r_void
op_star
id|v
)paren
(brace
id|set_ratelimit
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ratelimit_nb
r_static
r_struct
id|notifier_block
id|ratelimit_nb
op_assign
(brace
dot
id|notifier_call
op_assign
id|ratelimit_handler
comma
dot
id|next
op_assign
l_int|NULL
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * If the machine has a large highmem:lowmem ratio then scale back the default&n; * dirty memory thresholds: allowing too much dirty highmem pins an excessive&n; * number of buffer_heads.&n; */
DECL|function|page_writeback_init
r_void
id|__init
id|page_writeback_init
c_func
(paren
r_void
)paren
(brace
r_int
id|buffer_pages
op_assign
id|nr_free_buffer_pages
c_func
(paren
)paren
suffix:semicolon
r_int
id|correction
suffix:semicolon
id|total_pages
op_assign
id|nr_free_pagecache_pages
c_func
(paren
)paren
suffix:semicolon
id|correction
op_assign
(paren
l_int|100
op_star
l_int|4
op_star
id|buffer_pages
)paren
op_div
id|total_pages
suffix:semicolon
r_if
c_cond
(paren
id|correction
OL
l_int|100
)paren
(brace
id|dirty_background_ratio
op_mul_assign
id|correction
suffix:semicolon
id|dirty_background_ratio
op_div_assign
l_int|100
suffix:semicolon
id|vm_dirty_ratio
op_mul_assign
id|correction
suffix:semicolon
id|vm_dirty_ratio
op_div_assign
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|dirty_background_ratio
op_le
l_int|0
)paren
id|dirty_background_ratio
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|vm_dirty_ratio
op_le
l_int|0
)paren
id|vm_dirty_ratio
op_assign
l_int|1
suffix:semicolon
)brace
id|mod_timer
c_func
(paren
op_amp
id|wb_timer
comma
id|jiffies
op_plus
(paren
id|dirty_writeback_centisecs
op_star
id|HZ
)paren
op_div
l_int|100
)paren
suffix:semicolon
id|set_ratelimit
c_func
(paren
)paren
suffix:semicolon
id|register_cpu_notifier
c_func
(paren
op_amp
id|ratelimit_nb
)paren
suffix:semicolon
)brace
DECL|function|do_writepages
r_int
id|do_writepages
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_struct
id|writeback_control
op_star
id|wbc
)paren
(brace
r_if
c_cond
(paren
id|wbc-&gt;nr_to_write
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mapping-&gt;a_ops-&gt;writepages
)paren
r_return
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|writepages
c_func
(paren
id|mapping
comma
id|wbc
)paren
suffix:semicolon
r_return
id|generic_writepages
c_func
(paren
id|mapping
comma
id|wbc
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * write_one_page - write out a single page and optionally wait on I/O&n; *&n; * @page - the page to write&n; * @wait - if true, wait on writeout&n; *&n; * The page must be locked by the caller and will be unlocked upon return.&n; *&n; * write_one_page() returns a negative error code if I/O failed.&n; */
DECL|function|write_one_page
r_int
id|write_one_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|wait
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page-&gt;mapping
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|writeback_control
id|wbc
op_assign
(brace
dot
id|sync_mode
op_assign
id|WB_SYNC_ALL
comma
dot
id|nr_to_write
op_assign
l_int|1
comma
)brace
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
id|wait_on_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clear_page_dirty_for_io
c_func
(paren
id|page
)paren
)paren
(brace
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|ret
op_assign
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|writepage
c_func
(paren
id|page
comma
op_amp
id|wbc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
op_logical_and
id|wait
)paren
(brace
id|wait_on_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageError
c_func
(paren
id|page
)paren
)paren
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|write_one_page
id|EXPORT_SYMBOL
c_func
(paren
id|write_one_page
)paren
suffix:semicolon
multiline_comment|/*&n; * For address_spaces which do not use buffers.  Just tag the page as dirty in&n; * its radix tree.&n; *&n; * This is also used when a single buffer is being dirtied: we want to set the&n; * page dirty in that case, but not all the buffers.  This is a &quot;bottom-up&quot;&n; * dirtying, whereas __set_page_dirty_buffers() is a &quot;top-down&quot; dirtying.&n; *&n; * Most callers have locked the page, which pins the address_space in memory.&n; * But zap_pte_range() does not lock the page, however in that case the&n; * mapping is pinned by the vma&squot;s -&gt;vm_file reference.&n; *&n; * We take care to handle the case where the page was truncated from the&n; * mapping by re-checking page_mapping() insode tree_lock.&n; */
DECL|function|__set_page_dirty_nobuffers
r_int
id|__set_page_dirty_nobuffers
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TestSetPageDirty
c_func
(paren
id|page
)paren
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page_mapping
c_func
(paren
id|page
)paren
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping2
suffix:semicolon
r_if
c_cond
(paren
id|mapping
)paren
(brace
id|write_lock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
id|mapping2
op_assign
id|page_mapping
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mapping2
)paren
(brace
multiline_comment|/* Race with truncate? */
id|BUG_ON
c_func
(paren
id|mapping2
op_ne
id|mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mapping-&gt;backing_dev_info-&gt;memory_backed
)paren
id|inc_page_state
c_func
(paren
id|nr_dirty
)paren
suffix:semicolon
id|radix_tree_tag_set
c_func
(paren
op_amp
id|mapping-&gt;page_tree
comma
id|page_index
c_func
(paren
id|page
)paren
comma
id|PAGECACHE_TAG_DIRTY
)paren
suffix:semicolon
)brace
id|write_unlock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mapping-&gt;host
)paren
(brace
multiline_comment|/* !PageAnon &amp;&amp; !swapper_space */
id|__mark_inode_dirty
c_func
(paren
id|mapping-&gt;host
comma
id|I_DIRTY_PAGES
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|__set_page_dirty_nobuffers
id|EXPORT_SYMBOL
c_func
(paren
id|__set_page_dirty_nobuffers
)paren
suffix:semicolon
multiline_comment|/*&n; * When a writepage implementation decides that it doesn&squot;t want to write this&n; * page for some reason, it should redirty the locked page via&n; * redirty_page_for_writepage() and it should then unlock the page and return 0&n; */
DECL|function|redirty_page_for_writepage
r_int
id|redirty_page_for_writepage
c_func
(paren
r_struct
id|writeback_control
op_star
id|wbc
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|wbc-&gt;pages_skipped
op_increment
suffix:semicolon
r_return
id|__set_page_dirty_nobuffers
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|variable|redirty_page_for_writepage
id|EXPORT_SYMBOL
c_func
(paren
id|redirty_page_for_writepage
)paren
suffix:semicolon
multiline_comment|/*&n; * If the mapping doesn&squot;t provide a set_page_dirty a_op, then&n; * just fall through and assume that it wants buffer_heads.&n; */
DECL|function|set_page_dirty
r_int
id|fastcall
id|set_page_dirty
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page_mapping
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|mapping
)paren
)paren
(brace
r_int
(paren
op_star
id|spd
)paren
(paren
r_struct
id|page
op_star
)paren
op_assign
id|mapping-&gt;a_ops-&gt;set_page_dirty
suffix:semicolon
r_if
c_cond
(paren
id|spd
)paren
r_return
(paren
op_star
id|spd
)paren
(paren
id|page
)paren
suffix:semicolon
r_return
id|__set_page_dirty_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|PageDirty
c_func
(paren
id|page
)paren
)paren
id|SetPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|set_page_dirty
id|EXPORT_SYMBOL
c_func
(paren
id|set_page_dirty
)paren
suffix:semicolon
multiline_comment|/*&n; * set_page_dirty() is racy if the caller has no reference against&n; * page-&gt;mapping-&gt;host, and if the page is unlocked.  This is because another&n; * CPU could truncate the page off the mapping and then free the mapping.&n; *&n; * Usually, the page _is_ locked, or the caller is a user-space process which&n; * holds a reference on the inode by having an open file.&n; *&n; * In other cases, the page should be locked before running set_page_dirty().&n; */
DECL|function|set_page_dirty_lock
r_int
id|set_page_dirty_lock
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
id|ret
suffix:semicolon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ret
op_assign
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|set_page_dirty_lock
id|EXPORT_SYMBOL
c_func
(paren
id|set_page_dirty_lock
)paren
suffix:semicolon
multiline_comment|/*&n; * Clear a page&squot;s dirty flag, while caring for dirty memory accounting. &n; * Returns true if the page was previously dirty.&n; */
DECL|function|test_clear_page_dirty
r_int
id|test_clear_page_dirty
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page_mapping
c_func
(paren
id|page
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|mapping
)paren
(brace
id|write_lock_irqsave
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TestClearPageDirty
c_func
(paren
id|page
)paren
)paren
(brace
id|radix_tree_tag_clear
c_func
(paren
op_amp
id|mapping-&gt;page_tree
comma
id|page_index
c_func
(paren
id|page
)paren
comma
id|PAGECACHE_TAG_DIRTY
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mapping-&gt;backing_dev_info-&gt;memory_backed
)paren
id|dec_page_state
c_func
(paren
id|nr_dirty
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|TestClearPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|variable|test_clear_page_dirty
id|EXPORT_SYMBOL
c_func
(paren
id|test_clear_page_dirty
)paren
suffix:semicolon
multiline_comment|/*&n; * Clear a page&squot;s dirty flag, while caring for dirty memory accounting.&n; * Returns true if the page was previously dirty.&n; *&n; * This is for preparing to put the page under writeout.  We leave the page&n; * tagged as dirty in the radix tree so that a concurrent write-for-sync&n; * can discover it via a PAGECACHE_TAG_DIRTY walk.  The -&gt;writepage&n; * implementation will run either set_page_writeback() or set_page_dirty(),&n; * at which stage we bring the page&squot;s dirty flag and radix-tree dirty tag&n; * back into sync.&n; *&n; * This incoherency between the page&squot;s dirty flag and radix-tree tag is&n; * unfortunate, but it only exists while the page is locked.&n; */
DECL|function|clear_page_dirty_for_io
r_int
id|clear_page_dirty_for_io
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page_mapping
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mapping
)paren
(brace
r_if
c_cond
(paren
id|TestClearPageDirty
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mapping-&gt;backing_dev_info-&gt;memory_backed
)paren
id|dec_page_state
c_func
(paren
id|nr_dirty
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|TestClearPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|variable|clear_page_dirty_for_io
id|EXPORT_SYMBOL
c_func
(paren
id|clear_page_dirty_for_io
)paren
suffix:semicolon
multiline_comment|/*&n; * Clear a page&squot;s dirty flag while ignoring dirty memory accounting&n; */
DECL|function|__clear_page_dirty
r_int
id|__clear_page_dirty
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page_mapping
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mapping
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TestClearPageDirty
c_func
(paren
id|page
)paren
)paren
(brace
id|radix_tree_tag_clear
c_func
(paren
op_amp
id|mapping-&gt;page_tree
comma
id|page_index
c_func
(paren
id|page
)paren
comma
id|PAGECACHE_TAG_DIRTY
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|TestClearPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|function|test_clear_page_writeback
r_int
id|test_clear_page_writeback
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page_mapping
c_func
(paren
id|page
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|mapping
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|TestClearPageWriteback
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|radix_tree_tag_clear
c_func
(paren
op_amp
id|mapping-&gt;page_tree
comma
id|page_index
c_func
(paren
id|page
)paren
comma
id|PAGECACHE_TAG_WRITEBACK
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
id|TestClearPageWriteback
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|test_set_page_writeback
r_int
id|test_set_page_writeback
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page_mapping
c_func
(paren
id|page
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|mapping
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|TestSetPageWriteback
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|radix_tree_tag_set
c_func
(paren
op_amp
id|mapping-&gt;page_tree
comma
id|page_index
c_func
(paren
id|page
)paren
comma
id|PAGECACHE_TAG_WRITEBACK
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageDirty
c_func
(paren
id|page
)paren
)paren
id|radix_tree_tag_clear
c_func
(paren
op_amp
id|mapping-&gt;page_tree
comma
id|page_index
c_func
(paren
id|page
)paren
comma
id|PAGECACHE_TAG_DIRTY
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
id|TestSetPageWriteback
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|test_set_page_writeback
id|EXPORT_SYMBOL
c_func
(paren
id|test_set_page_writeback
)paren
suffix:semicolon
multiline_comment|/*&n; * Return true if any of the pages in the mapping are marged with the&n; * passed tag.&n; */
DECL|function|mapping_tagged
r_int
id|mapping_tagged
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
id|tag
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|read_lock_irqsave
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|radix_tree_tagged
c_func
(paren
op_amp
id|mapping-&gt;page_tree
comma
id|tag
)paren
suffix:semicolon
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|mapping_tagged
id|EXPORT_SYMBOL
c_func
(paren
id|mapping_tagged
)paren
suffix:semicolon
eof
