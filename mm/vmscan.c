multiline_comment|/*&n; *  linux/mm/vmscan.c&n; *&n; *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; *&n; *  Swap reorganised 29.12.95, Stephen Tweedie.&n; *  kswapd added: 7.1.96  sct&n; *  Removed kswapd_ctl limits, and swap out as many pages as needed&n; *  to bring the system back to freepages.high: 2.4.97, Rik van Riel.&n; *  Zone aware kswapd started 02/00, Kanoj Sarcar (kanoj@sgi.com).&n; *  Multiqueue VM started 5.8.00, Rik van Riel.&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/writeback.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;&t;/* for try_to_release_page(),&n;&t;&t;&t;&t;&t;buffer_heads_over_limit */
macro_line|#include &lt;linux/mm_inline.h&gt;
macro_line|#include &lt;linux/pagevec.h&gt;
macro_line|#include &lt;linux/backing-dev.h&gt;
macro_line|#include &lt;linux/rmap.h&gt;
macro_line|#include &lt;linux/topology.h&gt;
macro_line|#include &lt;linux/cpu.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/rwsem.h&gt;
macro_line|#include &lt;asm/tlbflush.h&gt;
macro_line|#include &lt;asm/div64.h&gt;
macro_line|#include &lt;linux/swapops.h&gt;
multiline_comment|/* possible outcome of pageout() */
r_typedef
r_enum
(brace
multiline_comment|/* failed to write page out, page is locked */
DECL|enumerator|PAGE_KEEP
id|PAGE_KEEP
comma
multiline_comment|/* move page to the active list, page is locked */
DECL|enumerator|PAGE_ACTIVATE
id|PAGE_ACTIVATE
comma
multiline_comment|/* page has been sent to the disk successfully, page is unlocked */
DECL|enumerator|PAGE_SUCCESS
id|PAGE_SUCCESS
comma
multiline_comment|/* page is clean and locked */
DECL|enumerator|PAGE_CLEAN
id|PAGE_CLEAN
comma
DECL|typedef|pageout_t
)brace
id|pageout_t
suffix:semicolon
DECL|struct|scan_control
r_struct
id|scan_control
(brace
multiline_comment|/* Ask refill_inactive_zone, or shrink_cache to scan this many pages */
DECL|member|nr_to_scan
r_int
r_int
id|nr_to_scan
suffix:semicolon
multiline_comment|/* Incremented by the number of inactive pages that were scanned */
DECL|member|nr_scanned
r_int
r_int
id|nr_scanned
suffix:semicolon
multiline_comment|/* Incremented by the number of pages reclaimed */
DECL|member|nr_reclaimed
r_int
r_int
id|nr_reclaimed
suffix:semicolon
DECL|member|nr_mapped
r_int
r_int
id|nr_mapped
suffix:semicolon
multiline_comment|/* From page_state */
multiline_comment|/* How many pages shrink_cache() should reclaim */
DECL|member|nr_to_reclaim
r_int
id|nr_to_reclaim
suffix:semicolon
multiline_comment|/* Ask shrink_caches, or shrink_zone to scan at this priority */
DECL|member|priority
r_int
r_int
id|priority
suffix:semicolon
multiline_comment|/* This context&squot;s GFP mask */
DECL|member|gfp_mask
r_int
r_int
id|gfp_mask
suffix:semicolon
DECL|member|may_writepage
r_int
id|may_writepage
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * The list of shrinker callbacks used by to apply pressure to&n; * ageable caches.&n; */
DECL|struct|shrinker
r_struct
id|shrinker
(brace
DECL|member|shrinker
id|shrinker_t
id|shrinker
suffix:semicolon
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|seeks
r_int
id|seeks
suffix:semicolon
multiline_comment|/* seeks to recreate an obj */
DECL|member|nr
r_int
id|nr
suffix:semicolon
multiline_comment|/* objs pending delete */
)brace
suffix:semicolon
DECL|macro|lru_to_page
mdefine_line|#define lru_to_page(_head) (list_entry((_head)-&gt;prev, struct page, lru))
macro_line|#ifdef ARCH_HAS_PREFETCH
DECL|macro|prefetch_prev_lru_page
mdefine_line|#define prefetch_prev_lru_page(_page, _base, _field)&t;&t;&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if ((_page)-&gt;lru.prev != _base) {&t;&t;&t;&bslash;&n;&t;&t;&t;struct page *prev;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;prev = lru_to_page(&amp;(_page-&gt;lru));&t;&t;&bslash;&n;&t;&t;&t;prefetch(&amp;prev-&gt;_field);&t;&t;&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;} while (0)
macro_line|#else
DECL|macro|prefetch_prev_lru_page
mdefine_line|#define prefetch_prev_lru_page(_page, _base, _field) do { } while (0)
macro_line|#endif
macro_line|#ifdef ARCH_HAS_PREFETCHW
DECL|macro|prefetchw_prev_lru_page
mdefine_line|#define prefetchw_prev_lru_page(_page, _base, _field)&t;&t;&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if ((_page)-&gt;lru.prev != _base) {&t;&t;&t;&bslash;&n;&t;&t;&t;struct page *prev;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;prev = lru_to_page(&amp;(_page-&gt;lru));&t;&t;&bslash;&n;&t;&t;&t;prefetchw(&amp;prev-&gt;_field);&t;&t;&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;} while (0)
macro_line|#else
DECL|macro|prefetchw_prev_lru_page
mdefine_line|#define prefetchw_prev_lru_page(_page, _base, _field) do { } while (0)
macro_line|#endif
multiline_comment|/*&n; * From 0 .. 100.  Higher means more swappy.&n; */
DECL|variable|vm_swappiness
r_int
id|vm_swappiness
op_assign
l_int|60
suffix:semicolon
DECL|variable|total_memory
r_static
r_int
id|total_memory
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|shrinker_list
)paren
suffix:semicolon
r_static
id|DECLARE_RWSEM
c_func
(paren
id|shrinker_rwsem
)paren
suffix:semicolon
multiline_comment|/*&n; * Add a shrinker callback to be called from the vm&n; */
DECL|function|set_shrinker
r_struct
id|shrinker
op_star
id|set_shrinker
c_func
(paren
r_int
id|seeks
comma
id|shrinker_t
id|theshrinker
)paren
(brace
r_struct
id|shrinker
op_star
id|shrinker
suffix:semicolon
id|shrinker
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|shrinker
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shrinker
)paren
(brace
id|shrinker-&gt;shrinker
op_assign
id|theshrinker
suffix:semicolon
id|shrinker-&gt;seeks
op_assign
id|seeks
suffix:semicolon
id|shrinker-&gt;nr
op_assign
l_int|0
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|shrinker_rwsem
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|shrinker-&gt;list
comma
op_amp
id|shrinker_list
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|shrinker_rwsem
)paren
suffix:semicolon
)brace
r_return
id|shrinker
suffix:semicolon
)brace
DECL|variable|set_shrinker
id|EXPORT_SYMBOL
c_func
(paren
id|set_shrinker
)paren
suffix:semicolon
multiline_comment|/*&n; * Remove one&n; */
DECL|function|remove_shrinker
r_void
id|remove_shrinker
c_func
(paren
r_struct
id|shrinker
op_star
id|shrinker
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|shrinker_rwsem
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|shrinker-&gt;list
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|shrinker_rwsem
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|shrinker
)paren
suffix:semicolon
)brace
DECL|variable|remove_shrinker
id|EXPORT_SYMBOL
c_func
(paren
id|remove_shrinker
)paren
suffix:semicolon
DECL|macro|SHRINK_BATCH
mdefine_line|#define SHRINK_BATCH 128
multiline_comment|/*&n; * Call the shrink functions to age shrinkable caches&n; *&n; * Here we assume it costs one seek to replace a lru page and that it also&n; * takes a seek to recreate a cache object.  With this in mind we age equal&n; * percentages of the lru and ageable caches.  This should balance the seeks&n; * generated by these structures.&n; *&n; * If the vm encounted mapped pages on the LRU it increase the pressure on&n; * slab to avoid swapping.&n; *&n; * We do weird things to avoid (scanned*seeks*entries) overflowing 32 bits.&n; *&n; * `lru_pages&squot; represents the number of on-LRU pages in all the zones which&n; * are eligible for the caller&squot;s allocation attempt.  It is used for balancing&n; * slab reclaim versus page reclaim.&n; */
DECL|function|shrink_slab
r_static
r_int
id|shrink_slab
c_func
(paren
r_int
r_int
id|scanned
comma
r_int
r_int
id|gfp_mask
comma
r_int
r_int
id|lru_pages
)paren
(brace
r_struct
id|shrinker
op_star
id|shrinker
suffix:semicolon
r_if
c_cond
(paren
id|scanned
op_eq
l_int|0
)paren
id|scanned
op_assign
id|SWAP_CLUSTER_MAX
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|down_read_trylock
c_func
(paren
op_amp
id|shrinker_rwsem
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|shrinker
comma
op_amp
id|shrinker_list
comma
id|list
)paren
(brace
r_int
r_int
r_int
id|delta
suffix:semicolon
r_int
r_int
id|total_scan
suffix:semicolon
id|delta
op_assign
(paren
l_int|4
op_star
id|scanned
)paren
op_div
id|shrinker-&gt;seeks
suffix:semicolon
id|delta
op_mul_assign
(paren
op_star
id|shrinker-&gt;shrinker
)paren
(paren
l_int|0
comma
id|gfp_mask
)paren
suffix:semicolon
id|do_div
c_func
(paren
id|delta
comma
id|lru_pages
op_plus
l_int|1
)paren
suffix:semicolon
id|shrinker-&gt;nr
op_add_assign
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|shrinker-&gt;nr
OL
l_int|0
)paren
id|shrinker-&gt;nr
op_assign
id|LONG_MAX
suffix:semicolon
multiline_comment|/* It wrapped! */
id|total_scan
op_assign
id|shrinker-&gt;nr
suffix:semicolon
id|shrinker-&gt;nr
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|total_scan
op_ge
id|SHRINK_BATCH
)paren
(brace
r_int
id|this_scan
op_assign
id|SHRINK_BATCH
suffix:semicolon
r_int
id|shrink_ret
suffix:semicolon
id|shrink_ret
op_assign
(paren
op_star
id|shrinker-&gt;shrinker
)paren
(paren
id|this_scan
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shrink_ret
op_eq
op_minus
l_int|1
)paren
r_break
suffix:semicolon
id|mod_page_state
c_func
(paren
id|slabs_scanned
comma
id|this_scan
)paren
suffix:semicolon
id|total_scan
op_sub_assign
id|this_scan
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
id|shrinker-&gt;nr
op_add_assign
id|total_scan
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|shrinker_rwsem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Called without lock on whether page is mapped, so answer is unstable */
DECL|function|page_mapping_inuse
r_static
r_inline
r_int
id|page_mapping_inuse
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
multiline_comment|/* Page is in somebody&squot;s page tables. */
r_if
c_cond
(paren
id|page_mapped
c_func
(paren
id|page
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Be more reluctant to reclaim swapcache than pagecache */
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|mapping
op_assign
id|page_mapping
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mapping
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* File is mmap&squot;d by somebody? */
r_return
id|mapping_mapped
c_func
(paren
id|mapping
)paren
suffix:semicolon
)brace
DECL|function|is_page_cache_freeable
r_static
r_inline
r_int
id|is_page_cache_freeable
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_return
id|page_count
c_func
(paren
id|page
)paren
op_minus
op_logical_neg
op_logical_neg
id|PagePrivate
c_func
(paren
id|page
)paren
op_eq
l_int|2
suffix:semicolon
)brace
DECL|function|may_write_to_queue
r_static
r_int
id|may_write_to_queue
c_func
(paren
r_struct
id|backing_dev_info
op_star
id|bdi
)paren
(brace
r_if
c_cond
(paren
id|current_is_kswapd
c_func
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|current_is_pdflush
c_func
(paren
)paren
)paren
multiline_comment|/* This is unlikely, but why not... */
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bdi_write_congested
c_func
(paren
id|bdi
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bdi
op_eq
id|current-&gt;backing_dev_info
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We detected a synchronous write error writing a page out.  Probably&n; * -ENOSPC.  We need to propagate that into the address_space for a subsequent&n; * fsync(), msync() or close().&n; *&n; * The tricky part is that after writepage we cannot touch the mapping: nothing&n; * prevents it from being freed up.  But we have a ref on the page and once&n; * that page is locked, the mapping is pinned.&n; *&n; * We&squot;re allowed to run sleeping lock_page() here because we know the caller has&n; * __GFP_FS.&n; */
DECL|function|handle_write_error
r_static
r_void
id|handle_write_error
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|error
)paren
(brace
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page_mapping
c_func
(paren
id|page
)paren
op_eq
id|mapping
)paren
(brace
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|ENOSPC
)paren
id|set_bit
c_func
(paren
id|AS_ENOSPC
comma
op_amp
id|mapping-&gt;flags
)paren
suffix:semicolon
r_else
id|set_bit
c_func
(paren
id|AS_EIO
comma
op_amp
id|mapping-&gt;flags
)paren
suffix:semicolon
)brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pageout is called by shrink_list() for each dirty page. Calls -&gt;writepage().&n; */
DECL|function|pageout
r_static
id|pageout_t
id|pageout
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|address_space
op_star
id|mapping
)paren
(brace
multiline_comment|/*&n;&t; * If the page is dirty, only perform writeback if that write&n;&t; * will be non-blocking.  To prevent this allocation from being&n;&t; * stalled by pagecache activity.  But note that there may be&n;&t; * stalls if we need to run get_block().  We could test&n;&t; * PagePrivate for that.&n;&t; *&n;&t; * If this process is currently in generic_file_write() against&n;&t; * this page&squot;s queue, we can perform writeback even if that&n;&t; * will block.&n;&t; *&n;&t; * If the page is swapcache, write it back even if that would&n;&t; * block, for some throttling. This happens by accident, because&n;&t; * swap_backing_dev_info is bust: it doesn&squot;t reflect the&n;&t; * congestion state of the swapdevs.  Easy to fix, if needed.&n;&t; * See swapfile.c:page_queue_congested().&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|is_page_cache_freeable
c_func
(paren
id|page
)paren
)paren
r_return
id|PAGE_KEEP
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mapping
)paren
r_return
id|PAGE_KEEP
suffix:semicolon
r_if
c_cond
(paren
id|mapping-&gt;a_ops-&gt;writepage
op_eq
l_int|NULL
)paren
r_return
id|PAGE_ACTIVATE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|may_write_to_queue
c_func
(paren
id|mapping-&gt;backing_dev_info
)paren
)paren
r_return
id|PAGE_KEEP
suffix:semicolon
r_if
c_cond
(paren
id|clear_page_dirty_for_io
c_func
(paren
id|page
)paren
)paren
(brace
r_int
id|res
suffix:semicolon
r_struct
id|writeback_control
id|wbc
op_assign
(brace
dot
id|sync_mode
op_assign
id|WB_SYNC_NONE
comma
dot
id|nr_to_write
op_assign
id|SWAP_CLUSTER_MAX
comma
dot
id|nonblocking
op_assign
l_int|1
comma
dot
id|for_reclaim
op_assign
l_int|1
comma
)brace
suffix:semicolon
id|SetPageReclaim
c_func
(paren
id|page
)paren
suffix:semicolon
id|res
op_assign
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|writepage
c_func
(paren
id|page
comma
op_amp
id|wbc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
OL
l_int|0
)paren
id|handle_write_error
c_func
(paren
id|mapping
comma
id|page
comma
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|WRITEPAGE_ACTIVATE
)paren
(brace
id|ClearPageReclaim
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|PAGE_ACTIVATE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
(brace
multiline_comment|/* synchronous write or broken a_ops? */
id|ClearPageReclaim
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
id|PAGE_SUCCESS
suffix:semicolon
)brace
r_return
id|PAGE_CLEAN
suffix:semicolon
)brace
multiline_comment|/*&n; * shrink_list adds the number of reclaimed pages to sc-&gt;nr_reclaimed&n; */
DECL|function|shrink_list
r_static
r_int
id|shrink_list
c_func
(paren
r_struct
id|list_head
op_star
id|page_list
comma
r_struct
id|scan_control
op_star
id|sc
)paren
(brace
id|LIST_HEAD
c_func
(paren
id|ret_pages
)paren
suffix:semicolon
r_struct
id|pagevec
id|freed_pvec
suffix:semicolon
r_int
id|pgactivate
op_assign
l_int|0
suffix:semicolon
r_int
id|reclaimed
op_assign
l_int|0
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
id|pagevec_init
c_func
(paren
op_amp
id|freed_pvec
comma
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|page_list
)paren
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|may_enter_fs
suffix:semicolon
r_int
id|referenced
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
id|page
op_assign
id|lru_to_page
c_func
(paren
id|page_list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|page-&gt;lru
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TestSetPageLocked
c_func
(paren
id|page
)paren
)paren
r_goto
id|keep
suffix:semicolon
id|BUG_ON
c_func
(paren
id|PageActive
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|sc-&gt;nr_scanned
op_increment
suffix:semicolon
multiline_comment|/* Double the slab pressure for mapped and swapcache pages */
r_if
c_cond
(paren
id|page_mapped
c_func
(paren
id|page
)paren
op_logical_or
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
id|sc-&gt;nr_scanned
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
r_goto
id|keep_locked
suffix:semicolon
id|referenced
op_assign
id|page_referenced
c_func
(paren
id|page
comma
l_int|1
comma
id|sc-&gt;priority
op_le
l_int|0
)paren
suffix:semicolon
multiline_comment|/* In active use or really unfreeable?  Activate it. */
r_if
c_cond
(paren
id|referenced
op_logical_and
id|page_mapping_inuse
c_func
(paren
id|page
)paren
)paren
r_goto
id|activate_locked
suffix:semicolon
macro_line|#ifdef CONFIG_SWAP
multiline_comment|/*&n;&t;&t; * Anonymous process memory has backing store?&n;&t;&t; * Try to allocate it some swap space here.&n;&t;&t; */
r_if
c_cond
(paren
id|PageAnon
c_func
(paren
id|page
)paren
op_logical_and
op_logical_neg
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|add_to_swap
c_func
(paren
id|page
)paren
)paren
r_goto
id|activate_locked
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SWAP */
id|mapping
op_assign
id|page_mapping
c_func
(paren
id|page
)paren
suffix:semicolon
id|may_enter_fs
op_assign
(paren
id|sc-&gt;gfp_mask
op_amp
id|__GFP_FS
)paren
op_logical_or
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
op_logical_and
(paren
id|sc-&gt;gfp_mask
op_amp
id|__GFP_IO
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The page is mapped into the page tables of one or more&n;&t;&t; * processes. Try to unmap it here.&n;&t;&t; */
r_if
c_cond
(paren
id|page_mapped
c_func
(paren
id|page
)paren
op_logical_and
id|mapping
)paren
(brace
r_switch
c_cond
(paren
id|try_to_unmap
c_func
(paren
id|page
)paren
)paren
(brace
r_case
id|SWAP_FAIL
suffix:colon
r_goto
id|activate_locked
suffix:semicolon
r_case
id|SWAP_AGAIN
suffix:colon
r_goto
id|keep_locked
suffix:semicolon
r_case
id|SWAP_SUCCESS
suffix:colon
suffix:semicolon
multiline_comment|/* try to free the page below */
)brace
)brace
r_if
c_cond
(paren
id|PageDirty
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
id|referenced
)paren
r_goto
id|keep_locked
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|may_enter_fs
)paren
r_goto
id|keep_locked
suffix:semicolon
r_if
c_cond
(paren
id|laptop_mode
op_logical_and
op_logical_neg
id|sc-&gt;may_writepage
)paren
r_goto
id|keep_locked
suffix:semicolon
multiline_comment|/* Page is dirty, try to write it out here */
r_switch
c_cond
(paren
id|pageout
c_func
(paren
id|page
comma
id|mapping
)paren
)paren
(brace
r_case
id|PAGE_KEEP
suffix:colon
r_goto
id|keep_locked
suffix:semicolon
r_case
id|PAGE_ACTIVATE
suffix:colon
r_goto
id|activate_locked
suffix:semicolon
r_case
id|PAGE_SUCCESS
suffix:colon
r_if
c_cond
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
op_logical_or
id|PageDirty
c_func
(paren
id|page
)paren
)paren
r_goto
id|keep
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * A synchronous write - probably a ramdisk.  Go&n;&t;&t;&t;&t; * ahead and try to reclaim the page.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|TestSetPageLocked
c_func
(paren
id|page
)paren
)paren
r_goto
id|keep
suffix:semicolon
r_if
c_cond
(paren
id|PageDirty
c_func
(paren
id|page
)paren
op_logical_or
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
r_goto
id|keep_locked
suffix:semicolon
id|mapping
op_assign
id|page_mapping
c_func
(paren
id|page
)paren
suffix:semicolon
r_case
id|PAGE_CLEAN
suffix:colon
suffix:semicolon
multiline_comment|/* try to free the page below */
)brace
)brace
multiline_comment|/*&n;&t;&t; * If the page has buffers, try to free the buffer mappings&n;&t;&t; * associated with this page. If we succeed we try to free&n;&t;&t; * the page as well.&n;&t;&t; *&n;&t;&t; * We do this even if the page is PageDirty().&n;&t;&t; * try_to_release_page() does not perform I/O, but it is&n;&t;&t; * possible for a page to have PageDirty set, but it is actually&n;&t;&t; * clean (all its buffers are clean).  This happens if the&n;&t;&t; * buffers were written out directly, with submit_bh(). ext3&n;&t;&t; * will do this, as well as the blockdev mapping. &n;&t;&t; * try_to_release_page() will discover that cleanness and will&n;&t;&t; * drop the buffers and mark the page clean - it can be freed.&n;&t;&t; *&n;&t;&t; * Rarely, pages can have buffers and no -&gt;mapping.  These are&n;&t;&t; * the pages which were not successfully invalidated in&n;&t;&t; * truncate_complete_page().  We try to drop those buffers here&n;&t;&t; * and if that worked, and the page is no longer mapped into&n;&t;&t; * process address space (page_count == 1) it can be freed.&n;&t;&t; * Otherwise, leave the page on the LRU so it is swappable.&n;&t;&t; */
r_if
c_cond
(paren
id|PagePrivate
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|try_to_release_page
c_func
(paren
id|page
comma
id|sc-&gt;gfp_mask
)paren
)paren
r_goto
id|activate_locked
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mapping
op_logical_and
id|page_count
c_func
(paren
id|page
)paren
op_eq
l_int|1
)paren
r_goto
id|free_it
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mapping
)paren
r_goto
id|keep_locked
suffix:semicolon
multiline_comment|/* truncate got there first */
id|write_lock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The non-racy check for busy page.  It is critical to check&n;&t;&t; * PageDirty _after_ making sure that the page is freeable and&n;&t;&t; * not in use by anybody. &t;(pagecache + us == 2)&n;&t;&t; */
r_if
c_cond
(paren
id|page_count
c_func
(paren
id|page
)paren
op_ne
l_int|2
op_logical_or
id|PageDirty
c_func
(paren
id|page
)paren
)paren
(brace
id|write_unlock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
r_goto
id|keep_locked
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SWAP
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
(brace
id|swp_entry_t
id|swap
op_assign
(brace
dot
id|val
op_assign
id|page
op_member_access_from_pointer
r_private
)brace
suffix:semicolon
id|__delete_from_swap_cache
c_func
(paren
id|page
)paren
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
id|swap_free
c_func
(paren
id|swap
)paren
suffix:semicolon
id|__put_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* The pagecache ref */
r_goto
id|free_it
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SWAP */
id|__remove_from_page_cache
c_func
(paren
id|page
)paren
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
id|__put_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|free_it
suffix:colon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|reclaimed
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagevec_add
c_func
(paren
op_amp
id|freed_pvec
comma
id|page
)paren
)paren
id|__pagevec_release_nonlru
c_func
(paren
op_amp
id|freed_pvec
)paren
suffix:semicolon
r_continue
suffix:semicolon
id|activate_locked
suffix:colon
id|SetPageActive
c_func
(paren
id|page
)paren
suffix:semicolon
id|pgactivate
op_increment
suffix:semicolon
id|keep_locked
suffix:colon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|keep
suffix:colon
id|list_add
c_func
(paren
op_amp
id|page-&gt;lru
comma
op_amp
id|ret_pages
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|PageLRU
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
)brace
id|list_splice
c_func
(paren
op_amp
id|ret_pages
comma
id|page_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pagevec_count
c_func
(paren
op_amp
id|freed_pvec
)paren
)paren
id|__pagevec_release_nonlru
c_func
(paren
op_amp
id|freed_pvec
)paren
suffix:semicolon
id|mod_page_state
c_func
(paren
id|pgactivate
comma
id|pgactivate
)paren
suffix:semicolon
id|sc-&gt;nr_reclaimed
op_add_assign
id|reclaimed
suffix:semicolon
r_return
id|reclaimed
suffix:semicolon
)brace
multiline_comment|/*&n; * zone-&gt;lru_lock is heavily contented.  We relieve it by quickly privatising&n; * a batch of pages and working on them outside the lock.  Any pages which were&n; * not freed will be added back to the LRU.&n; *&n; * shrink_cache() adds the number of pages reclaimed to sc-&gt;nr_reclaimed&n; *&n; * For pagecache intensive workloads, the first loop here is the hottest spot&n; * in the kernel (apart from the copy_*_user functions).&n; */
DECL|function|shrink_cache
r_static
r_void
id|shrink_cache
c_func
(paren
r_struct
id|zone
op_star
id|zone
comma
r_struct
id|scan_control
op_star
id|sc
)paren
(brace
id|LIST_HEAD
c_func
(paren
id|page_list
)paren
suffix:semicolon
r_struct
id|pagevec
id|pvec
suffix:semicolon
r_int
id|max_scan
op_assign
id|sc-&gt;nr_to_scan
suffix:semicolon
id|pagevec_init
c_func
(paren
op_amp
id|pvec
comma
l_int|1
)paren
suffix:semicolon
id|lru_add_drain
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|max_scan
OG
l_int|0
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|nr_taken
op_assign
l_int|0
suffix:semicolon
r_int
id|nr_scan
op_assign
l_int|0
suffix:semicolon
r_int
id|nr_freed
suffix:semicolon
r_while
c_loop
(paren
id|nr_scan
op_increment
OL
id|SWAP_CLUSTER_MAX
op_logical_and
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|zone-&gt;inactive_list
)paren
)paren
(brace
id|page
op_assign
id|lru_to_page
c_func
(paren
op_amp
id|zone-&gt;inactive_list
)paren
suffix:semicolon
id|prefetchw_prev_lru_page
c_func
(paren
id|page
comma
op_amp
id|zone-&gt;inactive_list
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TestClearPageLRU
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|page-&gt;lru
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_page_testone
c_func
(paren
id|page
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * It is being freed elsewhere&n;&t;&t;&t;&t; */
id|__put_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageLRU
c_func
(paren
id|page
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|page-&gt;lru
comma
op_amp
id|zone-&gt;inactive_list
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|list_add
c_func
(paren
op_amp
id|page-&gt;lru
comma
op_amp
id|page_list
)paren
suffix:semicolon
id|nr_taken
op_increment
suffix:semicolon
)brace
id|zone-&gt;nr_inactive
op_sub_assign
id|nr_taken
suffix:semicolon
id|zone-&gt;pages_scanned
op_add_assign
id|nr_scan
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_taken
op_eq
l_int|0
)paren
r_goto
id|done
suffix:semicolon
id|max_scan
op_sub_assign
id|nr_scan
suffix:semicolon
r_if
c_cond
(paren
id|current_is_kswapd
c_func
(paren
)paren
)paren
id|mod_page_state_zone
c_func
(paren
id|zone
comma
id|pgscan_kswapd
comma
id|nr_scan
)paren
suffix:semicolon
r_else
id|mod_page_state_zone
c_func
(paren
id|zone
comma
id|pgscan_direct
comma
id|nr_scan
)paren
suffix:semicolon
id|nr_freed
op_assign
id|shrink_list
c_func
(paren
op_amp
id|page_list
comma
id|sc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_is_kswapd
c_func
(paren
)paren
)paren
id|mod_page_state
c_func
(paren
id|kswapd_steal
comma
id|nr_freed
)paren
suffix:semicolon
id|mod_page_state_zone
c_func
(paren
id|zone
comma
id|pgsteal
comma
id|nr_freed
)paren
suffix:semicolon
id|sc-&gt;nr_to_reclaim
op_sub_assign
id|nr_freed
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Put back any unfreeable pages.&n;&t;&t; */
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|page_list
)paren
)paren
(brace
id|page
op_assign
id|lru_to_page
c_func
(paren
op_amp
id|page_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TestSetPageLRU
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|page-&gt;lru
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageActive
c_func
(paren
id|page
)paren
)paren
id|add_page_to_active_list
c_func
(paren
id|zone
comma
id|page
)paren
suffix:semicolon
r_else
id|add_page_to_inactive_list
c_func
(paren
id|zone
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagevec_add
c_func
(paren
op_amp
id|pvec
comma
id|page
)paren
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
id|__pagevec_release
c_func
(paren
op_amp
id|pvec
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
)brace
)brace
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
id|done
suffix:colon
id|pagevec_release
c_func
(paren
op_amp
id|pvec
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This moves pages from the active list to the inactive list.&n; *&n; * We move them the other way if the page is referenced by one or more&n; * processes, from rmap.&n; *&n; * If the pages are mostly unmapped, the processing is fast and it is&n; * appropriate to hold zone-&gt;lru_lock across the whole operation.  But if&n; * the pages are mapped, the processing is slow (page_referenced()) so we&n; * should drop zone-&gt;lru_lock around each page.  It&squot;s impossible to balance&n; * this, so instead we remove the pages from the LRU while processing them.&n; * It is safe to rely on PG_active against the non-LRU pages in here because&n; * nobody will play with that bit on a non-LRU page.&n; *&n; * The downside is that we have to touch page-&gt;_count against each page.&n; * But we had to alter page-&gt;flags anyway.&n; */
r_static
r_void
DECL|function|refill_inactive_zone
id|refill_inactive_zone
c_func
(paren
r_struct
id|zone
op_star
id|zone
comma
r_struct
id|scan_control
op_star
id|sc
)paren
(brace
r_int
id|pgmoved
suffix:semicolon
r_int
id|pgdeactivate
op_assign
l_int|0
suffix:semicolon
r_int
id|pgscanned
op_assign
l_int|0
suffix:semicolon
r_int
id|nr_pages
op_assign
id|sc-&gt;nr_to_scan
suffix:semicolon
id|LIST_HEAD
c_func
(paren
id|l_hold
)paren
suffix:semicolon
multiline_comment|/* The pages which were snipped off */
id|LIST_HEAD
c_func
(paren
id|l_inactive
)paren
suffix:semicolon
multiline_comment|/* Pages to go onto the inactive_list */
id|LIST_HEAD
c_func
(paren
id|l_active
)paren
suffix:semicolon
multiline_comment|/* Pages to go onto the active_list */
r_struct
id|page
op_star
id|page
suffix:semicolon
r_struct
id|pagevec
id|pvec
suffix:semicolon
r_int
id|reclaim_mapped
op_assign
l_int|0
suffix:semicolon
r_int
id|mapped_ratio
suffix:semicolon
r_int
id|distress
suffix:semicolon
r_int
id|swap_tendency
suffix:semicolon
id|lru_add_drain
c_func
(paren
)paren
suffix:semicolon
id|pgmoved
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|pgscanned
OL
id|nr_pages
op_logical_and
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|zone-&gt;active_list
)paren
)paren
(brace
id|page
op_assign
id|lru_to_page
c_func
(paren
op_amp
id|zone-&gt;active_list
)paren
suffix:semicolon
id|prefetchw_prev_lru_page
c_func
(paren
id|page
comma
op_amp
id|zone-&gt;active_list
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TestClearPageLRU
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|page-&gt;lru
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_page_testone
c_func
(paren
id|page
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * It was already free!  release_pages() or put_page()&n;&t;&t;&t; * are about to remove it from the LRU and free it. So&n;&t;&t;&t; * put the refcount back and put the page back on the&n;&t;&t;&t; * LRU&n;&t;&t;&t; */
id|__put_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageLRU
c_func
(paren
id|page
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|page-&gt;lru
comma
op_amp
id|zone-&gt;active_list
)paren
suffix:semicolon
)brace
r_else
(brace
id|list_add
c_func
(paren
op_amp
id|page-&gt;lru
comma
op_amp
id|l_hold
)paren
suffix:semicolon
id|pgmoved
op_increment
suffix:semicolon
)brace
id|pgscanned
op_increment
suffix:semicolon
)brace
id|zone-&gt;pages_scanned
op_add_assign
id|pgscanned
suffix:semicolon
id|zone-&gt;nr_active
op_sub_assign
id|pgmoved
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * `distress&squot; is a measure of how much trouble we&squot;re having reclaiming&n;&t; * pages.  0 -&gt; no problems.  100 -&gt; great trouble.&n;&t; */
id|distress
op_assign
l_int|100
op_rshift
id|zone-&gt;prev_priority
suffix:semicolon
multiline_comment|/*&n;&t; * The point of this algorithm is to decide when to start reclaiming&n;&t; * mapped memory instead of just pagecache.  Work out how much memory&n;&t; * is mapped.&n;&t; */
id|mapped_ratio
op_assign
(paren
id|sc-&gt;nr_mapped
op_star
l_int|100
)paren
op_div
id|total_memory
suffix:semicolon
multiline_comment|/*&n;&t; * Now decide how much we really want to unmap some pages.  The mapped&n;&t; * ratio is downgraded - just because there&squot;s a lot of mapped memory&n;&t; * doesn&squot;t necessarily mean that page reclaim isn&squot;t succeeding.&n;&t; *&n;&t; * The distress ratio is important - we don&squot;t want to start going oom.&n;&t; *&n;&t; * A 100% value of vm_swappiness overrides this algorithm altogether.&n;&t; */
id|swap_tendency
op_assign
id|mapped_ratio
op_div
l_int|2
op_plus
id|distress
op_plus
id|vm_swappiness
suffix:semicolon
multiline_comment|/*&n;&t; * Now use this metric to decide whether to start moving mapped memory&n;&t; * onto the inactive list.&n;&t; */
r_if
c_cond
(paren
id|swap_tendency
op_ge
l_int|100
)paren
id|reclaim_mapped
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|l_hold
)paren
)paren
(brace
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
id|page
op_assign
id|lru_to_page
c_func
(paren
op_amp
id|l_hold
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|page-&gt;lru
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page_mapped
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|reclaim_mapped
op_logical_or
(paren
id|total_swap_pages
op_eq
l_int|0
op_logical_and
id|PageAnon
c_func
(paren
id|page
)paren
)paren
op_logical_or
id|page_referenced
c_func
(paren
id|page
comma
l_int|0
comma
id|sc-&gt;priority
op_le
l_int|0
)paren
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|page-&gt;lru
comma
op_amp
id|l_active
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
id|list_add
c_func
(paren
op_amp
id|page-&gt;lru
comma
op_amp
id|l_inactive
)paren
suffix:semicolon
)brace
id|pagevec_init
c_func
(paren
op_amp
id|pvec
comma
l_int|1
)paren
suffix:semicolon
id|pgmoved
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|l_inactive
)paren
)paren
(brace
id|page
op_assign
id|lru_to_page
c_func
(paren
op_amp
id|l_inactive
)paren
suffix:semicolon
id|prefetchw_prev_lru_page
c_func
(paren
id|page
comma
op_amp
id|l_inactive
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TestSetPageLRU
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TestClearPageActive
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|list_move
c_func
(paren
op_amp
id|page-&gt;lru
comma
op_amp
id|zone-&gt;inactive_list
)paren
suffix:semicolon
id|pgmoved
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagevec_add
c_func
(paren
op_amp
id|pvec
comma
id|page
)paren
)paren
(brace
id|zone-&gt;nr_inactive
op_add_assign
id|pgmoved
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
id|pgdeactivate
op_add_assign
id|pgmoved
suffix:semicolon
id|pgmoved
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buffer_heads_over_limit
)paren
id|pagevec_strip
c_func
(paren
op_amp
id|pvec
)paren
suffix:semicolon
id|__pagevec_release
c_func
(paren
op_amp
id|pvec
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
)brace
)brace
id|zone-&gt;nr_inactive
op_add_assign
id|pgmoved
suffix:semicolon
id|pgdeactivate
op_add_assign
id|pgmoved
suffix:semicolon
r_if
c_cond
(paren
id|buffer_heads_over_limit
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
id|pagevec_strip
c_func
(paren
op_amp
id|pvec
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
)brace
id|pgmoved
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|l_active
)paren
)paren
(brace
id|page
op_assign
id|lru_to_page
c_func
(paren
op_amp
id|l_active
)paren
suffix:semicolon
id|prefetchw_prev_lru_page
c_func
(paren
id|page
comma
op_amp
id|l_active
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TestSetPageLRU
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageActive
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|list_move
c_func
(paren
op_amp
id|page-&gt;lru
comma
op_amp
id|zone-&gt;active_list
)paren
suffix:semicolon
id|pgmoved
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagevec_add
c_func
(paren
op_amp
id|pvec
comma
id|page
)paren
)paren
(brace
id|zone-&gt;nr_active
op_add_assign
id|pgmoved
suffix:semicolon
id|pgmoved
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
id|__pagevec_release
c_func
(paren
op_amp
id|pvec
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
)brace
)brace
id|zone-&gt;nr_active
op_add_assign
id|pgmoved
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
id|pagevec_release
c_func
(paren
op_amp
id|pvec
)paren
suffix:semicolon
id|mod_page_state_zone
c_func
(paren
id|zone
comma
id|pgrefill
comma
id|pgscanned
)paren
suffix:semicolon
id|mod_page_state
c_func
(paren
id|pgdeactivate
comma
id|pgdeactivate
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a basic per-zone page freer.  Used by both kswapd and direct reclaim.&n; */
r_static
r_void
DECL|function|shrink_zone
id|shrink_zone
c_func
(paren
r_struct
id|zone
op_star
id|zone
comma
r_struct
id|scan_control
op_star
id|sc
)paren
(brace
r_int
r_int
id|nr_active
suffix:semicolon
r_int
r_int
id|nr_inactive
suffix:semicolon
multiline_comment|/*&n;&t; * Add one to `nr_to_scan&squot; just to make sure that the kernel will&n;&t; * slowly sift through the active list.&n;&t; */
id|zone-&gt;nr_scan_active
op_add_assign
(paren
id|zone-&gt;nr_active
op_rshift
id|sc-&gt;priority
)paren
op_plus
l_int|1
suffix:semicolon
id|nr_active
op_assign
id|zone-&gt;nr_scan_active
suffix:semicolon
r_if
c_cond
(paren
id|nr_active
op_ge
id|SWAP_CLUSTER_MAX
)paren
id|zone-&gt;nr_scan_active
op_assign
l_int|0
suffix:semicolon
r_else
id|nr_active
op_assign
l_int|0
suffix:semicolon
id|zone-&gt;nr_scan_inactive
op_add_assign
(paren
id|zone-&gt;nr_inactive
op_rshift
id|sc-&gt;priority
)paren
op_plus
l_int|1
suffix:semicolon
id|nr_inactive
op_assign
id|zone-&gt;nr_scan_inactive
suffix:semicolon
r_if
c_cond
(paren
id|nr_inactive
op_ge
id|SWAP_CLUSTER_MAX
)paren
id|zone-&gt;nr_scan_inactive
op_assign
l_int|0
suffix:semicolon
r_else
id|nr_inactive
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;nr_to_reclaim
op_assign
id|SWAP_CLUSTER_MAX
suffix:semicolon
r_while
c_loop
(paren
id|nr_active
op_logical_or
id|nr_inactive
)paren
(brace
r_if
c_cond
(paren
id|nr_active
)paren
(brace
id|sc-&gt;nr_to_scan
op_assign
id|min
c_func
(paren
id|nr_active
comma
(paren
r_int
r_int
)paren
id|SWAP_CLUSTER_MAX
)paren
suffix:semicolon
id|nr_active
op_sub_assign
id|sc-&gt;nr_to_scan
suffix:semicolon
id|refill_inactive_zone
c_func
(paren
id|zone
comma
id|sc
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nr_inactive
)paren
(brace
id|sc-&gt;nr_to_scan
op_assign
id|min
c_func
(paren
id|nr_inactive
comma
(paren
r_int
r_int
)paren
id|SWAP_CLUSTER_MAX
)paren
suffix:semicolon
id|nr_inactive
op_sub_assign
id|sc-&gt;nr_to_scan
suffix:semicolon
id|shrink_cache
c_func
(paren
id|zone
comma
id|sc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;nr_to_reclaim
op_le
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * This is the direct reclaim path, for page-allocating processes.  We only&n; * try to reclaim pages from zones which will satisfy the caller&squot;s allocation&n; * request.&n; *&n; * We reclaim from a zone even if that zone is over pages_high.  Because:&n; * a) The caller may be trying to free *extra* pages to satisfy a higher-order&n; *    allocation or&n; * b) The zones may be over pages_high but they must go *over* pages_high to&n; *    satisfy the `incremental min&squot; zone defense algorithm.&n; *&n; * Returns the number of reclaimed pages.&n; *&n; * If a zone is deemed to be full of pinned pages then just give it a light&n; * scan then give up on it.&n; */
r_static
r_void
DECL|function|shrink_caches
id|shrink_caches
c_func
(paren
r_struct
id|zone
op_star
op_star
id|zones
comma
r_struct
id|scan_control
op_star
id|sc
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|zones
(braket
id|i
)braket
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|zone
op_star
id|zone
op_assign
id|zones
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|zone-&gt;present_pages
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|zone-&gt;temp_priority
op_assign
id|sc-&gt;priority
suffix:semicolon
r_if
c_cond
(paren
id|zone-&gt;prev_priority
OG
id|sc-&gt;priority
)paren
id|zone-&gt;prev_priority
op_assign
id|sc-&gt;priority
suffix:semicolon
r_if
c_cond
(paren
id|zone-&gt;all_unreclaimable
op_logical_and
id|sc-&gt;priority
op_ne
id|DEF_PRIORITY
)paren
r_continue
suffix:semicolon
multiline_comment|/* Let kswapd poll it */
id|shrink_zone
c_func
(paren
id|zone
comma
id|sc
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is the main entry point to direct page reclaim.&n; *&n; * If a full scan of the inactive list fails to free enough memory then we&n; * are &quot;out of memory&quot; and something needs to be killed.&n; *&n; * If the caller is !__GFP_FS then the probability of a failure is reasonably&n; * high - the zone may be full of dirty or under-writeback pages, which this&n; * caller can&squot;t do much about.  We kick pdflush and take explicit naps in the&n; * hope that some of these pages can be written.  But if the allocating task&n; * holds filesystem locks which prevent writeout this might not work, and the&n; * allocation attempt will fail.&n; */
DECL|function|try_to_free_pages
r_int
id|try_to_free_pages
c_func
(paren
r_struct
id|zone
op_star
op_star
id|zones
comma
r_int
r_int
id|gfp_mask
comma
r_int
r_int
id|order
)paren
(brace
r_int
id|priority
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|total_scanned
op_assign
l_int|0
comma
id|total_reclaimed
op_assign
l_int|0
suffix:semicolon
r_struct
id|reclaim_state
op_star
id|reclaim_state
op_assign
id|current-&gt;reclaim_state
suffix:semicolon
r_struct
id|scan_control
id|sc
suffix:semicolon
r_int
r_int
id|lru_pages
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|sc.gfp_mask
op_assign
id|gfp_mask
suffix:semicolon
id|sc.may_writepage
op_assign
l_int|0
suffix:semicolon
id|inc_page_state
c_func
(paren
id|allocstall
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|zones
(braket
id|i
)braket
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|zone
op_star
id|zone
op_assign
id|zones
(braket
id|i
)braket
suffix:semicolon
id|zone-&gt;temp_priority
op_assign
id|DEF_PRIORITY
suffix:semicolon
id|lru_pages
op_add_assign
id|zone-&gt;nr_active
op_plus
id|zone-&gt;nr_inactive
suffix:semicolon
)brace
r_for
c_loop
(paren
id|priority
op_assign
id|DEF_PRIORITY
suffix:semicolon
id|priority
op_ge
l_int|0
suffix:semicolon
id|priority
op_decrement
)paren
(brace
id|sc.nr_mapped
op_assign
id|read_page_state
c_func
(paren
id|nr_mapped
)paren
suffix:semicolon
id|sc.nr_scanned
op_assign
l_int|0
suffix:semicolon
id|sc.nr_reclaimed
op_assign
l_int|0
suffix:semicolon
id|sc.priority
op_assign
id|priority
suffix:semicolon
id|shrink_caches
c_func
(paren
id|zones
comma
op_amp
id|sc
)paren
suffix:semicolon
id|shrink_slab
c_func
(paren
id|sc.nr_scanned
comma
id|gfp_mask
comma
id|lru_pages
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reclaim_state
)paren
(brace
id|sc.nr_reclaimed
op_add_assign
id|reclaim_state-&gt;reclaimed_slab
suffix:semicolon
id|reclaim_state-&gt;reclaimed_slab
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sc.nr_reclaimed
op_ge
id|SWAP_CLUSTER_MAX
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|total_scanned
op_add_assign
id|sc.nr_scanned
suffix:semicolon
id|total_reclaimed
op_add_assign
id|sc.nr_reclaimed
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Try to write back as many pages as we just scanned.  This&n;&t;&t; * tends to cause slow streaming writers to write data to the&n;&t;&t; * disk smoothly, at the dirtying rate, which is nice.   But&n;&t;&t; * that&squot;s undesirable in laptop mode, where we *want* lumpy&n;&t;&t; * writeout.  So in laptop mode, write out the whole world.&n;&t;&t; */
r_if
c_cond
(paren
id|total_scanned
OG
id|SWAP_CLUSTER_MAX
op_plus
id|SWAP_CLUSTER_MAX
op_div
l_int|2
)paren
(brace
id|wakeup_bdflush
c_func
(paren
id|laptop_mode
ques
c_cond
l_int|0
suffix:colon
id|total_scanned
)paren
suffix:semicolon
id|sc.may_writepage
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Take a nap, wait for some writeback to complete */
r_if
c_cond
(paren
id|sc.nr_scanned
op_logical_and
id|priority
OL
id|DEF_PRIORITY
op_minus
l_int|2
)paren
id|blk_congestion_wait
c_func
(paren
id|WRITE
comma
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|zones
(braket
id|i
)braket
op_ne
l_int|0
suffix:semicolon
id|i
op_increment
)paren
id|zones
(braket
id|i
)braket
op_member_access_from_pointer
id|prev_priority
op_assign
id|zones
(braket
id|i
)braket
op_member_access_from_pointer
id|temp_priority
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * For kswapd, balance_pgdat() will work across all this node&squot;s zones until&n; * they are all at pages_high.&n; *&n; * If `nr_pages&squot; is non-zero then it is the number of pages which are to be&n; * reclaimed, regardless of the zone occupancies.  This is a software suspend&n; * special.&n; *&n; * Returns the number of pages which were actually freed.&n; *&n; * There is special handling here for zones which are full of pinned pages.&n; * This can happen if the pages are all mlocked, or if they are all used by&n; * device drivers (say, ZONE_DMA).  Or if they are all in use by hugetlb.&n; * What we do is to detect the case where all pages in the zone have been&n; * scanned twice and there has been zero successful reclaim.  Mark the zone as&n; * dead and from now on, only perform a short scan.  Basically we&squot;re polling&n; * the zone for when the problem goes away.&n; *&n; * kswapd scans the zones in the highmem-&gt;normal-&gt;dma direction.  It skips&n; * zones which have free_pages &gt; pages_high, but once a zone is found to have&n; * free_pages &lt;= pages_high, we scan that zone and the lower zones regardless&n; * of the number of free pages in the lower zones.  This interoperates with&n; * the page allocator fallback scheme to ensure that aging of pages is balanced&n; * across the zones.&n; */
DECL|function|balance_pgdat
r_static
r_int
id|balance_pgdat
c_func
(paren
id|pg_data_t
op_star
id|pgdat
comma
r_int
id|nr_pages
comma
r_int
id|order
)paren
(brace
r_int
id|to_free
op_assign
id|nr_pages
suffix:semicolon
r_int
id|all_zones_ok
suffix:semicolon
r_int
id|priority
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|total_scanned
comma
id|total_reclaimed
suffix:semicolon
r_struct
id|reclaim_state
op_star
id|reclaim_state
op_assign
id|current-&gt;reclaim_state
suffix:semicolon
r_struct
id|scan_control
id|sc
suffix:semicolon
id|loop_again
suffix:colon
id|total_scanned
op_assign
l_int|0
suffix:semicolon
id|total_reclaimed
op_assign
l_int|0
suffix:semicolon
id|sc.gfp_mask
op_assign
id|GFP_KERNEL
suffix:semicolon
id|sc.may_writepage
op_assign
l_int|0
suffix:semicolon
id|sc.nr_mapped
op_assign
id|read_page_state
c_func
(paren
id|nr_mapped
)paren
suffix:semicolon
id|inc_page_state
c_func
(paren
id|pageoutrun
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pgdat-&gt;nr_zones
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|zone
op_star
id|zone
op_assign
id|pgdat-&gt;node_zones
op_plus
id|i
suffix:semicolon
id|zone-&gt;temp_priority
op_assign
id|DEF_PRIORITY
suffix:semicolon
)brace
r_for
c_loop
(paren
id|priority
op_assign
id|DEF_PRIORITY
suffix:semicolon
id|priority
op_ge
l_int|0
suffix:semicolon
id|priority
op_decrement
)paren
(brace
r_int
id|end_zone
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Inclusive.  0 = ZONE_DMA */
r_int
r_int
id|lru_pages
op_assign
l_int|0
suffix:semicolon
id|all_zones_ok
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|nr_pages
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Scan in the highmem-&gt;dma direction for the highest&n;&t;&t;&t; * zone which needs scanning&n;&t;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|pgdat-&gt;nr_zones
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_struct
id|zone
op_star
id|zone
op_assign
id|pgdat-&gt;node_zones
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|zone-&gt;present_pages
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|zone-&gt;all_unreclaimable
op_logical_and
id|priority
op_ne
id|DEF_PRIORITY
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zone_watermark_ok
c_func
(paren
id|zone
comma
id|order
comma
id|zone-&gt;pages_high
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
)paren
(brace
id|end_zone
op_assign
id|i
suffix:semicolon
r_goto
id|scan
suffix:semicolon
)brace
)brace
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
id|end_zone
op_assign
id|pgdat-&gt;nr_zones
op_minus
l_int|1
suffix:semicolon
)brace
id|scan
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|end_zone
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|zone
op_star
id|zone
op_assign
id|pgdat-&gt;node_zones
op_plus
id|i
suffix:semicolon
id|lru_pages
op_add_assign
id|zone-&gt;nr_active
op_plus
id|zone-&gt;nr_inactive
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Now scan the zone in the dma-&gt;highmem direction, stopping&n;&t;&t; * at the last zone which needs scanning.&n;&t;&t; *&n;&t;&t; * We do this because the page allocator works in the opposite&n;&t;&t; * direction.  This prevents the page allocator from allocating&n;&t;&t; * pages behind kswapd&squot;s direction of progress, which would&n;&t;&t; * cause too much scanning of the lower zones.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|end_zone
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|zone
op_star
id|zone
op_assign
id|pgdat-&gt;node_zones
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|zone-&gt;present_pages
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|zone-&gt;all_unreclaimable
op_logical_and
id|priority
op_ne
id|DEF_PRIORITY
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|nr_pages
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Not software suspend */
r_if
c_cond
(paren
op_logical_neg
id|zone_watermark_ok
c_func
(paren
id|zone
comma
id|order
comma
id|zone-&gt;pages_high
comma
id|end_zone
comma
l_int|0
comma
l_int|0
)paren
)paren
id|all_zones_ok
op_assign
l_int|0
suffix:semicolon
)brace
id|zone-&gt;temp_priority
op_assign
id|priority
suffix:semicolon
r_if
c_cond
(paren
id|zone-&gt;prev_priority
OG
id|priority
)paren
id|zone-&gt;prev_priority
op_assign
id|priority
suffix:semicolon
id|sc.nr_scanned
op_assign
l_int|0
suffix:semicolon
id|sc.nr_reclaimed
op_assign
l_int|0
suffix:semicolon
id|sc.priority
op_assign
id|priority
suffix:semicolon
id|shrink_zone
c_func
(paren
id|zone
comma
op_amp
id|sc
)paren
suffix:semicolon
id|reclaim_state-&gt;reclaimed_slab
op_assign
l_int|0
suffix:semicolon
id|shrink_slab
c_func
(paren
id|sc.nr_scanned
comma
id|GFP_KERNEL
comma
id|lru_pages
)paren
suffix:semicolon
id|sc.nr_reclaimed
op_add_assign
id|reclaim_state-&gt;reclaimed_slab
suffix:semicolon
id|total_reclaimed
op_add_assign
id|sc.nr_reclaimed
suffix:semicolon
id|total_scanned
op_add_assign
id|sc.nr_scanned
suffix:semicolon
r_if
c_cond
(paren
id|zone-&gt;all_unreclaimable
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|zone-&gt;pages_scanned
op_ge
(paren
id|zone-&gt;nr_active
op_plus
id|zone-&gt;nr_inactive
)paren
op_star
l_int|4
)paren
id|zone-&gt;all_unreclaimable
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If we&squot;ve done a decent amount of scanning and&n;&t;&t;&t; * the reclaim ratio is low, start doing writepage&n;&t;&t;&t; * even in laptop mode&n;&t;&t;&t; */
r_if
c_cond
(paren
id|total_scanned
OG
id|SWAP_CLUSTER_MAX
op_star
l_int|2
op_logical_and
id|total_scanned
OG
id|total_reclaimed
op_plus
id|total_reclaimed
op_div
l_int|2
)paren
id|sc.may_writepage
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nr_pages
op_logical_and
id|to_free
OG
id|total_reclaimed
)paren
r_continue
suffix:semicolon
multiline_comment|/* swsusp: need to do more work */
r_if
c_cond
(paren
id|all_zones_ok
)paren
r_break
suffix:semicolon
multiline_comment|/* kswapd: all done */
multiline_comment|/*&n;&t;&t; * OK, kswapd is getting into trouble.  Take a nap, then take&n;&t;&t; * another pass across the zones.&n;&t;&t; */
r_if
c_cond
(paren
id|total_scanned
op_logical_and
id|priority
OL
id|DEF_PRIORITY
op_minus
l_int|2
)paren
id|blk_congestion_wait
c_func
(paren
id|WRITE
comma
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We do this so kswapd doesn&squot;t build up large priorities for&n;&t;&t; * example when it is freeing in parallel with allocators. It&n;&t;&t; * matches the direct reclaim path behaviour in terms of impact&n;&t;&t; * on zone-&gt;*_priority.&n;&t;&t; */
r_if
c_cond
(paren
id|total_reclaimed
op_ge
id|SWAP_CLUSTER_MAX
)paren
r_break
suffix:semicolon
)brace
id|out
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pgdat-&gt;nr_zones
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|zone
op_star
id|zone
op_assign
id|pgdat-&gt;node_zones
op_plus
id|i
suffix:semicolon
id|zone-&gt;prev_priority
op_assign
id|zone-&gt;temp_priority
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|all_zones_ok
)paren
(brace
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
r_goto
id|loop_again
suffix:semicolon
)brace
r_return
id|total_reclaimed
suffix:semicolon
)brace
multiline_comment|/*&n; * The background pageout daemon, started as a kernel thread&n; * from the init process. &n; *&n; * This basically trickles out pages so that we have _some_&n; * free memory available even if there is no other activity&n; * that frees anything up. This is needed for things like routing&n; * etc, where we otherwise might have all activity going on in&n; * asynchronous contexts that cannot page things out.&n; *&n; * If there are applications that are active memory-allocators&n; * (most normal use), this basically shouldn&squot;t matter.&n; */
DECL|function|kswapd
r_static
r_int
id|kswapd
c_func
(paren
r_void
op_star
id|p
)paren
(brace
r_int
r_int
id|order
suffix:semicolon
id|pg_data_t
op_star
id|pgdat
op_assign
(paren
id|pg_data_t
op_star
)paren
id|p
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DEFINE_WAIT
c_func
(paren
id|wait
)paren
suffix:semicolon
r_struct
id|reclaim_state
id|reclaim_state
op_assign
(brace
dot
id|reclaimed_slab
op_assign
l_int|0
comma
)brace
suffix:semicolon
id|cpumask_t
id|cpumask
suffix:semicolon
id|daemonize
c_func
(paren
l_string|&quot;kswapd%d&quot;
comma
id|pgdat-&gt;node_id
)paren
suffix:semicolon
id|cpumask
op_assign
id|node_to_cpumask
c_func
(paren
id|pgdat-&gt;node_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpus_empty
c_func
(paren
id|cpumask
)paren
)paren
id|set_cpus_allowed
c_func
(paren
id|tsk
comma
id|cpumask
)paren
suffix:semicolon
id|current-&gt;reclaim_state
op_assign
op_amp
id|reclaim_state
suffix:semicolon
multiline_comment|/*&n;&t; * Tell the memory management that we&squot;re a &quot;memory allocator&quot;,&n;&t; * and that if we need more memory we should get access to it&n;&t; * regardless (see &quot;__alloc_pages()&quot;). &quot;kswapd&quot; should&n;&t; * never get caught in the normal page freeing logic.&n;&t; *&n;&t; * (Kswapd normally doesn&squot;t need memory anyway, but sometimes&n;&t; * you need a small amount of memory in order to be able to&n;&t; * page out something else, and this flag essentially protects&n;&t; * us from recursively trying to free more memory as we&squot;re&n;&t; * trying to free the first piece of memory in the first place).&n;&t; */
id|tsk-&gt;flags
op_or_assign
id|PF_MEMALLOC
op_or
id|PF_KSWAPD
suffix:semicolon
id|order
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
r_int
id|new_order
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;flags
op_amp
id|PF_FREEZE
)paren
id|refrigerator
c_func
(paren
id|PF_FREEZE
)paren
suffix:semicolon
id|prepare_to_wait
c_func
(paren
op_amp
id|pgdat-&gt;kswapd_wait
comma
op_amp
id|wait
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|new_order
op_assign
id|pgdat-&gt;kswapd_max_order
suffix:semicolon
id|pgdat-&gt;kswapd_max_order
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|order
OL
id|new_order
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Don&squot;t sleep if someone wants a larger &squot;order&squot;&n;&t;&t;&t; * allocation&n;&t;&t;&t; */
id|order
op_assign
id|new_order
suffix:semicolon
)brace
r_else
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|order
op_assign
id|pgdat-&gt;kswapd_max_order
suffix:semicolon
)brace
id|finish_wait
c_func
(paren
op_amp
id|pgdat-&gt;kswapd_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|balance_pgdat
c_func
(paren
id|pgdat
comma
l_int|0
comma
id|order
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * A zone is low on free memory, so wake its kswapd task to service it.&n; */
DECL|function|wakeup_kswapd
r_void
id|wakeup_kswapd
c_func
(paren
r_struct
id|zone
op_star
id|zone
comma
r_int
id|order
)paren
(brace
id|pg_data_t
op_star
id|pgdat
suffix:semicolon
r_if
c_cond
(paren
id|zone-&gt;present_pages
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|pgdat
op_assign
id|zone-&gt;zone_pgdat
suffix:semicolon
r_if
c_cond
(paren
id|zone_watermark_ok
c_func
(paren
id|zone
comma
id|order
comma
id|zone-&gt;pages_low
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|pgdat-&gt;kswapd_max_order
OL
id|order
)paren
id|pgdat-&gt;kswapd_max_order
op_assign
id|order
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|waitqueue_active
c_func
(paren
op_amp
id|zone-&gt;zone_pgdat-&gt;kswapd_wait
)paren
)paren
r_return
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|zone-&gt;zone_pgdat-&gt;kswapd_wait
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PM
multiline_comment|/*&n; * Try to free `nr_pages&squot; of memory, system-wide.  Returns the number of freed&n; * pages.&n; */
DECL|function|shrink_all_memory
r_int
id|shrink_all_memory
c_func
(paren
r_int
id|nr_pages
)paren
(brace
id|pg_data_t
op_star
id|pgdat
suffix:semicolon
r_int
id|nr_to_free
op_assign
id|nr_pages
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|reclaim_state
id|reclaim_state
op_assign
(brace
dot
id|reclaimed_slab
op_assign
l_int|0
comma
)brace
suffix:semicolon
id|current-&gt;reclaim_state
op_assign
op_amp
id|reclaim_state
suffix:semicolon
id|for_each_pgdat
c_func
(paren
id|pgdat
)paren
(brace
r_int
id|freed
suffix:semicolon
id|freed
op_assign
id|balance_pgdat
c_func
(paren
id|pgdat
comma
id|nr_to_free
comma
l_int|0
)paren
suffix:semicolon
id|ret
op_add_assign
id|freed
suffix:semicolon
id|nr_to_free
op_sub_assign
id|freed
suffix:semicolon
r_if
c_cond
(paren
id|nr_to_free
op_le
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|current-&gt;reclaim_state
op_assign
l_int|NULL
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_HOTPLUG_CPU
multiline_comment|/* It&squot;s optimal to keep kswapds on the same CPUs as their memory, but&n;   not required for correctness.  So if the last cpu in a node goes&n;   away, we get changed to run anywhere: as the first one comes back,&n;   restore their cpu bindings. */
DECL|function|cpu_callback
r_static
r_int
id|__devinit
id|cpu_callback
c_func
(paren
r_struct
id|notifier_block
op_star
id|nfb
comma
r_int
r_int
id|action
comma
r_void
op_star
id|hcpu
)paren
(brace
id|pg_data_t
op_star
id|pgdat
suffix:semicolon
id|cpumask_t
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
id|CPU_ONLINE
)paren
(brace
id|for_each_pgdat
c_func
(paren
id|pgdat
)paren
(brace
id|mask
op_assign
id|node_to_cpumask
c_func
(paren
id|pgdat-&gt;node_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|any_online_cpu
c_func
(paren
id|mask
)paren
op_ne
id|NR_CPUS
)paren
multiline_comment|/* One of our CPUs online: restore mask */
id|set_cpus_allowed
c_func
(paren
id|pgdat-&gt;kswapd
comma
id|mask
)paren
suffix:semicolon
)brace
)brace
r_return
id|NOTIFY_OK
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_HOTPLUG_CPU */
DECL|function|kswapd_init
r_static
r_int
id|__init
id|kswapd_init
c_func
(paren
r_void
)paren
(brace
id|pg_data_t
op_star
id|pgdat
suffix:semicolon
id|swap_setup
c_func
(paren
)paren
suffix:semicolon
id|for_each_pgdat
c_func
(paren
id|pgdat
)paren
id|pgdat-&gt;kswapd
op_assign
id|find_task_by_pid
c_func
(paren
id|kernel_thread
c_func
(paren
id|kswapd
comma
id|pgdat
comma
id|CLONE_KERNEL
)paren
)paren
suffix:semicolon
id|total_memory
op_assign
id|nr_free_pagecache_pages
c_func
(paren
)paren
suffix:semicolon
id|hotcpu_notifier
c_func
(paren
id|cpu_callback
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|module_init
c_func
(paren
id|kswapd_init
)paren
eof
