multiline_comment|/*&n; *  linux/mm/vmscan.c&n; *&n; *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; *&n; *  Swap reorganised 29.12.95, Stephen Tweedie.&n; *  kswapd added: 7.1.96  sct&n; *  Removed kswapd_ctl limits, and swap out as many pages as needed&n; *  to bring the system back to freepages.high: 2.4.97, Rik van Riel.&n; *  Version: $Id: vmscan.c,v 1.5 1998/02/23 22:14:28 sct Exp $&n; *  Zone aware kswapd started 02/00, Kanoj Sarcar (kanoj@sgi.com).&n; *  Multiqueue VM started 5.8.00, Rik van Riel.&n; */
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/swapctl.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
DECL|macro|MAX
mdefine_line|#define MAX(a,b) ((a) &gt; (b) ? (a) : (b))
multiline_comment|/*&n; * The swap-out function returns 1 if it successfully&n; * scanned all the pages it was asked to (`count&squot;).&n; * It returns zero if it couldn&squot;t do anything,&n; *&n; * rss may decrease because pages are shared, but this&n; * doesn&squot;t count as having freed a page.&n; */
multiline_comment|/*&n; * Estimate whether a zone has enough inactive or free pages..&n; */
DECL|function|zone_inactive_plenty
r_static
r_int
r_int
id|zone_inactive_plenty
c_func
(paren
id|zone_t
op_star
id|zone
)paren
(brace
r_int
r_int
id|inactive
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zone-&gt;size
)paren
r_return
l_int|0
suffix:semicolon
id|inactive
op_assign
id|zone-&gt;inactive_dirty_pages
suffix:semicolon
id|inactive
op_add_assign
id|zone-&gt;inactive_clean_pages
suffix:semicolon
id|inactive
op_add_assign
id|zone-&gt;free_pages
suffix:semicolon
r_return
(paren
id|inactive
OG
(paren
id|zone-&gt;size
op_div
l_int|3
)paren
)paren
suffix:semicolon
)brace
DECL|function|zone_inactive_shortage
r_static
r_int
r_int
id|zone_inactive_shortage
c_func
(paren
id|zone_t
op_star
id|zone
)paren
(brace
r_int
r_int
id|inactive
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zone-&gt;size
)paren
r_return
l_int|0
suffix:semicolon
id|inactive
op_assign
id|zone-&gt;inactive_dirty_pages
suffix:semicolon
id|inactive
op_add_assign
id|zone-&gt;inactive_clean_pages
suffix:semicolon
id|inactive
op_add_assign
id|zone-&gt;free_pages
suffix:semicolon
r_return
id|inactive
OL
id|zone-&gt;pages_high
suffix:semicolon
)brace
DECL|function|zone_free_plenty
r_static
r_int
r_int
id|zone_free_plenty
c_func
(paren
id|zone_t
op_star
id|zone
)paren
(brace
r_int
r_int
id|free
suffix:semicolon
id|free
op_assign
id|zone-&gt;free_pages
suffix:semicolon
id|free
op_add_assign
id|zone-&gt;inactive_clean_pages
suffix:semicolon
r_return
id|free
OG
id|zone-&gt;pages_high
op_star
l_int|2
suffix:semicolon
)brace
DECL|function|zone_free_shortage
r_static
r_int
r_int
id|zone_free_shortage
c_func
(paren
id|zone_t
op_star
id|zone
)paren
(brace
r_int
r_int
id|free
suffix:semicolon
id|free
op_assign
id|zone-&gt;free_pages
suffix:semicolon
id|free
op_add_assign
id|zone-&gt;inactive_clean_pages
suffix:semicolon
r_return
id|zone-&gt;size
op_logical_and
id|free
OL
id|zone-&gt;pages_low
suffix:semicolon
)brace
multiline_comment|/* mm-&gt;page_table_lock is held. mmap_sem is not held */
DECL|function|try_to_swap_out
r_static
r_void
id|try_to_swap_out
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
id|pte_t
op_star
id|page_table
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|pte_t
id|pte
suffix:semicolon
id|swp_entry_t
id|entry
suffix:semicolon
multiline_comment|/* &n;&t; * If we are doing a zone-specific scan, do not&n;&t; * touch pages from zones which don&squot;t have a &n;&t; * shortage.&n;&t; */
r_if
c_cond
(paren
id|zone_inactive_plenty
c_func
(paren
id|page-&gt;zone
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Don&squot;t look at this pte if it&squot;s been accessed recently. */
r_if
c_cond
(paren
id|ptep_test_and_clear_young
c_func
(paren
id|page_table
)paren
)paren
(brace
id|page-&gt;age
op_add_assign
id|PAGE_AGE_ADV
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;age
OG
id|PAGE_AGE_MAX
)paren
id|page-&gt;age
op_assign
id|PAGE_AGE_MAX
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TryLockPage
c_func
(paren
id|page
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* From this point on, the odds are that we&squot;re going to&n;&t; * nuke this pte, so read and clear the pte.  This hook&n;&t; * is needed on CPUs which update the accessed and dirty&n;&t; * bits in hardware.&n;&t; */
id|pte
op_assign
id|ptep_get_and_clear
c_func
(paren
id|page_table
)paren
suffix:semicolon
id|flush_tlb_page
c_func
(paren
id|vma
comma
id|address
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Is the page already in the swap cache? If so, then&n;&t; * we can just drop our reference to it without doing&n;&t; * any IO - it&squot;s already up-to-date on disk.&n;&t; */
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
(brace
id|entry.val
op_assign
id|page-&gt;index
suffix:semicolon
r_if
c_cond
(paren
id|pte_dirty
c_func
(paren
id|pte
)paren
)paren
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_swap_pte
suffix:colon
id|swap_duplicate
c_func
(paren
id|entry
)paren
suffix:semicolon
id|set_pte
c_func
(paren
id|page_table
comma
id|swp_entry_to_pte
c_func
(paren
id|entry
)paren
)paren
suffix:semicolon
id|drop_pte
suffix:colon
id|mm-&gt;rss
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;age
)paren
id|deactivate_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Is it a clean page? Then it must be recoverable&n;&t; * by just paging it in again, and we can just drop&n;&t; * it..&n;&t; *&n;&t; * However, this won&squot;t actually free any real&n;&t; * memory, as the page will just be in the page cache&n;&t; * somewhere, and as such we should just continue&n;&t; * our scan.&n;&t; *&n;&t; * Basically, this just makes it possible for us to do&n;&t; * some real work in the future in &quot;refill_inactive()&quot;.&n;&t; */
id|flush_cache_page
c_func
(paren
id|vma
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte_dirty
c_func
(paren
id|pte
)paren
)paren
r_goto
id|drop_pte
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, it&squot;s really dirty. That means that&n;&t; * we should either create a new swap cache&n;&t; * entry for it, or we should write it back&n;&t; * to its own backing store.&n;&t; */
r_if
c_cond
(paren
id|page-&gt;mapping
)paren
(brace
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|drop_pte
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This is a dirty, swappable page.  First of all,&n;&t; * get a suitable swap entry for it, and make sure&n;&t; * we have the swap cache set up to associate the&n;&t; * page with that swap entry.&n;&t; */
id|entry
op_assign
id|get_swap_page
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry.val
)paren
r_goto
id|out_unlock_restore
suffix:semicolon
multiline_comment|/* No swap space left */
multiline_comment|/* Add it to the swap cache and mark it dirty */
id|add_to_swap_cache
c_func
(paren
id|page
comma
id|entry
)paren
suffix:semicolon
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|set_swap_pte
suffix:semicolon
id|out_unlock_restore
suffix:colon
id|set_pte
c_func
(paren
id|page_table
comma
id|pte
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* mm-&gt;page_table_lock is held. mmap_sem is not held */
DECL|function|swap_out_pmd
r_static
r_int
id|swap_out_pmd
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
id|pmd_t
op_star
id|dir
comma
r_int
r_int
id|address
comma
r_int
r_int
id|end
comma
r_int
id|count
)paren
(brace
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
r_int
id|pmd_end
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|dir
)paren
)paren
r_return
id|count
suffix:semicolon
r_if
c_cond
(paren
id|pmd_bad
c_func
(paren
op_star
id|dir
)paren
)paren
(brace
id|pmd_ERROR
c_func
(paren
op_star
id|dir
)paren
suffix:semicolon
id|pmd_clear
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
id|pte
op_assign
id|pte_offset
c_func
(paren
id|dir
comma
id|address
)paren
suffix:semicolon
id|pmd_end
op_assign
(paren
id|address
op_plus
id|PMD_SIZE
)paren
op_amp
id|PMD_MASK
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|pmd_end
)paren
id|end
op_assign
id|pmd_end
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|pte_present
c_func
(paren
op_star
id|pte
)paren
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|pte_page
c_func
(paren
op_star
id|pte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|VALID_PAGE
c_func
(paren
id|page
)paren
op_logical_and
op_logical_neg
id|PageReserved
c_func
(paren
id|page
)paren
)paren
(brace
id|try_to_swap_out
c_func
(paren
id|mm
comma
id|vma
comma
id|address
comma
id|pte
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|count
)paren
r_break
suffix:semicolon
)brace
)brace
id|address
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|pte
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
op_logical_and
(paren
id|address
OL
id|end
)paren
)paren
suffix:semicolon
id|mm-&gt;swap_address
op_assign
id|address
op_plus
id|PAGE_SIZE
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/* mm-&gt;page_table_lock is held. mmap_sem is not held */
DECL|function|swap_out_pgd
r_static
r_inline
r_int
id|swap_out_pgd
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
id|pgd_t
op_star
id|dir
comma
r_int
r_int
id|address
comma
r_int
r_int
id|end
comma
r_int
id|count
)paren
(brace
id|pmd_t
op_star
id|pmd
suffix:semicolon
r_int
r_int
id|pgd_end
suffix:semicolon
r_if
c_cond
(paren
id|pgd_none
c_func
(paren
op_star
id|dir
)paren
)paren
r_return
id|count
suffix:semicolon
r_if
c_cond
(paren
id|pgd_bad
c_func
(paren
op_star
id|dir
)paren
)paren
(brace
id|pgd_ERROR
c_func
(paren
op_star
id|dir
)paren
suffix:semicolon
id|pgd_clear
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|dir
comma
id|address
)paren
suffix:semicolon
id|pgd_end
op_assign
(paren
id|address
op_plus
id|PGDIR_SIZE
)paren
op_amp
id|PGDIR_MASK
suffix:semicolon
r_if
c_cond
(paren
id|pgd_end
op_logical_and
(paren
id|end
OG
id|pgd_end
)paren
)paren
id|end
op_assign
id|pgd_end
suffix:semicolon
r_do
(brace
id|count
op_assign
id|swap_out_pmd
c_func
(paren
id|mm
comma
id|vma
comma
id|pmd
comma
id|address
comma
id|end
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_break
suffix:semicolon
id|address
op_assign
(paren
id|address
op_plus
id|PMD_SIZE
)paren
op_amp
id|PMD_MASK
suffix:semicolon
id|pmd
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
op_logical_and
(paren
id|address
OL
id|end
)paren
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/* mm-&gt;page_table_lock is held. mmap_sem is not held */
DECL|function|swap_out_vma
r_static
r_int
id|swap_out_vma
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
r_int
id|count
)paren
(brace
id|pgd_t
op_star
id|pgdir
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
multiline_comment|/* Don&squot;t swap out areas which are locked down */
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
(paren
id|VM_LOCKED
op_or
id|VM_RESERVED
)paren
)paren
r_return
id|count
suffix:semicolon
id|pgdir
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|address
)paren
suffix:semicolon
id|end
op_assign
id|vma-&gt;vm_end
suffix:semicolon
r_if
c_cond
(paren
id|address
op_ge
id|end
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
id|count
op_assign
id|swap_out_pgd
c_func
(paren
id|mm
comma
id|vma
comma
id|pgdir
comma
id|address
comma
id|end
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_break
suffix:semicolon
id|address
op_assign
(paren
id|address
op_plus
id|PGDIR_SIZE
)paren
op_amp
id|PGDIR_MASK
suffix:semicolon
id|pgdir
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
op_logical_and
(paren
id|address
OL
id|end
)paren
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns non-zero if we scanned all `count&squot; pages&n; */
DECL|function|swap_out_mm
r_static
r_int
id|swap_out_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
id|count
)paren
(brace
r_int
r_int
id|address
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Go through process&squot; page directory.&n;&t; */
multiline_comment|/*&n;&t; * Find the proper vm-area after freezing the vma chain &n;&t; * and ptes.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|address
op_assign
id|mm-&gt;swap_address
suffix:semicolon
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma
)paren
(brace
r_if
c_cond
(paren
id|address
OL
id|vma-&gt;vm_start
)paren
id|address
op_assign
id|vma-&gt;vm_start
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|count
op_assign
id|swap_out_vma
c_func
(paren
id|mm
comma
id|vma
comma
id|address
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_goto
id|out_unlock
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_break
suffix:semicolon
id|address
op_assign
id|vma-&gt;vm_start
suffix:semicolon
)brace
)brace
multiline_comment|/* Reset to 0 when we reach the end of address space */
id|mm-&gt;swap_address
op_assign
l_int|0
suffix:semicolon
id|out_unlock
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_return
op_logical_neg
id|count
suffix:semicolon
)brace
DECL|macro|SWAP_MM_SHIFT
mdefine_line|#define SWAP_MM_SHIFT&t;4
DECL|macro|SWAP_SHIFT
mdefine_line|#define SWAP_SHIFT&t;5
DECL|macro|SWAP_MIN
mdefine_line|#define SWAP_MIN&t;8
DECL|function|swap_amount
r_static
r_inline
r_int
id|swap_amount
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_int
id|nr
op_assign
id|mm-&gt;rss
op_rshift
id|SWAP_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|nr
OL
id|SWAP_MIN
)paren
(brace
id|nr
op_assign
id|SWAP_MIN
suffix:semicolon
r_if
c_cond
(paren
id|nr
OG
id|mm-&gt;rss
)paren
id|nr
op_assign
id|mm-&gt;rss
suffix:semicolon
)brace
r_return
id|nr
suffix:semicolon
)brace
DECL|function|swap_out
r_static
r_void
id|swap_out
c_func
(paren
r_int
r_int
id|priority
comma
r_int
id|gfp_mask
)paren
(brace
r_int
id|counter
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
multiline_comment|/* Always start by trying to penalize the process that is allocating memory */
r_if
c_cond
(paren
id|mm
)paren
id|retval
op_assign
id|swap_out_mm
c_func
(paren
id|mm
comma
id|swap_amount
c_func
(paren
id|mm
)paren
)paren
suffix:semicolon
multiline_comment|/* Then, look at the other mm&squot;s */
id|counter
op_assign
(paren
id|mmlist_nr
op_lshift
id|SWAP_MM_SHIFT
)paren
op_rshift
id|priority
suffix:semicolon
r_do
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mmlist_lock
)paren
suffix:semicolon
id|p
op_assign
id|init_mm.mmlist.next
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
op_amp
id|init_mm.mmlist
)paren
r_goto
id|empty
suffix:semicolon
multiline_comment|/* Move it to the back of the queue.. */
id|list_del
c_func
(paren
id|p
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
id|p
comma
op_amp
id|init_mm.mmlist
)paren
suffix:semicolon
id|mm
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|mm_struct
comma
id|mmlist
)paren
suffix:semicolon
multiline_comment|/* Make sure the mm doesn&squot;t disappear when we drop the lock.. */
id|atomic_inc
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mmlist_lock
)paren
suffix:semicolon
multiline_comment|/* Walk about 6% of the address space each time */
id|retval
op_or_assign
id|swap_out_mm
c_func
(paren
id|mm
comma
id|swap_amount
c_func
(paren
id|mm
)paren
)paren
suffix:semicolon
id|mmput
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|counter
op_ge
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
id|empty
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|mmlist_lock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * reclaim_page -&t;reclaims one page from the inactive_clean list&n; * @zone: reclaim a page from this zone&n; *&n; * The pages on the inactive_clean can be instantly reclaimed.&n; * The tests look impressive, but most of the time we&squot;ll grab&n; * the first page of the list and exit successfully.&n; */
DECL|function|reclaim_page
r_struct
id|page
op_star
id|reclaim_page
c_func
(paren
id|zone_t
op_star
id|zone
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|list_head
op_star
id|page_lru
suffix:semicolon
r_int
id|maxscan
suffix:semicolon
multiline_comment|/*&n;&t; * We only need the pagemap_lru_lock if we don&squot;t reclaim the page,&n;&t; * but we have to grab the pagecache_lock before the pagemap_lru_lock&n;&t; * to avoid deadlocks and most of the time we&squot;ll succeed anyway.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
id|maxscan
op_assign
id|zone-&gt;inactive_clean_pages
suffix:semicolon
r_while
c_loop
(paren
(paren
id|page_lru
op_assign
id|zone-&gt;inactive_clean_list.prev
)paren
op_ne
op_amp
id|zone-&gt;inactive_clean_list
op_logical_and
id|maxscan
op_decrement
)paren
(brace
id|page
op_assign
id|list_entry
c_func
(paren
id|page_lru
comma
r_struct
id|page
comma
id|lru
)paren
suffix:semicolon
multiline_comment|/* Wrong page on list?! (list corruption, should not happen) */
r_if
c_cond
(paren
op_logical_neg
id|PageInactiveClean
c_func
(paren
id|page
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VM: reclaim_page, wrong page on list.&bslash;n&quot;
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|page_lru
)paren
suffix:semicolon
id|page-&gt;zone-&gt;inactive_clean_pages
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Page is or was in use?  Move it to the active list. */
r_if
c_cond
(paren
id|PageReferenced
c_func
(paren
id|page
)paren
op_logical_or
(paren
op_logical_neg
id|page-&gt;buffers
op_logical_and
id|page_count
c_func
(paren
id|page
)paren
OG
l_int|1
)paren
)paren
(brace
id|del_page_from_inactive_clean_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|add_page_to_active_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|page-&gt;age
op_assign
id|PAGE_AGE_START
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* The page is dirty, or locked, move to inactive_dirty list. */
r_if
c_cond
(paren
id|page-&gt;buffers
op_logical_or
id|PageDirty
c_func
(paren
id|page
)paren
op_logical_or
id|TryLockPage
c_func
(paren
id|page
)paren
)paren
(brace
id|del_page_from_inactive_clean_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|add_page_to_inactive_dirty_list
c_func
(paren
id|page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* OK, remove the page from the caches. */
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
(brace
id|__delete_from_swap_cache
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|found_page
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page-&gt;mapping
)paren
(brace
id|__remove_inode_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|found_page
suffix:semicolon
)brace
multiline_comment|/* We should never ever get here. */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VM: reclaim_page, found unknown page&bslash;n&quot;
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|page_lru
)paren
suffix:semicolon
id|zone-&gt;inactive_clean_pages
op_decrement
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/* Reset page pointer, maybe we encountered an unfreeable page. */
id|page
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|found_page
suffix:colon
id|memory_pressure
op_increment
suffix:semicolon
id|del_page_from_inactive_clean_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page-&gt;age
op_assign
id|PAGE_AGE_START
suffix:semicolon
r_if
c_cond
(paren
id|page_count
c_func
(paren
id|page
)paren
op_ne
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;VM: reclaim_page, found page with count %d!&bslash;n&quot;
comma
id|page_count
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagecache_lock
)paren
suffix:semicolon
r_return
id|page
suffix:semicolon
)brace
multiline_comment|/**&n; * page_launder - clean dirty inactive pages, move to inactive_clean list&n; * @gfp_mask: what operations we are allowed to do&n; * @sync: are we allowed to do synchronous IO in emergencies ?&n; *&n; * When this function is called, we are most likely low on free +&n; * inactive_clean pages. Since we want to refill those pages as&n; * soon as possible, we&squot;ll make two loops over the inactive list,&n; * one to move the already cleaned pages to the inactive_clean lists&n; * and one to (often asynchronously) clean the dirty inactive pages.&n; *&n; * In situations where kswapd cannot keep up, user processes will&n; * end up calling this function. Since the user process needs to&n; * have a page before it can continue with its allocation, we&squot;ll&n; * do synchronous page flushing in that case.&n; *&n; * This code is heavily inspired by the FreeBSD source code. Thanks&n; * go out to Matthew Dillon.&n; */
DECL|macro|MAX_LAUNDER
mdefine_line|#define MAX_LAUNDER &t;&t;(4 * (1 &lt;&lt; page_cluster))
DECL|macro|CAN_DO_FS
mdefine_line|#define CAN_DO_FS&t;&t;(gfp_mask &amp; __GFP_FS)
DECL|macro|CAN_DO_IO
mdefine_line|#define CAN_DO_IO&t;&t;(gfp_mask &amp; __GFP_IO)
DECL|function|page_launder
r_int
id|page_launder
c_func
(paren
r_int
id|gfp_mask
comma
r_int
id|sync
)paren
(brace
r_int
id|launder_loop
comma
id|maxscan
comma
id|cleaned_pages
comma
id|maxlaunder
suffix:semicolon
r_struct
id|list_head
op_star
id|page_lru
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|launder_loop
op_assign
l_int|0
suffix:semicolon
id|maxlaunder
op_assign
l_int|0
suffix:semicolon
id|cleaned_pages
op_assign
l_int|0
suffix:semicolon
id|dirty_page_rescan
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
id|maxscan
op_assign
id|nr_inactive_dirty_pages
suffix:semicolon
r_while
c_loop
(paren
(paren
id|page_lru
op_assign
id|inactive_dirty_list.prev
)paren
op_ne
op_amp
id|inactive_dirty_list
op_logical_and
id|maxscan
op_decrement
OG
l_int|0
)paren
(brace
id|page
op_assign
id|list_entry
c_func
(paren
id|page_lru
comma
r_struct
id|page
comma
id|lru
)paren
suffix:semicolon
multiline_comment|/* Wrong page on list?! (list corruption, should not happen) */
r_if
c_cond
(paren
op_logical_neg
id|PageInactiveDirty
c_func
(paren
id|page
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VM: page_launder, wrong page on list.&bslash;n&quot;
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|page_lru
)paren
suffix:semicolon
id|nr_inactive_dirty_pages
op_decrement
suffix:semicolon
id|page-&gt;zone-&gt;inactive_dirty_pages
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Page is or was in use?  Move it to the active list. */
r_if
c_cond
(paren
id|PageReferenced
c_func
(paren
id|page
)paren
op_logical_or
(paren
op_logical_neg
id|page-&gt;buffers
op_logical_and
id|page_count
c_func
(paren
id|page
)paren
OG
l_int|1
)paren
op_logical_or
id|page_ramdisk
c_func
(paren
id|page
)paren
)paren
(brace
id|del_page_from_inactive_dirty_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|add_page_to_active_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|page-&gt;age
op_assign
id|PAGE_AGE_START
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * If this zone has plenty of pages free,&n;&t;&t; * don&squot;t spend time on cleaning it.&n;&t;&t; */
r_if
c_cond
(paren
id|zone_free_plenty
c_func
(paren
id|page-&gt;zone
)paren
)paren
(brace
id|list_del
c_func
(paren
id|page_lru
)paren
suffix:semicolon
id|list_add
c_func
(paren
id|page_lru
comma
op_amp
id|inactive_dirty_list
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The page is locked. IO in progress?&n;&t;&t; * Move it to the back of the list.&n;&t;&t; */
r_if
c_cond
(paren
id|TryLockPage
c_func
(paren
id|page
)paren
)paren
(brace
id|list_del
c_func
(paren
id|page_lru
)paren
suffix:semicolon
id|list_add
c_func
(paren
id|page_lru
comma
op_amp
id|inactive_dirty_list
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Dirty swap-cache page? Write it out if&n;&t;&t; * last copy..&n;&t;&t; */
r_if
c_cond
(paren
id|PageDirty
c_func
(paren
id|page
)paren
)paren
(brace
r_int
(paren
op_star
id|writepage
)paren
(paren
r_struct
id|page
op_star
)paren
op_assign
id|page-&gt;mapping-&gt;a_ops-&gt;writepage
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|writepage
)paren
r_goto
id|page_active
suffix:semicolon
multiline_comment|/* First time through? Move it to the back of the list */
r_if
c_cond
(paren
op_logical_neg
id|launder_loop
op_logical_or
op_logical_neg
id|CAN_DO_FS
)paren
(brace
id|list_del
c_func
(paren
id|page_lru
)paren
suffix:semicolon
id|list_add
c_func
(paren
id|page_lru
comma
op_amp
id|inactive_dirty_list
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* OK, do a physical asynchronous write to swap.  */
id|ClearPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
id|writepage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* And re-start the thing.. */
id|spin_lock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If the page has buffers, try to free the buffer mappings&n;&t;&t; * associated with this page. If we succeed we either free&n;&t;&t; * the page (in case it was a buffercache only page) or we&n;&t;&t; * move the page to the inactive_clean list.&n;&t;&t; *&n;&t;&t; * On the first round, we should free all previously cleaned&n;&t;&t; * buffer pages&n;&t;&t; */
r_if
c_cond
(paren
id|page-&gt;buffers
)paren
(brace
r_int
r_int
id|buffer_mask
suffix:semicolon
r_int
id|clearedbuf
suffix:semicolon
r_int
id|freed_page
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Since we might be doing disk IO, we have to&n;&t;&t;&t; * drop the spinlock and take an extra reference&n;&t;&t;&t; * on the page so it doesn&squot;t go away from under us.&n;&t;&t;&t; */
id|del_page_from_inactive_dirty_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
multiline_comment|/* Will we do (asynchronous) IO? */
r_if
c_cond
(paren
id|launder_loop
op_logical_and
id|maxlaunder
op_eq
l_int|0
op_logical_and
id|sync
)paren
id|buffer_mask
op_assign
id|gfp_mask
suffix:semicolon
multiline_comment|/* Do as much as we can */
r_else
r_if
c_cond
(paren
id|launder_loop
op_logical_and
id|maxlaunder
op_decrement
OG
l_int|0
)paren
id|buffer_mask
op_assign
id|gfp_mask
op_amp
op_complement
id|__GFP_WAIT
suffix:semicolon
multiline_comment|/* Don&squot;t wait, async write-out */
r_else
id|buffer_mask
op_assign
id|gfp_mask
op_amp
op_complement
(paren
id|__GFP_WAIT
op_or
id|__GFP_IO
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t even start IO */
multiline_comment|/* Try to free the page buffers. */
id|clearedbuf
op_assign
id|try_to_free_buffers
c_func
(paren
id|page
comma
id|buffer_mask
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Re-take the spinlock. Note that we cannot&n;&t;&t;&t; * unlock the page yet since we&squot;re still&n;&t;&t;&t; * accessing the page_struct here...&n;&t;&t;&t; */
id|spin_lock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
multiline_comment|/* The buffers were not freed. */
r_if
c_cond
(paren
op_logical_neg
id|clearedbuf
)paren
(brace
id|add_page_to_inactive_dirty_list
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* The page was only in the buffer cache. */
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;mapping
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|buffermem_pages
)paren
suffix:semicolon
id|freed_page
op_assign
l_int|1
suffix:semicolon
id|cleaned_pages
op_increment
suffix:semicolon
multiline_comment|/* The page has more users besides the cache and us. */
)brace
r_else
r_if
c_cond
(paren
id|page_count
c_func
(paren
id|page
)paren
OG
l_int|2
)paren
(brace
id|add_page_to_active_list
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* OK, we &quot;created&quot; a freeable page. */
)brace
r_else
multiline_comment|/* page-&gt;mapping &amp;&amp; page_count(page) == 2 */
(brace
id|add_page_to_inactive_clean_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|cleaned_pages
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Unlock the page and drop the extra reference.&n;&t;&t;&t; * We can only do it here because we are accessing&n;&t;&t;&t; * the page struct above.&n;&t;&t;&t; */
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; * If we&squot;re freeing buffer cache pages, stop when&n;&t;&t;&t; * we&squot;ve got enough free memory.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|freed_page
op_logical_and
op_logical_neg
id|total_free_shortage
c_func
(paren
)paren
)paren
r_break
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|page-&gt;mapping
op_logical_and
op_logical_neg
id|PageDirty
c_func
(paren
id|page
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If a page had an extra reference in&n;&t;&t;&t; * deactivate_page(), we will find it here.&n;&t;&t;&t; * Now the page is really freeable, so we&n;&t;&t;&t; * move it to the inactive_clean list.&n;&t;&t;&t; */
id|del_page_from_inactive_dirty_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|add_page_to_inactive_clean_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|cleaned_pages
op_increment
suffix:semicolon
)brace
r_else
(brace
id|page_active
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * OK, we don&squot;t know what to do with the page.&n;&t;&t;&t; * It&squot;s no use keeping it here, so we move it to&n;&t;&t;&t; * the active list.&n;&t;&t;&t; */
id|del_page_from_inactive_dirty_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|add_page_to_active_list
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we don&squot;t have enough free pages, we loop back once&n;&t; * to queue the dirty pages for writeout. When we were called&n;&t; * by a user process (that /needs/ a free page) and we didn&squot;t&n;&t; * free anything yet, we wait synchronously on the writeout of&n;&t; * MAX_SYNC_LAUNDER pages.&n;&t; *&n;&t; * We also wake up bdflush, since bdflush should, under most&n;&t; * loads, flush out the dirty pages before we have to wait on&n;&t; * IO.&n;&t; */
r_if
c_cond
(paren
id|CAN_DO_IO
op_logical_and
op_logical_neg
id|launder_loop
op_logical_and
id|total_free_shortage
c_func
(paren
)paren
)paren
(brace
id|launder_loop
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* If we cleaned pages, never do synchronous IO. */
r_if
c_cond
(paren
id|cleaned_pages
)paren
id|sync
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We only do a few &quot;out of order&quot; flushes. */
id|maxlaunder
op_assign
id|MAX_LAUNDER
suffix:semicolon
multiline_comment|/* Kflushd takes care of the rest. */
id|wakeup_bdflush
c_func
(paren
)paren
suffix:semicolon
r_goto
id|dirty_page_rescan
suffix:semicolon
)brace
multiline_comment|/* Return the number of pages moved to the inactive_clean list. */
r_return
id|cleaned_pages
suffix:semicolon
)brace
DECL|function|age_page_up
r_static
r_inline
r_void
id|age_page_up
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
id|age
op_assign
id|page-&gt;age
op_plus
id|PAGE_AGE_ADV
suffix:semicolon
r_if
c_cond
(paren
id|age
OG
id|PAGE_AGE_MAX
)paren
id|age
op_assign
id|PAGE_AGE_MAX
suffix:semicolon
id|page-&gt;age
op_assign
id|age
suffix:semicolon
)brace
multiline_comment|/**&n; * refill_inactive_scan - scan the active list and find pages to deactivate&n; * @priority: the priority at which to scan&n; * @target: number of pages to deactivate, zero for background aging&n; *&n; * This function will scan a portion of the active list to find&n; * unused pages, those pages will then be moved to the inactive list.&n; */
DECL|function|refill_inactive_scan
r_int
id|refill_inactive_scan
c_func
(paren
id|zone_t
op_star
id|zone
comma
r_int
r_int
id|priority
comma
r_int
id|target
)paren
(brace
r_struct
id|list_head
op_star
id|page_lru
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|maxscan
op_assign
id|nr_active_pages
op_rshift
id|priority
suffix:semicolon
r_int
id|page_active
op_assign
l_int|0
suffix:semicolon
r_int
id|nr_deactivated
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * When we are background aging, we try to increase the page aging&n;&t; * information in the system.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|target
)paren
id|maxscan
op_assign
id|nr_active_pages
op_rshift
l_int|4
suffix:semicolon
multiline_comment|/* Take the lock while messing with the list... */
id|spin_lock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|maxscan
op_decrement
OG
l_int|0
op_logical_and
(paren
id|page_lru
op_assign
id|active_list.prev
)paren
op_ne
op_amp
id|active_list
)paren
(brace
id|page
op_assign
id|list_entry
c_func
(paren
id|page_lru
comma
r_struct
id|page
comma
id|lru
)paren
suffix:semicolon
multiline_comment|/* Wrong page on list?! (list corruption, should not happen) */
r_if
c_cond
(paren
op_logical_neg
id|PageActive
c_func
(paren
id|page
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VM: refill_inactive, wrong page on list.&bslash;n&quot;
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|page_lru
)paren
suffix:semicolon
id|nr_active_pages
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Do not deactivate pages from zones which &n;&t;&t; * have plenty inactive pages.&n;&t;&t; */
r_if
c_cond
(paren
id|zone_inactive_plenty
c_func
(paren
id|page-&gt;zone
)paren
)paren
(brace
id|page_active
op_assign
l_int|1
suffix:semicolon
r_goto
id|skip_page
suffix:semicolon
)brace
multiline_comment|/* Do aging on the pages. */
r_if
c_cond
(paren
id|PageTestandClearReferenced
c_func
(paren
id|page
)paren
)paren
(brace
id|age_page_up
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_active
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|age_page_down_ageonly
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Since we don&squot;t hold a reference on the page&n;&t;&t;&t; * ourselves, we have to do our test a bit more&n;&t;&t;&t; * strict then deactivate_page(). This is needed&n;&t;&t;&t; * since otherwise the system could hang shuffling&n;&t;&t;&t; * unfreeable pages from the active list to the&n;&t;&t;&t; * inactive_dirty list and back again...&n;&t;&t;&t; *&n;&t;&t;&t; * SUBTLE: we can have buffer pages with count 1.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|page-&gt;age
op_eq
l_int|0
op_logical_and
id|page_count
c_func
(paren
id|page
)paren
op_le
(paren
id|page-&gt;buffers
ques
c_cond
l_int|2
suffix:colon
l_int|1
)paren
)paren
(brace
id|deactivate_page_nolock
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_active
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|page_active
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * If the page is still on the active list, move it&n;&t;&t; * to the other end of the list. Otherwise we exit if&n;&t;&t; * we have done enough work.&n;&t;&t; */
r_if
c_cond
(paren
id|page_active
op_logical_or
id|PageActive
c_func
(paren
id|page
)paren
)paren
(brace
id|skip_page
suffix:colon
id|list_del
c_func
(paren
id|page_lru
)paren
suffix:semicolon
id|list_add
c_func
(paren
id|page_lru
comma
op_amp
id|active_list
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|zone
op_logical_or
(paren
id|zone
op_logical_and
(paren
id|zone
op_eq
id|page-&gt;zone
)paren
)paren
)paren
id|nr_deactivated
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|target
op_logical_and
id|nr_deactivated
op_ge
id|target
)paren
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pagemap_lru_lock
)paren
suffix:semicolon
r_return
id|nr_deactivated
suffix:semicolon
)brace
multiline_comment|/*&n; * Check if we have are low on free pages globally.&n; */
DECL|function|free_shortage
r_int
id|free_shortage
c_func
(paren
r_void
)paren
(brace
r_int
id|freeable
op_assign
id|nr_free_pages
c_func
(paren
)paren
op_plus
id|nr_inactive_clean_pages
c_func
(paren
)paren
suffix:semicolon
r_int
id|freetarget
op_assign
id|freepages.high
suffix:semicolon
multiline_comment|/* Are we low on free pages globally? */
r_if
c_cond
(paren
id|freeable
OL
id|freetarget
)paren
r_return
id|freetarget
op_minus
id|freeable
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&n; * Check if there are zones with a severe shortage of free pages,&n; * or if all zones have a minor shortage.&n; */
DECL|function|total_free_shortage
r_int
id|total_free_shortage
c_func
(paren
r_void
)paren
(brace
r_int
id|sum
op_assign
l_int|0
suffix:semicolon
id|pg_data_t
op_star
id|pgdat
op_assign
id|pgdat_list
suffix:semicolon
multiline_comment|/* Do we have a global free shortage? */
r_if
c_cond
(paren
(paren
id|sum
op_assign
id|free_shortage
c_func
(paren
)paren
)paren
)paren
(brace
r_return
id|sum
suffix:semicolon
)brace
multiline_comment|/* If not, are we very low on any particular zone? */
r_do
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_ZONES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|zone_t
op_star
id|zone
op_assign
id|pgdat-&gt;node_zones
op_plus
id|i
suffix:semicolon
id|sum
op_add_assign
id|zone_free_shortage
c_func
(paren
id|zone
)paren
suffix:semicolon
)brace
id|pgdat
op_assign
id|pgdat-&gt;node_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pgdat
)paren
suffix:semicolon
r_return
id|sum
suffix:semicolon
)brace
multiline_comment|/*&n; * How many inactive pages are we short globally?&n; */
DECL|function|inactive_shortage
r_int
id|inactive_shortage
c_func
(paren
r_void
)paren
(brace
r_int
id|shortage
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Is the inactive dirty list too small? */
id|shortage
op_add_assign
id|freepages.high
suffix:semicolon
id|shortage
op_add_assign
id|inactive_target
suffix:semicolon
id|shortage
op_sub_assign
id|nr_free_pages
c_func
(paren
)paren
suffix:semicolon
id|shortage
op_sub_assign
id|nr_inactive_clean_pages
c_func
(paren
)paren
suffix:semicolon
id|shortage
op_sub_assign
id|nr_inactive_dirty_pages
suffix:semicolon
r_if
c_cond
(paren
id|shortage
OG
l_int|0
)paren
r_return
id|shortage
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Are we low on inactive pages globally or in any zone?&n; */
DECL|function|total_inactive_shortage
r_int
id|total_inactive_shortage
c_func
(paren
r_void
)paren
(brace
r_int
id|shortage
op_assign
l_int|0
suffix:semicolon
id|pg_data_t
op_star
id|pgdat
op_assign
id|pgdat_list
suffix:semicolon
r_if
c_cond
(paren
(paren
id|shortage
op_assign
id|inactive_shortage
c_func
(paren
)paren
)paren
)paren
(brace
r_return
id|shortage
suffix:semicolon
)brace
id|shortage
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_ZONES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|zone_shortage
suffix:semicolon
id|zone_t
op_star
id|zone
op_assign
id|pgdat-&gt;node_zones
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zone-&gt;size
)paren
r_continue
suffix:semicolon
id|zone_shortage
op_assign
id|zone-&gt;pages_high
suffix:semicolon
id|zone_shortage
op_sub_assign
id|zone-&gt;inactive_dirty_pages
suffix:semicolon
id|zone_shortage
op_sub_assign
id|zone-&gt;inactive_clean_pages
suffix:semicolon
id|zone_shortage
op_sub_assign
id|zone-&gt;free_pages
suffix:semicolon
r_if
c_cond
(paren
id|zone_shortage
OG
l_int|0
)paren
id|shortage
op_add_assign
id|zone_shortage
suffix:semicolon
)brace
id|pgdat
op_assign
id|pgdat-&gt;node_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pgdat
)paren
suffix:semicolon
r_return
id|shortage
suffix:semicolon
)brace
multiline_comment|/*&n; * Refill_inactive is the function used to scan and age the pages on&n; * the active list and in the working set of processes, moving the&n; * little-used pages to the inactive list.&n; *&n; * When called by kswapd, we try to deactivate as many pages as needed&n; * to recover from the inactive page shortage. This makes it possible&n; * for kswapd to keep up with memory demand so user processes can get&n; * low latency on memory allocations.&n; *&n; * However, when the system starts to get overloaded we can get called&n; * by user processes. For user processes we want to both reduce the&n; * latency and make sure that multiple user processes together don&squot;t&n; * deactivate too many pages. To achieve this we simply do less work&n; * when called from a user process.&n; */
DECL|macro|DEF_PRIORITY
mdefine_line|#define DEF_PRIORITY (6)
DECL|function|refill_inactive_global
r_static
r_int
id|refill_inactive_global
c_func
(paren
r_int
r_int
id|gfp_mask
comma
r_int
id|user
)paren
(brace
r_int
id|count
comma
id|start_count
comma
id|maxtry
suffix:semicolon
r_if
c_cond
(paren
id|user
)paren
(brace
id|count
op_assign
(paren
l_int|1
op_lshift
id|page_cluster
)paren
suffix:semicolon
id|maxtry
op_assign
l_int|6
suffix:semicolon
)brace
r_else
(brace
id|count
op_assign
id|inactive_shortage
c_func
(paren
)paren
suffix:semicolon
id|maxtry
op_assign
l_int|1
op_lshift
id|DEF_PRIORITY
suffix:semicolon
)brace
id|start_count
op_assign
id|count
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|current-&gt;need_resched
)paren
(brace
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inactive_shortage
c_func
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Walk the VM space for a bit.. */
id|swap_out
c_func
(paren
id|DEF_PRIORITY
comma
id|gfp_mask
)paren
suffix:semicolon
id|count
op_sub_assign
id|refill_inactive_scan
c_func
(paren
l_int|NULL
comma
id|DEF_PRIORITY
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_le
l_int|0
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|maxtry
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|inactive_shortage
c_func
(paren
)paren
)paren
suffix:semicolon
id|done
suffix:colon
r_return
(paren
id|count
OL
id|start_count
)paren
suffix:semicolon
)brace
DECL|function|refill_inactive_zone
r_static
r_int
id|refill_inactive_zone
c_func
(paren
id|zone_t
op_star
id|zone
comma
r_int
r_int
id|gfp_mask
comma
r_int
id|user
)paren
(brace
r_int
id|count
comma
id|start_count
comma
id|maxtry
suffix:semicolon
id|count
op_assign
id|start_count
op_assign
id|zone_inactive_shortage
c_func
(paren
id|zone
)paren
suffix:semicolon
id|maxtry
op_assign
(paren
l_int|1
op_lshift
id|DEF_PRIORITY
)paren
suffix:semicolon
r_do
(brace
id|swap_out
c_func
(paren
id|DEF_PRIORITY
comma
id|gfp_mask
)paren
suffix:semicolon
id|count
op_sub_assign
id|refill_inactive_scan
c_func
(paren
id|zone
comma
id|DEF_PRIORITY
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_le
l_int|0
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|maxtry
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|zone_inactive_shortage
c_func
(paren
id|zone
)paren
)paren
(brace
suffix:semicolon
)brace
id|done
suffix:colon
r_return
(paren
id|count
OL
id|start_count
)paren
suffix:semicolon
)brace
DECL|function|refill_inactive
r_static
r_int
id|refill_inactive
c_func
(paren
r_int
r_int
id|gfp_mask
comma
r_int
id|user
)paren
(brace
r_int
id|type
op_assign
l_int|0
comma
id|ret
op_assign
l_int|0
suffix:semicolon
id|pg_data_t
op_star
id|pgdat
op_assign
id|pgdat_list
suffix:semicolon
multiline_comment|/*&n;&t; * First do a global scan if there is a &n;&t; * global shortage.&n;&t; */
r_if
c_cond
(paren
id|inactive_shortage
c_func
(paren
)paren
)paren
id|ret
op_add_assign
id|refill_inactive_global
c_func
(paren
id|gfp_mask
comma
id|user
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Then check if there is any specific zone &n;&t; * with a shortage and try to refill it if&n;&t; * so.&n;&t; */
r_for
c_loop
(paren
id|type
op_assign
l_int|0
suffix:semicolon
id|type
OL
id|MAX_NR_ZONES
suffix:semicolon
id|type
op_increment
)paren
(brace
id|zone_t
op_star
id|zone
op_assign
id|pgdat-&gt;node_zones
op_plus
id|type
suffix:semicolon
r_if
c_cond
(paren
id|zone_inactive_shortage
c_func
(paren
id|zone
)paren
)paren
id|ret
op_add_assign
id|refill_inactive_zone
c_func
(paren
id|zone
comma
id|gfp_mask
comma
id|user
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|macro|DEF_PRIORITY
mdefine_line|#define DEF_PRIORITY (6)
DECL|function|do_try_to_free_pages
r_static
r_int
id|do_try_to_free_pages
c_func
(paren
r_int
r_int
id|gfp_mask
comma
r_int
id|user
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re low on free pages, move pages from the&n;&t; * inactive_dirty list to the inactive_clean list.&n;&t; *&n;&t; * Usually bdflush will have pre-cleaned the pages&n;&t; * before we get around to moving them to the other&n;&t; * list, so this is a relatively cheap operation.&n;&t; */
id|ret
op_add_assign
id|page_launder
c_func
(paren
id|gfp_mask
comma
id|user
)paren
suffix:semicolon
id|ret
op_add_assign
id|shrink_dcache_memory
c_func
(paren
id|DEF_PRIORITY
comma
id|gfp_mask
)paren
suffix:semicolon
id|ret
op_add_assign
id|shrink_icache_memory
c_func
(paren
id|DEF_PRIORITY
comma
id|gfp_mask
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If needed, we move pages from the active list&n;&t; * to the inactive list.&n;&t; */
id|ret
op_add_assign
id|refill_inactive
c_func
(paren
id|gfp_mask
comma
id|user
)paren
suffix:semicolon
multiline_comment|/* &t;&n;&t; * Reclaim unused slab cache if memory is low.&n;&t; */
id|kmem_cache_reap
c_func
(paren
id|gfp_mask
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|kswapd_wait
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|kswapd_wait
)paren
suffix:semicolon
DECL|variable|kswapd_done
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|kswapd_done
)paren
suffix:semicolon
multiline_comment|/*&n; * The background pageout daemon, started as a kernel thread&n; * from the init process. &n; *&n; * This basically trickles out pages so that we have _some_&n; * free memory available even if there is no other activity&n; * that frees anything up. This is needed for things like routing&n; * etc, where we otherwise might have all activity going on in&n; * asynchronous contexts that cannot page things out.&n; *&n; * If there are applications that are active memory-allocators&n; * (most normal use), this basically shouldn&squot;t matter.&n; */
DECL|function|kswapd
r_int
id|kswapd
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|daemonize
c_func
(paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|tsk-&gt;comm
comma
l_string|&quot;kswapd&quot;
)paren
suffix:semicolon
id|sigfillset
c_func
(paren
op_amp
id|tsk-&gt;blocked
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Tell the memory management that we&squot;re a &quot;memory allocator&quot;,&n;&t; * and that if we need more memory we should get access to it&n;&t; * regardless (see &quot;__alloc_pages()&quot;). &quot;kswapd&quot; should&n;&t; * never get caught in the normal page freeing logic.&n;&t; *&n;&t; * (Kswapd normally doesn&squot;t need memory anyway, but sometimes&n;&t; * you need a small amount of memory in order to be able to&n;&t; * page out something else, and this flag essentially protects&n;&t; * us from recursively trying to free more memory as we&squot;re&n;&t; * trying to free the first piece of memory in the first place).&n;&t; */
id|tsk-&gt;flags
op_or_assign
id|PF_MEMALLOC
suffix:semicolon
multiline_comment|/*&n;&t; * Kswapd main loop.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_static
r_int
id|recalc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If needed, try to free some memory. */
r_if
c_cond
(paren
id|total_inactive_shortage
c_func
(paren
)paren
op_logical_or
id|total_free_shortage
c_func
(paren
)paren
)paren
id|do_try_to_free_pages
c_func
(paren
id|GFP_KSWAPD
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Once a second ... */
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|recalc
op_plus
id|HZ
)paren
)paren
(brace
id|recalc
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Recalculate VM statistics. */
id|recalculate_vm_stats
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Do background page aging. */
id|refill_inactive_scan
c_func
(paren
l_int|NULL
comma
id|DEF_PRIORITY
comma
l_int|0
)paren
suffix:semicolon
)brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * We go to sleep if either the free page shortage&n;&t;&t; * or the inactive page shortage is gone. We do this&n;&t;&t; * because:&n;&t;&t; * 1) we need no more free pages   or&n;&t;&t; * 2) the inactive pages need to be flushed to disk,&n;&t;&t; *    it wouldn&squot;t help to eat CPU time now ...&n;&t;&t; *&n;&t;&t; * We go to sleep for one second, but if it&squot;s needed&n;&t;&t; * we&squot;ll be woken up earlier...&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|total_free_shortage
c_func
(paren
)paren
op_logical_or
op_logical_neg
id|total_inactive_shortage
c_func
(paren
)paren
)paren
(brace
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|kswapd_wait
comma
id|HZ
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we couldn&squot;t free enough memory, we see if it was&n;&t;&t; * due to the system just not having enough memory.&n;&t;&t; * If that is the case, the only solution is to kill&n;&t;&t; * a process (the alternative is enternal deadlock).&n;&t;&t; *&n;&t;&t; * If there still is enough memory around, we just loop&n;&t;&t; * and try free some more memory...&n;&t;&t; */
)brace
r_else
r_if
c_cond
(paren
id|out_of_memory
c_func
(paren
)paren
)paren
(brace
id|oom_kill
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|wakeup_kswapd
r_void
id|wakeup_kswapd
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|kswapd_wait
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|kswapd_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by non-kswapd processes when they want more&n; * memory but are unable to sleep on kswapd because&n; * they might be holding some IO locks ...&n; */
DECL|function|try_to_free_pages
r_int
id|try_to_free_pages
c_func
(paren
r_int
r_int
id|gfp_mask
)paren
(brace
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|gfp_mask
op_amp
id|__GFP_WAIT
)paren
(brace
id|current-&gt;flags
op_or_assign
id|PF_MEMALLOC
suffix:semicolon
id|ret
op_assign
id|do_try_to_free_pages
c_func
(paren
id|gfp_mask
comma
l_int|1
)paren
suffix:semicolon
id|current-&gt;flags
op_and_assign
op_complement
id|PF_MEMALLOC
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|kreclaimd_wait
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|kreclaimd_wait
)paren
suffix:semicolon
multiline_comment|/*&n; * Kreclaimd will move pages from the inactive_clean list to the&n; * free list, in order to keep atomic allocations possible under&n; * all circumstances.&n; */
DECL|function|kreclaimd
r_int
id|kreclaimd
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|pg_data_t
op_star
id|pgdat
suffix:semicolon
id|daemonize
c_func
(paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|tsk-&gt;comm
comma
l_string|&quot;kreclaimd&quot;
)paren
suffix:semicolon
id|sigfillset
c_func
(paren
op_amp
id|tsk-&gt;blocked
)paren
suffix:semicolon
id|current-&gt;flags
op_or_assign
id|PF_MEMALLOC
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * We sleep until someone wakes us up from&n;&t;&t; * page_alloc.c::__alloc_pages().&n;&t;&t; */
id|interruptible_sleep_on
c_func
(paren
op_amp
id|kreclaimd_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Move some pages from the inactive_clean lists to&n;&t;&t; * the free lists, if it is needed.&n;&t;&t; */
id|pgdat
op_assign
id|pgdat_list
suffix:semicolon
r_do
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_ZONES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|zone_t
op_star
id|zone
op_assign
id|pgdat-&gt;node_zones
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zone-&gt;size
)paren
r_continue
suffix:semicolon
r_while
c_loop
(paren
id|zone-&gt;free_pages
OL
id|zone-&gt;pages_low
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
id|page
op_assign
id|reclaim_page
c_func
(paren
id|zone
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_break
suffix:semicolon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
id|pgdat
op_assign
id|pgdat-&gt;node_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pgdat
)paren
suffix:semicolon
)brace
)brace
DECL|function|kswapd_init
r_static
r_int
id|__init
id|kswapd_init
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Starting kswapd v1.8&bslash;n&quot;
)paren
suffix:semicolon
id|swap_setup
c_func
(paren
)paren
suffix:semicolon
id|kernel_thread
c_func
(paren
id|kswapd
comma
l_int|NULL
comma
id|CLONE_FS
op_or
id|CLONE_FILES
op_or
id|CLONE_SIGNAL
)paren
suffix:semicolon
id|kernel_thread
c_func
(paren
id|kreclaimd
comma
l_int|NULL
comma
id|CLONE_FS
op_or
id|CLONE_FILES
op_or
id|CLONE_SIGNAL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|module_init
c_func
(paren
id|kswapd_init
)paren
eof
