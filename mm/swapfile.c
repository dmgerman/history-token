multiline_comment|/*&n; *  linux/mm/swapfile.c&n; *&n; *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; *  Swap reorganised 29.12.95, Stephen Tweedie&n; */
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/swapctl.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt; /* for blk_size */
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/shm.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
DECL|variable|swaplock
id|spinlock_t
id|swaplock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|nr_swapfiles
r_int
r_int
id|nr_swapfiles
suffix:semicolon
DECL|variable|total_swap_pages
r_int
id|total_swap_pages
suffix:semicolon
DECL|variable|swap_overflow
r_static
r_int
id|swap_overflow
suffix:semicolon
DECL|variable|Bad_file
r_static
r_const
r_char
id|Bad_file
(braket
)braket
op_assign
l_string|&quot;Bad swap file entry &quot;
suffix:semicolon
DECL|variable|Unused_file
r_static
r_const
r_char
id|Unused_file
(braket
)braket
op_assign
l_string|&quot;Unused swap file entry &quot;
suffix:semicolon
DECL|variable|Bad_offset
r_static
r_const
r_char
id|Bad_offset
(braket
)braket
op_assign
l_string|&quot;Bad swap offset entry &quot;
suffix:semicolon
DECL|variable|Unused_offset
r_static
r_const
r_char
id|Unused_offset
(braket
)braket
op_assign
l_string|&quot;Unused swap offset entry &quot;
suffix:semicolon
DECL|variable|swap_list
r_struct
id|swap_list_t
id|swap_list
op_assign
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|swap_info
r_struct
id|swap_info_struct
id|swap_info
(braket
id|MAX_SWAPFILES
)braket
suffix:semicolon
multiline_comment|/*&n; * When swap space gets filled up, we will set this flag.&n; * This will make do_swap_page(), in the page fault path,&n; * free swap entries on swapin so we&squot;ll reclaim swap space&n; * in order to be able to swap something out.&n; *&n; * At the moment we start reclaiming when swap usage goes&n; * over 80% of swap space.&n; *&n; * XXX: Random numbers, fixme.&n; */
DECL|macro|SWAP_FULL_PCT
mdefine_line|#define SWAP_FULL_PCT 80
DECL|function|vm_swap_full
r_int
id|vm_swap_full
(paren
r_void
)paren
(brace
r_int
id|swap_used
op_assign
id|total_swap_pages
op_minus
id|nr_swap_pages
suffix:semicolon
r_return
id|swap_used
op_star
l_int|100
OG
id|total_swap_pages
op_star
id|SWAP_FULL_PCT
suffix:semicolon
)brace
DECL|macro|SWAPFILE_CLUSTER
mdefine_line|#define SWAPFILE_CLUSTER 256
DECL|function|scan_swap_map
r_static
r_inline
r_int
id|scan_swap_map
c_func
(paren
r_struct
id|swap_info_struct
op_star
id|si
comma
r_int
r_int
id|count
)paren
(brace
r_int
r_int
id|offset
suffix:semicolon
multiline_comment|/* &n;&t; * We try to cluster swap pages by allocating them&n;&t; * sequentially in swap.  Once we&squot;ve allocated&n;&t; * SWAPFILE_CLUSTER pages this way, however, we resort to&n;&t; * first-free allocation, starting a new cluster.  This&n;&t; * prevents us from scattering swap pages all over the entire&n;&t; * swap partition, so that we reduce overall disk seek times&n;&t; * between swap pages.  -- sct */
r_if
c_cond
(paren
id|si-&gt;cluster_nr
)paren
(brace
r_while
c_loop
(paren
id|si-&gt;cluster_next
op_le
id|si-&gt;highest_bit
)paren
(brace
id|offset
op_assign
id|si-&gt;cluster_next
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|si-&gt;swap_map
(braket
id|offset
)braket
)paren
r_continue
suffix:semicolon
id|si-&gt;cluster_nr
op_decrement
suffix:semicolon
r_goto
id|got_page
suffix:semicolon
)brace
)brace
id|si-&gt;cluster_nr
op_assign
id|SWAPFILE_CLUSTER
suffix:semicolon
multiline_comment|/* try to find an empty (even not aligned) cluster. */
id|offset
op_assign
id|si-&gt;lowest_bit
suffix:semicolon
id|check_next_cluster
suffix:colon
r_if
c_cond
(paren
id|offset
op_plus
id|SWAPFILE_CLUSTER
op_minus
l_int|1
op_le
id|si-&gt;highest_bit
)paren
(brace
r_int
id|nr
suffix:semicolon
r_for
c_loop
(paren
id|nr
op_assign
id|offset
suffix:semicolon
id|nr
OL
id|offset
op_plus
id|SWAPFILE_CLUSTER
suffix:semicolon
id|nr
op_increment
)paren
r_if
c_cond
(paren
id|si-&gt;swap_map
(braket
id|nr
)braket
)paren
(brace
id|offset
op_assign
id|nr
op_plus
l_int|1
suffix:semicolon
r_goto
id|check_next_cluster
suffix:semicolon
)brace
multiline_comment|/* We found a completly empty cluster, so start&n;&t;&t; * using it.&n;&t;&t; */
r_goto
id|got_page
suffix:semicolon
)brace
multiline_comment|/* No luck, so now go finegrined as usual. -Andrea */
r_for
c_loop
(paren
id|offset
op_assign
id|si-&gt;lowest_bit
suffix:semicolon
id|offset
op_le
id|si-&gt;highest_bit
suffix:semicolon
id|offset
op_increment
)paren
(brace
r_if
c_cond
(paren
id|si-&gt;swap_map
(braket
id|offset
)braket
)paren
r_continue
suffix:semicolon
id|got_page
suffix:colon
r_if
c_cond
(paren
id|offset
op_eq
id|si-&gt;lowest_bit
)paren
id|si-&gt;lowest_bit
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
id|si-&gt;highest_bit
)paren
id|si-&gt;highest_bit
op_decrement
suffix:semicolon
id|si-&gt;swap_map
(braket
id|offset
)braket
op_assign
id|count
suffix:semicolon
id|nr_swap_pages
op_decrement
suffix:semicolon
id|si-&gt;cluster_next
op_assign
id|offset
op_plus
l_int|1
suffix:semicolon
r_return
id|offset
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__get_swap_page
id|swp_entry_t
id|__get_swap_page
c_func
(paren
r_int
r_int
id|count
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
id|swp_entry_t
id|entry
suffix:semicolon
r_int
id|type
comma
id|wrapped
op_assign
l_int|0
suffix:semicolon
id|entry.val
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Out of memory */
r_if
c_cond
(paren
id|count
op_ge
id|SWAP_MAP_MAX
)paren
r_goto
id|bad_count
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
id|type
op_assign
id|swap_list.next
suffix:semicolon
r_if
c_cond
(paren
id|type
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|nr_swap_pages
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|p
op_assign
op_amp
id|swap_info
(braket
id|type
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|SWP_WRITEOK
)paren
op_eq
id|SWP_WRITEOK
)paren
(brace
id|swap_device_lock
c_func
(paren
id|p
)paren
suffix:semicolon
id|offset
op_assign
id|scan_swap_map
c_func
(paren
id|p
comma
id|count
)paren
suffix:semicolon
id|swap_device_unlock
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
)paren
(brace
id|entry
op_assign
id|SWP_ENTRY
c_func
(paren
id|type
comma
id|offset
)paren
suffix:semicolon
id|type
op_assign
id|swap_info
(braket
id|type
)braket
dot
id|next
suffix:semicolon
r_if
c_cond
(paren
id|type
OL
l_int|0
op_logical_or
id|p-&gt;prio
op_ne
id|swap_info
(braket
id|type
)braket
dot
id|prio
)paren
(brace
id|swap_list.next
op_assign
id|swap_list.head
suffix:semicolon
)brace
r_else
(brace
id|swap_list.next
op_assign
id|type
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
)brace
id|type
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wrapped
)paren
(brace
r_if
c_cond
(paren
id|type
OL
l_int|0
op_logical_or
id|p-&gt;prio
op_ne
id|swap_info
(braket
id|type
)braket
dot
id|prio
)paren
(brace
id|type
op_assign
id|swap_list.head
suffix:semicolon
id|wrapped
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|type
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* out of swap space */
)brace
id|out
suffix:colon
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|entry
suffix:semicolon
id|bad_count
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;get_swap_page: bad count %hd from %p&bslash;n&quot;
comma
id|count
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
id|entry
suffix:semicolon
)brace
multiline_comment|/*&n; * Caller has made sure that the swapdevice corresponding to entry&n; * is still around or has not been recycled.&n; */
DECL|function|__swap_free
r_void
id|__swap_free
c_func
(paren
id|swp_entry_t
id|entry
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_int
r_int
id|offset
comma
id|type
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry.val
)paren
r_goto
id|out
suffix:semicolon
id|type
op_assign
id|SWP_TYPE
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
r_goto
id|bad_nofile
suffix:semicolon
id|p
op_assign
op_amp
id|swap_info
(braket
id|type
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|SWP_USED
)paren
)paren
r_goto
id|bad_device
suffix:semicolon
id|offset
op_assign
id|SWP_OFFSET
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|p-&gt;max
)paren
r_goto
id|bad_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
r_goto
id|bad_free
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;prio
OG
id|swap_info
(braket
id|swap_list.next
)braket
dot
id|prio
)paren
id|swap_list.next
op_assign
id|type
suffix:semicolon
id|swap_device_lock
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;swap_map
(braket
id|offset
)braket
OL
id|SWAP_MAP_MAX
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;swap_map
(braket
id|offset
)braket
OL
id|count
)paren
r_goto
id|bad_count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;swap_map
(braket
id|offset
)braket
op_sub_assign
id|count
)paren
)paren
(brace
r_if
c_cond
(paren
id|offset
OL
id|p-&gt;lowest_bit
)paren
id|p-&gt;lowest_bit
op_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|offset
OG
id|p-&gt;highest_bit
)paren
id|p-&gt;highest_bit
op_assign
id|offset
suffix:semicolon
id|nr_swap_pages
op_increment
suffix:semicolon
)brace
)brace
id|swap_device_unlock
c_func
(paren
id|p
)paren
suffix:semicolon
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
id|out
suffix:colon
r_return
suffix:semicolon
id|bad_nofile
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_free: %s%08lx&bslash;n&quot;
comma
id|Bad_file
comma
id|entry.val
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_device
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_free: %s%08lx&bslash;n&quot;
comma
id|Unused_file
comma
id|entry.val
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_offset
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_free: %s%08lx&bslash;n&quot;
comma
id|Bad_offset
comma
id|entry.val
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_free
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_free: %s%08lx&bslash;n&quot;
comma
id|Unused_offset
comma
id|entry.val
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_count
suffix:colon
id|swap_device_unlock
c_func
(paren
id|p
)paren
suffix:semicolon
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_free: Bad count %hd current count %hd&bslash;n&quot;
comma
id|count
comma
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * The swap entry has been read in advance, and we return 1 to indicate&n; * that the page has been used or is no longer needed.&n; *&n; * Always set the resulting pte to be nowrite (the same as COW pages&n; * after one process has exited).  We don&squot;t know just how many PTEs will&n; * share this swap entry, so be cautious and let do_wp_page work out&n; * what to do if a write is requested later.&n; */
multiline_comment|/* BKL, mmlist_lock and vma-&gt;vm_mm-&gt;page_table_lock are held */
DECL|function|unuse_pte
r_static
r_inline
r_void
id|unuse_pte
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
id|pte_t
op_star
id|dir
comma
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|pte_t
id|pte
op_assign
op_star
id|dir
suffix:semicolon
r_if
c_cond
(paren
id|pte_to_swp_entry
c_func
(paren
id|pte
)paren
dot
id|val
op_ne
id|entry.val
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|pte_none
c_func
(paren
id|pte
)paren
op_logical_or
id|pte_present
c_func
(paren
id|pte
)paren
)paren
r_return
suffix:semicolon
id|get_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_pte
c_func
(paren
id|dir
comma
id|pte_mkold
c_func
(paren
id|mk_pte
c_func
(paren
id|page
comma
id|vma-&gt;vm_page_prot
)paren
)paren
)paren
suffix:semicolon
id|swap_free
c_func
(paren
id|entry
)paren
suffix:semicolon
op_increment
id|vma-&gt;vm_mm-&gt;rss
suffix:semicolon
)brace
multiline_comment|/* BKL, mmlist_lock and vma-&gt;vm_mm-&gt;page_table_lock are held */
DECL|function|unuse_pmd
r_static
r_inline
r_void
id|unuse_pmd
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
id|pmd_t
op_star
id|dir
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
r_int
r_int
id|offset
comma
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|dir
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|pmd_bad
c_func
(paren
op_star
id|dir
)paren
)paren
(brace
id|pmd_ERROR
c_func
(paren
op_star
id|dir
)paren
suffix:semicolon
id|pmd_clear
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pte
op_assign
id|pte_offset
c_func
(paren
id|dir
comma
id|address
)paren
suffix:semicolon
id|offset
op_add_assign
id|address
op_amp
id|PMD_MASK
suffix:semicolon
id|address
op_and_assign
op_complement
id|PMD_MASK
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|PMD_SIZE
)paren
id|end
op_assign
id|PMD_SIZE
suffix:semicolon
r_do
(brace
id|unuse_pte
c_func
(paren
id|vma
comma
id|offset
op_plus
id|address
op_minus
id|vma-&gt;vm_start
comma
id|pte
comma
id|entry
comma
id|page
)paren
suffix:semicolon
id|address
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|pte
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
op_logical_and
(paren
id|address
OL
id|end
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* BKL, mmlist_lock and vma-&gt;vm_mm-&gt;page_table_lock are held */
DECL|function|unuse_pgd
r_static
r_inline
r_void
id|unuse_pgd
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
id|pgd_t
op_star
id|dir
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|pmd_t
op_star
id|pmd
suffix:semicolon
r_int
r_int
id|offset
comma
id|end
suffix:semicolon
r_if
c_cond
(paren
id|pgd_none
c_func
(paren
op_star
id|dir
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|pgd_bad
c_func
(paren
op_star
id|dir
)paren
)paren
(brace
id|pgd_ERROR
c_func
(paren
op_star
id|dir
)paren
suffix:semicolon
id|pgd_clear
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|dir
comma
id|address
)paren
suffix:semicolon
id|offset
op_assign
id|address
op_amp
id|PGDIR_MASK
suffix:semicolon
id|address
op_and_assign
op_complement
id|PGDIR_MASK
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|PGDIR_SIZE
)paren
id|end
op_assign
id|PGDIR_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|address
op_ge
id|end
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
id|unuse_pmd
c_func
(paren
id|vma
comma
id|pmd
comma
id|address
comma
id|end
op_minus
id|address
comma
id|offset
comma
id|entry
comma
id|page
)paren
suffix:semicolon
id|address
op_assign
(paren
id|address
op_plus
id|PMD_SIZE
)paren
op_amp
id|PMD_MASK
suffix:semicolon
id|pmd
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
op_logical_and
(paren
id|address
OL
id|end
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* BKL, mmlist_lock and vma-&gt;vm_mm-&gt;page_table_lock are held */
DECL|function|unuse_vma
r_static
r_void
id|unuse_vma
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
id|pgd_t
op_star
id|pgdir
comma
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
r_int
id|start
op_assign
id|vma-&gt;vm_start
comma
id|end
op_assign
id|vma-&gt;vm_end
suffix:semicolon
r_if
c_cond
(paren
id|start
op_ge
id|end
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
id|unuse_pgd
c_func
(paren
id|vma
comma
id|pgdir
comma
id|start
comma
id|end
op_minus
id|start
comma
id|entry
comma
id|page
)paren
suffix:semicolon
id|start
op_assign
(paren
id|start
op_plus
id|PGDIR_SIZE
)paren
op_amp
id|PGDIR_MASK
suffix:semicolon
id|pgdir
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|start
op_logical_and
(paren
id|start
OL
id|end
)paren
)paren
suffix:semicolon
)brace
DECL|function|unuse_process
r_static
r_void
id|unuse_process
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
multiline_comment|/*&n;&t; * Go through process&squot; page directory.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|vma
op_assign
id|mm-&gt;mmap
suffix:semicolon
id|vma
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
)paren
(brace
id|pgd_t
op_star
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|vma-&gt;vm_start
)paren
suffix:semicolon
id|unuse_vma
c_func
(paren
id|vma
comma
id|pgd
comma
id|entry
comma
id|page
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Scan swap_map from current position to next entry still in use.&n; * Recycle to start on reaching the end, returning 0 when empty.&n; */
DECL|function|find_next_to_unuse
r_static
r_int
id|find_next_to_unuse
c_func
(paren
r_struct
id|swap_info_struct
op_star
id|si
comma
r_int
id|prev
)paren
(brace
r_int
id|max
op_assign
id|si-&gt;max
suffix:semicolon
r_int
id|i
op_assign
id|prev
suffix:semicolon
r_int
id|count
suffix:semicolon
multiline_comment|/*&n;&t; * No need for swap_device_lock(si) here: we&squot;re just looking&n;&t; * for whether an entry is in use, not modifying it; false&n;&t; * hits are okay, and sys_swapoff() has already prevented new&n;&t; * allocations from this area (while holding swap_list_lock()).&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_increment
id|i
op_ge
id|max
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prev
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * No entries in use at top of swap_map,&n;&t;&t;&t; * loop back to start and recheck there.&n;&t;&t;&t; */
id|max
op_assign
id|prev
op_plus
l_int|1
suffix:semicolon
id|prev
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
l_int|1
suffix:semicolon
)brace
id|count
op_assign
id|si-&gt;swap_map
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|count
op_logical_and
id|count
op_ne
id|SWAP_MAP_BAD
)paren
r_break
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * We completely avoid races by reading each swap page in advance,&n; * and then search for the process using it.  All the necessary&n; * page table adjustments can then be made atomically.&n; */
DECL|function|try_to_unuse
r_static
r_int
id|try_to_unuse
c_func
(paren
r_int
r_int
id|type
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|si
op_assign
op_amp
id|swap_info
(braket
id|type
)braket
suffix:semicolon
r_struct
id|mm_struct
op_star
id|start_mm
suffix:semicolon
r_int
r_int
op_star
id|swap_map
suffix:semicolon
r_int
r_int
id|swcount
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|swp_entry_t
id|entry
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|reset_overflow
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * When searching mms for an entry, a good strategy is to&n;&t; * start at the first mm we freed the previous entry from&n;&t; * (though actually we don&squot;t notice whether we or coincidence&n;&t; * freed the entry).  Initialize this start_mm with a hold.&n;&t; *&n;&t; * A simpler strategy would be to start at the last mm we&n;&t; * freed the previous entry from; but that would take less&n;&t; * advantage of mmlist ordering (now preserved by swap_out()),&n;&t; * which clusters forked address spaces together, most recent&n;&t; * child immediately after parent.  If we race with dup_mmap(),&n;&t; * we very much want to resolve parent before child, otherwise&n;&t; * we may miss some entries: using last mm would invert that.&n;&t; */
id|start_mm
op_assign
op_amp
id|init_mm
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|init_mm.mm_users
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Keep on scanning until all entries have gone.  Usually,&n;&t; * one pass through swap_map is enough, but not necessarily:&n;&t; * mmput() removes mm from mmlist before exit_mmap() and its&n;&t; * zap_page_range().  That&squot;s not too bad, those entries are&n;&t; * on their way out, and handled faster there than here.&n;&t; * do_munmap() behaves similarly, taking the range out of mm&squot;s&n;&t; * vma list before zap_page_range().  But unfortunately, when&n;&t; * unmapping a part of a vma, it takes the whole out first,&n;&t; * then reinserts what&squot;s left after (might even reschedule if&n;&t; * open() method called) - so swap entries may be invisible&n;&t; * to swapoff for a while, then reappear - but that is rare.&n;&t; */
r_while
c_loop
(paren
(paren
id|i
op_assign
id|find_next_to_unuse
c_func
(paren
id|si
comma
id|i
)paren
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t; * Get a page for the entry, using the existing swap&n;&t;&t; * cache page if there is one.  Otherwise, get a clean&n;&t;&t; * page and read the swap into it. &n;&t;&t; */
id|swap_map
op_assign
op_amp
id|si-&gt;swap_map
(braket
id|i
)braket
suffix:semicolon
id|entry
op_assign
id|SWP_ENTRY
c_func
(paren
id|type
comma
id|i
)paren
suffix:semicolon
id|page
op_assign
id|read_swap_cache_async
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Either swap_duplicate() failed because entry&n;&t;&t;&t; * has been freed independently, and will not be&n;&t;&t;&t; * reused since sys_swapoff() already disabled&n;&t;&t;&t; * allocation from here, or alloc_page() failed.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
op_star
id|swap_map
)paren
r_continue
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Don&squot;t hold on to start_mm if it looks like exiting.&n;&t;&t; * Can mmput ever block? if so, then we cannot risk&n;&t;&t; * it between deleting the page from the swap cache,&n;&t;&t; * and completing the search through mms (and cannot&n;&t;&t; * use it to avoid the long hold on mmlist_lock there).&n;&t;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|start_mm-&gt;mm_users
)paren
op_eq
l_int|1
)paren
(brace
id|mmput
c_func
(paren
id|start_mm
)paren
suffix:semicolon
id|start_mm
op_assign
op_amp
id|init_mm
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|init_mm.mm_users
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Wait for and lock page.  Remove it from swap cache&n;&t;&t; * so try_to_swap_out won&squot;t bump swap count.  Mark dirty&n;&t;&t; * so try_to_swap_out will preserve it without us having&n;&t;&t; * to mark any present ptes as dirty: so we can skip&n;&t;&t; * searching processes once swap count has all gone.&n;&t;&t; */
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
id|delete_from_swap_cache_nolock
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|flush_page_to_ram
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Remove all references to entry, without blocking.&n;&t;&t; * Whenever we reach init_mm, there&squot;s no address space&n;&t;&t; * to search, but use it as a reminder to search shmem.&n;&t;&t; */
id|swcount
op_assign
op_star
id|swap_map
suffix:semicolon
r_if
c_cond
(paren
id|swcount
)paren
(brace
r_if
c_cond
(paren
id|start_mm
op_eq
op_amp
id|init_mm
)paren
id|shmem_unuse
c_func
(paren
id|entry
comma
id|page
)paren
suffix:semicolon
r_else
id|unuse_process
c_func
(paren
id|start_mm
comma
id|entry
comma
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|swap_map
)paren
(brace
r_int
id|set_start_mm
op_assign
(paren
op_star
id|swap_map
op_ge
id|swcount
)paren
suffix:semicolon
r_struct
id|list_head
op_star
id|p
op_assign
op_amp
id|start_mm-&gt;mmlist
suffix:semicolon
r_struct
id|mm_struct
op_star
id|new_start_mm
op_assign
id|start_mm
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mmlist_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|swap_map
op_logical_and
(paren
id|p
op_assign
id|p-&gt;next
)paren
op_ne
op_amp
id|start_mm-&gt;mmlist
)paren
(brace
id|mm
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|mm_struct
comma
id|mmlist
)paren
suffix:semicolon
id|swcount
op_assign
op_star
id|swap_map
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
op_amp
id|init_mm
)paren
(brace
id|set_start_mm
op_assign
l_int|1
suffix:semicolon
id|shmem_unuse
c_func
(paren
id|entry
comma
id|page
)paren
suffix:semicolon
)brace
r_else
id|unuse_process
c_func
(paren
id|mm
comma
id|entry
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|set_start_mm
op_logical_and
op_star
id|swap_map
OL
id|swcount
)paren
(brace
id|new_start_mm
op_assign
id|mm
suffix:semicolon
id|set_start_mm
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|atomic_inc
c_func
(paren
op_amp
id|new_start_mm-&gt;mm_users
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mmlist_lock
)paren
suffix:semicolon
id|mmput
c_func
(paren
id|start_mm
)paren
suffix:semicolon
id|start_mm
op_assign
id|new_start_mm
suffix:semicolon
)brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * How could swap count reach 0x7fff when the maximum&n;&t;&t; * pid is 0x7fff, and there&squot;s no way to repeat a swap&n;&t;&t; * page within an mm (except in shmem, where it&squot;s the&n;&t;&t; * shared object which takes the reference count)?&n;&t;&t; * We believe SWAP_MAP_MAX cannot occur in Linux 2.4.&n;&t;&t; *&n;&t;&t; * If that&squot;s wrong, then we should worry more about&n;&t;&t; * exit_mmap() and do_munmap() cases described above:&n;&t;&t; * we might be resetting SWAP_MAP_MAX too early here.&n;&t;&t; * We know &quot;Undead&quot;s can happen, they&squot;re okay, so don&squot;t&n;&t;&t; * report them; but do report if we reset SWAP_MAP_MAX.&n;&t;&t; */
r_if
c_cond
(paren
op_star
id|swap_map
op_eq
id|SWAP_MAP_MAX
)paren
(brace
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
id|swap_device_lock
c_func
(paren
id|si
)paren
suffix:semicolon
id|nr_swap_pages
op_increment
suffix:semicolon
op_star
id|swap_map
op_assign
l_int|0
suffix:semicolon
id|swap_device_unlock
c_func
(paren
id|si
)paren
suffix:semicolon
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
id|reset_overflow
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Make sure that we aren&squot;t completely killing&n;&t;&t; * interactive performance.  Interruptible check on&n;&t;&t; * signal_pending() would be nice, but changes the spec?&n;&t;&t; */
r_if
c_cond
(paren
id|current-&gt;need_resched
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_else
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|mmput
c_func
(paren
id|start_mm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reset_overflow
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;swapoff: cleared swap entry overflow&bslash;n&quot;
)paren
suffix:semicolon
id|swap_overflow
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|sys_swapoff
id|asmlinkage
r_int
id|sys_swapoff
c_func
(paren
r_const
r_char
op_star
id|specialfile
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|nameidata
id|nd
suffix:semicolon
r_int
id|i
comma
id|type
comma
id|prev
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|err
op_assign
id|user_path_walk
c_func
(paren
id|specialfile
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|prev
op_assign
op_minus
l_int|1
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|type
op_assign
id|swap_list.head
suffix:semicolon
id|type
op_ge
l_int|0
suffix:semicolon
id|type
op_assign
id|swap_info
(braket
id|type
)braket
dot
id|next
)paren
(brace
id|p
op_assign
id|swap_info
op_plus
id|type
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|SWP_WRITEOK
)paren
op_eq
id|SWP_WRITEOK
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;swap_file
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;swap_file
op_eq
id|nd.dentry
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|S_ISBLK
c_func
(paren
id|nd.dentry-&gt;d_inode-&gt;i_mode
)paren
op_logical_and
(paren
id|p-&gt;swap_device
op_eq
id|nd.dentry-&gt;d_inode-&gt;i_rdev
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
id|prev
op_assign
id|type
suffix:semicolon
)brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|type
OL
l_int|0
)paren
(brace
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prev
OL
l_int|0
)paren
(brace
id|swap_list.head
op_assign
id|p-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|swap_info
(braket
id|prev
)braket
dot
id|next
op_assign
id|p-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_eq
id|swap_list.next
)paren
(brace
multiline_comment|/* just pick something that&squot;s safe... */
id|swap_list.next
op_assign
id|swap_list.head
suffix:semicolon
)brace
id|nr_swap_pages
op_sub_assign
id|p-&gt;pages
suffix:semicolon
id|total_swap_pages
op_sub_assign
id|p-&gt;pages
suffix:semicolon
id|p-&gt;flags
op_assign
id|SWP_USED
suffix:semicolon
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
id|try_to_unuse
c_func
(paren
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
multiline_comment|/* re-insert swap space back into swap_list */
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|prev
op_assign
op_minus
l_int|1
comma
id|i
op_assign
id|swap_list.head
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|prev
op_assign
id|i
comma
id|i
op_assign
id|swap_info
(braket
id|i
)braket
dot
id|next
)paren
r_if
c_cond
(paren
id|p-&gt;prio
op_ge
id|swap_info
(braket
id|i
)braket
dot
id|prio
)paren
r_break
suffix:semicolon
id|p-&gt;next
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|prev
OL
l_int|0
)paren
id|swap_list.head
op_assign
id|swap_list.next
op_assign
id|p
op_minus
id|swap_info
suffix:semicolon
r_else
id|swap_info
(braket
id|prev
)braket
dot
id|next
op_assign
id|p
op_minus
id|swap_info
suffix:semicolon
id|nr_swap_pages
op_add_assign
id|p-&gt;pages
suffix:semicolon
id|total_swap_pages
op_add_assign
id|p-&gt;pages
suffix:semicolon
id|p-&gt;flags
op_assign
id|SWP_WRITEOK
suffix:semicolon
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;swap_device
)paren
id|blkdev_put
c_func
(paren
id|nd.dentry-&gt;d_inode-&gt;i_bdev
comma
id|BDEV_SWAP
)paren
suffix:semicolon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
id|nd.dentry
op_assign
id|p-&gt;swap_file
suffix:semicolon
id|p-&gt;swap_file
op_assign
l_int|NULL
suffix:semicolon
id|nd.mnt
op_assign
id|p-&gt;swap_vfsmnt
suffix:semicolon
id|p-&gt;swap_vfsmnt
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;swap_device
op_assign
l_int|0
suffix:semicolon
id|p-&gt;max
op_assign
l_int|0
suffix:semicolon
id|vfree
c_func
(paren
id|p-&gt;swap_map
)paren
suffix:semicolon
id|p-&gt;swap_map
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|out_dput
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|function|get_swaparea_info
r_int
id|get_swaparea_info
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_char
op_star
id|page
op_assign
(paren
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_struct
id|swap_info_struct
op_star
id|ptr
op_assign
id|swap_info
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|len
op_assign
l_int|0
comma
id|usedswap
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;Filename&bslash;t&bslash;t&bslash;tType&bslash;t&bslash;tSize&bslash;tUsed&bslash;tPriority&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_swapfiles
suffix:semicolon
id|i
op_increment
comma
id|ptr
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|ptr-&gt;flags
op_amp
id|SWP_USED
)paren
op_logical_and
id|ptr-&gt;swap_map
)paren
(brace
r_char
op_star
id|path
op_assign
id|d_path
c_func
(paren
id|ptr-&gt;swap_file
comma
id|ptr-&gt;swap_vfsmnt
comma
id|page
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%-31s &quot;
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr-&gt;swap_device
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;file&bslash;t&bslash;t&quot;
)paren
suffix:semicolon
r_else
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;partition&bslash;t&quot;
)paren
suffix:semicolon
id|usedswap
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ptr-&gt;max
suffix:semicolon
op_increment
id|j
)paren
r_switch
c_cond
(paren
id|ptr-&gt;swap_map
(braket
id|j
)braket
)paren
(brace
r_case
id|SWAP_MAP_BAD
suffix:colon
r_case
l_int|0
suffix:colon
r_continue
suffix:semicolon
r_default
suffix:colon
id|usedswap
op_increment
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%d&bslash;t%d&bslash;t%d&bslash;n&quot;
comma
id|ptr-&gt;pages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|usedswap
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|ptr-&gt;prio
)paren
suffix:semicolon
)brace
)brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|page
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|is_swap_partition
r_int
id|is_swap_partition
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|ptr
op_assign
id|swap_info
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_swapfiles
suffix:semicolon
id|i
op_increment
comma
id|ptr
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ptr-&gt;flags
op_amp
id|SWP_USED
)paren
r_if
c_cond
(paren
id|ptr-&gt;swap_device
op_eq
id|dev
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Written 01/25/92 by Simmule Turner, heavily changed by Linus.&n; *&n; * The swapon system call&n; */
DECL|function|sys_swapon
id|asmlinkage
r_int
id|sys_swapon
c_func
(paren
r_const
r_char
op_star
id|specialfile
comma
r_int
id|swap_flags
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_struct
id|nameidata
id|nd
suffix:semicolon
r_struct
id|inode
op_star
id|swap_inode
suffix:semicolon
r_int
r_int
id|type
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|prev
suffix:semicolon
r_int
id|error
suffix:semicolon
r_static
r_int
id|least_priority
op_assign
l_int|0
suffix:semicolon
r_union
id|swap_header
op_star
id|swap_header
op_assign
l_int|0
suffix:semicolon
r_int
id|swap_header_version
suffix:semicolon
r_int
id|nr_good_pages
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|maxpages
op_assign
l_int|1
suffix:semicolon
r_int
id|swapfilesize
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|p
op_assign
id|swap_info
suffix:semicolon
r_for
c_loop
(paren
id|type
op_assign
l_int|0
suffix:semicolon
id|type
OL
id|nr_swapfiles
suffix:semicolon
id|type
op_increment
comma
id|p
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|SWP_USED
)paren
)paren
r_break
suffix:semicolon
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|MAX_SWAPFILES
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
id|nr_swapfiles
op_assign
id|type
op_plus
l_int|1
suffix:semicolon
id|p-&gt;flags
op_assign
id|SWP_USED
suffix:semicolon
id|p-&gt;swap_file
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;swap_vfsmnt
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;swap_device
op_assign
l_int|0
suffix:semicolon
id|p-&gt;swap_map
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;lowest_bit
op_assign
l_int|0
suffix:semicolon
id|p-&gt;highest_bit
op_assign
l_int|0
suffix:semicolon
id|p-&gt;cluster_nr
op_assign
l_int|0
suffix:semicolon
id|p-&gt;sdev_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|p-&gt;next
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|swap_flags
op_amp
id|SWAP_FLAG_PREFER
)paren
(brace
id|p-&gt;prio
op_assign
(paren
id|swap_flags
op_amp
id|SWAP_FLAG_PRIO_MASK
)paren
op_rshift
id|SWAP_FLAG_PRIO_SHIFT
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;prio
op_assign
op_decrement
id|least_priority
suffix:semicolon
)brace
id|error
op_assign
id|user_path_walk
c_func
(paren
id|specialfile
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|bad_swap_2
suffix:semicolon
id|p-&gt;swap_file
op_assign
id|nd.dentry
suffix:semicolon
id|p-&gt;swap_vfsmnt
op_assign
id|nd.mnt
suffix:semicolon
id|swap_inode
op_assign
id|nd.dentry-&gt;d_inode
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|S_ISBLK
c_func
(paren
id|swap_inode-&gt;i_mode
)paren
)paren
(brace
id|kdev_t
id|dev
op_assign
id|swap_inode-&gt;i_rdev
suffix:semicolon
r_struct
id|block_device_operations
op_star
id|bdops
suffix:semicolon
id|p-&gt;swap_device
op_assign
id|dev
suffix:semicolon
id|set_blocksize
c_func
(paren
id|dev
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|bdev
op_assign
id|swap_inode-&gt;i_bdev
suffix:semicolon
id|bdops
op_assign
id|devfs_get_ops
c_func
(paren
id|devfs_get_handle_from_inode
c_func
(paren
id|swap_inode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdops
)paren
id|bdev-&gt;bd_op
op_assign
id|bdops
suffix:semicolon
id|error
op_assign
id|blkdev_get
c_func
(paren
id|bdev
comma
id|FMODE_READ
op_or
id|FMODE_WRITE
comma
l_int|0
comma
id|BDEV_SWAP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|bad_swap_2
suffix:semicolon
id|set_blocksize
c_func
(paren
id|dev
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_or
(paren
id|blk_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
op_logical_and
op_logical_neg
id|blk_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
)paren
)paren
r_goto
id|bad_swap
suffix:semicolon
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_swapfiles
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
id|swap_info
(braket
id|i
)braket
dot
id|swap_device
)paren
r_goto
id|bad_swap
suffix:semicolon
)brace
id|swapfilesize
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|blk_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
)paren
id|swapfilesize
op_assign
id|blk_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
op_rshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|swap_inode-&gt;i_mode
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_swapfiles
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|type
op_logical_or
op_logical_neg
id|swap_info
(braket
id|i
)braket
dot
id|swap_file
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|swap_inode
op_eq
id|swap_info
(braket
id|i
)braket
dot
id|swap_file-&gt;d_inode
)paren
r_goto
id|bad_swap
suffix:semicolon
)brace
id|swapfilesize
op_assign
id|swap_inode-&gt;i_size
op_rshift
id|PAGE_SHIFT
suffix:semicolon
)brace
r_else
r_goto
id|bad_swap
suffix:semicolon
id|swap_header
op_assign
(paren
r_void
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_USER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|swap_header
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to start swapping: out of memory :-)&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
id|lock_page
c_func
(paren
id|virt_to_page
c_func
(paren
id|swap_header
)paren
)paren
suffix:semicolon
id|rw_swap_page_nolock
c_func
(paren
id|READ
comma
id|SWP_ENTRY
c_func
(paren
id|type
comma
l_int|0
)paren
comma
(paren
r_char
op_star
)paren
id|swap_header
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;SWAP-SPACE&quot;
comma
id|swap_header-&gt;magic.magic
comma
l_int|10
)paren
)paren
id|swap_header_version
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;SWAPSPACE2&quot;
comma
id|swap_header-&gt;magic.magic
comma
l_int|10
)paren
)paren
id|swap_header_version
op_assign
l_int|2
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to find swap-space signature&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|swap_header_version
)paren
(brace
r_case
l_int|1
suffix:colon
id|memset
c_func
(paren
(paren
(paren
r_char
op_star
)paren
id|swap_header
)paren
op_plus
id|PAGE_SIZE
op_minus
l_int|10
comma
l_int|0
comma
l_int|10
)paren
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
id|p-&gt;lowest_bit
op_assign
l_int|0
suffix:semicolon
id|p-&gt;highest_bit
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|8
op_star
id|PAGE_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|i
comma
(paren
r_char
op_star
)paren
id|swap_header
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;lowest_bit
)paren
id|p-&gt;lowest_bit
op_assign
id|i
suffix:semicolon
id|p-&gt;highest_bit
op_assign
id|i
suffix:semicolon
id|maxpages
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|j
op_increment
suffix:semicolon
)brace
)brace
id|nr_good_pages
op_assign
id|j
suffix:semicolon
id|p-&gt;swap_map
op_assign
id|vmalloc
c_func
(paren
id|maxpages
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;swap_map
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|maxpages
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|i
comma
(paren
r_char
op_star
)paren
id|swap_header
)paren
)paren
id|p-&gt;swap_map
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_else
id|p-&gt;swap_map
(braket
id|i
)braket
op_assign
id|SWAP_MAP_BAD
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* Check the swap header&squot;s sub-version and the size of&n;                   the swap file and bad block lists */
r_if
c_cond
(paren
id|swap_header-&gt;info.version
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Unable to handle swap header version %d&bslash;n&quot;
comma
id|swap_header-&gt;info.version
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
id|p-&gt;lowest_bit
op_assign
l_int|1
suffix:semicolon
id|p-&gt;highest_bit
op_assign
id|swap_header-&gt;info.last_page
op_minus
l_int|1
suffix:semicolon
id|maxpages
op_assign
id|SWP_OFFSET
c_func
(paren
id|SWP_ENTRY
c_func
(paren
l_int|0
comma
op_complement
l_int|0UL
)paren
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|maxpages
OG
id|swap_header-&gt;info.last_page
)paren
id|maxpages
op_assign
id|swap_header-&gt;info.last_page
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|swap_header-&gt;info.nr_badpages
OG
id|MAX_SWAP_BADPAGES
)paren
r_goto
id|bad_swap
suffix:semicolon
multiline_comment|/* OK, set up the swap map and apply the bad block list */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;swap_map
op_assign
id|vmalloc
c_func
(paren
id|maxpages
op_star
r_sizeof
(paren
r_int
)paren
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|p-&gt;swap_map
comma
l_int|0
comma
id|maxpages
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|swap_header-&gt;info.nr_badpages
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|page
op_assign
id|swap_header-&gt;info.badpages
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|page
op_le
l_int|0
op_logical_or
id|page
op_ge
id|swap_header-&gt;info.last_page
)paren
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_else
id|p-&gt;swap_map
(braket
id|page
)braket
op_assign
id|SWAP_MAP_BAD
suffix:semicolon
)brace
id|nr_good_pages
op_assign
id|swap_header-&gt;info.last_page
op_minus
id|swap_header-&gt;info.nr_badpages
op_minus
l_int|1
multiline_comment|/* header page */
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|bad_swap
suffix:semicolon
)brace
r_if
c_cond
(paren
id|swapfilesize
op_logical_and
id|maxpages
OG
id|swapfilesize
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Swap area shorter than signature indicates&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|nr_good_pages
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Empty swap-file&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
id|p-&gt;swap_map
(braket
l_int|0
)braket
op_assign
id|SWAP_MAP_BAD
suffix:semicolon
id|p-&gt;max
op_assign
id|maxpages
suffix:semicolon
id|p-&gt;flags
op_assign
id|SWP_WRITEOK
suffix:semicolon
id|p-&gt;pages
op_assign
id|nr_good_pages
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
id|nr_swap_pages
op_add_assign
id|nr_good_pages
suffix:semicolon
id|total_swap_pages
op_add_assign
id|nr_good_pages
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Adding Swap: %dk swap-space (priority %d)&bslash;n&quot;
comma
id|nr_good_pages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|p-&gt;prio
)paren
suffix:semicolon
multiline_comment|/* insert swap space into swap_list: */
id|prev
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|swap_list.head
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_assign
id|swap_info
(braket
id|i
)braket
dot
id|next
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;prio
op_ge
id|swap_info
(braket
id|i
)braket
dot
id|prio
)paren
(brace
r_break
suffix:semicolon
)brace
id|prev
op_assign
id|i
suffix:semicolon
)brace
id|p-&gt;next
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|prev
OL
l_int|0
)paren
(brace
id|swap_list.head
op_assign
id|swap_list.next
op_assign
id|p
op_minus
id|swap_info
suffix:semicolon
)brace
r_else
(brace
id|swap_info
(braket
id|prev
)braket
dot
id|next
op_assign
id|p
op_minus
id|swap_info
suffix:semicolon
)brace
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_swap
suffix:colon
r_if
c_cond
(paren
id|bdev
)paren
id|blkdev_put
c_func
(paren
id|bdev
comma
id|BDEV_SWAP
)paren
suffix:semicolon
id|bad_swap_2
suffix:colon
r_if
c_cond
(paren
id|p-&gt;swap_map
)paren
id|vfree
c_func
(paren
id|p-&gt;swap_map
)paren
suffix:semicolon
id|nd.mnt
op_assign
id|p-&gt;swap_vfsmnt
suffix:semicolon
id|nd.dentry
op_assign
id|p-&gt;swap_file
suffix:semicolon
id|p-&gt;swap_device
op_assign
l_int|0
suffix:semicolon
id|p-&gt;swap_file
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;swap_vfsmnt
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;swap_map
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|swap_flags
op_amp
id|SWAP_FLAG_PREFER
)paren
)paren
op_increment
id|least_priority
suffix:semicolon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|swap_header
)paren
id|free_page
c_func
(paren
(paren
r_int
)paren
id|swap_header
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|si_swapinfo
r_void
id|si_swapinfo
c_func
(paren
r_struct
id|sysinfo
op_star
id|val
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|freeswap
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|totalswap
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_swapfiles
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|j
suffix:semicolon
r_if
c_cond
(paren
(paren
id|swap_info
(braket
id|i
)braket
dot
id|flags
op_amp
id|SWP_WRITEOK
)paren
op_ne
id|SWP_WRITEOK
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|swap_info
(braket
id|i
)braket
dot
id|max
suffix:semicolon
op_increment
id|j
)paren
(brace
r_switch
c_cond
(paren
id|swap_info
(braket
id|i
)braket
dot
id|swap_map
(braket
id|j
)braket
)paren
(brace
r_case
id|SWAP_MAP_BAD
suffix:colon
r_continue
suffix:semicolon
r_case
l_int|0
suffix:colon
id|freeswap
op_increment
suffix:semicolon
r_default
suffix:colon
id|totalswap
op_increment
suffix:semicolon
)brace
)brace
)brace
id|val-&gt;freeswap
op_assign
id|freeswap
suffix:semicolon
id|val-&gt;totalswap
op_assign
id|totalswap
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Verify that a swap entry is valid and increment its swap map count.&n; *&n; * Note: if swap_map[] reaches SWAP_MAP_MAX the entries are treated as&n; * &quot;permanent&quot;, but will be reclaimed by the next swapoff.&n; */
DECL|function|swap_duplicate
r_int
id|swap_duplicate
c_func
(paren
id|swp_entry_t
id|entry
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_int
r_int
id|offset
comma
id|type
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Swap entry 0 is illegal */
r_if
c_cond
(paren
op_logical_neg
id|entry.val
)paren
r_goto
id|out
suffix:semicolon
id|type
op_assign
id|SWP_TYPE
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
r_goto
id|bad_file
suffix:semicolon
id|p
op_assign
id|type
op_plus
id|swap_info
suffix:semicolon
id|offset
op_assign
id|SWP_OFFSET
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|p-&gt;max
)paren
r_goto
id|bad_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
r_goto
id|bad_unused
suffix:semicolon
multiline_comment|/*&n;&t; * Entry is valid, so increment the map count.&n;&t; */
id|swap_device_lock
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;swap_map
(braket
id|offset
)braket
OL
id|SWAP_MAP_MAX
)paren
id|p-&gt;swap_map
(braket
id|offset
)braket
op_increment
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|swap_overflow
op_increment
OL
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;swap_dup: swap entry overflow&bslash;n&quot;
)paren
suffix:semicolon
id|p-&gt;swap_map
(braket
id|offset
)braket
op_assign
id|SWAP_MAP_MAX
suffix:semicolon
)brace
id|swap_device_unlock
c_func
(paren
id|p
)paren
suffix:semicolon
id|result
op_assign
l_int|1
suffix:semicolon
id|out
suffix:colon
r_return
id|result
suffix:semicolon
id|bad_file
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_dup: %s%08lx&bslash;n&quot;
comma
id|Bad_file
comma
id|entry.val
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_offset
suffix:colon
multiline_comment|/* Don&squot;t report: can happen in read_swap_cache_async after swapoff */
r_goto
id|out
suffix:semicolon
id|bad_unused
suffix:colon
multiline_comment|/* Don&squot;t report: can happen in read_swap_cache_async after blocking */
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Page lock needs to be held in all cases to prevent races with&n; * swap file deletion.&n; */
DECL|function|swap_count
r_int
id|swap_count
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_int
r_int
id|offset
comma
id|type
suffix:semicolon
id|swp_entry_t
id|entry
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|entry.val
op_assign
id|page-&gt;index
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry.val
)paren
r_goto
id|bad_entry
suffix:semicolon
id|type
op_assign
id|SWP_TYPE
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
r_goto
id|bad_file
suffix:semicolon
id|p
op_assign
id|type
op_plus
id|swap_info
suffix:semicolon
id|offset
op_assign
id|SWP_OFFSET
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|p-&gt;max
)paren
r_goto
id|bad_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
r_goto
id|bad_unused
suffix:semicolon
id|retval
op_assign
id|p-&gt;swap_map
(braket
id|offset
)braket
suffix:semicolon
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
id|bad_entry
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_count: null entry!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_file
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_count: %s%08lx&bslash;n&quot;
comma
id|Bad_file
comma
id|entry.val
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_offset
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_count: %s%08lx&bslash;n&quot;
comma
id|Bad_offset
comma
id|entry.val
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_unused
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_count: %s%08lx&bslash;n&quot;
comma
id|Unused_offset
comma
id|entry.val
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Kernel_lock protects against swap device deletion.&n; */
DECL|function|get_swaphandle_info
r_void
id|get_swaphandle_info
c_func
(paren
id|swp_entry_t
id|entry
comma
r_int
r_int
op_star
id|offset
comma
id|kdev_t
op_star
id|dev
comma
r_struct
id|inode
op_star
op_star
id|swapf
)paren
(brace
r_int
r_int
id|type
suffix:semicolon
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
id|type
op_assign
id|SWP_TYPE
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rw_swap_page: %s%08lx&bslash;n&quot;
comma
id|Bad_file
comma
id|entry.val
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|p
op_assign
op_amp
id|swap_info
(braket
id|type
)braket
suffix:semicolon
op_star
id|offset
op_assign
id|SWP_OFFSET
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|offset
op_ge
id|p-&gt;max
op_logical_and
op_star
id|offset
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rw_swap_page: %s%08lx&bslash;n&quot;
comma
id|Bad_offset
comma
id|entry.val
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;swap_map
op_logical_and
op_logical_neg
id|p-&gt;swap_map
(braket
op_star
id|offset
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rw_swap_page: %s%08lx&bslash;n&quot;
comma
id|Unused_offset
comma
id|entry.val
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|SWP_USED
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rw_swap_page: %s%08lx&bslash;n&quot;
comma
id|Unused_file
comma
id|entry.val
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;swap_device
)paren
(brace
op_star
id|dev
op_assign
id|p-&gt;swap_device
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;swap_file
)paren
(brace
op_star
id|swapf
op_assign
id|p-&gt;swap_file-&gt;d_inode
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rw_swap_page: no swap file or device&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Kernel_lock protects against swap device deletion. Grab an extra&n; * reference on the swaphandle so that it dos not become unused.&n; */
DECL|function|valid_swaphandles
r_int
id|valid_swaphandles
c_func
(paren
id|swp_entry_t
id|entry
comma
r_int
r_int
op_star
id|offset
)paren
(brace
r_int
id|ret
op_assign
l_int|0
comma
id|i
op_assign
l_int|1
op_lshift
id|page_cluster
suffix:semicolon
r_int
r_int
id|toff
suffix:semicolon
r_struct
id|swap_info_struct
op_star
id|swapdev
op_assign
id|SWP_TYPE
c_func
(paren
id|entry
)paren
op_plus
id|swap_info
suffix:semicolon
op_star
id|offset
op_assign
id|SWP_OFFSET
c_func
(paren
id|entry
)paren
suffix:semicolon
id|toff
op_assign
op_star
id|offset
op_assign
(paren
op_star
id|offset
op_rshift
id|page_cluster
)paren
op_lshift
id|page_cluster
suffix:semicolon
id|swap_device_lock
c_func
(paren
id|swapdev
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* Don&squot;t read-ahead past the end of the swap area */
r_if
c_cond
(paren
id|toff
op_ge
id|swapdev-&gt;max
)paren
r_break
suffix:semicolon
multiline_comment|/* Don&squot;t read in bad or busy pages */
r_if
c_cond
(paren
op_logical_neg
id|swapdev-&gt;swap_map
(braket
id|toff
)braket
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|swapdev-&gt;swap_map
(braket
id|toff
)braket
op_eq
id|SWAP_MAP_BAD
)paren
r_break
suffix:semicolon
id|swapdev-&gt;swap_map
(braket
id|toff
)braket
op_increment
suffix:semicolon
id|toff
op_increment
suffix:semicolon
id|ret
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|i
)paren
suffix:semicolon
id|swap_device_unlock
c_func
(paren
id|swapdev
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
eof
