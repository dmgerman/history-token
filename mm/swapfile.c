multiline_comment|/*&n; *  linux/mm/swapfile.c&n; *&n; *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; *  Swap reorganised 29.12.95, Stephen Tweedie&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/hugetlb.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/namei.h&gt;
macro_line|#include &lt;linux/shm.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/writeback.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/rmap.h&gt;
macro_line|#include &lt;linux/security.h&gt;
macro_line|#include &lt;linux/backing-dev.h&gt;
macro_line|#include &lt;linux/syscalls.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/tlbflush.h&gt;
macro_line|#include &lt;linux/swapops.h&gt;
DECL|variable|swaplock
id|spinlock_t
id|swaplock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|nr_swapfiles
r_int
r_int
id|nr_swapfiles
suffix:semicolon
DECL|variable|total_swap_pages
r_int
id|total_swap_pages
suffix:semicolon
DECL|variable|swap_overflow
r_static
r_int
id|swap_overflow
suffix:semicolon
DECL|variable|total_swap_pages
id|EXPORT_SYMBOL
c_func
(paren
id|total_swap_pages
)paren
suffix:semicolon
DECL|variable|Bad_file
r_static
r_const
r_char
id|Bad_file
(braket
)braket
op_assign
l_string|&quot;Bad swap file entry &quot;
suffix:semicolon
DECL|variable|Unused_file
r_static
r_const
r_char
id|Unused_file
(braket
)braket
op_assign
l_string|&quot;Unused swap file entry &quot;
suffix:semicolon
DECL|variable|Bad_offset
r_static
r_const
r_char
id|Bad_offset
(braket
)braket
op_assign
l_string|&quot;Bad swap offset entry &quot;
suffix:semicolon
DECL|variable|Unused_offset
r_static
r_const
r_char
id|Unused_offset
(braket
)braket
op_assign
l_string|&quot;Unused swap offset entry &quot;
suffix:semicolon
DECL|variable|swap_list
r_struct
id|swap_list_t
id|swap_list
op_assign
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|swap_info
r_struct
id|swap_info_struct
id|swap_info
(braket
id|MAX_SWAPFILES
)braket
suffix:semicolon
r_static
id|DECLARE_MUTEX
c_func
(paren
id|swapon_sem
)paren
suffix:semicolon
multiline_comment|/*&n; * We need this because the bdev-&gt;unplug_fn can sleep and we cannot&n; * hold swap_list_lock while calling the unplug_fn. And swap_list_lock&n; * cannot be turned into a semaphore.&n; */
r_static
id|DECLARE_RWSEM
c_func
(paren
id|swap_unplug_sem
)paren
suffix:semicolon
DECL|macro|SWAPFILE_CLUSTER
mdefine_line|#define SWAPFILE_CLUSTER 256
DECL|function|swap_unplug_io_fn
r_void
id|swap_unplug_io_fn
c_func
(paren
r_struct
id|backing_dev_info
op_star
id|unused_bdi
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|swp_entry_t
id|entry
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|swap_unplug_sem
)paren
suffix:semicolon
id|entry.val
op_assign
id|page
op_member_access_from_pointer
r_private
suffix:semicolon
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
op_assign
id|swap_info
(braket
id|swp_type
c_func
(paren
id|entry
)paren
)braket
dot
id|bdev
suffix:semicolon
r_struct
id|backing_dev_info
op_star
id|bdi
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the page is removed from swapcache from under us (with a&n;&t;&t; * racy try_to_unuse/swapoff) we need an additional reference&n;&t;&t; * count to avoid reading garbage from page-&gt;private above. If&n;&t;&t; * the WARN_ON triggers during a swapoff it maybe the race&n;&t;&t; * condition and it&squot;s harmless. However if it triggers without&n;&t;&t; * swapoff it signals a problem.&n;&t;&t; */
id|WARN_ON
c_func
(paren
id|page_count
c_func
(paren
id|page
)paren
op_le
l_int|1
)paren
suffix:semicolon
id|bdi
op_assign
id|bdev-&gt;bd_inode-&gt;i_mapping-&gt;backing_dev_info
suffix:semicolon
id|bdi
op_member_access_from_pointer
id|unplug_io_fn
c_func
(paren
id|bdi
comma
id|page
)paren
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|swap_unplug_sem
)paren
suffix:semicolon
)brace
DECL|function|scan_swap_map
r_static
r_inline
r_int
id|scan_swap_map
c_func
(paren
r_struct
id|swap_info_struct
op_star
id|si
)paren
(brace
r_int
r_int
id|offset
suffix:semicolon
multiline_comment|/* &n;&t; * We try to cluster swap pages by allocating them&n;&t; * sequentially in swap.  Once we&squot;ve allocated&n;&t; * SWAPFILE_CLUSTER pages this way, however, we resort to&n;&t; * first-free allocation, starting a new cluster.  This&n;&t; * prevents us from scattering swap pages all over the entire&n;&t; * swap partition, so that we reduce overall disk seek times&n;&t; * between swap pages.  -- sct */
r_if
c_cond
(paren
id|si-&gt;cluster_nr
)paren
(brace
r_while
c_loop
(paren
id|si-&gt;cluster_next
op_le
id|si-&gt;highest_bit
)paren
(brace
id|offset
op_assign
id|si-&gt;cluster_next
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|si-&gt;swap_map
(braket
id|offset
)braket
)paren
r_continue
suffix:semicolon
id|si-&gt;cluster_nr
op_decrement
suffix:semicolon
r_goto
id|got_page
suffix:semicolon
)brace
)brace
id|si-&gt;cluster_nr
op_assign
id|SWAPFILE_CLUSTER
suffix:semicolon
multiline_comment|/* try to find an empty (even not aligned) cluster. */
id|offset
op_assign
id|si-&gt;lowest_bit
suffix:semicolon
id|check_next_cluster
suffix:colon
r_if
c_cond
(paren
id|offset
op_plus
id|SWAPFILE_CLUSTER
op_minus
l_int|1
op_le
id|si-&gt;highest_bit
)paren
(brace
r_int
r_int
id|nr
suffix:semicolon
r_for
c_loop
(paren
id|nr
op_assign
id|offset
suffix:semicolon
id|nr
OL
id|offset
op_plus
id|SWAPFILE_CLUSTER
suffix:semicolon
id|nr
op_increment
)paren
r_if
c_cond
(paren
id|si-&gt;swap_map
(braket
id|nr
)braket
)paren
(brace
id|offset
op_assign
id|nr
op_plus
l_int|1
suffix:semicolon
r_goto
id|check_next_cluster
suffix:semicolon
)brace
multiline_comment|/* We found a completly empty cluster, so start&n;&t;&t; * using it.&n;&t;&t; */
r_goto
id|got_page
suffix:semicolon
)brace
multiline_comment|/* No luck, so now go finegrined as usual. -Andrea */
r_for
c_loop
(paren
id|offset
op_assign
id|si-&gt;lowest_bit
suffix:semicolon
id|offset
op_le
id|si-&gt;highest_bit
suffix:semicolon
id|offset
op_increment
)paren
(brace
r_if
c_cond
(paren
id|si-&gt;swap_map
(braket
id|offset
)braket
)paren
r_continue
suffix:semicolon
id|si-&gt;lowest_bit
op_assign
id|offset
op_plus
l_int|1
suffix:semicolon
id|got_page
suffix:colon
r_if
c_cond
(paren
id|offset
op_eq
id|si-&gt;lowest_bit
)paren
id|si-&gt;lowest_bit
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
id|si-&gt;highest_bit
)paren
id|si-&gt;highest_bit
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|si-&gt;lowest_bit
OG
id|si-&gt;highest_bit
)paren
(brace
id|si-&gt;lowest_bit
op_assign
id|si-&gt;max
suffix:semicolon
id|si-&gt;highest_bit
op_assign
l_int|0
suffix:semicolon
)brace
id|si-&gt;swap_map
(braket
id|offset
)braket
op_assign
l_int|1
suffix:semicolon
id|si-&gt;inuse_pages
op_increment
suffix:semicolon
id|nr_swap_pages
op_decrement
suffix:semicolon
id|si-&gt;cluster_next
op_assign
id|offset
op_plus
l_int|1
suffix:semicolon
r_return
id|offset
suffix:semicolon
)brace
id|si-&gt;lowest_bit
op_assign
id|si-&gt;max
suffix:semicolon
id|si-&gt;highest_bit
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_swap_page
id|swp_entry_t
id|get_swap_page
c_func
(paren
r_void
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
id|swp_entry_t
id|entry
suffix:semicolon
r_int
id|type
comma
id|wrapped
op_assign
l_int|0
suffix:semicolon
id|entry.val
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Out of memory */
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
id|type
op_assign
id|swap_list.next
suffix:semicolon
r_if
c_cond
(paren
id|type
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|nr_swap_pages
op_le
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|p
op_assign
op_amp
id|swap_info
(braket
id|type
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|SWP_ACTIVE
)paren
op_eq
id|SWP_ACTIVE
)paren
(brace
id|swap_device_lock
c_func
(paren
id|p
)paren
suffix:semicolon
id|offset
op_assign
id|scan_swap_map
c_func
(paren
id|p
)paren
suffix:semicolon
id|swap_device_unlock
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
)paren
(brace
id|entry
op_assign
id|swp_entry
c_func
(paren
id|type
comma
id|offset
)paren
suffix:semicolon
id|type
op_assign
id|swap_info
(braket
id|type
)braket
dot
id|next
suffix:semicolon
r_if
c_cond
(paren
id|type
OL
l_int|0
op_logical_or
id|p-&gt;prio
op_ne
id|swap_info
(braket
id|type
)braket
dot
id|prio
)paren
(brace
id|swap_list.next
op_assign
id|swap_list.head
suffix:semicolon
)brace
r_else
(brace
id|swap_list.next
op_assign
id|type
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
)brace
id|type
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wrapped
)paren
(brace
r_if
c_cond
(paren
id|type
OL
l_int|0
op_logical_or
id|p-&gt;prio
op_ne
id|swap_info
(braket
id|type
)braket
dot
id|prio
)paren
(brace
id|type
op_assign
id|swap_list.head
suffix:semicolon
id|wrapped
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|type
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* out of swap space */
)brace
id|out
suffix:colon
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|entry
suffix:semicolon
)brace
DECL|function|swap_info_get
r_static
r_struct
id|swap_info_struct
op_star
id|swap_info_get
c_func
(paren
id|swp_entry_t
id|entry
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_int
r_int
id|offset
comma
id|type
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry.val
)paren
r_goto
id|out
suffix:semicolon
id|type
op_assign
id|swp_type
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
r_goto
id|bad_nofile
suffix:semicolon
id|p
op_assign
op_amp
id|swap_info
(braket
id|type
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|SWP_USED
)paren
)paren
r_goto
id|bad_device
suffix:semicolon
id|offset
op_assign
id|swp_offset
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|p-&gt;max
)paren
r_goto
id|bad_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
r_goto
id|bad_free
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;prio
OG
id|swap_info
(braket
id|swap_list.next
)braket
dot
id|prio
)paren
id|swap_list.next
op_assign
id|type
suffix:semicolon
id|swap_device_lock
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
id|bad_free
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_free: %s%08lx&bslash;n&quot;
comma
id|Unused_offset
comma
id|entry.val
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_offset
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_free: %s%08lx&bslash;n&quot;
comma
id|Bad_offset
comma
id|entry.val
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_device
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_free: %s%08lx&bslash;n&quot;
comma
id|Unused_file
comma
id|entry.val
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_nofile
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_free: %s%08lx&bslash;n&quot;
comma
id|Bad_file
comma
id|entry.val
)paren
suffix:semicolon
id|out
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|swap_info_put
r_static
r_void
id|swap_info_put
c_func
(paren
r_struct
id|swap_info_struct
op_star
id|p
)paren
(brace
id|swap_device_unlock
c_func
(paren
id|p
)paren
suffix:semicolon
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|swap_entry_free
r_static
r_int
id|swap_entry_free
c_func
(paren
r_struct
id|swap_info_struct
op_star
id|p
comma
r_int
r_int
id|offset
)paren
(brace
r_int
id|count
op_assign
id|p-&gt;swap_map
(braket
id|offset
)braket
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
id|SWAP_MAP_MAX
)paren
(brace
id|count
op_decrement
suffix:semicolon
id|p-&gt;swap_map
(braket
id|offset
)braket
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
(brace
r_if
c_cond
(paren
id|offset
OL
id|p-&gt;lowest_bit
)paren
id|p-&gt;lowest_bit
op_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|offset
OG
id|p-&gt;highest_bit
)paren
id|p-&gt;highest_bit
op_assign
id|offset
suffix:semicolon
id|nr_swap_pages
op_increment
suffix:semicolon
id|p-&gt;inuse_pages
op_decrement
suffix:semicolon
)brace
)brace
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; * Caller has made sure that the swapdevice corresponding to entry&n; * is still around or has not been recycled.&n; */
DECL|function|swap_free
r_void
id|swap_free
c_func
(paren
id|swp_entry_t
id|entry
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
id|p
op_assign
id|swap_info_get
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
id|swap_entry_free
c_func
(paren
id|p
comma
id|swp_offset
c_func
(paren
id|entry
)paren
)paren
suffix:semicolon
id|swap_info_put
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Check if we&squot;re the only user of a swap page,&n; * when the page is locked.&n; */
DECL|function|exclusive_swap_page
r_static
r_int
id|exclusive_swap_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
id|swp_entry_t
id|entry
suffix:semicolon
id|entry.val
op_assign
id|page
op_member_access_from_pointer
r_private
suffix:semicolon
id|p
op_assign
id|swap_info_get
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
multiline_comment|/* Is the only swap cache user the cache itself? */
r_if
c_cond
(paren
id|p-&gt;swap_map
(braket
id|swp_offset
c_func
(paren
id|entry
)paren
)braket
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Recheck the page count with the swapcache lock held.. */
id|spin_lock_irq
c_func
(paren
op_amp
id|swapper_space.tree_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page_count
c_func
(paren
id|page
)paren
op_eq
l_int|2
)paren
id|retval
op_assign
l_int|1
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|swapper_space.tree_lock
)paren
suffix:semicolon
)brace
id|swap_info_put
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * We can use this swap cache entry directly&n; * if there are no other references to it.&n; *&n; * Here &quot;exclusive_swap_page()&quot; does the real&n; * work, but we opportunistically check whether&n; * we need to get all the locks first..&n; */
DECL|function|can_share_swap_page
r_int
id|can_share_swap_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|page_count
c_func
(paren
id|page
)paren
)paren
(brace
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|PagePrivate
c_func
(paren
id|page
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Fallthrough */
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
r_break
suffix:semicolon
id|retval
op_assign
id|exclusive_swap_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|page
)paren
)paren
r_break
suffix:semicolon
id|retval
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Work out if there are any other processes sharing this&n; * swap cache page. Free it if you can. Return success.&n; */
DECL|function|remove_exclusive_swap_page
r_int
id|remove_exclusive_swap_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
id|swp_entry_t
id|entry
suffix:semicolon
id|BUG_ON
c_func
(paren
id|PagePrivate
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|page_count
c_func
(paren
id|page
)paren
op_ne
l_int|2
)paren
multiline_comment|/* 2: us + cache */
r_return
l_int|0
suffix:semicolon
id|entry.val
op_assign
id|page
op_member_access_from_pointer
r_private
suffix:semicolon
id|p
op_assign
id|swap_info_get
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Is the only swap cache user the cache itself? */
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;swap_map
(braket
id|swp_offset
c_func
(paren
id|entry
)paren
)braket
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Recheck the page count with the swapcache lock held.. */
id|spin_lock_irq
c_func
(paren
op_amp
id|swapper_space.tree_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|page_count
c_func
(paren
id|page
)paren
op_eq
l_int|2
)paren
op_logical_and
op_logical_neg
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
(brace
id|__delete_from_swap_cache
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|retval
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|swapper_space.tree_lock
)paren
suffix:semicolon
)brace
id|swap_info_put
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|swap_free
c_func
(paren
id|entry
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Free the swap entry like above, but also try to&n; * free the page cache entry if it is the last user.&n; */
DECL|function|free_swap_and_cache
r_void
id|free_swap_and_cache
c_func
(paren
id|swp_entry_t
id|entry
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
id|p
op_assign
id|swap_info_get
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
id|swap_entry_free
c_func
(paren
id|p
comma
id|swp_offset
c_func
(paren
id|entry
)paren
)paren
op_eq
l_int|1
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|swapper_space.tree_lock
)paren
suffix:semicolon
id|page
op_assign
id|radix_tree_lookup
c_func
(paren
op_amp
id|swapper_space.page_tree
comma
id|entry.val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
op_logical_and
id|TestSetPageLocked
c_func
(paren
id|page
)paren
)paren
id|page
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|swapper_space.tree_lock
)paren
suffix:semicolon
)brace
id|swap_info_put
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page
)paren
(brace
r_int
id|one_user
suffix:semicolon
id|BUG_ON
c_func
(paren
id|PagePrivate
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|one_user
op_assign
(paren
id|page_count
c_func
(paren
id|page
)paren
op_eq
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Only cache user (+us), or swap space full? Free it! */
r_if
c_cond
(paren
op_logical_neg
id|PageWriteback
c_func
(paren
id|page
)paren
op_logical_and
(paren
id|one_user
op_logical_or
id|vm_swap_full
c_func
(paren
)paren
)paren
)paren
(brace
id|delete_from_swap_cache
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The swap entry has been read in advance, and we return 1 to indicate&n; * that the page has been used or is no longer needed.&n; *&n; * Always set the resulting pte to be nowrite (the same as COW pages&n; * after one process has exited).  We don&squot;t know just how many PTEs will&n; * share this swap entry, so be cautious and let do_wp_page work out&n; * what to do if a write is requested later.&n; */
multiline_comment|/* vma-&gt;vm_mm-&gt;page_table_lock is held */
r_static
r_void
DECL|function|unuse_pte
id|unuse_pte
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
id|pte_t
op_star
id|dir
comma
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|vma-&gt;vm_mm-&gt;rss
op_increment
suffix:semicolon
id|get_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_pte
c_func
(paren
id|dir
comma
id|pte_mkold
c_func
(paren
id|mk_pte
c_func
(paren
id|page
comma
id|vma-&gt;vm_page_prot
)paren
)paren
)paren
suffix:semicolon
id|page_add_anon_rmap
c_func
(paren
id|page
comma
id|vma
comma
id|address
)paren
suffix:semicolon
id|swap_free
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
multiline_comment|/* vma-&gt;vm_mm-&gt;page_table_lock is held */
DECL|function|unuse_pmd
r_static
r_int
r_int
id|unuse_pmd
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
id|pmd_t
op_star
id|dir
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
r_int
r_int
id|offset
comma
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
id|pte_t
id|swp_pte
op_assign
id|swp_entry_to_pte
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|dir
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pmd_bad
c_func
(paren
op_star
id|dir
)paren
)paren
(brace
id|pmd_ERROR
c_func
(paren
op_star
id|dir
)paren
suffix:semicolon
id|pmd_clear
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pte
op_assign
id|pte_offset_map
c_func
(paren
id|dir
comma
id|address
)paren
suffix:semicolon
id|offset
op_add_assign
id|address
op_amp
id|PMD_MASK
suffix:semicolon
id|address
op_and_assign
op_complement
id|PMD_MASK
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|PMD_SIZE
)paren
id|end
op_assign
id|PMD_SIZE
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * swapoff spends a _lot_ of time in this loop!&n;&t;&t; * Test inline before going to call unuse_pte.&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|pte_same
c_func
(paren
op_star
id|pte
comma
id|swp_pte
)paren
)paren
)paren
(brace
id|unuse_pte
c_func
(paren
id|vma
comma
id|offset
op_plus
id|address
comma
id|pte
comma
id|entry
comma
id|page
)paren
suffix:semicolon
id|pte_unmap
c_func
(paren
id|pte
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Move the page to the active list so it is not&n;&t;&t;&t; * immediately swapped out again after swapon.&n;&t;&t;&t; */
id|activate_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* add 1 since address may be 0 */
r_return
l_int|1
op_plus
id|offset
op_plus
id|address
suffix:semicolon
)brace
id|address
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|pte
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
op_logical_and
(paren
id|address
OL
id|end
)paren
)paren
suffix:semicolon
id|pte_unmap
c_func
(paren
id|pte
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* vma-&gt;vm_mm-&gt;page_table_lock is held */
DECL|function|unuse_pud
r_static
r_int
r_int
id|unuse_pud
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
id|pud_t
op_star
id|pud
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
r_int
r_int
id|offset
comma
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|pmd_t
op_star
id|pmd
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
r_int
r_int
id|foundaddr
suffix:semicolon
r_if
c_cond
(paren
id|pud_none
c_func
(paren
op_star
id|pud
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pud_bad
c_func
(paren
op_star
id|pud
)paren
)paren
(brace
id|pud_ERROR
c_func
(paren
op_star
id|pud
)paren
suffix:semicolon
id|pud_clear
c_func
(paren
id|pud
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pud
comma
id|address
)paren
suffix:semicolon
id|offset
op_add_assign
id|address
op_amp
id|PUD_MASK
suffix:semicolon
id|address
op_and_assign
op_complement
id|PUD_MASK
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|PUD_SIZE
)paren
id|end
op_assign
id|PUD_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|address
op_ge
id|end
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
id|foundaddr
op_assign
id|unuse_pmd
c_func
(paren
id|vma
comma
id|pmd
comma
id|address
comma
id|end
op_minus
id|address
comma
id|offset
comma
id|entry
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|foundaddr
)paren
r_return
id|foundaddr
suffix:semicolon
id|address
op_assign
(paren
id|address
op_plus
id|PMD_SIZE
)paren
op_amp
id|PMD_MASK
suffix:semicolon
id|pmd
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
op_logical_and
(paren
id|address
OL
id|end
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* vma-&gt;vm_mm-&gt;page_table_lock is held */
DECL|function|unuse_pgd
r_static
r_int
r_int
id|unuse_pgd
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
id|pgd_t
op_star
id|pgd
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
comma
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|pud_t
op_star
id|pud
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_int
r_int
id|foundaddr
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
r_if
c_cond
(paren
id|pgd_none
c_func
(paren
op_star
id|pgd
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pgd_bad
c_func
(paren
op_star
id|pgd
)paren
)paren
(brace
id|pgd_ERROR
c_func
(paren
op_star
id|pgd
)paren
suffix:semicolon
id|pgd_clear
c_func
(paren
id|pgd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pud
op_assign
id|pud_offset
c_func
(paren
id|pgd
comma
id|address
)paren
suffix:semicolon
id|offset
op_assign
id|address
op_amp
id|PGDIR_MASK
suffix:semicolon
id|address
op_and_assign
op_complement
id|PGDIR_MASK
suffix:semicolon
id|end
op_assign
id|address
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|PGDIR_SIZE
)paren
id|end
op_assign
id|PGDIR_SIZE
suffix:semicolon
id|BUG_ON
(paren
id|address
op_ge
id|end
)paren
suffix:semicolon
r_do
(brace
id|foundaddr
op_assign
id|unuse_pud
c_func
(paren
id|vma
comma
id|pud
comma
id|address
comma
id|end
op_minus
id|address
comma
id|offset
comma
id|entry
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|foundaddr
)paren
r_return
id|foundaddr
suffix:semicolon
id|address
op_assign
(paren
id|address
op_plus
id|PUD_SIZE
)paren
op_amp
id|PUD_MASK
suffix:semicolon
id|pud
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|address
op_logical_and
(paren
id|address
OL
id|end
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* vma-&gt;vm_mm-&gt;page_table_lock is held */
DECL|function|unuse_vma
r_static
r_int
r_int
id|unuse_vma
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|pgd_t
op_star
id|pgd
suffix:semicolon
r_int
r_int
id|start
comma
id|end
comma
id|next
suffix:semicolon
r_int
r_int
id|foundaddr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;mapping
)paren
(brace
id|start
op_assign
id|page_address_in_vma
c_func
(paren
id|page
comma
id|vma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
op_eq
op_minus
id|EFAULT
)paren
r_return
l_int|0
suffix:semicolon
r_else
id|end
op_assign
id|start
op_plus
id|PAGE_SIZE
suffix:semicolon
)brace
r_else
(brace
id|start
op_assign
id|vma-&gt;vm_start
suffix:semicolon
id|end
op_assign
id|vma-&gt;vm_end
suffix:semicolon
)brace
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|vma-&gt;vm_mm
comma
id|start
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|pgd_index
c_func
(paren
id|start
)paren
suffix:semicolon
id|i
op_le
id|pgd_index
c_func
(paren
id|end
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|next
op_assign
(paren
id|start
op_plus
id|PGDIR_SIZE
)paren
op_amp
id|PGDIR_MASK
suffix:semicolon
r_if
c_cond
(paren
id|next
OG
id|end
op_logical_or
id|next
op_le
id|start
)paren
id|next
op_assign
id|end
suffix:semicolon
id|foundaddr
op_assign
id|unuse_pgd
c_func
(paren
id|vma
comma
id|pgd
comma
id|start
comma
id|next
op_minus
id|start
comma
id|entry
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|foundaddr
)paren
r_return
id|foundaddr
suffix:semicolon
id|start
op_assign
id|next
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|pgd
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|unuse_process
r_static
r_int
id|unuse_process
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
id|swp_entry_t
id|entry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
r_int
id|foundaddr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Go through process&squot; page directory.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|down_read_trylock
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Our reference to the page stops try_to_unmap_one from&n;&t;&t; * unmapping its ptes, so swapoff can make progress.&n;&t;&t; */
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|vma
op_assign
id|mm-&gt;mmap
suffix:semicolon
id|vma
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
)paren
(brace
r_if
c_cond
(paren
id|vma-&gt;anon_vma
)paren
(brace
id|foundaddr
op_assign
id|unuse_vma
c_func
(paren
id|vma
comma
id|entry
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|foundaddr
)paren
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Currently unuse_process cannot fail, but leave error handling&n;&t; * at call sites for now, since we change it from time to time.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Scan swap_map from current position to next entry still in use.&n; * Recycle to start on reaching the end, returning 0 when empty.&n; */
DECL|function|find_next_to_unuse
r_static
r_int
id|find_next_to_unuse
c_func
(paren
r_struct
id|swap_info_struct
op_star
id|si
comma
r_int
id|prev
)paren
(brace
r_int
id|max
op_assign
id|si-&gt;max
suffix:semicolon
r_int
id|i
op_assign
id|prev
suffix:semicolon
r_int
id|count
suffix:semicolon
multiline_comment|/*&n;&t; * No need for swap_device_lock(si) here: we&squot;re just looking&n;&t; * for whether an entry is in use, not modifying it; false&n;&t; * hits are okay, and sys_swapoff() has already prevented new&n;&t; * allocations from this area (while holding swap_list_lock()).&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_increment
id|i
op_ge
id|max
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prev
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * No entries in use at top of swap_map,&n;&t;&t;&t; * loop back to start and recheck there.&n;&t;&t;&t; */
id|max
op_assign
id|prev
op_plus
l_int|1
suffix:semicolon
id|prev
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
l_int|1
suffix:semicolon
)brace
id|count
op_assign
id|si-&gt;swap_map
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|count
op_logical_and
id|count
op_ne
id|SWAP_MAP_BAD
)paren
r_break
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * We completely avoid races by reading each swap page in advance,&n; * and then search for the process using it.  All the necessary&n; * page table adjustments can then be made atomically.&n; */
DECL|function|try_to_unuse
r_static
r_int
id|try_to_unuse
c_func
(paren
r_int
r_int
id|type
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|si
op_assign
op_amp
id|swap_info
(braket
id|type
)braket
suffix:semicolon
r_struct
id|mm_struct
op_star
id|start_mm
suffix:semicolon
r_int
r_int
op_star
id|swap_map
suffix:semicolon
r_int
r_int
id|swcount
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|swp_entry_t
id|entry
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|reset_overflow
op_assign
l_int|0
suffix:semicolon
r_int
id|shmem
suffix:semicolon
multiline_comment|/*&n;&t; * When searching mms for an entry, a good strategy is to&n;&t; * start at the first mm we freed the previous entry from&n;&t; * (though actually we don&squot;t notice whether we or coincidence&n;&t; * freed the entry).  Initialize this start_mm with a hold.&n;&t; *&n;&t; * A simpler strategy would be to start at the last mm we&n;&t; * freed the previous entry from; but that would take less&n;&t; * advantage of mmlist ordering, which clusters forked mms&n;&t; * together, child after parent.  If we race with dup_mmap(), we&n;&t; * prefer to resolve parent before child, lest we miss entries&n;&t; * duplicated after we scanned child: using last mm would invert&n;&t; * that.  Though it&squot;s only a serious concern when an overflowed&n;&t; * swap count is reset from SWAP_MAP_MAX, preventing a rescan.&n;&t; */
id|start_mm
op_assign
op_amp
id|init_mm
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|init_mm.mm_users
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Keep on scanning until all entries have gone.  Usually,&n;&t; * one pass through swap_map is enough, but not necessarily:&n;&t; * there are races when an instance of an entry might be missed.&n;&t; */
r_while
c_loop
(paren
(paren
id|i
op_assign
id|find_next_to_unuse
c_func
(paren
id|si
comma
id|i
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * Get a page for the entry, using the existing swap&n;&t;&t; * cache page if there is one.  Otherwise, get a clean&n;&t;&t; * page and read the swap into it. &n;&t;&t; */
id|swap_map
op_assign
op_amp
id|si-&gt;swap_map
(braket
id|i
)braket
suffix:semicolon
id|entry
op_assign
id|swp_entry
c_func
(paren
id|type
comma
id|i
)paren
suffix:semicolon
id|page
op_assign
id|read_swap_cache_async
c_func
(paren
id|entry
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Either swap_duplicate() failed because entry&n;&t;&t;&t; * has been freed independently, and will not be&n;&t;&t;&t; * reused since sys_swapoff() already disabled&n;&t;&t;&t; * allocation from here, or alloc_page() failed.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
op_star
id|swap_map
)paren
r_continue
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Don&squot;t hold on to start_mm if it looks like exiting.&n;&t;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|start_mm-&gt;mm_users
)paren
op_eq
l_int|1
)paren
(brace
id|mmput
c_func
(paren
id|start_mm
)paren
suffix:semicolon
id|start_mm
op_assign
op_amp
id|init_mm
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|init_mm.mm_users
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Wait for and lock page.  When do_swap_page races with&n;&t;&t; * try_to_unuse, do_swap_page can handle the fault much&n;&t;&t; * faster than try_to_unuse can locate the entry.  This&n;&t;&t; * apparently redundant &quot;wait_on_page_locked&quot; lets try_to_unuse&n;&t;&t; * defer to do_swap_page in such a case - in some tests,&n;&t;&t; * do_swap_page and try_to_unuse repeatedly compete.&n;&t;&t; */
id|wait_on_page_locked
c_func
(paren
id|page
)paren
suffix:semicolon
id|wait_on_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|wait_on_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Remove all references to entry.&n;&t;&t; * Whenever we reach init_mm, there&squot;s no address space&n;&t;&t; * to search, but use it as a reminder to search shmem.&n;&t;&t; */
id|shmem
op_assign
l_int|0
suffix:semicolon
id|swcount
op_assign
op_star
id|swap_map
suffix:semicolon
r_if
c_cond
(paren
id|swcount
OG
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|start_mm
op_eq
op_amp
id|init_mm
)paren
id|shmem
op_assign
id|shmem_unuse
c_func
(paren
id|entry
comma
id|page
)paren
suffix:semicolon
r_else
id|retval
op_assign
id|unuse_process
c_func
(paren
id|start_mm
comma
id|entry
comma
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|swap_map
OG
l_int|1
)paren
(brace
r_int
id|set_start_mm
op_assign
(paren
op_star
id|swap_map
op_ge
id|swcount
)paren
suffix:semicolon
r_struct
id|list_head
op_star
id|p
op_assign
op_amp
id|start_mm-&gt;mmlist
suffix:semicolon
r_struct
id|mm_struct
op_star
id|new_start_mm
op_assign
id|start_mm
suffix:semicolon
r_struct
id|mm_struct
op_star
id|prev_mm
op_assign
id|start_mm
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|new_start_mm-&gt;mm_users
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|prev_mm-&gt;mm_users
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mmlist_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|swap_map
OG
l_int|1
op_logical_and
op_logical_neg
id|retval
op_logical_and
(paren
id|p
op_assign
id|p-&gt;next
)paren
op_ne
op_amp
id|start_mm-&gt;mmlist
)paren
(brace
id|mm
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|mm_struct
comma
id|mmlist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_inc_return
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
op_eq
l_int|1
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|mmlist_lock
)paren
suffix:semicolon
id|mmput
c_func
(paren
id|prev_mm
)paren
suffix:semicolon
id|prev_mm
op_assign
id|mm
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
id|swcount
op_assign
op_star
id|swap_map
suffix:semicolon
r_if
c_cond
(paren
id|swcount
op_le
l_int|1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mm
op_eq
op_amp
id|init_mm
)paren
(brace
id|set_start_mm
op_assign
l_int|1
suffix:semicolon
id|shmem
op_assign
id|shmem_unuse
c_func
(paren
id|entry
comma
id|page
)paren
suffix:semicolon
)brace
r_else
id|retval
op_assign
id|unuse_process
c_func
(paren
id|mm
comma
id|entry
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|set_start_mm
op_logical_and
op_star
id|swap_map
OL
id|swcount
)paren
(brace
id|mmput
c_func
(paren
id|new_start_mm
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
suffix:semicolon
id|new_start_mm
op_assign
id|mm
suffix:semicolon
id|set_start_mm
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|mmlist_lock
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|mmlist_lock
)paren
suffix:semicolon
id|mmput
c_func
(paren
id|prev_mm
)paren
suffix:semicolon
id|mmput
c_func
(paren
id|start_mm
)paren
suffix:semicolon
id|start_mm
op_assign
id|new_start_mm
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * How could swap count reach 0x7fff when the maximum&n;&t;&t; * pid is 0x7fff, and there&squot;s no way to repeat a swap&n;&t;&t; * page within an mm (except in shmem, where it&squot;s the&n;&t;&t; * shared object which takes the reference count)?&n;&t;&t; * We believe SWAP_MAP_MAX cannot occur in Linux 2.4.&n;&t;&t; *&n;&t;&t; * If that&squot;s wrong, then we should worry more about&n;&t;&t; * exit_mmap() and do_munmap() cases described above:&n;&t;&t; * we might be resetting SWAP_MAP_MAX too early here.&n;&t;&t; * We know &quot;Undead&quot;s can happen, they&squot;re okay, so don&squot;t&n;&t;&t; * report them; but do report if we reset SWAP_MAP_MAX.&n;&t;&t; */
r_if
c_cond
(paren
op_star
id|swap_map
op_eq
id|SWAP_MAP_MAX
)paren
(brace
id|swap_device_lock
c_func
(paren
id|si
)paren
suffix:semicolon
op_star
id|swap_map
op_assign
l_int|1
suffix:semicolon
id|swap_device_unlock
c_func
(paren
id|si
)paren
suffix:semicolon
id|reset_overflow
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If a reference remains (rare), we would like to leave&n;&t;&t; * the page in the swap cache; but try_to_unmap could&n;&t;&t; * then re-duplicate the entry once we drop page lock,&n;&t;&t; * so we might loop indefinitely; also, that page could&n;&t;&t; * not be swapped out to other storage meanwhile.  So:&n;&t;&t; * delete from cache even if there&squot;s another reference,&n;&t;&t; * after ensuring that the data has been saved to disk -&n;&t;&t; * since if the reference remains (rarer), it will be&n;&t;&t; * read from disk into another page.  Splitting into two&n;&t;&t; * pages would be incorrect if swap supported &quot;shared&n;&t;&t; * private&quot; pages, but they are handled by tmpfs files.&n;&t;&t; *&n;&t;&t; * Note shmem_unuse already deleted a swappage from&n;&t;&t; * the swap cache, unless the move to filepage failed:&n;&t;&t; * in which case it left swappage in cache, lowered its&n;&t;&t; * swap count to pass quickly through the loops above,&n;&t;&t; * and now we must reincrement count to try again later.&n;&t;&t; */
r_if
c_cond
(paren
(paren
op_star
id|swap_map
OG
l_int|1
)paren
op_logical_and
id|PageDirty
c_func
(paren
id|page
)paren
op_logical_and
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
(brace
r_struct
id|writeback_control
id|wbc
op_assign
(brace
dot
id|sync_mode
op_assign
id|WB_SYNC_NONE
comma
)brace
suffix:semicolon
id|swap_writepage
c_func
(paren
id|page
comma
op_amp
id|wbc
)paren
suffix:semicolon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|wait_on_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
id|shmem
)paren
id|swap_duplicate
c_func
(paren
id|entry
)paren
suffix:semicolon
r_else
id|delete_from_swap_cache
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * So we could skip searching mms once swap count went&n;&t;&t; * to 1, we did not mark any present ptes as dirty: must&n;&t;&t; * mark page dirty so shrink_list will preserve it.&n;&t;&t; */
id|SetPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure that we aren&squot;t completely killing&n;&t;&t; * interactive performance.&n;&t;&t; */
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
id|mmput
c_func
(paren
id|start_mm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reset_overflow
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;swapoff: cleared swap entry overflow&bslash;n&quot;
)paren
suffix:semicolon
id|swap_overflow
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * After a successful try_to_unuse, if no swap is now in use, we know we&n; * can empty the mmlist.  swap_list_lock must be held on entry and exit.&n; * Note that mmlist_lock nests inside swap_list_lock, and an mm must be&n; * added to the mmlist just after page_duplicate - before would be racy.&n; */
DECL|function|drain_mmlist
r_static
r_void
id|drain_mmlist
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|p
comma
op_star
id|next
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_swapfiles
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|swap_info
(braket
id|i
)braket
dot
id|inuse_pages
)paren
r_return
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mmlist_lock
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|p
comma
id|next
comma
op_amp
id|init_mm.mmlist
)paren
id|list_del_init
c_func
(paren
id|p
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mmlist_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Use this swapdev&squot;s extent info to locate the (PAGE_SIZE) block which&n; * corresponds to page offset `offset&squot;.&n; */
DECL|function|map_swap_page
id|sector_t
id|map_swap_page
c_func
(paren
r_struct
id|swap_info_struct
op_star
id|sis
comma
id|pgoff_t
id|offset
)paren
(brace
r_struct
id|swap_extent
op_star
id|se
op_assign
id|sis-&gt;curr_swap_extent
suffix:semicolon
r_struct
id|swap_extent
op_star
id|start_se
op_assign
id|se
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_if
c_cond
(paren
id|se-&gt;start_page
op_le
id|offset
op_logical_and
id|offset
OL
(paren
id|se-&gt;start_page
op_plus
id|se-&gt;nr_pages
)paren
)paren
(brace
r_return
id|se-&gt;start_block
op_plus
(paren
id|offset
op_minus
id|se-&gt;start_page
)paren
suffix:semicolon
)brace
id|lh
op_assign
id|se-&gt;list.prev
suffix:semicolon
r_if
c_cond
(paren
id|lh
op_eq
op_amp
id|sis-&gt;extent_list
)paren
id|lh
op_assign
id|lh-&gt;prev
suffix:semicolon
id|se
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|swap_extent
comma
id|list
)paren
suffix:semicolon
id|sis-&gt;curr_swap_extent
op_assign
id|se
suffix:semicolon
id|BUG_ON
c_func
(paren
id|se
op_eq
id|start_se
)paren
suffix:semicolon
multiline_comment|/* It *must* be present */
)brace
)brace
multiline_comment|/*&n; * Free all of a swapdev&squot;s extent information&n; */
DECL|function|destroy_swap_extents
r_static
r_void
id|destroy_swap_extents
c_func
(paren
r_struct
id|swap_info_struct
op_star
id|sis
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|sis-&gt;extent_list
)paren
)paren
(brace
r_struct
id|swap_extent
op_star
id|se
suffix:semicolon
id|se
op_assign
id|list_entry
c_func
(paren
id|sis-&gt;extent_list.next
comma
r_struct
id|swap_extent
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|se-&gt;list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|se
)paren
suffix:semicolon
)brace
id|sis-&gt;nr_extents
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a block range (and the corresponding page range) into this swapdev&squot;s&n; * extent list.  The extent list is kept sorted in block order.&n; *&n; * This function rather assumes that it is called in ascending sector_t order.&n; * It doesn&squot;t look for extent coalescing opportunities.&n; */
r_static
r_int
DECL|function|add_swap_extent
id|add_swap_extent
c_func
(paren
r_struct
id|swap_info_struct
op_star
id|sis
comma
r_int
r_int
id|start_page
comma
r_int
r_int
id|nr_pages
comma
id|sector_t
id|start_block
)paren
(brace
r_struct
id|swap_extent
op_star
id|se
suffix:semicolon
r_struct
id|swap_extent
op_star
id|new_se
suffix:semicolon
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
id|lh
op_assign
id|sis-&gt;extent_list.next
suffix:semicolon
multiline_comment|/* The highest-addressed block */
r_while
c_loop
(paren
id|lh
op_ne
op_amp
id|sis-&gt;extent_list
)paren
(brace
id|se
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|swap_extent
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|se-&gt;start_block
op_plus
id|se-&gt;nr_pages
op_eq
id|start_block
op_logical_and
id|se-&gt;start_page
op_plus
id|se-&gt;nr_pages
op_eq
id|start_page
)paren
(brace
multiline_comment|/* Merge it */
id|se-&gt;nr_pages
op_add_assign
id|nr_pages
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|lh
op_assign
id|lh-&gt;next
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * No merge.  Insert a new extent, preserving ordering.&n;&t; */
id|new_se
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|se
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_se
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|new_se-&gt;start_page
op_assign
id|start_page
suffix:semicolon
id|new_se-&gt;nr_pages
op_assign
id|nr_pages
suffix:semicolon
id|new_se-&gt;start_block
op_assign
id|start_block
suffix:semicolon
id|lh
op_assign
id|sis-&gt;extent_list.prev
suffix:semicolon
multiline_comment|/* The lowest block */
r_while
c_loop
(paren
id|lh
op_ne
op_amp
id|sis-&gt;extent_list
)paren
(brace
id|se
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|swap_extent
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|se-&gt;start_block
OG
id|start_block
)paren
r_break
suffix:semicolon
id|lh
op_assign
id|lh-&gt;prev
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
op_amp
id|new_se-&gt;list
comma
id|lh
)paren
suffix:semicolon
id|sis-&gt;nr_extents
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * A `swap extent&squot; is a simple thing which maps a contiguous range of pages&n; * onto a contiguous range of disk blocks.  An ordered list of swap extents&n; * is built at swapon time and is then used at swap_writepage/swap_readpage&n; * time for locating where on disk a page belongs.&n; *&n; * If the swapfile is an S_ISBLK block device, a single extent is installed.&n; * This is done so that the main operating code can treat S_ISBLK and S_ISREG&n; * swap files identically.&n; *&n; * Whether the swapdev is an S_ISREG file or an S_ISBLK blockdev, the swap&n; * extent list operates in PAGE_SIZE disk blocks.  Both S_ISREG and S_ISBLK&n; * swapfiles are handled *identically* after swapon time.&n; *&n; * For S_ISREG swapfiles, setup_swap_extents() will walk all the file&squot;s blocks&n; * and will parse them into an ordered extent list, in PAGE_SIZE chunks.  If&n; * some stray blocks are found which do not fall within the PAGE_SIZE alignment&n; * requirements, they are simply tossed out - we will never use those blocks&n; * for swapping.&n; *&n; * For S_ISREG swapfiles we hold i_sem across the life of the swapon.  This&n; * prevents root from shooting her foot off by ftruncating an in-use swapfile,&n; * which will scribble on the fs.&n; *&n; * The amount of disk space which a single swap extent represents varies.&n; * Typically it is in the 1-4 megabyte range.  So we can have hundreds of&n; * extents in the list.  To avoid much list walking, we cache the previous&n; * search location in `curr_swap_extent&squot;, and start new searches from there.&n; * This is extremely effective.  The average number of iterations in&n; * map_swap_page() has been measured at about 0.3 per page.  - akpm.&n; */
DECL|function|setup_swap_extents
r_static
r_int
id|setup_swap_extents
c_func
(paren
r_struct
id|swap_info_struct
op_star
id|sis
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|blocks_per_page
suffix:semicolon
r_int
r_int
id|page_no
suffix:semicolon
r_int
id|blkbits
suffix:semicolon
id|sector_t
id|probe_block
suffix:semicolon
id|sector_t
id|last_block
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|inode
op_assign
id|sis-&gt;swap_file-&gt;f_mapping-&gt;host
suffix:semicolon
r_if
c_cond
(paren
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|ret
op_assign
id|add_swap_extent
c_func
(paren
id|sis
comma
l_int|0
comma
id|sis-&gt;max
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|blkbits
op_assign
id|inode-&gt;i_blkbits
suffix:semicolon
id|blocks_per_page
op_assign
id|PAGE_SIZE
op_rshift
id|blkbits
suffix:semicolon
multiline_comment|/*&n;&t; * Map all the blocks into the extent list.  This code doesn&squot;t try&n;&t; * to be very smart.&n;&t; */
id|probe_block
op_assign
l_int|0
suffix:semicolon
id|page_no
op_assign
l_int|0
suffix:semicolon
id|last_block
op_assign
id|i_size_read
c_func
(paren
id|inode
)paren
op_rshift
id|blkbits
suffix:semicolon
r_while
c_loop
(paren
(paren
id|probe_block
op_plus
id|blocks_per_page
)paren
op_le
id|last_block
op_logical_and
id|page_no
OL
id|sis-&gt;max
)paren
(brace
r_int
id|block_in_page
suffix:semicolon
id|sector_t
id|first_block
suffix:semicolon
id|first_block
op_assign
id|bmap
c_func
(paren
id|inode
comma
id|probe_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first_block
op_eq
l_int|0
)paren
r_goto
id|bad_bmap
suffix:semicolon
multiline_comment|/*&n;&t;&t; * It must be PAGE_SIZE aligned on-disk&n;&t;&t; */
r_if
c_cond
(paren
id|first_block
op_amp
(paren
id|blocks_per_page
op_minus
l_int|1
)paren
)paren
(brace
id|probe_block
op_increment
suffix:semicolon
r_goto
id|reprobe
suffix:semicolon
)brace
r_for
c_loop
(paren
id|block_in_page
op_assign
l_int|1
suffix:semicolon
id|block_in_page
OL
id|blocks_per_page
suffix:semicolon
id|block_in_page
op_increment
)paren
(brace
id|sector_t
id|block
suffix:semicolon
id|block
op_assign
id|bmap
c_func
(paren
id|inode
comma
id|probe_block
op_plus
id|block_in_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block
op_eq
l_int|0
)paren
r_goto
id|bad_bmap
suffix:semicolon
r_if
c_cond
(paren
id|block
op_ne
id|first_block
op_plus
id|block_in_page
)paren
(brace
multiline_comment|/* Discontiguity */
id|probe_block
op_increment
suffix:semicolon
r_goto
id|reprobe
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * We found a PAGE_SIZE-length, PAGE_SIZE-aligned run of blocks&n;&t;&t; */
id|ret
op_assign
id|add_swap_extent
c_func
(paren
id|sis
comma
id|page_no
comma
l_int|1
comma
id|first_block
op_rshift
(paren
id|PAGE_SHIFT
op_minus
id|blkbits
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|page_no
op_increment
suffix:semicolon
id|probe_block
op_add_assign
id|blocks_per_page
suffix:semicolon
id|reprobe
suffix:colon
r_continue
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|page_no
op_eq
l_int|0
)paren
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|sis-&gt;max
op_assign
id|page_no
suffix:semicolon
id|sis-&gt;highest_bit
op_assign
id|page_no
op_minus
l_int|1
suffix:semicolon
id|done
suffix:colon
id|sis-&gt;curr_swap_extent
op_assign
id|list_entry
c_func
(paren
id|sis-&gt;extent_list.prev
comma
r_struct
id|swap_extent
comma
id|list
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_bmap
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swapon: swapfile has holes&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#if 0&t;/* We don&squot;t need this yet */
macro_line|#include &lt;linux/backing-dev.h&gt;
r_int
id|page_queue_congested
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|backing_dev_info
op_star
id|bdi
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
multiline_comment|/* It pins the swap_info_struct */
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
(brace
id|swp_entry_t
id|entry
op_assign
(brace
dot
id|val
op_assign
id|page
op_member_access_from_pointer
r_private
)brace
suffix:semicolon
r_struct
id|swap_info_struct
op_star
id|sis
suffix:semicolon
id|sis
op_assign
id|get_swap_info_struct
c_func
(paren
id|swp_type
c_func
(paren
id|entry
)paren
)paren
suffix:semicolon
id|bdi
op_assign
id|sis-&gt;bdev-&gt;bd_inode-&gt;i_mapping-&gt;backing_dev_info
suffix:semicolon
)brace
r_else
id|bdi
op_assign
id|page-&gt;mapping-&gt;backing_dev_info
suffix:semicolon
r_return
id|bdi_write_congested
c_func
(paren
id|bdi
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|sys_swapoff
id|asmlinkage
r_int
id|sys_swapoff
c_func
(paren
r_const
r_char
id|__user
op_star
id|specialfile
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
op_star
id|swap_map
suffix:semicolon
r_struct
id|file
op_star
id|swap_file
comma
op_star
id|victim
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_char
op_star
id|pathname
suffix:semicolon
r_int
id|i
comma
id|type
comma
id|prev
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|pathname
op_assign
id|getname
c_func
(paren
id|specialfile
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|pathname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|pathname
)paren
)paren
r_goto
id|out
suffix:semicolon
id|victim
op_assign
id|filp_open
c_func
(paren
id|pathname
comma
id|O_RDWR
op_or
id|O_LARGEFILE
comma
l_int|0
)paren
suffix:semicolon
id|putname
c_func
(paren
id|pathname
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|victim
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|victim
)paren
)paren
r_goto
id|out
suffix:semicolon
id|mapping
op_assign
id|victim-&gt;f_mapping
suffix:semicolon
id|prev
op_assign
op_minus
l_int|1
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|type
op_assign
id|swap_list.head
suffix:semicolon
id|type
op_ge
l_int|0
suffix:semicolon
id|type
op_assign
id|swap_info
(braket
id|type
)braket
dot
id|next
)paren
(brace
id|p
op_assign
id|swap_info
op_plus
id|type
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;flags
op_amp
id|SWP_ACTIVE
)paren
op_eq
id|SWP_ACTIVE
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;swap_file-&gt;f_mapping
op_eq
id|mapping
)paren
r_break
suffix:semicolon
)brace
id|prev
op_assign
id|type
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
OL
l_int|0
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|security_vm_enough_memory
c_func
(paren
id|p-&gt;pages
)paren
)paren
id|vm_unacct_memory
c_func
(paren
id|p-&gt;pages
)paren
suffix:semicolon
r_else
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prev
OL
l_int|0
)paren
(brace
id|swap_list.head
op_assign
id|p-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|swap_info
(braket
id|prev
)braket
dot
id|next
op_assign
id|p-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_eq
id|swap_list.next
)paren
(brace
multiline_comment|/* just pick something that&squot;s safe... */
id|swap_list.next
op_assign
id|swap_list.head
suffix:semicolon
)brace
id|nr_swap_pages
op_sub_assign
id|p-&gt;pages
suffix:semicolon
id|total_swap_pages
op_sub_assign
id|p-&gt;pages
suffix:semicolon
id|p-&gt;flags
op_and_assign
op_complement
id|SWP_WRITEOK
suffix:semicolon
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;flags
op_or_assign
id|PF_SWAPOFF
suffix:semicolon
id|err
op_assign
id|try_to_unuse
c_func
(paren
id|type
)paren
suffix:semicolon
id|current-&gt;flags
op_and_assign
op_complement
id|PF_SWAPOFF
suffix:semicolon
multiline_comment|/* wait for any unplug function to finish */
id|down_write
c_func
(paren
op_amp
id|swap_unplug_sem
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|swap_unplug_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
multiline_comment|/* re-insert swap space back into swap_list */
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|prev
op_assign
op_minus
l_int|1
comma
id|i
op_assign
id|swap_list.head
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|prev
op_assign
id|i
comma
id|i
op_assign
id|swap_info
(braket
id|i
)braket
dot
id|next
)paren
r_if
c_cond
(paren
id|p-&gt;prio
op_ge
id|swap_info
(braket
id|i
)braket
dot
id|prio
)paren
r_break
suffix:semicolon
id|p-&gt;next
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|prev
OL
l_int|0
)paren
id|swap_list.head
op_assign
id|swap_list.next
op_assign
id|p
op_minus
id|swap_info
suffix:semicolon
r_else
id|swap_info
(braket
id|prev
)braket
dot
id|next
op_assign
id|p
op_minus
id|swap_info
suffix:semicolon
id|nr_swap_pages
op_add_assign
id|p-&gt;pages
suffix:semicolon
id|total_swap_pages
op_add_assign
id|p-&gt;pages
suffix:semicolon
id|p-&gt;flags
op_or_assign
id|SWP_WRITEOK
suffix:semicolon
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|swapon_sem
)paren
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
id|drain_mmlist
c_func
(paren
)paren
suffix:semicolon
id|swap_device_lock
c_func
(paren
id|p
)paren
suffix:semicolon
id|swap_file
op_assign
id|p-&gt;swap_file
suffix:semicolon
id|p-&gt;swap_file
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;max
op_assign
l_int|0
suffix:semicolon
id|swap_map
op_assign
id|p-&gt;swap_map
suffix:semicolon
id|p-&gt;swap_map
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|destroy_swap_extents
c_func
(paren
id|p
)paren
suffix:semicolon
id|swap_device_unlock
c_func
(paren
id|p
)paren
suffix:semicolon
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|swapon_sem
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|swap_map
)paren
suffix:semicolon
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
r_if
c_cond
(paren
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
op_assign
id|I_BDEV
c_func
(paren
id|inode
)paren
suffix:semicolon
id|set_blocksize
c_func
(paren
id|bdev
comma
id|p-&gt;old_block_size
)paren
suffix:semicolon
id|bd_release
c_func
(paren
id|bdev
)paren
suffix:semicolon
)brace
r_else
(brace
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|inode-&gt;i_flags
op_and_assign
op_complement
id|S_SWAPFILE
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
)brace
id|filp_close
c_func
(paren
id|swap_file
comma
l_int|NULL
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|out_dput
suffix:colon
id|filp_close
c_func
(paren
id|victim
comma
l_int|NULL
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/* iterator */
DECL|function|swap_start
r_static
r_void
op_star
id|swap_start
c_func
(paren
r_struct
id|seq_file
op_star
id|swap
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|ptr
op_assign
id|swap_info
suffix:semicolon
r_int
id|i
suffix:semicolon
id|loff_t
id|l
op_assign
op_star
id|pos
suffix:semicolon
id|down
c_func
(paren
op_amp
id|swapon_sem
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_swapfiles
suffix:semicolon
id|i
op_increment
comma
id|ptr
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ptr-&gt;flags
op_amp
id|SWP_USED
)paren
op_logical_or
op_logical_neg
id|ptr-&gt;swap_map
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|l
op_decrement
)paren
r_return
id|ptr
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|swap_next
r_static
r_void
op_star
id|swap_next
c_func
(paren
r_struct
id|seq_file
op_star
id|swap
comma
r_void
op_star
id|v
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|ptr
op_assign
id|v
suffix:semicolon
r_struct
id|swap_info_struct
op_star
id|endptr
op_assign
id|swap_info
op_plus
id|nr_swapfiles
suffix:semicolon
r_for
c_loop
(paren
op_increment
id|ptr
suffix:semicolon
id|ptr
OL
id|endptr
suffix:semicolon
id|ptr
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ptr-&gt;flags
op_amp
id|SWP_USED
)paren
op_logical_or
op_logical_neg
id|ptr-&gt;swap_map
)paren
r_continue
suffix:semicolon
op_increment
op_star
id|pos
suffix:semicolon
r_return
id|ptr
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|swap_stop
r_static
r_void
id|swap_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|swap
comma
r_void
op_star
id|v
)paren
(brace
id|up
c_func
(paren
op_amp
id|swapon_sem
)paren
suffix:semicolon
)brace
DECL|function|swap_show
r_static
r_int
id|swap_show
c_func
(paren
r_struct
id|seq_file
op_star
id|swap
comma
r_void
op_star
id|v
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|ptr
op_assign
id|v
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|v
op_eq
id|swap_info
)paren
id|seq_puts
c_func
(paren
id|swap
comma
l_string|&quot;Filename&bslash;t&bslash;t&bslash;t&bslash;tType&bslash;t&bslash;tSize&bslash;tUsed&bslash;tPriority&bslash;n&quot;
)paren
suffix:semicolon
id|file
op_assign
id|ptr-&gt;swap_file
suffix:semicolon
id|len
op_assign
id|seq_path
c_func
(paren
id|swap
comma
id|file-&gt;f_vfsmnt
comma
id|file-&gt;f_dentry
comma
l_string|&quot; &bslash;t&bslash;n&bslash;&bslash;&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|swap
comma
l_string|&quot;%*s%s&bslash;t%d&bslash;t%ld&bslash;t%d&bslash;n&quot;
comma
id|len
OL
l_int|40
ques
c_cond
l_int|40
op_minus
id|len
suffix:colon
l_int|1
comma
l_string|&quot; &quot;
comma
id|S_ISBLK
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_mode
)paren
ques
c_cond
l_string|&quot;partition&quot;
suffix:colon
l_string|&quot;file&bslash;t&quot;
comma
id|ptr-&gt;pages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|ptr-&gt;inuse_pages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|ptr-&gt;prio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|swaps_op
r_static
r_struct
id|seq_operations
id|swaps_op
op_assign
(brace
dot
id|start
op_assign
id|swap_start
comma
dot
id|next
op_assign
id|swap_next
comma
dot
id|stop
op_assign
id|swap_stop
comma
dot
id|show
op_assign
id|swap_show
)brace
suffix:semicolon
DECL|function|swaps_open
r_static
r_int
id|swaps_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_return
id|seq_open
c_func
(paren
id|file
comma
op_amp
id|swaps_op
)paren
suffix:semicolon
)brace
DECL|variable|proc_swaps_operations
r_static
r_struct
id|file_operations
id|proc_swaps_operations
op_assign
(brace
dot
id|open
op_assign
id|swaps_open
comma
dot
id|read
op_assign
id|seq_read
comma
dot
id|llseek
op_assign
id|seq_lseek
comma
dot
id|release
op_assign
id|seq_release
comma
)brace
suffix:semicolon
DECL|function|procswaps_init
r_static
r_int
id|__init
id|procswaps_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|entry
suffix:semicolon
id|entry
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;swaps&quot;
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
id|entry-&gt;proc_fops
op_assign
op_amp
id|proc_swaps_operations
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|procswaps_init
id|__initcall
c_func
(paren
id|procswaps_init
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PROC_FS */
multiline_comment|/*&n; * Written 01/25/92 by Simmule Turner, heavily changed by Linus.&n; *&n; * The swapon system call&n; */
DECL|function|sys_swapon
id|asmlinkage
r_int
id|sys_swapon
c_func
(paren
r_const
r_char
id|__user
op_star
id|specialfile
comma
r_int
id|swap_flags
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_char
op_star
id|name
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|file
op_star
id|swap_file
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
r_int
r_int
id|type
suffix:semicolon
r_int
id|i
comma
id|prev
suffix:semicolon
r_int
id|error
suffix:semicolon
r_static
r_int
id|least_priority
suffix:semicolon
r_union
id|swap_header
op_star
id|swap_header
op_assign
l_int|NULL
suffix:semicolon
r_int
id|swap_header_version
suffix:semicolon
r_int
id|nr_good_pages
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|maxpages
op_assign
l_int|1
suffix:semicolon
r_int
id|swapfilesize
suffix:semicolon
r_int
r_int
op_star
id|swap_map
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
l_int|NULL
suffix:semicolon
r_int
id|did_down
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
id|p
op_assign
id|swap_info
suffix:semicolon
r_for
c_loop
(paren
id|type
op_assign
l_int|0
suffix:semicolon
id|type
OL
id|nr_swapfiles
suffix:semicolon
id|type
op_increment
comma
id|p
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;flags
op_amp
id|SWP_USED
)paren
)paren
r_break
suffix:semicolon
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/*&n;&t; * Test if adding another swap device is possible. There are&n;&t; * two limiting factors: 1) the number of bits for the swap&n;&t; * type swp_entry_t definition and 2) the number of bits for&n;&t; * the swap type in the swap ptes as defined by the different&n;&t; * architectures. To honor both limitations a swap entry&n;&t; * with swap offset 0 and swap type ~0UL is created, encoded&n;&t; * to a swap pte, decoded to a swp_entry_t again and finally&n;&t; * the swap type part is extracted. This will mask all bits&n;&t; * from the initial ~0UL that can&squot;t be encoded in either the&n;&t; * swp_entry_t or the architecture definition of a swap pte.&n;&t; */
r_if
c_cond
(paren
id|type
OG
id|swp_type
c_func
(paren
id|pte_to_swp_entry
c_func
(paren
id|swp_entry_to_pte
c_func
(paren
id|swp_entry
c_func
(paren
op_complement
l_int|0UL
comma
l_int|0
)paren
)paren
)paren
)paren
)paren
(brace
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
id|nr_swapfiles
op_assign
id|type
op_plus
l_int|1
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|p-&gt;extent_list
)paren
suffix:semicolon
id|p-&gt;flags
op_assign
id|SWP_USED
suffix:semicolon
id|p-&gt;nr_extents
op_assign
l_int|0
suffix:semicolon
id|p-&gt;swap_file
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;old_block_size
op_assign
l_int|0
suffix:semicolon
id|p-&gt;swap_map
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;lowest_bit
op_assign
l_int|0
suffix:semicolon
id|p-&gt;highest_bit
op_assign
l_int|0
suffix:semicolon
id|p-&gt;cluster_nr
op_assign
l_int|0
suffix:semicolon
id|p-&gt;inuse_pages
op_assign
l_int|0
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|p-&gt;sdev_lock
)paren
suffix:semicolon
id|p-&gt;next
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|swap_flags
op_amp
id|SWAP_FLAG_PREFER
)paren
(brace
id|p-&gt;prio
op_assign
(paren
id|swap_flags
op_amp
id|SWAP_FLAG_PRIO_MASK
)paren
op_rshift
id|SWAP_FLAG_PRIO_SHIFT
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;prio
op_assign
op_decrement
id|least_priority
suffix:semicolon
)brace
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
id|name
op_assign
id|getname
c_func
(paren
id|specialfile
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|name
)paren
)paren
(brace
id|name
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|bad_swap_2
suffix:semicolon
)brace
id|swap_file
op_assign
id|filp_open
c_func
(paren
id|name
comma
id|O_RDWR
op_or
id|O_LARGEFILE
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|swap_file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|swap_file
)paren
)paren
(brace
id|swap_file
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|bad_swap_2
suffix:semicolon
)brace
id|p-&gt;swap_file
op_assign
id|swap_file
suffix:semicolon
id|mapping
op_assign
id|swap_file-&gt;f_mapping
suffix:semicolon
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_swapfiles
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|q
op_assign
op_amp
id|swap_info
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|type
op_logical_or
op_logical_neg
id|q-&gt;swap_file
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mapping
op_eq
id|q-&gt;swap_file-&gt;f_mapping
)paren
r_goto
id|bad_swap
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|bdev
op_assign
id|I_BDEV
c_func
(paren
id|inode
)paren
suffix:semicolon
id|error
op_assign
id|bd_claim
c_func
(paren
id|bdev
comma
id|sys_swapon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
id|bdev
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
id|p-&gt;old_block_size
op_assign
id|block_size
c_func
(paren
id|bdev
)paren
suffix:semicolon
id|error
op_assign
id|set_blocksize
c_func
(paren
id|bdev
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_goto
id|bad_swap
suffix:semicolon
id|p-&gt;bdev
op_assign
id|bdev
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|p-&gt;bdev
op_assign
id|inode-&gt;i_sb-&gt;s_bdev
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|did_down
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|IS_SWAPFILE
c_func
(paren
id|inode
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
)brace
r_else
(brace
r_goto
id|bad_swap
suffix:semicolon
)brace
id|swapfilesize
op_assign
id|i_size_read
c_func
(paren
id|inode
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/*&n;&t; * Read the swap header.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|mapping-&gt;a_ops-&gt;readpage
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
id|page
op_assign
id|read_cache_page
c_func
(paren
id|mapping
comma
l_int|0
comma
(paren
id|filler_t
op_star
)paren
id|mapping-&gt;a_ops-&gt;readpage
comma
id|swap_file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
id|wait_on_page_locked
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|bad_swap
suffix:semicolon
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|swap_header
op_assign
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;SWAP-SPACE&quot;
comma
id|swap_header-&gt;magic.magic
comma
l_int|10
)paren
)paren
id|swap_header_version
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;SWAPSPACE2&quot;
comma
id|swap_header-&gt;magic.magic
comma
l_int|10
)paren
)paren
id|swap_header_version
op_assign
l_int|2
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to find swap-space signature&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|swap_header_version
)paren
(brace
r_case
l_int|1
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;version 0 swap is no longer supported. &quot;
l_string|&quot;Use mkswap -v1 %s&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* Check the swap header&squot;s sub-version and the size of&n;                   the swap file and bad block lists */
r_if
c_cond
(paren
id|swap_header-&gt;info.version
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Unable to handle swap header version %d&bslash;n&quot;
comma
id|swap_header-&gt;info.version
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
id|p-&gt;lowest_bit
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Find out how many pages are allowed for a single swap&n;&t;&t; * device. There are two limiting factors: 1) the number of&n;&t;&t; * bits for the swap offset in the swp_entry_t type and&n;&t;&t; * 2) the number of bits in the a swap pte as defined by&n;&t;&t; * the different architectures. In order to find the&n;&t;&t; * largest possible bit mask a swap entry with swap type 0&n;&t;&t; * and swap offset ~0UL is created, encoded to a swap pte,&n;&t;&t; * decoded to a swp_entry_t again and finally the swap&n;&t;&t; * offset is extracted. This will mask all the bits from&n;&t;&t; * the initial ~0UL mask that can&squot;t be encoded in either&n;&t;&t; * the swp_entry_t or the architecture definition of a&n;&t;&t; * swap pte.&n;&t;&t; */
id|maxpages
op_assign
id|swp_offset
c_func
(paren
id|pte_to_swp_entry
c_func
(paren
id|swp_entry_to_pte
c_func
(paren
id|swp_entry
c_func
(paren
l_int|0
comma
op_complement
l_int|0UL
)paren
)paren
)paren
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|maxpages
OG
id|swap_header-&gt;info.last_page
)paren
id|maxpages
op_assign
id|swap_header-&gt;info.last_page
suffix:semicolon
id|p-&gt;highest_bit
op_assign
id|maxpages
op_minus
l_int|1
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|swap_header-&gt;info.nr_badpages
OG
id|MAX_SWAP_BADPAGES
)paren
r_goto
id|bad_swap
suffix:semicolon
multiline_comment|/* OK, set up the swap map and apply the bad block list */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;swap_map
op_assign
id|vmalloc
c_func
(paren
id|maxpages
op_star
r_sizeof
(paren
r_int
)paren
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|p-&gt;swap_map
comma
l_int|0
comma
id|maxpages
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|swap_header-&gt;info.nr_badpages
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|page
op_assign
id|swap_header-&gt;info.badpages
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|page
op_le
l_int|0
op_logical_or
id|page
op_ge
id|swap_header-&gt;info.last_page
)paren
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_else
id|p-&gt;swap_map
(braket
id|page
)braket
op_assign
id|SWAP_MAP_BAD
suffix:semicolon
)brace
id|nr_good_pages
op_assign
id|swap_header-&gt;info.last_page
op_minus
id|swap_header-&gt;info.nr_badpages
op_minus
l_int|1
multiline_comment|/* header page */
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|bad_swap
suffix:semicolon
)brace
r_if
c_cond
(paren
id|swapfilesize
op_logical_and
id|maxpages
OG
id|swapfilesize
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Swap area shorter than signature indicates&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|nr_good_pages
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Empty swap-file&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad_swap
suffix:semicolon
)brace
id|p-&gt;swap_map
(braket
l_int|0
)braket
op_assign
id|SWAP_MAP_BAD
suffix:semicolon
id|p-&gt;max
op_assign
id|maxpages
suffix:semicolon
id|p-&gt;pages
op_assign
id|nr_good_pages
suffix:semicolon
id|error
op_assign
id|setup_swap_extents
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|bad_swap
suffix:semicolon
id|down
c_func
(paren
op_amp
id|swapon_sem
)paren
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
id|swap_device_lock
c_func
(paren
id|p
)paren
suffix:semicolon
id|p-&gt;flags
op_assign
id|SWP_ACTIVE
suffix:semicolon
id|nr_swap_pages
op_add_assign
id|nr_good_pages
suffix:semicolon
id|total_swap_pages
op_add_assign
id|nr_good_pages
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Adding %dk swap on %s.  Priority:%d extents:%d&bslash;n&quot;
comma
id|nr_good_pages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|name
comma
id|p-&gt;prio
comma
id|p-&gt;nr_extents
)paren
suffix:semicolon
multiline_comment|/* insert swap space into swap_list: */
id|prev
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|swap_list.head
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_assign
id|swap_info
(braket
id|i
)braket
dot
id|next
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;prio
op_ge
id|swap_info
(braket
id|i
)braket
dot
id|prio
)paren
(brace
r_break
suffix:semicolon
)brace
id|prev
op_assign
id|i
suffix:semicolon
)brace
id|p-&gt;next
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|prev
OL
l_int|0
)paren
(brace
id|swap_list.head
op_assign
id|swap_list.next
op_assign
id|p
op_minus
id|swap_info
suffix:semicolon
)brace
r_else
(brace
id|swap_info
(braket
id|prev
)braket
dot
id|next
op_assign
id|p
op_minus
id|swap_info
suffix:semicolon
)brace
id|swap_device_unlock
c_func
(paren
id|p
)paren
suffix:semicolon
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|swapon_sem
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_swap
suffix:colon
r_if
c_cond
(paren
id|bdev
)paren
(brace
id|set_blocksize
c_func
(paren
id|bdev
comma
id|p-&gt;old_block_size
)paren
suffix:semicolon
id|bd_release
c_func
(paren
id|bdev
)paren
suffix:semicolon
)brace
id|bad_swap_2
suffix:colon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
id|swap_map
op_assign
id|p-&gt;swap_map
suffix:semicolon
id|p-&gt;swap_file
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;swap_map
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|swap_flags
op_amp
id|SWAP_FLAG_PREFER
)paren
)paren
op_increment
id|least_priority
suffix:semicolon
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
id|destroy_swap_extents
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|swap_map
)paren
id|vfree
c_func
(paren
id|swap_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|swap_file
)paren
id|filp_close
c_func
(paren
id|swap_file
comma
l_int|NULL
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|page
op_logical_and
op_logical_neg
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|name
)paren
id|putname
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|did_down
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|inode-&gt;i_flags
op_or_assign
id|S_SWAPFILE
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|si_swapinfo
r_void
id|si_swapinfo
c_func
(paren
r_struct
id|sysinfo
op_star
id|val
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|nr_to_be_unused
op_assign
l_int|0
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_swapfiles
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|swap_info
(braket
id|i
)braket
dot
id|flags
op_amp
id|SWP_USED
)paren
op_logical_or
(paren
id|swap_info
(braket
id|i
)braket
dot
id|flags
op_amp
id|SWP_WRITEOK
)paren
)paren
r_continue
suffix:semicolon
id|nr_to_be_unused
op_add_assign
id|swap_info
(braket
id|i
)braket
dot
id|inuse_pages
suffix:semicolon
)brace
id|val-&gt;freeswap
op_assign
id|nr_swap_pages
op_plus
id|nr_to_be_unused
suffix:semicolon
id|val-&gt;totalswap
op_assign
id|total_swap_pages
op_plus
id|nr_to_be_unused
suffix:semicolon
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Verify that a swap entry is valid and increment its swap map count.&n; *&n; * Note: if swap_map[] reaches SWAP_MAP_MAX the entries are treated as&n; * &quot;permanent&quot;, but will be reclaimed by the next swapoff.&n; */
DECL|function|swap_duplicate
r_int
id|swap_duplicate
c_func
(paren
id|swp_entry_t
id|entry
)paren
(brace
r_struct
id|swap_info_struct
op_star
id|p
suffix:semicolon
r_int
r_int
id|offset
comma
id|type
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|type
op_assign
id|swp_type
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|nr_swapfiles
)paren
r_goto
id|bad_file
suffix:semicolon
id|p
op_assign
id|type
op_plus
id|swap_info
suffix:semicolon
id|offset
op_assign
id|swp_offset
c_func
(paren
id|entry
)paren
suffix:semicolon
id|swap_device_lock
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
id|p-&gt;max
op_logical_and
id|p-&gt;swap_map
(braket
id|offset
)braket
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;swap_map
(braket
id|offset
)braket
OL
id|SWAP_MAP_MAX
op_minus
l_int|1
)paren
(brace
id|p-&gt;swap_map
(braket
id|offset
)braket
op_increment
suffix:semicolon
id|result
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;swap_map
(braket
id|offset
)braket
op_le
id|SWAP_MAP_MAX
)paren
(brace
r_if
c_cond
(paren
id|swap_overflow
op_increment
OL
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;swap_dup: swap entry overflow&bslash;n&quot;
)paren
suffix:semicolon
id|p-&gt;swap_map
(braket
id|offset
)braket
op_assign
id|SWAP_MAP_MAX
suffix:semicolon
id|result
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|swap_device_unlock
c_func
(paren
id|p
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|result
suffix:semicolon
id|bad_file
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swap_dup: %s%08lx&bslash;n&quot;
comma
id|Bad_file
comma
id|entry.val
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_struct
id|swap_info_struct
op_star
DECL|function|get_swap_info_struct
id|get_swap_info_struct
c_func
(paren
r_int
id|type
)paren
(brace
r_return
op_amp
id|swap_info
(braket
id|type
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * swap_device_lock prevents swap_map being freed. Don&squot;t grab an extra&n; * reference on the swaphandle, it doesn&squot;t matter if it becomes unused.&n; */
DECL|function|valid_swaphandles
r_int
id|valid_swaphandles
c_func
(paren
id|swp_entry_t
id|entry
comma
r_int
r_int
op_star
id|offset
)paren
(brace
r_int
id|ret
op_assign
l_int|0
comma
id|i
op_assign
l_int|1
op_lshift
id|page_cluster
suffix:semicolon
r_int
r_int
id|toff
suffix:semicolon
r_struct
id|swap_info_struct
op_star
id|swapdev
op_assign
id|swp_type
c_func
(paren
id|entry
)paren
op_plus
id|swap_info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_cluster
)paren
multiline_comment|/* no readahead */
r_return
l_int|0
suffix:semicolon
id|toff
op_assign
(paren
id|swp_offset
c_func
(paren
id|entry
)paren
op_rshift
id|page_cluster
)paren
op_lshift
id|page_cluster
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|toff
)paren
multiline_comment|/* first page is swap header */
id|toff
op_increment
comma
id|i
op_decrement
suffix:semicolon
op_star
id|offset
op_assign
id|toff
suffix:semicolon
id|swap_device_lock
c_func
(paren
id|swapdev
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* Don&squot;t read-ahead past the end of the swap area */
r_if
c_cond
(paren
id|toff
op_ge
id|swapdev-&gt;max
)paren
r_break
suffix:semicolon
multiline_comment|/* Don&squot;t read in free or bad pages */
r_if
c_cond
(paren
op_logical_neg
id|swapdev-&gt;swap_map
(braket
id|toff
)braket
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|swapdev-&gt;swap_map
(braket
id|toff
)braket
op_eq
id|SWAP_MAP_BAD
)paren
r_break
suffix:semicolon
id|toff
op_increment
suffix:semicolon
id|ret
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|i
)paren
suffix:semicolon
id|swap_device_unlock
c_func
(paren
id|swapdev
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
eof
