multiline_comment|/*&n; *  linux/mm/swap.c&n; *&n; *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; */
multiline_comment|/*&n; * This file contains the default values for the opereation of the&n; * Linux VM subsystem. Fine-tuning documentation can be found in&n; * Documentation/sysctl/vm.txt.&n; * Started 18.12.91&n; * Swap aging added 23.2.95, Stephen Tweedie.&n; * Buffermem limits added 12.3.98, Rik van Riel.&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/pagevec.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/mm_inline.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;&t;/* for try_to_release_page() */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/percpu_counter.h&gt;
macro_line|#include &lt;linux/percpu.h&gt;
macro_line|#include &lt;linux/cpu.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/init.h&gt;
multiline_comment|/* How many pages do we try to swap or page in/out together? */
DECL|variable|page_cluster
r_int
id|page_cluster
suffix:semicolon
macro_line|#ifdef CONFIG_HUGETLB_PAGE
DECL|function|put_page
r_void
id|put_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|PageCompound
c_func
(paren
id|page
)paren
)paren
)paren
(brace
id|page
op_assign
(paren
r_struct
id|page
op_star
)paren
id|page
op_member_access_from_pointer
r_private
suffix:semicolon
r_if
c_cond
(paren
id|put_page_testzero
c_func
(paren
id|page
)paren
)paren
(brace
r_void
(paren
op_star
id|dtor
)paren
(paren
r_struct
id|page
op_star
id|page
)paren
suffix:semicolon
id|dtor
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_struct
id|page
op_star
)paren
)paren
id|page
(braket
l_int|1
)braket
dot
id|mapping
suffix:semicolon
(paren
op_star
id|dtor
)paren
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|PageReserved
c_func
(paren
id|page
)paren
op_logical_and
id|put_page_testzero
c_func
(paren
id|page
)paren
)paren
id|__page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|variable|put_page
id|EXPORT_SYMBOL
c_func
(paren
id|put_page
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Writeback is about to end against a page which has been marked for immediate&n; * reclaim.  If it still appears to be reclaimable, move it to the tail of the&n; * inactive list.  The page still has PageWriteback set, which will pin it.&n; *&n; * We don&squot;t expect many pages to come through here, so don&squot;t bother batching&n; * things up.&n; *&n; * To avoid placing the page at the tail of the LRU while PG_writeback is still&n; * set, this function will clear PG_writeback before performing the page&n; * motion.  Do that inside the lru lock because once PG_writeback is cleared&n; * we may not touch the page.&n; *&n; * Returns zero if it cleared PG_writeback.&n; */
DECL|function|rotate_reclaimable_page
r_int
id|rotate_reclaimable_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|zone
op_star
id|zone
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|PageLocked
c_func
(paren
id|page
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|PageDirty
c_func
(paren
id|page
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|PageActive
c_func
(paren
id|page
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLRU
c_func
(paren
id|page
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|zone
op_assign
id|page_zone
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|zone-&gt;lru_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageLRU
c_func
(paren
id|page
)paren
op_logical_and
op_logical_neg
id|PageActive
c_func
(paren
id|page
)paren
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|page-&gt;lru
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|page-&gt;lru
comma
op_amp
id|zone-&gt;inactive_list
)paren
suffix:semicolon
id|inc_page_state
c_func
(paren
id|pgrotated
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|test_clear_page_writeback
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|zone-&gt;lru_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * FIXME: speed this up?&n; */
DECL|function|activate_page
r_void
id|fastcall
id|activate_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|zone
op_star
id|zone
op_assign
id|page_zone
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageLRU
c_func
(paren
id|page
)paren
op_logical_and
op_logical_neg
id|PageActive
c_func
(paren
id|page
)paren
)paren
(brace
id|del_page_from_inactive_list
c_func
(paren
id|zone
comma
id|page
)paren
suffix:semicolon
id|SetPageActive
c_func
(paren
id|page
)paren
suffix:semicolon
id|add_page_to_active_list
c_func
(paren
id|zone
comma
id|page
)paren
suffix:semicolon
id|inc_page_state
c_func
(paren
id|pgactivate
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Mark a page as having seen activity.&n; *&n; * inactive,unreferenced&t;-&gt;&t;inactive,referenced&n; * inactive,referenced&t;&t;-&gt;&t;active,unreferenced&n; * active,unreferenced&t;&t;-&gt;&t;active,referenced&n; */
DECL|function|mark_page_accessed
r_void
id|fastcall
id|mark_page_accessed
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|PageActive
c_func
(paren
id|page
)paren
op_logical_and
id|PageReferenced
c_func
(paren
id|page
)paren
op_logical_and
id|PageLRU
c_func
(paren
id|page
)paren
)paren
(brace
id|activate_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ClearPageReferenced
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|PageReferenced
c_func
(paren
id|page
)paren
)paren
(brace
id|SetPageReferenced
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
DECL|variable|mark_page_accessed
id|EXPORT_SYMBOL
c_func
(paren
id|mark_page_accessed
)paren
suffix:semicolon
multiline_comment|/**&n; * lru_cache_add: add a page to the page lists&n; * @page: the page to add&n; */
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_struct
id|pagevec
comma
id|lru_add_pvecs
)paren
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_struct
id|pagevec
comma
id|lru_add_active_pvecs
)paren
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|function|lru_cache_add
r_void
id|fastcall
id|lru_cache_add
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|pagevec
op_star
id|pvec
op_assign
op_amp
id|get_cpu_var
c_func
(paren
id|lru_add_pvecs
)paren
suffix:semicolon
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagevec_add
c_func
(paren
id|pvec
comma
id|page
)paren
)paren
id|__pagevec_lru_add
c_func
(paren
id|pvec
)paren
suffix:semicolon
id|put_cpu_var
c_func
(paren
id|lru_add_pvecs
)paren
suffix:semicolon
)brace
DECL|function|lru_cache_add_active
r_void
id|fastcall
id|lru_cache_add_active
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|pagevec
op_star
id|pvec
op_assign
op_amp
id|get_cpu_var
c_func
(paren
id|lru_add_active_pvecs
)paren
suffix:semicolon
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagevec_add
c_func
(paren
id|pvec
comma
id|page
)paren
)paren
id|__pagevec_lru_add_active
c_func
(paren
id|pvec
)paren
suffix:semicolon
id|put_cpu_var
c_func
(paren
id|lru_add_active_pvecs
)paren
suffix:semicolon
)brace
DECL|function|lru_add_drain
r_void
id|lru_add_drain
c_func
(paren
r_void
)paren
(brace
r_struct
id|pagevec
op_star
id|pvec
op_assign
op_amp
id|get_cpu_var
c_func
(paren
id|lru_add_pvecs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pagevec_count
c_func
(paren
id|pvec
)paren
)paren
id|__pagevec_lru_add
c_func
(paren
id|pvec
)paren
suffix:semicolon
id|pvec
op_assign
op_amp
id|__get_cpu_var
c_func
(paren
id|lru_add_active_pvecs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pagevec_count
c_func
(paren
id|pvec
)paren
)paren
id|__pagevec_lru_add_active
c_func
(paren
id|pvec
)paren
suffix:semicolon
id|put_cpu_var
c_func
(paren
id|lru_add_pvecs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This path almost never happens for VM activity - pages are normally&n; * freed via pagevecs.  But it gets used by networking.&n; */
DECL|function|__page_cache_release
r_void
id|fastcall
id|__page_cache_release
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|zone
op_star
id|zone
op_assign
id|page_zone
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|zone-&gt;lru_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TestClearPageLRU
c_func
(paren
id|page
)paren
)paren
id|del_page_from_lru
c_func
(paren
id|zone
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page_count
c_func
(paren
id|page
)paren
op_ne
l_int|0
)paren
id|page
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|zone-&gt;lru_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
id|free_hot_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|variable|__page_cache_release
id|EXPORT_SYMBOL
c_func
(paren
id|__page_cache_release
)paren
suffix:semicolon
multiline_comment|/*&n; * Batched page_cache_release().  Decrement the reference count on all the&n; * passed pages.  If it fell to zero then remove the page from the LRU and&n; * free it.&n; *&n; * Avoid taking zone-&gt;lru_lock if possible, but if it is taken, retain it&n; * for the remainder of the operation.&n; *&n; * The locking in this function is against shrink_cache(): we recheck the&n; * page count inside the lock to see whether shrink_cache grabbed the page&n; * via the LRU.  If it did, give up: shrink_cache will free it.&n; */
DECL|function|release_pages
r_void
id|release_pages
c_func
(paren
r_struct
id|page
op_star
op_star
id|pages
comma
r_int
id|nr
comma
r_int
id|cold
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|pagevec
id|pages_to_free
suffix:semicolon
r_struct
id|zone
op_star
id|zone
op_assign
l_int|NULL
suffix:semicolon
id|pagevec_init
c_func
(paren
op_amp
id|pages_to_free
comma
id|cold
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|pages
(braket
id|i
)braket
suffix:semicolon
r_struct
id|zone
op_star
id|pagezone
suffix:semicolon
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|page
)paren
op_logical_or
op_logical_neg
id|put_page_testzero
c_func
(paren
id|page
)paren
)paren
r_continue
suffix:semicolon
id|pagezone
op_assign
id|page_zone
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pagezone
op_ne
id|zone
)paren
(brace
r_if
c_cond
(paren
id|zone
)paren
id|spin_unlock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
id|zone
op_assign
id|pagezone
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TestClearPageLRU
c_func
(paren
id|page
)paren
)paren
id|del_page_from_lru
c_func
(paren
id|zone
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page_count
c_func
(paren
id|page
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pagevec_add
c_func
(paren
op_amp
id|pages_to_free
comma
id|page
)paren
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
id|__pagevec_free
c_func
(paren
op_amp
id|pages_to_free
)paren
suffix:semicolon
id|pagevec_reinit
c_func
(paren
op_amp
id|pages_to_free
)paren
suffix:semicolon
id|zone
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* No lock is held */
)brace
)brace
)brace
r_if
c_cond
(paren
id|zone
)paren
id|spin_unlock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
id|pagevec_free
c_func
(paren
op_amp
id|pages_to_free
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The pages which we&squot;re about to release may be in the deferred lru-addition&n; * queues.  That would prevent them from really being freed right now.  That&squot;s&n; * OK from a correctness point of view but is inefficient - those pages may be&n; * cache-warm and we want to give them back to the page allocator ASAP.&n; *&n; * So __pagevec_release() will drain those queues here.  __pagevec_lru_add()&n; * and __pagevec_lru_add_active() call release_pages() directly to avoid&n; * mutual recursion.&n; */
DECL|function|__pagevec_release
r_void
id|__pagevec_release
c_func
(paren
r_struct
id|pagevec
op_star
id|pvec
)paren
(brace
id|lru_add_drain
c_func
(paren
)paren
suffix:semicolon
id|release_pages
c_func
(paren
id|pvec-&gt;pages
comma
id|pagevec_count
c_func
(paren
id|pvec
)paren
comma
id|pvec-&gt;cold
)paren
suffix:semicolon
id|pagevec_reinit
c_func
(paren
id|pvec
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pagevec_release() for pages which are known to not be on the LRU&n; *&n; * This function reinitialises the caller&squot;s pagevec.&n; */
DECL|function|__pagevec_release_nonlru
r_void
id|__pagevec_release_nonlru
c_func
(paren
r_struct
id|pagevec
op_star
id|pvec
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|pagevec
id|pages_to_free
suffix:semicolon
id|pagevec_init
c_func
(paren
op_amp
id|pages_to_free
comma
id|pvec-&gt;cold
)paren
suffix:semicolon
id|pages_to_free.cold
op_assign
id|pvec-&gt;cold
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pagevec_count
c_func
(paren
id|pvec
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|pvec-&gt;pages
(braket
id|i
)braket
suffix:semicolon
id|BUG_ON
c_func
(paren
id|PageLRU
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|put_page_testzero
c_func
(paren
id|page
)paren
)paren
id|pagevec_add
c_func
(paren
op_amp
id|pages_to_free
comma
id|page
)paren
suffix:semicolon
)brace
id|pagevec_free
c_func
(paren
op_amp
id|pages_to_free
)paren
suffix:semicolon
id|pagevec_reinit
c_func
(paren
id|pvec
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add the passed pages to the LRU, then drop the caller&squot;s refcount&n; * on them.  Reinitialises the caller&squot;s pagevec.&n; */
DECL|function|__pagevec_lru_add
r_void
id|__pagevec_lru_add
c_func
(paren
r_struct
id|pagevec
op_star
id|pvec
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|zone
op_star
id|zone
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pagevec_count
c_func
(paren
id|pvec
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|pvec-&gt;pages
(braket
id|i
)braket
suffix:semicolon
r_struct
id|zone
op_star
id|pagezone
op_assign
id|page_zone
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pagezone
op_ne
id|zone
)paren
(brace
r_if
c_cond
(paren
id|zone
)paren
id|spin_unlock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
id|zone
op_assign
id|pagezone
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TestSetPageLRU
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|add_page_to_inactive_list
c_func
(paren
id|zone
comma
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zone
)paren
id|spin_unlock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
id|release_pages
c_func
(paren
id|pvec-&gt;pages
comma
id|pvec-&gt;nr
comma
id|pvec-&gt;cold
)paren
suffix:semicolon
id|pagevec_reinit
c_func
(paren
id|pvec
)paren
suffix:semicolon
)brace
DECL|variable|__pagevec_lru_add
id|EXPORT_SYMBOL
c_func
(paren
id|__pagevec_lru_add
)paren
suffix:semicolon
DECL|function|__pagevec_lru_add_active
r_void
id|__pagevec_lru_add_active
c_func
(paren
r_struct
id|pagevec
op_star
id|pvec
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|zone
op_star
id|zone
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pagevec_count
c_func
(paren
id|pvec
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|pvec-&gt;pages
(braket
id|i
)braket
suffix:semicolon
r_struct
id|zone
op_star
id|pagezone
op_assign
id|page_zone
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pagezone
op_ne
id|zone
)paren
(brace
r_if
c_cond
(paren
id|zone
)paren
id|spin_unlock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
id|zone
op_assign
id|pagezone
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TestSetPageLRU
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TestSetPageActive
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|add_page_to_active_list
c_func
(paren
id|zone
comma
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zone
)paren
id|spin_unlock_irq
c_func
(paren
op_amp
id|zone-&gt;lru_lock
)paren
suffix:semicolon
id|release_pages
c_func
(paren
id|pvec-&gt;pages
comma
id|pvec-&gt;nr
comma
id|pvec-&gt;cold
)paren
suffix:semicolon
id|pagevec_reinit
c_func
(paren
id|pvec
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to drop buffers from the pages in a pagevec&n; */
DECL|function|pagevec_strip
r_void
id|pagevec_strip
c_func
(paren
r_struct
id|pagevec
op_star
id|pvec
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pagevec_count
c_func
(paren
id|pvec
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|pvec-&gt;pages
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|PagePrivate
c_func
(paren
id|page
)paren
op_logical_and
op_logical_neg
id|TestSetPageLocked
c_func
(paren
id|page
)paren
)paren
(brace
id|try_to_release_page
c_func
(paren
id|page
comma
l_int|0
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**&n; * pagevec_lookup - gang pagecache lookup&n; * @pvec:&t;Where the resulting pages are placed&n; * @mapping:&t;The address_space to search&n; * @start:&t;The starting page index&n; * @nr_pages:&t;The maximum number of pages&n; *&n; * pagevec_lookup() will search for and return a group of up to @nr_pages pages&n; * in the mapping.  The pages are placed in @pvec.  pagevec_lookup() takes a&n; * reference against the pages in @pvec.&n; *&n; * The search returns a group of mapping-contiguous pages with ascending&n; * indexes.  There may be holes in the indices due to not-present pages.&n; *&n; * pagevec_lookup() returns the number of pages which were found.&n; */
DECL|function|pagevec_lookup
r_int
id|pagevec_lookup
c_func
(paren
r_struct
id|pagevec
op_star
id|pvec
comma
r_struct
id|address_space
op_star
id|mapping
comma
id|pgoff_t
id|start
comma
r_int
id|nr_pages
)paren
(brace
id|pvec-&gt;nr
op_assign
id|find_get_pages
c_func
(paren
id|mapping
comma
id|start
comma
id|nr_pages
comma
id|pvec-&gt;pages
)paren
suffix:semicolon
r_return
id|pagevec_count
c_func
(paren
id|pvec
)paren
suffix:semicolon
)brace
DECL|function|pagevec_lookup_tag
r_int
id|pagevec_lookup_tag
c_func
(paren
r_struct
id|pagevec
op_star
id|pvec
comma
r_struct
id|address_space
op_star
id|mapping
comma
id|pgoff_t
op_star
id|index
comma
r_int
id|tag
comma
r_int
id|nr_pages
)paren
(brace
id|pvec-&gt;nr
op_assign
id|find_get_pages_tag
c_func
(paren
id|mapping
comma
id|index
comma
id|tag
comma
id|nr_pages
comma
id|pvec-&gt;pages
)paren
suffix:semicolon
r_return
id|pagevec_count
c_func
(paren
id|pvec
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n; * We tolerate a little inaccuracy to avoid ping-ponging the counter between&n; * CPUs&n; */
DECL|macro|ACCT_THRESHOLD
mdefine_line|#define ACCT_THRESHOLD&t;max(16, NR_CPUS * 2)
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_int
comma
id|committed_space
)paren
op_assign
l_int|0
suffix:semicolon
DECL|function|vm_acct_memory
r_void
id|vm_acct_memory
c_func
(paren
r_int
id|pages
)paren
(brace
r_int
op_star
id|local
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
id|local
op_assign
op_amp
id|__get_cpu_var
c_func
(paren
id|committed_space
)paren
suffix:semicolon
op_star
id|local
op_add_assign
id|pages
suffix:semicolon
r_if
c_cond
(paren
op_star
id|local
OG
id|ACCT_THRESHOLD
op_logical_or
op_star
id|local
OL
op_minus
id|ACCT_THRESHOLD
)paren
(brace
id|atomic_add
c_func
(paren
op_star
id|local
comma
op_amp
id|vm_committed_space
)paren
suffix:semicolon
op_star
id|local
op_assign
l_int|0
suffix:semicolon
)brace
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|vm_acct_memory
id|EXPORT_SYMBOL
c_func
(paren
id|vm_acct_memory
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_HOTPLUG_CPU
DECL|function|lru_drain_cache
r_static
r_void
id|lru_drain_cache
c_func
(paren
r_int
r_int
id|cpu
)paren
(brace
r_struct
id|pagevec
op_star
id|pvec
op_assign
op_amp
id|per_cpu
c_func
(paren
id|lru_add_pvecs
comma
id|cpu
)paren
suffix:semicolon
multiline_comment|/* CPU is dead, so no locking needed. */
r_if
c_cond
(paren
id|pagevec_count
c_func
(paren
id|pvec
)paren
)paren
id|__pagevec_lru_add
c_func
(paren
id|pvec
)paren
suffix:semicolon
id|pvec
op_assign
op_amp
id|per_cpu
c_func
(paren
id|lru_add_active_pvecs
comma
id|cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pagevec_count
c_func
(paren
id|pvec
)paren
)paren
id|__pagevec_lru_add_active
c_func
(paren
id|pvec
)paren
suffix:semicolon
)brace
multiline_comment|/* Drop the CPU&squot;s cached committed space back into the central pool. */
DECL|function|cpu_swap_callback
r_static
r_int
id|cpu_swap_callback
c_func
(paren
r_struct
id|notifier_block
op_star
id|nfb
comma
r_int
r_int
id|action
comma
r_void
op_star
id|hcpu
)paren
(brace
r_int
op_star
id|committed
suffix:semicolon
id|committed
op_assign
op_amp
id|per_cpu
c_func
(paren
id|committed_space
comma
(paren
r_int
)paren
id|hcpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
id|CPU_DEAD
)paren
(brace
id|atomic_add
c_func
(paren
op_star
id|committed
comma
op_amp
id|vm_committed_space
)paren
suffix:semicolon
op_star
id|committed
op_assign
l_int|0
suffix:semicolon
id|lru_drain_cache
c_func
(paren
(paren
r_int
)paren
id|hcpu
)paren
suffix:semicolon
)brace
r_return
id|NOTIFY_OK
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_HOTPLUG_CPU */
macro_line|#endif /* CONFIG_SMP */
macro_line|#ifdef CONFIG_SMP
DECL|function|percpu_counter_mod
r_void
id|percpu_counter_mod
c_func
(paren
r_struct
id|percpu_counter
op_star
id|fbc
comma
r_int
id|amount
)paren
(brace
r_int
id|count
suffix:semicolon
r_int
op_star
id|pcount
suffix:semicolon
r_int
id|cpu
op_assign
id|get_cpu
c_func
(paren
)paren
suffix:semicolon
id|pcount
op_assign
id|per_cpu_ptr
c_func
(paren
id|fbc-&gt;counters
comma
id|cpu
)paren
suffix:semicolon
id|count
op_assign
op_star
id|pcount
op_plus
id|amount
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ge
id|FBC_BATCH
op_logical_or
id|count
op_le
op_minus
id|FBC_BATCH
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|fbc-&gt;lock
)paren
suffix:semicolon
id|fbc-&gt;count
op_add_assign
id|count
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|fbc-&gt;lock
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
)brace
op_star
id|pcount
op_assign
id|count
suffix:semicolon
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|percpu_counter_mod
id|EXPORT_SYMBOL
c_func
(paren
id|percpu_counter_mod
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Perform any setup for the swap system&n; */
DECL|function|swap_setup
r_void
id|__init
id|swap_setup
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|megs
op_assign
id|num_physpages
op_rshift
(paren
l_int|20
op_minus
id|PAGE_SHIFT
)paren
suffix:semicolon
multiline_comment|/* Use a smaller cluster for small-memory machines */
r_if
c_cond
(paren
id|megs
OL
l_int|16
)paren
id|page_cluster
op_assign
l_int|2
suffix:semicolon
r_else
id|page_cluster
op_assign
l_int|3
suffix:semicolon
multiline_comment|/*&n;&t; * Right now other parts of the system means that we&n;&t; * _really_ don&squot;t want to cluster much more&n;&t; */
id|hotcpu_notifier
c_func
(paren
id|cpu_swap_callback
comma
l_int|0
)paren
suffix:semicolon
)brace
eof
