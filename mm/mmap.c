multiline_comment|/*&n; * mm/mmap.c&n; *&n; * Written by obz.&n; *&n; * Address space accounting code&t;&lt;alan@redhat.com&gt;&n; */
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/shm.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/personality.h&gt;
macro_line|#include &lt;linux/security.h&gt;
macro_line|#include &lt;linux/profile.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/tlb.h&gt;
r_extern
r_void
id|unmap_page_range
c_func
(paren
id|mmu_gather_t
op_star
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
)paren
suffix:semicolon
r_extern
r_void
id|clear_page_tables
c_func
(paren
id|mmu_gather_t
op_star
id|tlb
comma
r_int
r_int
id|first
comma
r_int
id|nr
)paren
suffix:semicolon
multiline_comment|/*&n; * WARNING: the debugging will use recursive algorithms so never enable this&n; * unless you know what you are doing.&n; */
DECL|macro|DEBUG_MM_RB
macro_line|#undef DEBUG_MM_RB
multiline_comment|/* description of effects of mapping type and prot in current implementation.&n; * this is due to the limited x86 page protection hardware.  The expected&n; * behavior is in parens:&n; *&n; * map_type&t;prot&n; *&t;&t;PROT_NONE&t;PROT_READ&t;PROT_WRITE&t;PROT_EXEC&n; * MAP_SHARED&t;r: (no) no&t;r: (yes) yes&t;r: (no) yes&t;r: (no) yes&n; *&t;&t;w: (no) no&t;w: (no) no&t;w: (yes) yes&t;w: (no) no&n; *&t;&t;x: (no) no&t;x: (no) yes&t;x: (no) yes&t;x: (yes) yes&n; *&t;&t;&n; * MAP_PRIVATE&t;r: (no) no&t;r: (yes) yes&t;r: (no) yes&t;r: (no) yes&n; *&t;&t;w: (no) no&t;w: (no) no&t;w: (copy) copy&t;w: (no) no&n; *&t;&t;x: (no) no&t;x: (no) yes&t;x: (no) yes&t;x: (yes) yes&n; *&n; */
DECL|variable|protection_map
id|pgprot_t
id|protection_map
(braket
l_int|16
)braket
op_assign
(brace
id|__P000
comma
id|__P001
comma
id|__P010
comma
id|__P011
comma
id|__P100
comma
id|__P101
comma
id|__P110
comma
id|__P111
comma
id|__S000
comma
id|__S001
comma
id|__S010
comma
id|__S011
comma
id|__S100
comma
id|__S101
comma
id|__S110
comma
id|__S111
)brace
suffix:semicolon
DECL|variable|sysctl_overcommit_memory
r_int
id|sysctl_overcommit_memory
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* default is heuristic overcommit */
DECL|variable|sysctl_overcommit_ratio
r_int
id|sysctl_overcommit_ratio
op_assign
l_int|50
suffix:semicolon
multiline_comment|/* default is 50% */
DECL|variable|vm_committed_space
id|atomic_t
id|vm_committed_space
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|function|vm_unacct_memory
r_inline
r_void
id|vm_unacct_memory
c_func
(paren
r_int
id|pages
)paren
(brace
id|atomic_sub
c_func
(paren
id|pages
comma
op_amp
id|vm_committed_space
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check that a process has enough memory to allocate a new virtual&n; * mapping. 1 means there is enough memory for the allocation to&n; * succeed and 0 implies there is not.&n; *&n; * We currently support three overcommit policies, which are set via the&n; * vm.overcommit_memory sysctl.  See Documentation/vm/overcommit-acounting&n; *&n; * Strict overcommit modes added 2002 Feb 26 by Alan Cox.&n; * Additional code 2002 Jul 20 by Robert Love.&n; */
DECL|function|vm_enough_memory
r_int
id|vm_enough_memory
c_func
(paren
r_int
id|pages
)paren
(brace
r_int
r_int
id|free
comma
id|allowed
suffix:semicolon
r_struct
id|sysinfo
id|i
suffix:semicolon
id|atomic_add
c_func
(paren
id|pages
comma
op_amp
id|vm_committed_space
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Sometimes we want to use more memory than we have&n;&t; */
r_if
c_cond
(paren
id|sysctl_overcommit_memory
op_eq
l_int|1
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sysctl_overcommit_memory
op_eq
l_int|0
)paren
(brace
id|free
op_assign
id|get_page_cache_size
c_func
(paren
)paren
suffix:semicolon
id|free
op_add_assign
id|nr_free_pages
c_func
(paren
)paren
suffix:semicolon
id|free
op_add_assign
id|nr_swap_pages
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This double-counts: the nrpages are both in the&n;&t;&t; * page-cache and in the swapper space. At the same time,&n;&t;&t; * this compensates for the swap-space over-allocation&n;&t;&t; * (ie &quot;nr_swap_pages&quot; being too small).&n;&t;&t; */
id|free
op_add_assign
id|swapper_space.nrpages
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The code below doesn&squot;t account for free space in the&n;&t;&t; * inode and dentry slab cache, slab cache fragmentation,&n;&t;&t; * inodes and dentries which will become freeable under&n;&t;&t; * VM load, etc. Lets just hope all these (complex)&n;&t;&t; * factors balance out...&n;&t;&t; */
id|free
op_add_assign
(paren
id|dentry_stat.nr_unused
op_star
r_sizeof
(paren
r_struct
id|dentry
)paren
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|free
op_add_assign
(paren
id|inodes_stat.nr_unused
op_star
r_sizeof
(paren
r_struct
id|inode
)paren
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|free
OG
id|pages
)paren
r_return
l_int|1
suffix:semicolon
id|vm_unacct_memory
c_func
(paren
id|pages
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * FIXME: need to add arch hooks to get the bits we need&n;&t; * without this higher overhead crap&n;&t; */
id|si_meminfo
c_func
(paren
op_amp
id|i
)paren
suffix:semicolon
id|allowed
op_assign
id|i.totalram
op_star
id|sysctl_overcommit_ratio
op_div
l_int|100
suffix:semicolon
id|allowed
op_add_assign
id|total_swap_pages
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|vm_committed_space
)paren
OL
id|allowed
)paren
r_return
l_int|1
suffix:semicolon
id|vm_unacct_memory
c_func
(paren
id|pages
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Remove one vm structure from the inode&squot;s i_mapping address space. */
DECL|function|remove_shared_vm_struct
r_static
r_inline
r_void
id|remove_shared_vm_struct
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|vma-&gt;vm_file
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|inode-&gt;i_mapping-&gt;i_shared_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_DENYWRITE
)paren
id|atomic_inc
c_func
(paren
op_amp
id|inode-&gt;i_writecount
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|vma-&gt;shared
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|inode-&gt;i_mapping-&gt;i_shared_lock
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  sys_brk() for the most part doesn&squot;t need the global kernel&n; *  lock, except when an application is doing something nasty&n; *  like trying to un-brk an area that has already been mapped&n; *  to a regular file.  in this case, the unmapping will need&n; *  to invoke file system routines that need the global lock.&n; */
DECL|function|sys_brk
id|asmlinkage
r_int
r_int
id|sys_brk
c_func
(paren
r_int
r_int
id|brk
)paren
(brace
r_int
r_int
id|rlim
comma
id|retval
suffix:semicolon
r_int
r_int
id|newbrk
comma
id|oldbrk
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|brk
OL
id|mm-&gt;end_code
)paren
r_goto
id|out
suffix:semicolon
id|newbrk
op_assign
id|PAGE_ALIGN
c_func
(paren
id|brk
)paren
suffix:semicolon
id|oldbrk
op_assign
id|PAGE_ALIGN
c_func
(paren
id|mm-&gt;brk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldbrk
op_eq
id|newbrk
)paren
r_goto
id|set_brk
suffix:semicolon
multiline_comment|/* Always allow shrinking brk. */
r_if
c_cond
(paren
id|brk
op_le
id|mm-&gt;brk
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|do_munmap
c_func
(paren
id|mm
comma
id|newbrk
comma
id|oldbrk
op_minus
id|newbrk
)paren
)paren
r_goto
id|set_brk
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Check against rlimit.. */
id|rlim
op_assign
id|current-&gt;rlim
(braket
id|RLIMIT_DATA
)braket
dot
id|rlim_cur
suffix:semicolon
r_if
c_cond
(paren
id|rlim
template_param
id|rlim
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Check against existing mmap mappings. */
r_if
c_cond
(paren
id|find_vma_intersection
c_func
(paren
id|mm
comma
id|oldbrk
comma
id|newbrk
op_plus
id|PAGE_SIZE
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Ok, looks good - let it rip. */
r_if
c_cond
(paren
id|do_brk
c_func
(paren
id|oldbrk
comma
id|newbrk
op_minus
id|oldbrk
)paren
op_ne
id|oldbrk
)paren
r_goto
id|out
suffix:semicolon
id|set_brk
suffix:colon
id|mm-&gt;brk
op_assign
id|brk
suffix:semicolon
id|out
suffix:colon
id|retval
op_assign
id|mm-&gt;brk
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Combine the mmap &quot;prot&quot; and &quot;flags&quot; argument into one &quot;vm_flags&quot; used&n; * internally. Essentially, translate the &quot;PROT_xxx&quot; and &quot;MAP_xxx&quot; bits&n; * into &quot;VM_xxx&quot;.&n; */
DECL|function|calc_vm_flags
r_static
r_inline
r_int
r_int
id|calc_vm_flags
c_func
(paren
r_int
r_int
id|prot
comma
r_int
r_int
id|flags
)paren
(brace
DECL|macro|_trans
mdefine_line|#define _trans(x,bit1,bit2) &bslash;&n;((bit1==bit2)?(x&amp;bit1):(x&amp;bit1)?bit2:0)
r_int
r_int
id|prot_bits
comma
id|flag_bits
suffix:semicolon
id|prot_bits
op_assign
id|_trans
c_func
(paren
id|prot
comma
id|PROT_READ
comma
id|VM_READ
)paren
op_or
id|_trans
c_func
(paren
id|prot
comma
id|PROT_WRITE
comma
id|VM_WRITE
)paren
op_or
id|_trans
c_func
(paren
id|prot
comma
id|PROT_EXEC
comma
id|VM_EXEC
)paren
suffix:semicolon
id|flag_bits
op_assign
id|_trans
c_func
(paren
id|flags
comma
id|MAP_GROWSDOWN
comma
id|VM_GROWSDOWN
)paren
op_or
id|_trans
c_func
(paren
id|flags
comma
id|MAP_DENYWRITE
comma
id|VM_DENYWRITE
)paren
op_or
id|_trans
c_func
(paren
id|flags
comma
id|MAP_EXECUTABLE
comma
id|VM_EXECUTABLE
)paren
suffix:semicolon
r_return
id|prot_bits
op_or
id|flag_bits
suffix:semicolon
DECL|macro|_trans
macro_line|#undef _trans
)brace
macro_line|#ifdef DEBUG_MM_RB
DECL|function|browse_rb
r_static
r_int
id|browse_rb
c_func
(paren
r_struct
id|rb_node
op_star
id|rb_node
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rb_node
)paren
(brace
id|i
op_increment
suffix:semicolon
id|i
op_add_assign
id|browse_rb
c_func
(paren
id|rb_node-&gt;rb_left
)paren
suffix:semicolon
id|i
op_add_assign
id|browse_rb
c_func
(paren
id|rb_node-&gt;rb_right
)paren
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
DECL|function|validate_mm
r_static
r_void
id|validate_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_int
id|bug
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|tmp
op_assign
id|mm-&gt;mmap
suffix:semicolon
r_while
c_loop
(paren
id|tmp
)paren
(brace
id|tmp
op_assign
id|tmp-&gt;vm_next
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ne
id|mm-&gt;map_count
)paren
id|printk
c_func
(paren
l_string|&quot;map_count %d vm_next %d&bslash;n&quot;
comma
id|mm-&gt;map_count
comma
id|i
)paren
comma
id|bug
op_assign
l_int|1
suffix:semicolon
id|i
op_assign
id|browse_rb
c_func
(paren
id|mm-&gt;mm_rb.rb_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|mm-&gt;map_count
)paren
id|printk
c_func
(paren
l_string|&quot;map_count %d rb %d&bslash;n&quot;
comma
id|mm-&gt;map_count
comma
id|i
)paren
comma
id|bug
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bug
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|validate_mm
mdefine_line|#define validate_mm(mm) do { } while (0)
macro_line|#endif
DECL|function|find_vma_prepare
r_static
r_struct
id|vm_area_struct
op_star
id|find_vma_prepare
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
comma
r_struct
id|vm_area_struct
op_star
op_star
id|pprev
comma
r_struct
id|rb_node
op_star
op_star
op_star
id|rb_link
comma
r_struct
id|rb_node
op_star
op_star
id|rb_parent
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_struct
id|rb_node
op_star
op_star
id|__rb_link
comma
op_star
id|__rb_parent
comma
op_star
id|rb_prev
suffix:semicolon
id|__rb_link
op_assign
op_amp
id|mm-&gt;mm_rb.rb_node
suffix:semicolon
id|rb_prev
op_assign
id|__rb_parent
op_assign
l_int|NULL
suffix:semicolon
id|vma
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
op_star
id|__rb_link
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma_tmp
suffix:semicolon
id|__rb_parent
op_assign
op_star
id|__rb_link
suffix:semicolon
id|vma_tmp
op_assign
id|rb_entry
c_func
(paren
id|__rb_parent
comma
r_struct
id|vm_area_struct
comma
id|vm_rb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma_tmp-&gt;vm_end
OG
id|addr
)paren
(brace
id|vma
op_assign
id|vma_tmp
suffix:semicolon
r_if
c_cond
(paren
id|vma_tmp-&gt;vm_start
op_le
id|addr
)paren
r_return
id|vma
suffix:semicolon
id|__rb_link
op_assign
op_amp
id|__rb_parent-&gt;rb_left
suffix:semicolon
)brace
r_else
(brace
id|rb_prev
op_assign
id|__rb_parent
suffix:semicolon
id|__rb_link
op_assign
op_amp
id|__rb_parent-&gt;rb_right
suffix:semicolon
)brace
)brace
op_star
id|pprev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|rb_prev
)paren
op_star
id|pprev
op_assign
id|rb_entry
c_func
(paren
id|rb_prev
comma
r_struct
id|vm_area_struct
comma
id|vm_rb
)paren
suffix:semicolon
op_star
id|rb_link
op_assign
id|__rb_link
suffix:semicolon
op_star
id|rb_parent
op_assign
id|__rb_parent
suffix:semicolon
r_return
id|vma
suffix:semicolon
)brace
DECL|function|__vma_link_list
r_static
r_inline
r_void
id|__vma_link_list
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|vm_area_struct
op_star
id|prev
comma
r_struct
id|rb_node
op_star
id|rb_parent
)paren
(brace
r_if
c_cond
(paren
id|prev
)paren
(brace
id|vma-&gt;vm_next
op_assign
id|prev-&gt;vm_next
suffix:semicolon
id|prev-&gt;vm_next
op_assign
id|vma
suffix:semicolon
)brace
r_else
(brace
id|mm-&gt;mmap
op_assign
id|vma
suffix:semicolon
r_if
c_cond
(paren
id|rb_parent
)paren
id|vma-&gt;vm_next
op_assign
id|rb_entry
c_func
(paren
id|rb_parent
comma
r_struct
id|vm_area_struct
comma
id|vm_rb
)paren
suffix:semicolon
r_else
id|vma-&gt;vm_next
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|__vma_link_rb
r_static
r_inline
r_void
id|__vma_link_rb
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|rb_node
op_star
op_star
id|rb_link
comma
r_struct
id|rb_node
op_star
id|rb_parent
)paren
(brace
id|rb_link_node
c_func
(paren
op_amp
id|vma-&gt;vm_rb
comma
id|rb_parent
comma
id|rb_link
)paren
suffix:semicolon
id|rb_insert_color
c_func
(paren
op_amp
id|vma-&gt;vm_rb
comma
op_amp
id|mm-&gt;mm_rb
)paren
suffix:semicolon
)brace
DECL|function|__vma_link_file
r_static
r_inline
r_void
id|__vma_link_file
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
id|file
op_assign
id|vma-&gt;vm_file
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_DENYWRITE
)paren
id|atomic_dec
c_func
(paren
op_amp
id|inode-&gt;i_writecount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_SHARED
)paren
id|list_add_tail
c_func
(paren
op_amp
id|vma-&gt;shared
comma
op_amp
id|mapping-&gt;i_mmap_shared
)paren
suffix:semicolon
r_else
id|list_add_tail
c_func
(paren
op_amp
id|vma-&gt;shared
comma
op_amp
id|mapping-&gt;i_mmap
)paren
suffix:semicolon
)brace
)brace
DECL|function|__vma_link
r_static
r_void
id|__vma_link
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|vm_area_struct
op_star
id|prev
comma
r_struct
id|rb_node
op_star
op_star
id|rb_link
comma
r_struct
id|rb_node
op_star
id|rb_parent
)paren
(brace
id|__vma_link_list
c_func
(paren
id|mm
comma
id|vma
comma
id|prev
comma
id|rb_parent
)paren
suffix:semicolon
id|__vma_link_rb
c_func
(paren
id|mm
comma
id|vma
comma
id|rb_link
comma
id|rb_parent
)paren
suffix:semicolon
id|__vma_link_file
c_func
(paren
id|vma
)paren
suffix:semicolon
)brace
DECL|function|vma_link
r_static
r_inline
r_void
id|vma_link
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|vm_area_struct
op_star
id|prev
comma
r_struct
id|rb_node
op_star
op_star
id|rb_link
comma
r_struct
id|rb_node
op_star
id|rb_parent
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_file
)paren
id|mapping
op_assign
id|vma-&gt;vm_file-&gt;f_dentry-&gt;d_inode-&gt;i_mapping
suffix:semicolon
r_if
c_cond
(paren
id|mapping
)paren
id|spin_lock
c_func
(paren
op_amp
id|mapping-&gt;i_shared_lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|__vma_link
c_func
(paren
id|mm
comma
id|vma
comma
id|prev
comma
id|rb_link
comma
id|rb_parent
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mapping
)paren
id|spin_unlock
c_func
(paren
op_amp
id|mapping-&gt;i_shared_lock
)paren
suffix:semicolon
id|mm-&gt;map_count
op_increment
suffix:semicolon
id|validate_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
DECL|function|vma_merge
r_static
r_int
id|vma_merge
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|prev
comma
r_struct
id|rb_node
op_star
id|rb_parent
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|end
comma
r_int
r_int
id|vm_flags
)paren
(brace
id|spinlock_t
op_star
id|lock
op_assign
op_amp
id|mm-&gt;page_table_lock
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prev
)paren
(brace
id|prev
op_assign
id|rb_entry
c_func
(paren
id|rb_parent
comma
r_struct
id|vm_area_struct
comma
id|vm_rb
)paren
suffix:semicolon
r_goto
id|merge_next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prev-&gt;vm_end
op_eq
id|addr
op_logical_and
id|can_vma_merge
c_func
(paren
id|prev
comma
id|vm_flags
)paren
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|next
suffix:semicolon
id|spin_lock
c_func
(paren
id|lock
)paren
suffix:semicolon
id|prev-&gt;vm_end
op_assign
id|end
suffix:semicolon
id|next
op_assign
id|prev-&gt;vm_next
suffix:semicolon
r_if
c_cond
(paren
id|next
op_logical_and
id|prev-&gt;vm_end
op_eq
id|next-&gt;vm_start
op_logical_and
id|can_vma_merge
c_func
(paren
id|next
comma
id|vm_flags
)paren
)paren
(brace
id|prev-&gt;vm_end
op_assign
id|next-&gt;vm_end
suffix:semicolon
id|__vma_unlink
c_func
(paren
id|mm
comma
id|next
comma
id|prev
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
id|lock
)paren
suffix:semicolon
id|mm-&gt;map_count
op_decrement
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|next
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|prev
op_assign
id|prev-&gt;vm_next
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
(brace
id|merge_next
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|can_vma_merge
c_func
(paren
id|prev
comma
id|vm_flags
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|end
op_eq
id|prev-&gt;vm_start
)paren
(brace
id|spin_lock
c_func
(paren
id|lock
)paren
suffix:semicolon
id|prev-&gt;vm_start
op_assign
id|addr
suffix:semicolon
id|spin_unlock
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The caller must hold down_write(current-&gt;mm-&gt;mmap_sem).&n; */
DECL|function|do_mmap_pgoff
r_int
r_int
id|do_mmap_pgoff
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|prot
comma
r_int
r_int
id|flags
comma
r_int
r_int
id|pgoff
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
comma
op_star
id|prev
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|vm_flags
suffix:semicolon
r_int
id|correct_wcount
op_assign
l_int|0
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|rb_node
op_star
op_star
id|rb_link
comma
op_star
id|rb_parent
suffix:semicolon
r_int
r_int
id|charged
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file
op_logical_and
(paren
op_logical_neg
id|file-&gt;f_op
op_logical_or
op_logical_neg
id|file-&gt;f_op-&gt;mmap
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_return
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|TASK_SIZE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|len
op_assign
id|PAGE_ALIGN
c_func
(paren
id|len
)paren
suffix:semicolon
multiline_comment|/* offset overflow? */
r_if
c_cond
(paren
(paren
id|pgoff
op_plus
(paren
id|len
op_rshift
id|PAGE_SHIFT
)paren
)paren
OL
id|pgoff
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Too many mappings? */
r_if
c_cond
(paren
id|mm-&gt;map_count
OG
id|MAX_MAP_COUNT
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Obtain the address to map to. we verify (or select) it and ensure&n;&t; * that it represents a valid section of the address space.&n;&t; */
id|addr
op_assign
id|get_unmapped_area
c_func
(paren
id|file
comma
id|addr
comma
id|len
comma
id|pgoff
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_amp
op_complement
id|PAGE_MASK
)paren
r_return
id|addr
suffix:semicolon
multiline_comment|/* Do simple checking here so the lower-level routines won&squot;t have&n;&t; * to. we assume access permissions have been handled by the open&n;&t; * of the memory object, so we don&squot;t do any here.&n;&t; */
id|vm_flags
op_assign
id|calc_vm_flags
c_func
(paren
id|prot
comma
id|flags
)paren
op_or
id|mm-&gt;def_flags
op_or
id|VM_MAYREAD
op_or
id|VM_MAYWRITE
op_or
id|VM_MAYEXEC
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MAP_LOCKED
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_IPC_LOCK
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|vm_flags
op_or_assign
id|VM_LOCKED
suffix:semicolon
)brace
multiline_comment|/* mlock MCL_FUTURE? */
r_if
c_cond
(paren
id|vm_flags
op_amp
id|VM_LOCKED
)paren
(brace
r_int
r_int
id|locked
op_assign
id|mm-&gt;locked_vm
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|locked
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|locked
OG
id|current-&gt;rlim
(braket
id|RLIMIT_MEMLOCK
)braket
dot
id|rlim_cur
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file
)paren
(brace
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_switch
c_cond
(paren
id|flags
op_amp
id|MAP_TYPE
)paren
(brace
r_case
id|MAP_SHARED
suffix:colon
r_if
c_cond
(paren
(paren
id|prot
op_amp
id|PROT_WRITE
)paren
op_logical_and
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* Make sure we don&squot;t allow writing to an append-only file.. */
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* make sure there are no mandatory locks on the file. */
r_if
c_cond
(paren
id|locks_verify_locked
c_func
(paren
id|inode
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|vm_flags
op_or_assign
id|VM_SHARED
op_or
id|VM_MAYSHARE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
id|vm_flags
op_and_assign
op_complement
(paren
id|VM_MAYWRITE
op_or
id|VM_SHARED
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|MAP_PRIVATE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_else
(brace
id|vm_flags
op_or_assign
id|VM_SHARED
op_or
id|VM_MAYSHARE
suffix:semicolon
r_switch
c_cond
(paren
id|flags
op_amp
id|MAP_TYPE
)paren
(brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|MAP_PRIVATE
suffix:colon
id|vm_flags
op_and_assign
op_complement
(paren
id|VM_SHARED
op_or
id|VM_MAYSHARE
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|MAP_SHARED
suffix:colon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|security_file_mmap
c_func
(paren
id|file
comma
id|prot
comma
id|flags
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* Clear old maps */
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|munmap_back
suffix:colon
id|vma
op_assign
id|find_vma_prepare
c_func
(paren
id|mm
comma
id|addr
comma
op_amp
id|prev
comma
op_amp
id|rb_link
comma
op_amp
id|rb_parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma
op_logical_and
id|vma-&gt;vm_start
OL
id|addr
op_plus
id|len
)paren
(brace
r_if
c_cond
(paren
id|do_munmap
c_func
(paren
id|mm
comma
id|addr
comma
id|len
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|munmap_back
suffix:semicolon
)brace
multiline_comment|/* Check against address space limit. */
r_if
c_cond
(paren
(paren
id|mm-&gt;total_vm
op_lshift
id|PAGE_SHIFT
)paren
op_plus
id|len
OG
id|current-&gt;rlim
(braket
id|RLIMIT_AS
)braket
dot
id|rlim_cur
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MAP_NORESERVE
)paren
op_logical_or
id|sysctl_overcommit_memory
OG
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|vm_flags
op_amp
id|VM_SHARED
)paren
(brace
multiline_comment|/* Check memory availability in shmem_file_setup? */
id|vm_flags
op_or_assign
id|VM_ACCOUNT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vm_flags
op_amp
id|VM_WRITE
)paren
(brace
multiline_comment|/* Private writable mapping: check memory availability */
id|charged
op_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vm_enough_memory
c_func
(paren
id|charged
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|vm_flags
op_or_assign
id|VM_ACCOUNT
suffix:semicolon
)brace
)brace
multiline_comment|/* Can we just expand an old anonymous mapping? */
r_if
c_cond
(paren
op_logical_neg
id|file
op_logical_and
op_logical_neg
(paren
id|vm_flags
op_amp
id|VM_SHARED
)paren
op_logical_and
id|rb_parent
)paren
r_if
c_cond
(paren
id|vma_merge
c_func
(paren
id|mm
comma
id|prev
comma
id|rb_parent
comma
id|addr
comma
id|addr
op_plus
id|len
comma
id|vm_flags
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Determine the object being mapped and call the appropriate&n;&t; * specific mapper. the address has already been validated, but&n;&t; * not unmapped, but the maps are removed from the list.&n;&t; */
id|vma
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_goto
id|unacct_error
suffix:semicolon
id|vma-&gt;vm_mm
op_assign
id|mm
suffix:semicolon
id|vma-&gt;vm_start
op_assign
id|addr
suffix:semicolon
id|vma-&gt;vm_end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
id|vma-&gt;vm_flags
op_assign
id|vm_flags
suffix:semicolon
id|vma-&gt;vm_page_prot
op_assign
id|protection_map
(braket
id|vm_flags
op_amp
l_int|0x0f
)braket
suffix:semicolon
id|vma-&gt;vm_ops
op_assign
l_int|NULL
suffix:semicolon
id|vma-&gt;vm_pgoff
op_assign
id|pgoff
suffix:semicolon
id|vma-&gt;vm_file
op_assign
l_int|NULL
suffix:semicolon
id|vma-&gt;vm_private_data
op_assign
l_int|NULL
suffix:semicolon
id|vma-&gt;vm_raend
op_assign
l_int|0
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|vma-&gt;shared
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|vm_flags
op_amp
(paren
id|VM_GROWSDOWN
op_or
id|VM_GROWSUP
)paren
)paren
r_goto
id|free_vma
suffix:semicolon
r_if
c_cond
(paren
id|vm_flags
op_amp
id|VM_DENYWRITE
)paren
(brace
id|error
op_assign
id|deny_write_access
c_func
(paren
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|free_vma
suffix:semicolon
id|correct_wcount
op_assign
l_int|1
suffix:semicolon
)brace
id|vma-&gt;vm_file
op_assign
id|file
suffix:semicolon
id|get_file
c_func
(paren
id|file
)paren
suffix:semicolon
id|error
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|mmap
c_func
(paren
id|file
comma
id|vma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|unmap_and_free_vma
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vm_flags
op_amp
id|VM_SHARED
)paren
(brace
id|error
op_assign
id|shmem_zero_setup
c_func
(paren
id|vma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|free_vma
suffix:semicolon
)brace
multiline_comment|/* We set VM_ACCOUNT in a shared mapping&squot;s vm_flags, to inform&n;&t; * shmem_zero_setup (perhaps called through /dev/zero&squot;s -&gt;mmap)&n;&t; * that memory reservation must be checked; but that reservation&n;&t; * belongs to shared memory object, not to vma: so now clear it.&n;&t; */
r_if
c_cond
(paren
(paren
id|vm_flags
op_amp
(paren
id|VM_SHARED
op_or
id|VM_ACCOUNT
)paren
)paren
op_eq
(paren
id|VM_SHARED
op_or
id|VM_ACCOUNT
)paren
)paren
id|vma-&gt;vm_flags
op_and_assign
op_complement
id|VM_ACCOUNT
suffix:semicolon
multiline_comment|/* Can addr have changed??&n;&t; *&n;&t; * Answer: Yes, several device drivers can do it in their&n;&t; *         f_op-&gt;mmap method. -DaveM&n;&t; */
id|addr
op_assign
id|vma-&gt;vm_start
suffix:semicolon
id|vma_link
c_func
(paren
id|mm
comma
id|vma
comma
id|prev
comma
id|rb_link
comma
id|rb_parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|correct_wcount
)paren
id|atomic_inc
c_func
(paren
op_amp
id|inode-&gt;i_writecount
)paren
suffix:semicolon
id|out
suffix:colon
id|mm-&gt;total_vm
op_add_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|vm_flags
op_amp
id|VM_LOCKED
)paren
(brace
id|mm-&gt;locked_vm
op_add_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|make_pages_present
c_func
(paren
id|addr
comma
id|addr
op_plus
id|len
)paren
suffix:semicolon
)brace
r_return
id|addr
suffix:semicolon
id|unmap_and_free_vma
suffix:colon
r_if
c_cond
(paren
id|correct_wcount
)paren
id|atomic_inc
c_func
(paren
op_amp
id|inode-&gt;i_writecount
)paren
suffix:semicolon
id|vma-&gt;vm_file
op_assign
l_int|NULL
suffix:semicolon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
multiline_comment|/* Undo any partial mapping done by a device driver. */
id|zap_page_range
c_func
(paren
id|vma
comma
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
)paren
suffix:semicolon
id|free_vma
suffix:colon
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|vma
)paren
suffix:semicolon
id|unacct_error
suffix:colon
r_if
c_cond
(paren
id|charged
)paren
id|vm_unacct_memory
c_func
(paren
id|charged
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Get an address range which is currently unmapped.&n; * For shmat() with addr=0.&n; *&n; * Ugly calling convention alert:&n; * Return value with the low bits set means error value,&n; * ie&n; *&t;if (ret &amp; ~PAGE_MASK)&n; *&t;&t;error = ret;&n; *&n; * This function &quot;knows&quot; that -ENOMEM has the bits set.&n; */
macro_line|#ifndef HAVE_ARCH_UNMAPPED_AREA
DECL|function|arch_get_unmapped_area
r_static
r_inline
r_int
r_int
id|arch_get_unmapped_area
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|pgoff
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|TASK_SIZE
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|addr
)paren
(brace
id|addr
op_assign
id|PAGE_ALIGN
c_func
(paren
id|addr
)paren
suffix:semicolon
id|vma
op_assign
id|find_vma
c_func
(paren
id|current-&gt;mm
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TASK_SIZE
op_minus
id|len
op_ge
id|addr
op_logical_and
(paren
op_logical_neg
id|vma
op_logical_or
id|addr
op_plus
id|len
op_le
id|vma-&gt;vm_start
)paren
)paren
r_return
id|addr
suffix:semicolon
)brace
id|addr
op_assign
id|PAGE_ALIGN
c_func
(paren
id|TASK_UNMAPPED_BASE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|vma
op_assign
id|find_vma
c_func
(paren
id|current-&gt;mm
comma
id|addr
)paren
suffix:semicolon
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
)paren
(brace
multiline_comment|/* At this point:  (!vma || addr &lt; vma-&gt;vm_end). */
r_if
c_cond
(paren
id|TASK_SIZE
op_minus
id|len
OL
id|addr
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
op_logical_or
id|addr
op_plus
id|len
op_le
id|vma-&gt;vm_start
)paren
r_return
id|addr
suffix:semicolon
id|addr
op_assign
id|vma-&gt;vm_end
suffix:semicolon
)brace
)brace
macro_line|#else
r_extern
r_int
r_int
id|arch_get_unmapped_area
c_func
(paren
r_struct
id|file
op_star
comma
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
macro_line|#endif&t;
DECL|function|get_unmapped_area
r_int
r_int
id|get_unmapped_area
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|pgoff
comma
r_int
r_int
id|flags
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|MAP_FIXED
)paren
(brace
r_if
c_cond
(paren
id|addr
OG
id|TASK_SIZE
op_minus
id|len
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_amp
op_complement
id|PAGE_MASK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|addr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file
op_logical_and
id|file-&gt;f_op
op_logical_and
id|file-&gt;f_op-&gt;get_unmapped_area
)paren
r_return
id|file-&gt;f_op
op_member_access_from_pointer
id|get_unmapped_area
c_func
(paren
id|file
comma
id|addr
comma
id|len
comma
id|pgoff
comma
id|flags
)paren
suffix:semicolon
r_return
id|arch_get_unmapped_area
c_func
(paren
id|file
comma
id|addr
comma
id|len
comma
id|pgoff
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Look up the first VMA which satisfies  addr &lt; vm_end,  NULL if none. */
DECL|function|find_vma
r_struct
id|vm_area_struct
op_star
id|find_vma
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|mm
)paren
(brace
multiline_comment|/* Check the cache first. */
multiline_comment|/* (Cache hit rate is typically around 35%.) */
id|vma
op_assign
id|mm-&gt;mmap_cache
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma
op_logical_and
id|vma-&gt;vm_end
OG
id|addr
op_logical_and
id|vma-&gt;vm_start
op_le
id|addr
)paren
)paren
(brace
r_struct
id|rb_node
op_star
id|rb_node
suffix:semicolon
id|rb_node
op_assign
id|mm-&gt;mm_rb.rb_node
suffix:semicolon
id|vma
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|rb_node
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma_tmp
suffix:semicolon
id|vma_tmp
op_assign
id|rb_entry
c_func
(paren
id|rb_node
comma
r_struct
id|vm_area_struct
comma
id|vm_rb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma_tmp-&gt;vm_end
OG
id|addr
)paren
(brace
id|vma
op_assign
id|vma_tmp
suffix:semicolon
r_if
c_cond
(paren
id|vma_tmp-&gt;vm_start
op_le
id|addr
)paren
r_break
suffix:semicolon
id|rb_node
op_assign
id|rb_node-&gt;rb_left
suffix:semicolon
)brace
r_else
id|rb_node
op_assign
id|rb_node-&gt;rb_right
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vma
)paren
id|mm-&gt;mmap_cache
op_assign
id|vma
suffix:semicolon
)brace
)brace
r_return
id|vma
suffix:semicolon
)brace
multiline_comment|/* Same as find_vma, but also return a pointer to the previous VMA in *pprev. */
DECL|function|find_vma_prev
r_struct
id|vm_area_struct
op_star
id|find_vma_prev
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
comma
r_struct
id|vm_area_struct
op_star
op_star
id|pprev
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
l_int|NULL
comma
op_star
id|prev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|rb_node
op_star
id|rb_node
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mm
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Guard against addr being lower than the first VMA */
id|vma
op_assign
id|mm-&gt;mmap
suffix:semicolon
multiline_comment|/* Go through the RB tree quickly. */
id|rb_node
op_assign
id|mm-&gt;mm_rb.rb_node
suffix:semicolon
r_while
c_loop
(paren
id|rb_node
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma_tmp
suffix:semicolon
id|vma_tmp
op_assign
id|rb_entry
c_func
(paren
id|rb_node
comma
r_struct
id|vm_area_struct
comma
id|vm_rb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
OL
id|vma_tmp-&gt;vm_end
)paren
(brace
id|rb_node
op_assign
id|rb_node-&gt;rb_left
suffix:semicolon
)brace
r_else
(brace
id|prev
op_assign
id|vma_tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prev-&gt;vm_next
op_logical_or
(paren
id|addr
OL
id|prev-&gt;vm_next-&gt;vm_end
)paren
)paren
r_break
suffix:semicolon
id|rb_node
op_assign
id|rb_node-&gt;rb_right
suffix:semicolon
)brace
)brace
id|out
suffix:colon
op_star
id|pprev
op_assign
id|prev
suffix:semicolon
r_return
id|prev
ques
c_cond
id|prev-&gt;vm_next
suffix:colon
id|vma
suffix:semicolon
)brace
macro_line|#ifdef ARCH_STACK_GROWSUP
multiline_comment|/*&n; * vma is the first one with address &gt; vma-&gt;vm_end.  Have to extend vma.&n; */
DECL|function|expand_stack
r_int
id|expand_stack
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
)paren
(brace
r_int
r_int
id|grow
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_GROWSUP
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t; * vma-&gt;vm_start/vm_end cannot change under us because the caller&n;&t; * is required to hold the mmap_sem in read mode. We need to get&n;&t; * the spinlock only before relocating the vma range ourself.&n;&t; */
id|address
op_add_assign
l_int|4
op_plus
id|PAGE_SIZE
op_minus
l_int|1
suffix:semicolon
id|address
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|vma-&gt;vm_mm-&gt;page_table_lock
)paren
suffix:semicolon
id|grow
op_assign
(paren
id|address
op_minus
id|vma-&gt;vm_end
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* Overcommit.. */
r_if
c_cond
(paren
op_logical_neg
id|vm_enough_memory
c_func
(paren
id|grow
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|vma-&gt;vm_mm-&gt;page_table_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|address
op_minus
id|vma-&gt;vm_start
OG
id|current-&gt;rlim
(braket
id|RLIMIT_STACK
)braket
dot
id|rlim_cur
op_logical_or
(paren
(paren
id|vma-&gt;vm_mm-&gt;total_vm
op_plus
id|grow
)paren
op_lshift
id|PAGE_SHIFT
)paren
OG
id|current-&gt;rlim
(braket
id|RLIMIT_AS
)braket
dot
id|rlim_cur
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|vma-&gt;vm_mm-&gt;page_table_lock
)paren
suffix:semicolon
id|vm_unacct_memory
c_func
(paren
id|grow
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|vma-&gt;vm_end
op_assign
id|address
suffix:semicolon
id|vma-&gt;vm_mm-&gt;total_vm
op_add_assign
id|grow
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_LOCKED
)paren
id|vma-&gt;vm_mm-&gt;locked_vm
op_add_assign
id|grow
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|vma-&gt;vm_mm-&gt;page_table_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|find_extend_vma
r_struct
id|vm_area_struct
op_star
id|find_extend_vma
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
comma
op_star
id|prev
suffix:semicolon
id|addr
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|vma
op_assign
id|find_vma_prev
c_func
(paren
id|mm
comma
id|addr
comma
op_amp
id|prev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma
op_logical_and
(paren
id|vma-&gt;vm_start
op_le
id|addr
)paren
)paren
r_return
id|vma
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prev
op_logical_or
id|expand_stack
c_func
(paren
id|prev
comma
id|addr
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|prev-&gt;vm_flags
op_amp
id|VM_LOCKED
)paren
(brace
id|make_pages_present
c_func
(paren
id|addr
comma
id|prev-&gt;vm_end
)paren
suffix:semicolon
)brace
r_return
id|prev
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/*&n; * vma is the first one with address &lt; vma-&gt;vm_start.  Have to extend vma.&n; */
DECL|function|expand_stack
r_int
id|expand_stack
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
)paren
(brace
r_int
r_int
id|grow
suffix:semicolon
multiline_comment|/*&n;&t; * vma-&gt;vm_start/vm_end cannot change under us because the caller&n;&t; * is required to hold the mmap_sem in read mode. We need to get&n;&t; * the spinlock only before relocating the vma range ourself.&n;&t; */
id|address
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|vma-&gt;vm_mm-&gt;page_table_lock
)paren
suffix:semicolon
id|grow
op_assign
(paren
id|vma-&gt;vm_start
op_minus
id|address
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* Overcommit.. */
r_if
c_cond
(paren
op_logical_neg
id|vm_enough_memory
c_func
(paren
id|grow
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|vma-&gt;vm_mm-&gt;page_table_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vma-&gt;vm_end
op_minus
id|address
OG
id|current-&gt;rlim
(braket
id|RLIMIT_STACK
)braket
dot
id|rlim_cur
op_logical_or
(paren
(paren
id|vma-&gt;vm_mm-&gt;total_vm
op_plus
id|grow
)paren
op_lshift
id|PAGE_SHIFT
)paren
OG
id|current-&gt;rlim
(braket
id|RLIMIT_AS
)braket
dot
id|rlim_cur
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|vma-&gt;vm_mm-&gt;page_table_lock
)paren
suffix:semicolon
id|vm_unacct_memory
c_func
(paren
id|grow
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|vma-&gt;vm_start
op_assign
id|address
suffix:semicolon
id|vma-&gt;vm_pgoff
op_sub_assign
id|grow
suffix:semicolon
id|vma-&gt;vm_mm-&gt;total_vm
op_add_assign
id|grow
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_LOCKED
)paren
id|vma-&gt;vm_mm-&gt;locked_vm
op_add_assign
id|grow
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|vma-&gt;vm_mm-&gt;page_table_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|find_extend_vma
r_struct
id|vm_area_struct
op_star
id|find_extend_vma
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
r_int
id|start
suffix:semicolon
id|addr
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_start
op_le
id|addr
)paren
r_return
id|vma
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_GROWSDOWN
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|start
op_assign
id|vma-&gt;vm_start
suffix:semicolon
r_if
c_cond
(paren
id|expand_stack
c_func
(paren
id|vma
comma
id|addr
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_LOCKED
)paren
(brace
id|make_pages_present
c_func
(paren
id|addr
comma
id|start
)paren
suffix:semicolon
)brace
r_return
id|vma
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Try to free as many page directory entries as we can,&n; * without having to work very hard at actually scanning&n; * the page tables themselves.&n; *&n; * Right now we try to free page tables if we have a nice&n; * PGDIR-aligned area that got free&squot;d up. We could be more&n; * granular if we want to, but this is fast and simple,&n; * and covers the bad cases.&n; *&n; * &quot;prev&quot;, if it exists, points to a vma before the one&n; * we just free&squot;d - but there&squot;s no telling how much before.&n; */
DECL|function|free_pgtables
r_static
r_void
id|free_pgtables
c_func
(paren
id|mmu_gather_t
op_star
id|tlb
comma
r_struct
id|vm_area_struct
op_star
id|prev
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_int
r_int
id|first
op_assign
id|start
op_amp
id|PGDIR_MASK
suffix:semicolon
r_int
r_int
id|last
op_assign
id|end
op_plus
id|PGDIR_SIZE
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|start_index
comma
id|end_index
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|tlb-&gt;mm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prev
)paren
(brace
id|prev
op_assign
id|mm-&gt;mmap
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prev
)paren
r_goto
id|no_mmaps
suffix:semicolon
r_if
c_cond
(paren
id|prev-&gt;vm_end
OG
id|start
)paren
(brace
r_if
c_cond
(paren
id|last
OG
id|prev-&gt;vm_start
)paren
id|last
op_assign
id|prev-&gt;vm_start
suffix:semicolon
r_goto
id|no_mmaps
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|next
op_assign
id|prev-&gt;vm_next
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
(brace
r_if
c_cond
(paren
id|next-&gt;vm_start
OL
id|start
)paren
(brace
id|prev
op_assign
id|next
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|last
OG
id|next-&gt;vm_start
)paren
id|last
op_assign
id|next-&gt;vm_start
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prev-&gt;vm_end
OG
id|first
)paren
id|first
op_assign
id|prev-&gt;vm_end
op_plus
id|PGDIR_SIZE
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|no_mmaps
suffix:colon
r_if
c_cond
(paren
id|last
OL
id|first
)paren
multiline_comment|/* needed for arches with discontiguous pgd indices */
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If the PGD bits are not consecutive in the virtual address, the&n;&t; * old method of shifting the VA &gt;&gt; by PGDIR_SHIFT doesn&squot;t work.&n;&t; */
id|start_index
op_assign
id|pgd_index
c_func
(paren
id|first
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start_index
OL
id|FIRST_USER_PGD_NR
)paren
id|start_index
op_assign
id|FIRST_USER_PGD_NR
suffix:semicolon
id|end_index
op_assign
id|pgd_index
c_func
(paren
id|last
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end_index
OG
id|start_index
)paren
(brace
id|clear_page_tables
c_func
(paren
id|tlb
comma
id|start_index
comma
id|end_index
op_minus
id|start_index
)paren
suffix:semicolon
id|flush_tlb_pgtables
c_func
(paren
id|mm
comma
id|first
op_amp
id|PGDIR_MASK
comma
id|last
op_amp
id|PGDIR_MASK
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Normal function to fix up a mapping&n; * This function is the default for when an area has no specific&n; * function.  This may be used as part of a more specific routine.&n; *&n; * By the time this function is called, the area struct has been&n; * removed from the process mapping list.&n; */
DECL|function|unmap_vma
r_static
r_void
id|unmap_vma
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|area
)paren
(brace
r_int
id|len
op_assign
id|area-&gt;vm_end
op_minus
id|area-&gt;vm_start
suffix:semicolon
id|area-&gt;vm_mm-&gt;total_vm
op_sub_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|area-&gt;vm_flags
op_amp
id|VM_LOCKED
)paren
id|area-&gt;vm_mm-&gt;locked_vm
op_sub_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|remove_shared_vm_struct
c_func
(paren
id|area
)paren
suffix:semicolon
r_if
c_cond
(paren
id|area-&gt;vm_ops
op_logical_and
id|area-&gt;vm_ops-&gt;close
)paren
id|area-&gt;vm_ops
op_member_access_from_pointer
id|close
c_func
(paren
id|area
)paren
suffix:semicolon
r_if
c_cond
(paren
id|area-&gt;vm_file
)paren
id|fput
c_func
(paren
id|area-&gt;vm_file
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|area
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Update the VMA and inode share lists.&n; *&n; * Ok - we have the memory areas we should free on the &squot;free&squot; list,&n; * so release them, and do the vma updates.&n; */
DECL|function|unmap_vma_list
r_static
r_void
id|unmap_vma_list
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|mpnt
)paren
(brace
r_do
(brace
r_struct
id|vm_area_struct
op_star
id|next
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
id|unmap_vma
c_func
(paren
id|mm
comma
id|mpnt
)paren
suffix:semicolon
id|mpnt
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mpnt
op_ne
l_int|NULL
)paren
suffix:semicolon
id|validate_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get rid of page table information in the indicated region.&n; *&n; * Called with the page table lock held.&n; */
DECL|function|unmap_region
r_static
r_void
id|unmap_region
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|mpnt
comma
r_struct
id|vm_area_struct
op_star
id|prev
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
id|mmu_gather_t
op_star
id|tlb
suffix:semicolon
id|tlb
op_assign
id|tlb_gather_mmu
c_func
(paren
id|mm
comma
l_int|0
)paren
suffix:semicolon
r_do
(brace
r_int
r_int
id|from
comma
id|to
comma
id|len
suffix:semicolon
id|from
op_assign
id|start
OL
id|mpnt-&gt;vm_start
ques
c_cond
id|mpnt-&gt;vm_start
suffix:colon
id|start
suffix:semicolon
id|to
op_assign
id|end
OG
id|mpnt-&gt;vm_end
ques
c_cond
id|mpnt-&gt;vm_end
suffix:colon
id|end
suffix:semicolon
id|unmap_page_range
c_func
(paren
id|tlb
comma
id|mpnt
comma
id|from
comma
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_flags
op_amp
id|VM_ACCOUNT
)paren
(brace
id|len
op_assign
id|to
op_minus
id|from
suffix:semicolon
id|vm_unacct_memory
c_func
(paren
id|len
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|mpnt
op_assign
id|mpnt-&gt;vm_next
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
id|free_pgtables
c_func
(paren
id|tlb
comma
id|prev
comma
id|start
comma
id|end
)paren
suffix:semicolon
id|tlb_finish_mmu
c_func
(paren
id|tlb
comma
id|start
comma
id|end
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a list of vma&squot;s touched by the unmap,&n; * removing them from the VM lists as we go..&n; *&n; * Called with the page_table_lock held.&n; */
DECL|function|touched_by_munmap
r_static
r_struct
id|vm_area_struct
op_star
id|touched_by_munmap
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|mpnt
comma
r_struct
id|vm_area_struct
op_star
id|prev
comma
r_int
r_int
id|end
)paren
(brace
r_struct
id|vm_area_struct
op_star
op_star
id|npp
comma
op_star
id|touched
suffix:semicolon
id|npp
op_assign
(paren
id|prev
ques
c_cond
op_amp
id|prev-&gt;vm_next
suffix:colon
op_amp
id|mm-&gt;mmap
)paren
suffix:semicolon
id|touched
op_assign
l_int|NULL
suffix:semicolon
r_do
(brace
r_struct
id|vm_area_struct
op_star
id|next
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|is_vm_hugetlb_page
c_func
(paren
id|mpnt
)paren
)paren
)paren
(brace
id|mpnt-&gt;vm_next
op_assign
id|touched
suffix:semicolon
id|touched
op_assign
id|mpnt
suffix:semicolon
id|rb_erase
c_func
(paren
op_amp
id|mpnt-&gt;vm_rb
comma
op_amp
id|mm-&gt;mm_rb
)paren
suffix:semicolon
id|mm-&gt;map_count
op_decrement
suffix:semicolon
)brace
r_else
id|free_hugepages
c_func
(paren
id|mpnt
)paren
suffix:semicolon
id|mpnt
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mpnt
op_logical_and
id|mpnt-&gt;vm_start
OL
id|end
)paren
suffix:semicolon
op_star
id|npp
op_assign
id|mpnt
suffix:semicolon
id|mm-&gt;mmap_cache
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Kill the cache. */
r_return
id|touched
suffix:semicolon
)brace
multiline_comment|/*&n; * Split a vma into two pieces at address &squot;addr&squot;, a new vma is allocated&n; * either for the first part or the the tail.&n; */
DECL|function|split_vma
r_int
id|split_vma
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|addr
comma
r_int
id|new_below
)paren
(brace
r_struct
id|vm_area_struct
op_star
r_new
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;map_count
op_ge
id|MAX_MAP_COUNT
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_new
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* most fields are the same, copy all, and then fixup */
op_star
r_new
op_assign
op_star
id|vma
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|shared
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_below
)paren
(brace
r_new
op_member_access_from_pointer
id|vm_end
op_assign
id|addr
suffix:semicolon
id|vma-&gt;vm_start
op_assign
id|addr
suffix:semicolon
id|vma-&gt;vm_pgoff
op_add_assign
(paren
(paren
id|addr
op_minus
r_new
op_member_access_from_pointer
id|vm_start
)paren
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
)brace
r_else
(brace
id|vma-&gt;vm_end
op_assign
id|addr
suffix:semicolon
r_new
op_member_access_from_pointer
id|vm_start
op_assign
id|addr
suffix:semicolon
r_new
op_member_access_from_pointer
id|vm_pgoff
op_add_assign
(paren
(paren
id|addr
op_minus
id|vma-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
)brace
r_new
op_member_access_from_pointer
id|vm_raend
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|vm_file
)paren
id|get_file
c_func
(paren
r_new
op_member_access_from_pointer
id|vm_file
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|vm_ops
op_logical_and
r_new
op_member_access_from_pointer
id|vm_ops-&gt;open
)paren
r_new
op_member_access_from_pointer
id|vm_ops
op_member_access_from_pointer
id|open
c_func
(paren
r_new
)paren
suffix:semicolon
id|insert_vm_struct
c_func
(paren
id|mm
comma
r_new
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Munmap is split into 2 main parts -- this part which finds&n; * what needs doing, and the areas themselves, which do the&n; * work.  This now handles partial unmappings.&n; * Jeremy Fitzhardinge &lt;jeremy@goop.org&gt;&n; */
DECL|function|do_munmap
r_int
id|do_munmap
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
id|len
)paren
(brace
r_int
r_int
id|end
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|mpnt
comma
op_star
id|prev
comma
op_star
id|last
suffix:semicolon
r_if
c_cond
(paren
(paren
id|start
op_amp
op_complement
id|PAGE_MASK
)paren
op_logical_or
id|start
OG
id|TASK_SIZE
op_logical_or
id|len
OG
id|TASK_SIZE
op_minus
id|start
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|PAGE_ALIGN
c_func
(paren
id|len
)paren
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Find the first overlapping VMA */
id|mpnt
op_assign
id|find_vma_prev
c_func
(paren
id|mm
comma
id|start
comma
op_amp
id|prev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mpnt
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* we have  start &lt; mpnt-&gt;vm_end  */
multiline_comment|/* if it doesn&squot;t overlap, we have nothing.. */
id|end
op_assign
id|start
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_start
op_ge
id|end
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Something will probably happen, so notify. */
r_if
c_cond
(paren
id|mpnt-&gt;vm_file
op_logical_and
(paren
id|mpnt-&gt;vm_flags
op_amp
id|VM_EXEC
)paren
)paren
id|profile_exec_unmap
c_func
(paren
id|mm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we need to split any vma, do it now to save pain later.&n;&t; */
r_if
c_cond
(paren
id|start
OG
id|mpnt-&gt;vm_start
)paren
(brace
r_if
c_cond
(paren
id|split_vma
c_func
(paren
id|mm
comma
id|mpnt
comma
id|start
comma
l_int|0
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|prev
op_assign
id|mpnt
suffix:semicolon
id|mpnt
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
)brace
multiline_comment|/* Does it split the last one? */
id|last
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last
op_logical_and
id|end
OG
id|last-&gt;vm_start
)paren
(brace
r_if
c_cond
(paren
id|split_vma
c_func
(paren
id|mm
comma
id|last
comma
id|end
comma
l_int|0
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Remove the vma&squot;s, and unmap the actual pages&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|mpnt
op_assign
id|touched_by_munmap
c_func
(paren
id|mm
comma
id|mpnt
comma
id|prev
comma
id|end
)paren
suffix:semicolon
id|unmap_region
c_func
(paren
id|mm
comma
id|mpnt
comma
id|prev
comma
id|start
comma
id|end
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
multiline_comment|/* Fix up all other VM information */
id|unmap_vma_list
c_func
(paren
id|mm
comma
id|mpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_munmap
id|asmlinkage
r_int
id|sys_munmap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
id|len
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|ret
op_assign
id|do_munmap
c_func
(paren
id|mm
comma
id|addr
comma
id|len
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *  this is really a simplified &quot;do_mmap&quot;.  it only handles&n; *  anonymous maps.  eventually we may be able to do some&n; *  brk-specific accounting here.&n; */
DECL|function|do_brk
r_int
r_int
id|do_brk
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
comma
op_star
id|prev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|rb_node
op_star
op_star
id|rb_link
comma
op_star
id|rb_parent
suffix:semicolon
id|len
op_assign
id|PAGE_ALIGN
c_func
(paren
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_return
id|addr
suffix:semicolon
multiline_comment|/*&n;&t; * mlock MCL_FUTURE?&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;def_flags
op_amp
id|VM_LOCKED
)paren
(brace
r_int
r_int
id|locked
op_assign
id|mm-&gt;locked_vm
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|locked
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|locked
OG
id|current-&gt;rlim
(braket
id|RLIMIT_MEMLOCK
)braket
dot
id|rlim_cur
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clear old maps.  this also does some error checking for us&n;&t; */
id|munmap_back
suffix:colon
id|vma
op_assign
id|find_vma_prepare
c_func
(paren
id|mm
comma
id|addr
comma
op_amp
id|prev
comma
op_amp
id|rb_link
comma
op_amp
id|rb_parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma
op_logical_and
id|vma-&gt;vm_start
OL
id|addr
op_plus
id|len
)paren
(brace
r_if
c_cond
(paren
id|do_munmap
c_func
(paren
id|mm
comma
id|addr
comma
id|len
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|munmap_back
suffix:semicolon
)brace
multiline_comment|/* Check against address space limits *after* clearing old maps... */
r_if
c_cond
(paren
(paren
id|mm-&gt;total_vm
op_lshift
id|PAGE_SHIFT
)paren
op_plus
id|len
OG
id|current-&gt;rlim
(braket
id|RLIMIT_AS
)braket
dot
id|rlim_cur
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;map_count
OG
id|MAX_MAP_COUNT
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vm_enough_memory
c_func
(paren
id|len
op_rshift
id|PAGE_SHIFT
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|flags
op_assign
id|VM_DATA_DEFAULT_FLAGS
op_or
id|VM_ACCOUNT
op_or
id|mm-&gt;def_flags
suffix:semicolon
multiline_comment|/* Can we just expand an old anonymous mapping? */
r_if
c_cond
(paren
id|rb_parent
op_logical_and
id|vma_merge
c_func
(paren
id|mm
comma
id|prev
comma
id|rb_parent
comma
id|addr
comma
id|addr
op_plus
id|len
comma
id|flags
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * create a vma struct for an anonymous mapping&n;&t; */
id|vma
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
(brace
id|vm_unacct_memory
c_func
(paren
id|len
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|vma-&gt;vm_mm
op_assign
id|mm
suffix:semicolon
id|vma-&gt;vm_start
op_assign
id|addr
suffix:semicolon
id|vma-&gt;vm_end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
id|vma-&gt;vm_flags
op_assign
id|flags
suffix:semicolon
id|vma-&gt;vm_page_prot
op_assign
id|protection_map
(braket
id|flags
op_amp
l_int|0x0f
)braket
suffix:semicolon
id|vma-&gt;vm_ops
op_assign
l_int|NULL
suffix:semicolon
id|vma-&gt;vm_pgoff
op_assign
l_int|0
suffix:semicolon
id|vma-&gt;vm_file
op_assign
l_int|NULL
suffix:semicolon
id|vma-&gt;vm_private_data
op_assign
l_int|NULL
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|vma-&gt;shared
)paren
suffix:semicolon
id|vma_link
c_func
(paren
id|mm
comma
id|vma
comma
id|prev
comma
id|rb_link
comma
id|rb_parent
)paren
suffix:semicolon
id|out
suffix:colon
id|mm-&gt;total_vm
op_add_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|VM_LOCKED
)paren
(brace
id|mm-&gt;locked_vm
op_add_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|make_pages_present
c_func
(paren
id|addr
comma
id|addr
op_plus
id|len
)paren
suffix:semicolon
)brace
r_return
id|addr
suffix:semicolon
)brace
multiline_comment|/* Build the RB tree corresponding to the VMA list. */
DECL|function|build_mmap_rb
r_void
id|build_mmap_rb
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_struct
id|rb_node
op_star
op_star
id|rb_link
comma
op_star
id|rb_parent
suffix:semicolon
id|mm-&gt;mm_rb
op_assign
id|RB_ROOT
suffix:semicolon
id|rb_link
op_assign
op_amp
id|mm-&gt;mm_rb.rb_node
suffix:semicolon
id|rb_parent
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|vma
op_assign
id|mm-&gt;mmap
suffix:semicolon
id|vma
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
)paren
(brace
id|__vma_link_rb
c_func
(paren
id|mm
comma
id|vma
comma
id|rb_link
comma
id|rb_parent
)paren
suffix:semicolon
id|rb_parent
op_assign
op_amp
id|vma-&gt;vm_rb
suffix:semicolon
id|rb_link
op_assign
op_amp
id|rb_parent-&gt;rb_right
suffix:semicolon
)brace
)brace
multiline_comment|/* Release all mmaps. */
DECL|function|exit_mmap
r_void
id|exit_mmap
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
id|mmu_gather_t
op_star
id|tlb
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|mpnt
suffix:semicolon
id|profile_exit_mmap
c_func
(paren
id|mm
)paren
suffix:semicolon
id|release_segments
c_func
(paren
id|mm
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|tlb
op_assign
id|tlb_gather_mmu
c_func
(paren
id|mm
comma
l_int|1
)paren
suffix:semicolon
id|flush_cache_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
id|mpnt
op_assign
id|mm-&gt;mmap
suffix:semicolon
r_while
c_loop
(paren
id|mpnt
)paren
(brace
r_int
r_int
id|start
op_assign
id|mpnt-&gt;vm_start
suffix:semicolon
r_int
r_int
id|end
op_assign
id|mpnt-&gt;vm_end
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the VMA has been charged for, account for its&n;&t;&t; * removal&n;&t;&t; */
r_if
c_cond
(paren
id|mpnt-&gt;vm_flags
op_amp
id|VM_ACCOUNT
)paren
id|vm_unacct_memory
c_func
(paren
(paren
id|end
op_minus
id|start
)paren
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|mm-&gt;map_count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|is_vm_hugetlb_page
c_func
(paren
id|mpnt
)paren
)paren
)paren
id|unmap_page_range
c_func
(paren
id|tlb
comma
id|mpnt
comma
id|start
comma
id|end
)paren
suffix:semicolon
r_else
id|mpnt-&gt;vm_ops
op_member_access_from_pointer
id|close
c_func
(paren
id|mpnt
)paren
suffix:semicolon
id|mpnt
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
)brace
multiline_comment|/* This is just debugging */
r_if
c_cond
(paren
id|mm-&gt;map_count
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|clear_page_tables
c_func
(paren
id|tlb
comma
id|FIRST_USER_PGD_NR
comma
id|USER_PTRS_PER_PGD
)paren
suffix:semicolon
id|tlb_finish_mmu
c_func
(paren
id|tlb
comma
l_int|0
comma
id|TASK_SIZE
)paren
suffix:semicolon
id|mpnt
op_assign
id|mm-&gt;mmap
suffix:semicolon
id|mm-&gt;mmap
op_assign
id|mm-&gt;mmap_cache
op_assign
l_int|NULL
suffix:semicolon
id|mm-&gt;mm_rb
op_assign
id|RB_ROOT
suffix:semicolon
id|mm-&gt;rss
op_assign
l_int|0
suffix:semicolon
id|mm-&gt;total_vm
op_assign
l_int|0
suffix:semicolon
id|mm-&gt;locked_vm
op_assign
l_int|0
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Walk the list again, actually closing and freeing it&n;&t; * without holding any MM locks.&n;&t; */
r_while
c_loop
(paren
id|mpnt
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|next
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
id|remove_shared_vm_struct
c_func
(paren
id|mpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_ops
)paren
(brace
r_if
c_cond
(paren
id|mpnt-&gt;vm_ops-&gt;close
)paren
id|mpnt-&gt;vm_ops
op_member_access_from_pointer
id|close
c_func
(paren
id|mpnt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mpnt-&gt;vm_file
)paren
id|fput
c_func
(paren
id|mpnt-&gt;vm_file
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|mpnt
)paren
suffix:semicolon
id|mpnt
op_assign
id|next
suffix:semicolon
)brace
)brace
multiline_comment|/* Insert vm structure into process list sorted by address&n; * and into the inode&squot;s i_mmap ring.  If vm_file is non-NULL&n; * then the i_shared_lock must be held here.&n; */
DECL|function|insert_vm_struct
r_void
id|insert_vm_struct
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|__vma
comma
op_star
id|prev
suffix:semicolon
r_struct
id|rb_node
op_star
op_star
id|rb_link
comma
op_star
id|rb_parent
suffix:semicolon
id|__vma
op_assign
id|find_vma_prepare
c_func
(paren
id|mm
comma
id|vma-&gt;vm_start
comma
op_amp
id|prev
comma
op_amp
id|rb_link
comma
op_amp
id|rb_parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__vma
op_logical_and
id|__vma-&gt;vm_start
OL
id|vma-&gt;vm_end
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|vma_link
c_func
(paren
id|mm
comma
id|vma
comma
id|prev
comma
id|rb_link
comma
id|rb_parent
)paren
suffix:semicolon
id|validate_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
eof
