multiline_comment|/*&n; * mm/mmap.c&n; *&n; * Written by obz.&n; *&n; * Address space accounting code&t;&lt;alan@redhat.com&gt;&n; */
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/shm.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/syscalls.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/personality.h&gt;
macro_line|#include &lt;linux/security.h&gt;
macro_line|#include &lt;linux/hugetlb.h&gt;
macro_line|#include &lt;linux/profile.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/mount.h&gt;
macro_line|#include &lt;linux/mempolicy.h&gt;
macro_line|#include &lt;linux/rmap.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/cacheflush.h&gt;
macro_line|#include &lt;asm/tlb.h&gt;
multiline_comment|/*&n; * WARNING: the debugging will use recursive algorithms so never enable this&n; * unless you know what you are doing.&n; */
DECL|macro|DEBUG_MM_RB
macro_line|#undef DEBUG_MM_RB
multiline_comment|/* description of effects of mapping type and prot in current implementation.&n; * this is due to the limited x86 page protection hardware.  The expected&n; * behavior is in parens:&n; *&n; * map_type&t;prot&n; *&t;&t;PROT_NONE&t;PROT_READ&t;PROT_WRITE&t;PROT_EXEC&n; * MAP_SHARED&t;r: (no) no&t;r: (yes) yes&t;r: (no) yes&t;r: (no) yes&n; *&t;&t;w: (no) no&t;w: (no) no&t;w: (yes) yes&t;w: (no) no&n; *&t;&t;x: (no) no&t;x: (no) yes&t;x: (no) yes&t;x: (yes) yes&n; *&t;&t;&n; * MAP_PRIVATE&t;r: (no) no&t;r: (yes) yes&t;r: (no) yes&t;r: (no) yes&n; *&t;&t;w: (no) no&t;w: (no) no&t;w: (copy) copy&t;w: (no) no&n; *&t;&t;x: (no) no&t;x: (no) yes&t;x: (no) yes&t;x: (yes) yes&n; *&n; */
DECL|variable|protection_map
id|pgprot_t
id|protection_map
(braket
l_int|16
)braket
op_assign
(brace
id|__P000
comma
id|__P001
comma
id|__P010
comma
id|__P011
comma
id|__P100
comma
id|__P101
comma
id|__P110
comma
id|__P111
comma
id|__S000
comma
id|__S001
comma
id|__S010
comma
id|__S011
comma
id|__S100
comma
id|__S101
comma
id|__S110
comma
id|__S111
)brace
suffix:semicolon
DECL|variable|sysctl_overcommit_memory
r_int
id|sysctl_overcommit_memory
op_assign
id|OVERCOMMIT_GUESS
suffix:semicolon
multiline_comment|/* heuristic overcommit */
DECL|variable|sysctl_overcommit_ratio
r_int
id|sysctl_overcommit_ratio
op_assign
l_int|50
suffix:semicolon
multiline_comment|/* default is 50% */
DECL|variable|sysctl_max_map_count
r_int
id|sysctl_max_map_count
op_assign
id|DEFAULT_MAX_MAP_COUNT
suffix:semicolon
DECL|variable|vm_committed_space
id|atomic_t
id|vm_committed_space
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|sysctl_overcommit_memory
id|EXPORT_SYMBOL
c_func
(paren
id|sysctl_overcommit_memory
)paren
suffix:semicolon
DECL|variable|sysctl_overcommit_ratio
id|EXPORT_SYMBOL
c_func
(paren
id|sysctl_overcommit_ratio
)paren
suffix:semicolon
DECL|variable|sysctl_max_map_count
id|EXPORT_SYMBOL
c_func
(paren
id|sysctl_max_map_count
)paren
suffix:semicolon
DECL|variable|vm_committed_space
id|EXPORT_SYMBOL
c_func
(paren
id|vm_committed_space
)paren
suffix:semicolon
multiline_comment|/*&n; * Requires inode-&gt;i_mapping-&gt;i_mmap_lock&n; */
DECL|function|__remove_shared_vm_struct
r_static
r_void
id|__remove_shared_vm_struct
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|file
op_star
id|file
comma
r_struct
id|address_space
op_star
id|mapping
)paren
(brace
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_DENYWRITE
)paren
id|atomic_inc
c_func
(paren
op_amp
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_writecount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_SHARED
)paren
id|mapping-&gt;i_mmap_writable
op_decrement
suffix:semicolon
id|flush_dcache_mmap_lock
c_func
(paren
id|mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_NONLINEAR
)paren
)paren
id|list_del_init
c_func
(paren
op_amp
id|vma-&gt;shared.vm_set.list
)paren
suffix:semicolon
r_else
id|vma_prio_tree_remove
c_func
(paren
id|vma
comma
op_amp
id|mapping-&gt;i_mmap
)paren
suffix:semicolon
id|flush_dcache_mmap_unlock
c_func
(paren
id|mapping
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove one vm structure and free it.&n; */
DECL|function|remove_vm_struct
r_static
r_void
id|remove_vm_struct
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|vma-&gt;vm_file
suffix:semicolon
id|might_sleep
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|file-&gt;f_mapping
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mapping-&gt;i_mmap_lock
)paren
suffix:semicolon
id|__remove_shared_vm_struct
c_func
(paren
id|vma
comma
id|file
comma
id|mapping
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mapping-&gt;i_mmap_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vma-&gt;vm_ops
op_logical_and
id|vma-&gt;vm_ops-&gt;close
)paren
id|vma-&gt;vm_ops
op_member_access_from_pointer
id|close
c_func
(paren
id|vma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|anon_vma_unlink
c_func
(paren
id|vma
)paren
suffix:semicolon
id|mpol_free
c_func
(paren
id|vma_policy
c_func
(paren
id|vma
)paren
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|vma
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  sys_brk() for the most part doesn&squot;t need the global kernel&n; *  lock, except when an application is doing something nasty&n; *  like trying to un-brk an area that has already been mapped&n; *  to a regular file.  in this case, the unmapping will need&n; *  to invoke file system routines that need the global lock.&n; */
DECL|function|sys_brk
id|asmlinkage
r_int
r_int
id|sys_brk
c_func
(paren
r_int
r_int
id|brk
)paren
(brace
r_int
r_int
id|rlim
comma
id|retval
suffix:semicolon
r_int
r_int
id|newbrk
comma
id|oldbrk
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|brk
OL
id|mm-&gt;end_code
)paren
r_goto
id|out
suffix:semicolon
id|newbrk
op_assign
id|PAGE_ALIGN
c_func
(paren
id|brk
)paren
suffix:semicolon
id|oldbrk
op_assign
id|PAGE_ALIGN
c_func
(paren
id|mm-&gt;brk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldbrk
op_eq
id|newbrk
)paren
r_goto
id|set_brk
suffix:semicolon
multiline_comment|/* Always allow shrinking brk. */
r_if
c_cond
(paren
id|brk
op_le
id|mm-&gt;brk
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|do_munmap
c_func
(paren
id|mm
comma
id|newbrk
comma
id|oldbrk
op_minus
id|newbrk
)paren
)paren
r_goto
id|set_brk
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Check against rlimit.. */
id|rlim
op_assign
id|current-&gt;signal-&gt;rlim
(braket
id|RLIMIT_DATA
)braket
dot
id|rlim_cur
suffix:semicolon
r_if
c_cond
(paren
id|rlim
template_param
id|rlim
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Check against existing mmap mappings. */
r_if
c_cond
(paren
id|find_vma_intersection
c_func
(paren
id|mm
comma
id|oldbrk
comma
id|newbrk
op_plus
id|PAGE_SIZE
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Ok, looks good - let it rip. */
r_if
c_cond
(paren
id|do_brk
c_func
(paren
id|oldbrk
comma
id|newbrk
op_minus
id|oldbrk
)paren
op_ne
id|oldbrk
)paren
r_goto
id|out
suffix:semicolon
id|set_brk
suffix:colon
id|mm-&gt;brk
op_assign
id|brk
suffix:semicolon
id|out
suffix:colon
id|retval
op_assign
id|mm-&gt;brk
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_MM_RB
DECL|function|browse_rb
r_static
r_int
id|browse_rb
c_func
(paren
r_struct
id|rb_root
op_star
id|root
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|j
suffix:semicolon
r_struct
id|rb_node
op_star
id|nd
comma
op_star
id|pn
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|prev
op_assign
l_int|0
comma
id|pend
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|nd
op_assign
id|rb_first
c_func
(paren
id|root
)paren
suffix:semicolon
id|nd
suffix:semicolon
id|nd
op_assign
id|rb_next
c_func
(paren
id|nd
)paren
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
id|vma
op_assign
id|rb_entry
c_func
(paren
id|nd
comma
r_struct
id|vm_area_struct
comma
id|vm_rb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_start
OL
id|prev
)paren
id|printk
c_func
(paren
l_string|&quot;vm_start %lx prev %lx&bslash;n&quot;
comma
id|vma-&gt;vm_start
comma
id|prev
)paren
comma
id|i
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_start
OL
id|pend
)paren
id|printk
c_func
(paren
l_string|&quot;vm_start %lx pend %lx&bslash;n&quot;
comma
id|vma-&gt;vm_start
comma
id|pend
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_start
OG
id|vma-&gt;vm_end
)paren
id|printk
c_func
(paren
l_string|&quot;vm_end %lx &lt; vm_start %lx&bslash;n&quot;
comma
id|vma-&gt;vm_end
comma
id|vma-&gt;vm_start
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|pn
op_assign
id|nd
suffix:semicolon
)brace
id|j
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|nd
op_assign
id|pn
suffix:semicolon
id|nd
suffix:semicolon
id|nd
op_assign
id|rb_prev
c_func
(paren
id|nd
)paren
)paren
(brace
id|j
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ne
id|j
)paren
id|printk
c_func
(paren
l_string|&quot;backwards %d, forwards %d&bslash;n&quot;
comma
id|j
comma
id|i
)paren
comma
id|i
op_assign
l_int|0
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|validate_mm
r_void
id|validate_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_int
id|bug
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|tmp
op_assign
id|mm-&gt;mmap
suffix:semicolon
r_while
c_loop
(paren
id|tmp
)paren
(brace
id|tmp
op_assign
id|tmp-&gt;vm_next
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ne
id|mm-&gt;map_count
)paren
id|printk
c_func
(paren
l_string|&quot;map_count %d vm_next %d&bslash;n&quot;
comma
id|mm-&gt;map_count
comma
id|i
)paren
comma
id|bug
op_assign
l_int|1
suffix:semicolon
id|i
op_assign
id|browse_rb
c_func
(paren
op_amp
id|mm-&gt;mm_rb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|mm-&gt;map_count
)paren
id|printk
c_func
(paren
l_string|&quot;map_count %d rb %d&bslash;n&quot;
comma
id|mm-&gt;map_count
comma
id|i
)paren
comma
id|bug
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bug
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|validate_mm
mdefine_line|#define validate_mm(mm) do { } while (0)
macro_line|#endif
r_static
r_struct
id|vm_area_struct
op_star
DECL|function|find_vma_prepare
id|find_vma_prepare
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
comma
r_struct
id|vm_area_struct
op_star
op_star
id|pprev
comma
r_struct
id|rb_node
op_star
op_star
op_star
id|rb_link
comma
r_struct
id|rb_node
op_star
op_star
id|rb_parent
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_struct
id|rb_node
op_star
op_star
id|__rb_link
comma
op_star
id|__rb_parent
comma
op_star
id|rb_prev
suffix:semicolon
id|__rb_link
op_assign
op_amp
id|mm-&gt;mm_rb.rb_node
suffix:semicolon
id|rb_prev
op_assign
id|__rb_parent
op_assign
l_int|NULL
suffix:semicolon
id|vma
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
op_star
id|__rb_link
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma_tmp
suffix:semicolon
id|__rb_parent
op_assign
op_star
id|__rb_link
suffix:semicolon
id|vma_tmp
op_assign
id|rb_entry
c_func
(paren
id|__rb_parent
comma
r_struct
id|vm_area_struct
comma
id|vm_rb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma_tmp-&gt;vm_end
OG
id|addr
)paren
(brace
id|vma
op_assign
id|vma_tmp
suffix:semicolon
r_if
c_cond
(paren
id|vma_tmp-&gt;vm_start
op_le
id|addr
)paren
r_return
id|vma
suffix:semicolon
id|__rb_link
op_assign
op_amp
id|__rb_parent-&gt;rb_left
suffix:semicolon
)brace
r_else
(brace
id|rb_prev
op_assign
id|__rb_parent
suffix:semicolon
id|__rb_link
op_assign
op_amp
id|__rb_parent-&gt;rb_right
suffix:semicolon
)brace
)brace
op_star
id|pprev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|rb_prev
)paren
op_star
id|pprev
op_assign
id|rb_entry
c_func
(paren
id|rb_prev
comma
r_struct
id|vm_area_struct
comma
id|vm_rb
)paren
suffix:semicolon
op_star
id|rb_link
op_assign
id|__rb_link
suffix:semicolon
op_star
id|rb_parent
op_assign
id|__rb_parent
suffix:semicolon
r_return
id|vma
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|__vma_link_list
id|__vma_link_list
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|vm_area_struct
op_star
id|prev
comma
r_struct
id|rb_node
op_star
id|rb_parent
)paren
(brace
r_if
c_cond
(paren
id|prev
)paren
(brace
id|vma-&gt;vm_next
op_assign
id|prev-&gt;vm_next
suffix:semicolon
id|prev-&gt;vm_next
op_assign
id|vma
suffix:semicolon
)brace
r_else
(brace
id|mm-&gt;mmap
op_assign
id|vma
suffix:semicolon
r_if
c_cond
(paren
id|rb_parent
)paren
id|vma-&gt;vm_next
op_assign
id|rb_entry
c_func
(paren
id|rb_parent
comma
r_struct
id|vm_area_struct
comma
id|vm_rb
)paren
suffix:semicolon
r_else
id|vma-&gt;vm_next
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|__vma_link_rb
r_void
id|__vma_link_rb
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|rb_node
op_star
op_star
id|rb_link
comma
r_struct
id|rb_node
op_star
id|rb_parent
)paren
(brace
id|rb_link_node
c_func
(paren
op_amp
id|vma-&gt;vm_rb
comma
id|rb_parent
comma
id|rb_link
)paren
suffix:semicolon
id|rb_insert_color
c_func
(paren
op_amp
id|vma-&gt;vm_rb
comma
op_amp
id|mm-&gt;mm_rb
)paren
suffix:semicolon
)brace
DECL|function|__vma_link_file
r_static
r_inline
r_void
id|__vma_link_file
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
id|file
op_assign
id|vma-&gt;vm_file
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|file-&gt;f_mapping
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_DENYWRITE
)paren
id|atomic_dec
c_func
(paren
op_amp
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_writecount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_SHARED
)paren
id|mapping-&gt;i_mmap_writable
op_increment
suffix:semicolon
id|flush_dcache_mmap_lock
c_func
(paren
id|mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_NONLINEAR
)paren
)paren
id|vma_nonlinear_insert
c_func
(paren
id|vma
comma
op_amp
id|mapping-&gt;i_mmap_nonlinear
)paren
suffix:semicolon
r_else
id|vma_prio_tree_insert
c_func
(paren
id|vma
comma
op_amp
id|mapping-&gt;i_mmap
)paren
suffix:semicolon
id|flush_dcache_mmap_unlock
c_func
(paren
id|mapping
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|__vma_link
id|__vma_link
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|vm_area_struct
op_star
id|prev
comma
r_struct
id|rb_node
op_star
op_star
id|rb_link
comma
r_struct
id|rb_node
op_star
id|rb_parent
)paren
(brace
id|__vma_link_list
c_func
(paren
id|mm
comma
id|vma
comma
id|prev
comma
id|rb_parent
)paren
suffix:semicolon
id|__vma_link_rb
c_func
(paren
id|mm
comma
id|vma
comma
id|rb_link
comma
id|rb_parent
)paren
suffix:semicolon
id|__anon_vma_link
c_func
(paren
id|vma
)paren
suffix:semicolon
)brace
DECL|function|vma_link
r_static
r_void
id|vma_link
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|vm_area_struct
op_star
id|prev
comma
r_struct
id|rb_node
op_star
op_star
id|rb_link
comma
r_struct
id|rb_node
op_star
id|rb_parent
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_file
)paren
id|mapping
op_assign
id|vma-&gt;vm_file-&gt;f_mapping
suffix:semicolon
r_if
c_cond
(paren
id|mapping
)paren
id|spin_lock
c_func
(paren
op_amp
id|mapping-&gt;i_mmap_lock
)paren
suffix:semicolon
id|anon_vma_lock
c_func
(paren
id|vma
)paren
suffix:semicolon
id|__vma_link
c_func
(paren
id|mm
comma
id|vma
comma
id|prev
comma
id|rb_link
comma
id|rb_parent
)paren
suffix:semicolon
id|__vma_link_file
c_func
(paren
id|vma
)paren
suffix:semicolon
id|anon_vma_unlock
c_func
(paren
id|vma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mapping
)paren
id|spin_unlock
c_func
(paren
op_amp
id|mapping-&gt;i_mmap_lock
)paren
suffix:semicolon
id|mm-&gt;map_count
op_increment
suffix:semicolon
id|validate_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Helper for vma_adjust in the split_vma insert case:&n; * insert vm structure into list and rbtree and anon_vma,&n; * but it has already been inserted into prio_tree earlier.&n; */
r_static
r_void
DECL|function|__insert_vm_struct
id|__insert_vm_struct
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|__vma
comma
op_star
id|prev
suffix:semicolon
r_struct
id|rb_node
op_star
op_star
id|rb_link
comma
op_star
id|rb_parent
suffix:semicolon
id|__vma
op_assign
id|find_vma_prepare
c_func
(paren
id|mm
comma
id|vma-&gt;vm_start
comma
op_amp
id|prev
comma
op_amp
id|rb_link
comma
op_amp
id|rb_parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__vma
op_logical_and
id|__vma-&gt;vm_start
OL
id|vma-&gt;vm_end
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|__vma_link
c_func
(paren
id|mm
comma
id|vma
comma
id|prev
comma
id|rb_link
comma
id|rb_parent
)paren
suffix:semicolon
id|mm-&gt;map_count
op_increment
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|__vma_unlink
id|__vma_unlink
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|vm_area_struct
op_star
id|prev
)paren
(brace
id|prev-&gt;vm_next
op_assign
id|vma-&gt;vm_next
suffix:semicolon
id|rb_erase
c_func
(paren
op_amp
id|vma-&gt;vm_rb
comma
op_amp
id|mm-&gt;mm_rb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;mmap_cache
op_eq
id|vma
)paren
id|mm-&gt;mmap_cache
op_assign
id|prev
suffix:semicolon
)brace
multiline_comment|/*&n; * We cannot adjust vm_start, vm_end, vm_pgoff fields of a vma that&n; * is already present in an i_mmap tree without adjusting the tree.&n; * The following helper function should be used when such adjustments&n; * are necessary.  The &quot;insert&quot; vma (if any) is to be inserted&n; * before we drop the necessary locks.&n; */
DECL|function|vma_adjust
r_void
id|vma_adjust
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
id|pgoff_t
id|pgoff
comma
r_struct
id|vm_area_struct
op_star
id|insert
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|next
op_assign
id|vma-&gt;vm_next
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|importer
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|prio_tree_root
op_star
id|root
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|file
op_star
id|file
op_assign
id|vma-&gt;vm_file
suffix:semicolon
r_struct
id|anon_vma
op_star
id|anon_vma
op_assign
l_int|NULL
suffix:semicolon
r_int
id|adjust_next
op_assign
l_int|0
suffix:semicolon
r_int
id|remove_next
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|next
op_logical_and
op_logical_neg
id|insert
)paren
(brace
r_if
c_cond
(paren
id|end
op_ge
id|next-&gt;vm_end
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * vma expands, overlapping all the next, and&n;&t;&t;&t; * perhaps the one after too (mprotect case 6).&n;&t;&t;&t; */
id|again
suffix:colon
id|remove_next
op_assign
l_int|1
op_plus
(paren
id|end
OG
id|next-&gt;vm_end
)paren
suffix:semicolon
id|end
op_assign
id|next-&gt;vm_end
suffix:semicolon
id|anon_vma
op_assign
id|next-&gt;anon_vma
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|end
OG
id|next-&gt;vm_start
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * vma expands, overlapping part of the next:&n;&t;&t;&t; * mprotect case 5 shifting the boundary up.&n;&t;&t;&t; */
id|adjust_next
op_assign
(paren
id|end
op_minus
id|next-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|anon_vma
op_assign
id|next-&gt;anon_vma
suffix:semicolon
id|importer
op_assign
id|vma
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|end
OL
id|vma-&gt;vm_end
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * vma shrinks, and !insert tells it&squot;s not&n;&t;&t;&t; * split_vma inserting another: so it must be&n;&t;&t;&t; * mprotect case 4 shifting the boundary down.&n;&t;&t;&t; */
id|adjust_next
op_assign
op_minus
(paren
(paren
id|vma-&gt;vm_end
op_minus
id|end
)paren
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|anon_vma
op_assign
id|next-&gt;anon_vma
suffix:semicolon
id|importer
op_assign
id|next
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file
)paren
(brace
id|mapping
op_assign
id|file-&gt;f_mapping
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_NONLINEAR
)paren
)paren
id|root
op_assign
op_amp
id|mapping-&gt;i_mmap
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mapping-&gt;i_mmap_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|insert
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Put into prio_tree now, so instantiated pages&n;&t;&t;&t; * are visible to arm/parisc __flush_dcache_page&n;&t;&t;&t; * throughout; but we cannot insert into address&n;&t;&t;&t; * space until vma start or end is updated.&n;&t;&t;&t; */
id|__vma_link_file
c_func
(paren
id|insert
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * When changing only vma-&gt;vm_end, we don&squot;t really need&n;&t; * anon_vma lock: but is that case worth optimizing out?&n;&t; */
r_if
c_cond
(paren
id|vma-&gt;anon_vma
)paren
id|anon_vma
op_assign
id|vma-&gt;anon_vma
suffix:semicolon
r_if
c_cond
(paren
id|anon_vma
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|anon_vma-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Easily overlooked: when mprotect shifts the boundary,&n;&t;&t; * make sure the expanding vma has anon_vma set if the&n;&t;&t; * shrinking vma had, to cover any anon pages imported.&n;&t;&t; */
r_if
c_cond
(paren
id|importer
op_logical_and
op_logical_neg
id|importer-&gt;anon_vma
)paren
(brace
id|importer-&gt;anon_vma
op_assign
id|anon_vma
suffix:semicolon
id|__anon_vma_link
c_func
(paren
id|importer
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|root
)paren
(brace
id|flush_dcache_mmap_lock
c_func
(paren
id|mapping
)paren
suffix:semicolon
id|vma_prio_tree_remove
c_func
(paren
id|vma
comma
id|root
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adjust_next
)paren
id|vma_prio_tree_remove
c_func
(paren
id|next
comma
id|root
)paren
suffix:semicolon
)brace
id|vma-&gt;vm_start
op_assign
id|start
suffix:semicolon
id|vma-&gt;vm_end
op_assign
id|end
suffix:semicolon
id|vma-&gt;vm_pgoff
op_assign
id|pgoff
suffix:semicolon
r_if
c_cond
(paren
id|adjust_next
)paren
(brace
id|next-&gt;vm_start
op_add_assign
id|adjust_next
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|next-&gt;vm_pgoff
op_add_assign
id|adjust_next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|root
)paren
(brace
r_if
c_cond
(paren
id|adjust_next
)paren
id|vma_prio_tree_insert
c_func
(paren
id|next
comma
id|root
)paren
suffix:semicolon
id|vma_prio_tree_insert
c_func
(paren
id|vma
comma
id|root
)paren
suffix:semicolon
id|flush_dcache_mmap_unlock
c_func
(paren
id|mapping
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|remove_next
)paren
(brace
multiline_comment|/*&n;&t;&t; * vma_merge has merged next into vma, and needs&n;&t;&t; * us to remove next before dropping the locks.&n;&t;&t; */
id|__vma_unlink
c_func
(paren
id|mm
comma
id|next
comma
id|vma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
id|__remove_shared_vm_struct
c_func
(paren
id|next
comma
id|file
comma
id|mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next-&gt;anon_vma
)paren
id|__anon_vma_merge
c_func
(paren
id|vma
comma
id|next
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|insert
)paren
(brace
multiline_comment|/*&n;&t;&t; * split_vma has split insert from vma, and needs&n;&t;&t; * us to insert it before dropping the locks&n;&t;&t; * (it may either follow vma or precede it).&n;&t;&t; */
id|__insert_vm_struct
c_func
(paren
id|mm
comma
id|insert
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|anon_vma
)paren
id|spin_unlock
c_func
(paren
op_amp
id|anon_vma-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mapping
)paren
id|spin_unlock
c_func
(paren
op_amp
id|mapping-&gt;i_mmap_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remove_next
)paren
(brace
r_if
c_cond
(paren
id|file
)paren
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|mm-&gt;map_count
op_decrement
suffix:semicolon
id|mpol_free
c_func
(paren
id|vma_policy
c_func
(paren
id|next
)paren
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|next
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * In mprotect&squot;s case 6 (see comments on vma_merge),&n;&t;&t; * we must remove another next too. It would clutter&n;&t;&t; * up the code too much to do both in one go.&n;&t;&t; */
r_if
c_cond
(paren
id|remove_next
op_eq
l_int|2
)paren
(brace
id|next
op_assign
id|vma-&gt;vm_next
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
)brace
id|validate_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * If the vma has a -&gt;close operation then the driver probably needs to release&n; * per-vma resources, so we don&squot;t attempt to merge those.&n; */
DECL|macro|VM_SPECIAL
mdefine_line|#define VM_SPECIAL (VM_IO | VM_DONTCOPY | VM_DONTEXPAND | VM_RESERVED)
DECL|function|is_mergeable_vma
r_static
r_inline
r_int
id|is_mergeable_vma
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|vm_flags
)paren
(brace
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_ne
id|vm_flags
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_file
op_ne
id|file
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_ops
op_logical_and
id|vma-&gt;vm_ops-&gt;close
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|is_mergeable_anon_vma
r_static
r_inline
r_int
id|is_mergeable_anon_vma
c_func
(paren
r_struct
id|anon_vma
op_star
id|anon_vma1
comma
r_struct
id|anon_vma
op_star
id|anon_vma2
)paren
(brace
r_return
op_logical_neg
id|anon_vma1
op_logical_or
op_logical_neg
id|anon_vma2
op_logical_or
(paren
id|anon_vma1
op_eq
id|anon_vma2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Return true if we can merge this (vm_flags,anon_vma,file,vm_pgoff)&n; * in front of (at a lower virtual address and file offset than) the vma.&n; *&n; * We cannot merge two vmas if they have differently assigned (non-NULL)&n; * anon_vmas, nor if same anon_vma is assigned but offsets incompatible.&n; *&n; * We don&squot;t check here for the merged mmap wrapping around the end of pagecache&n; * indices (16TB on ia32) because do_mmap_pgoff() does not permit mmap&squot;s which&n; * wrap, nor mmaps which cover the final page at index -1UL.&n; */
r_static
r_int
DECL|function|can_vma_merge_before
id|can_vma_merge_before
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|vm_flags
comma
r_struct
id|anon_vma
op_star
id|anon_vma
comma
r_struct
id|file
op_star
id|file
comma
id|pgoff_t
id|vm_pgoff
)paren
(brace
r_if
c_cond
(paren
id|is_mergeable_vma
c_func
(paren
id|vma
comma
id|file
comma
id|vm_flags
)paren
op_logical_and
id|is_mergeable_anon_vma
c_func
(paren
id|anon_vma
comma
id|vma-&gt;anon_vma
)paren
)paren
(brace
r_if
c_cond
(paren
id|vma-&gt;vm_pgoff
op_eq
id|vm_pgoff
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Return true if we can merge this (vm_flags,anon_vma,file,vm_pgoff)&n; * beyond (at a higher virtual address and file offset than) the vma.&n; *&n; * We cannot merge two vmas if they have differently assigned (non-NULL)&n; * anon_vmas, nor if same anon_vma is assigned but offsets incompatible.&n; */
r_static
r_int
DECL|function|can_vma_merge_after
id|can_vma_merge_after
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|vm_flags
comma
r_struct
id|anon_vma
op_star
id|anon_vma
comma
r_struct
id|file
op_star
id|file
comma
id|pgoff_t
id|vm_pgoff
)paren
(brace
r_if
c_cond
(paren
id|is_mergeable_vma
c_func
(paren
id|vma
comma
id|file
comma
id|vm_flags
)paren
op_logical_and
id|is_mergeable_anon_vma
c_func
(paren
id|anon_vma
comma
id|vma-&gt;anon_vma
)paren
)paren
(brace
id|pgoff_t
id|vm_pglen
suffix:semicolon
id|vm_pglen
op_assign
(paren
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_pgoff
op_plus
id|vm_pglen
op_eq
id|vm_pgoff
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Given a mapping request (addr,end,vm_flags,file,pgoff), figure out&n; * whether that can be merged with its predecessor or its successor.&n; * Or both (it neatly fills a hole).&n; *&n; * In most cases - when called for mmap, brk or mremap - [addr,end) is&n; * certain not to be mapped by the time vma_merge is called; but when&n; * called for mprotect, it is certain to be already mapped (either at&n; * an offset within prev, or at the start of next), and the flags of&n; * this area are about to be changed to vm_flags - and the no-change&n; * case has already been eliminated.&n; *&n; * The following mprotect cases have to be considered, where AAAA is&n; * the area passed down from mprotect_fixup, never extending beyond one&n; * vma, PPPPPP is the prev vma specified, and NNNNNN the next vma after:&n; *&n; *     AAAA             AAAA                AAAA          AAAA&n; *    PPPPPPNNNNNN    PPPPPPNNNNNN    PPPPPPNNNNNN    PPPPNNNNXXXX&n; *    cannot merge    might become    might become    might become&n; *                    PPNNNNNNNNNN    PPPPPPPPPPNN    PPPPPPPPPPPP 6 or&n; *    mmap, brk or    case 4 below    case 5 below    PPPPPPPPXXXX 7 or&n; *    mremap move:                                    PPPPNNNNNNNN 8&n; *        AAAA&n; *    PPPP    NNNN    PPPPPPPPPPPP    PPPPPPPPNNNN    PPPPNNNNNNNN&n; *    might become    case 1 below    case 2 below    case 3 below&n; *&n; * Odd one out? Case 8, because it extends NNNN but needs flags of XXXX:&n; * mprotect_fixup updates vm_flags &amp; vm_page_prot on successful return.&n; */
DECL|function|vma_merge
r_struct
id|vm_area_struct
op_star
id|vma_merge
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|prev
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|end
comma
r_int
r_int
id|vm_flags
comma
r_struct
id|anon_vma
op_star
id|anon_vma
comma
r_struct
id|file
op_star
id|file
comma
id|pgoff_t
id|pgoff
comma
r_struct
id|mempolicy
op_star
id|policy
)paren
(brace
id|pgoff_t
id|pglen
op_assign
(paren
id|end
op_minus
id|addr
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|area
comma
op_star
id|next
suffix:semicolon
multiline_comment|/*&n;&t; * We later require that vma-&gt;vm_flags == vm_flags,&n;&t; * so this tests vma-&gt;vm_flags &amp; VM_SPECIAL, too.&n;&t; */
r_if
c_cond
(paren
id|vm_flags
op_amp
id|VM_SPECIAL
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
id|next
op_assign
id|prev-&gt;vm_next
suffix:semicolon
r_else
id|next
op_assign
id|mm-&gt;mmap
suffix:semicolon
id|area
op_assign
id|next
suffix:semicolon
r_if
c_cond
(paren
id|next
op_logical_and
id|next-&gt;vm_end
op_eq
id|end
)paren
multiline_comment|/* cases 6, 7, 8 */
id|next
op_assign
id|next-&gt;vm_next
suffix:semicolon
multiline_comment|/*&n;&t; * Can it merge with the predecessor?&n;&t; */
r_if
c_cond
(paren
id|prev
op_logical_and
id|prev-&gt;vm_end
op_eq
id|addr
op_logical_and
id|mpol_equal
c_func
(paren
id|vma_policy
c_func
(paren
id|prev
)paren
comma
id|policy
)paren
op_logical_and
id|can_vma_merge_after
c_func
(paren
id|prev
comma
id|vm_flags
comma
id|anon_vma
comma
id|file
comma
id|pgoff
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * OK, it can.  Can we now merge in the successor as well?&n;&t;&t; */
r_if
c_cond
(paren
id|next
op_logical_and
id|end
op_eq
id|next-&gt;vm_start
op_logical_and
id|mpol_equal
c_func
(paren
id|policy
comma
id|vma_policy
c_func
(paren
id|next
)paren
)paren
op_logical_and
id|can_vma_merge_before
c_func
(paren
id|next
comma
id|vm_flags
comma
id|anon_vma
comma
id|file
comma
id|pgoff
op_plus
id|pglen
)paren
op_logical_and
id|is_mergeable_anon_vma
c_func
(paren
id|prev-&gt;anon_vma
comma
id|next-&gt;anon_vma
)paren
)paren
(brace
multiline_comment|/* cases 1, 6 */
id|vma_adjust
c_func
(paren
id|prev
comma
id|prev-&gt;vm_start
comma
id|next-&gt;vm_end
comma
id|prev-&gt;vm_pgoff
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* cases 2, 5, 7 */
id|vma_adjust
c_func
(paren
id|prev
comma
id|prev-&gt;vm_start
comma
id|end
comma
id|prev-&gt;vm_pgoff
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|prev
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Can this new request be merged in front of next?&n;&t; */
r_if
c_cond
(paren
id|next
op_logical_and
id|end
op_eq
id|next-&gt;vm_start
op_logical_and
id|mpol_equal
c_func
(paren
id|policy
comma
id|vma_policy
c_func
(paren
id|next
)paren
)paren
op_logical_and
id|can_vma_merge_before
c_func
(paren
id|next
comma
id|vm_flags
comma
id|anon_vma
comma
id|file
comma
id|pgoff
op_plus
id|pglen
)paren
)paren
(brace
r_if
c_cond
(paren
id|prev
op_logical_and
id|addr
OL
id|prev-&gt;vm_end
)paren
multiline_comment|/* case 4 */
id|vma_adjust
c_func
(paren
id|prev
comma
id|prev-&gt;vm_start
comma
id|addr
comma
id|prev-&gt;vm_pgoff
comma
l_int|NULL
)paren
suffix:semicolon
r_else
multiline_comment|/* cases 3, 8 */
id|vma_adjust
c_func
(paren
id|area
comma
id|addr
comma
id|next-&gt;vm_end
comma
id|next-&gt;vm_pgoff
op_minus
id|pglen
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|area
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * find_mergeable_anon_vma is used by anon_vma_prepare, to check&n; * neighbouring vmas for a suitable anon_vma, before it goes off&n; * to allocate a new anon_vma.  It checks because a repetitive&n; * sequence of mprotects and faults may otherwise lead to distinct&n; * anon_vmas being allocated, preventing vma merge in subsequent&n; * mprotect.&n; */
DECL|function|find_mergeable_anon_vma
r_struct
id|anon_vma
op_star
id|find_mergeable_anon_vma
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|near
suffix:semicolon
r_int
r_int
id|vm_flags
suffix:semicolon
id|near
op_assign
id|vma-&gt;vm_next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|near
)paren
r_goto
id|try_prev
suffix:semicolon
multiline_comment|/*&n;&t; * Since only mprotect tries to remerge vmas, match flags&n;&t; * which might be mprotected into each other later on.&n;&t; * Neither mlock nor madvise tries to remerge at present,&n;&t; * so leave their flags as obstructing a merge.&n;&t; */
id|vm_flags
op_assign
id|vma-&gt;vm_flags
op_amp
op_complement
(paren
id|VM_READ
op_or
id|VM_WRITE
op_or
id|VM_EXEC
)paren
suffix:semicolon
id|vm_flags
op_or_assign
id|near-&gt;vm_flags
op_amp
(paren
id|VM_READ
op_or
id|VM_WRITE
op_or
id|VM_EXEC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|near-&gt;anon_vma
op_logical_and
id|vma-&gt;vm_end
op_eq
id|near-&gt;vm_start
op_logical_and
id|mpol_equal
c_func
(paren
id|vma_policy
c_func
(paren
id|vma
)paren
comma
id|vma_policy
c_func
(paren
id|near
)paren
)paren
op_logical_and
id|can_vma_merge_before
c_func
(paren
id|near
comma
id|vm_flags
comma
l_int|NULL
comma
id|vma-&gt;vm_file
comma
id|vma-&gt;vm_pgoff
op_plus
(paren
(paren
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
)paren
)paren
)paren
r_return
id|near-&gt;anon_vma
suffix:semicolon
id|try_prev
suffix:colon
multiline_comment|/*&n;&t; * It is potentially slow to have to call find_vma_prev here.&n;&t; * But it&squot;s only on the first write fault on the vma, not&n;&t; * every time, and we could devise a way to avoid it later&n;&t; * (e.g. stash info in next&squot;s anon_vma_node when assigning&n;&t; * an anon_vma, or when trying vma_merge).  Another time.&n;&t; */
r_if
c_cond
(paren
id|find_vma_prev
c_func
(paren
id|vma-&gt;vm_mm
comma
id|vma-&gt;vm_start
comma
op_amp
id|near
)paren
op_ne
id|vma
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|near
)paren
r_goto
id|none
suffix:semicolon
id|vm_flags
op_assign
id|vma-&gt;vm_flags
op_amp
op_complement
(paren
id|VM_READ
op_or
id|VM_WRITE
op_or
id|VM_EXEC
)paren
suffix:semicolon
id|vm_flags
op_or_assign
id|near-&gt;vm_flags
op_amp
(paren
id|VM_READ
op_or
id|VM_WRITE
op_or
id|VM_EXEC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|near-&gt;anon_vma
op_logical_and
id|near-&gt;vm_end
op_eq
id|vma-&gt;vm_start
op_logical_and
id|mpol_equal
c_func
(paren
id|vma_policy
c_func
(paren
id|near
)paren
comma
id|vma_policy
c_func
(paren
id|vma
)paren
)paren
op_logical_and
id|can_vma_merge_after
c_func
(paren
id|near
comma
id|vm_flags
comma
l_int|NULL
comma
id|vma-&gt;vm_file
comma
id|vma-&gt;vm_pgoff
)paren
)paren
r_return
id|near-&gt;anon_vma
suffix:semicolon
id|none
suffix:colon
multiline_comment|/*&n;&t; * There&squot;s no absolute need to look only at touching neighbours:&n;&t; * we could search further afield for &quot;compatible&quot; anon_vmas.&n;&t; * But it would probably just be a waste of time searching,&n;&t; * or lead to too many vmas hanging off the same anon_vma.&n;&t; * We&squot;re trying to allow mprotect remerging later on,&n;&t; * not trying to minimize memory used for anon_vmas.&n;&t; */
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|__vm_stat_account
r_void
id|__vm_stat_account
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|flags
comma
r_struct
id|file
op_star
id|file
comma
r_int
id|pages
)paren
(brace
r_const
r_int
r_int
id|stack_flags
op_assign
id|VM_STACK_FLAGS
op_amp
(paren
id|VM_GROWSUP
op_or
id|VM_GROWSDOWN
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_HUGETLB
r_if
c_cond
(paren
id|flags
op_amp
id|VM_HUGETLB
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|VM_DONTCOPY
)paren
)paren
id|mm-&gt;shared_vm
op_add_assign
id|pages
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_HUGETLB */
r_if
c_cond
(paren
id|file
)paren
(brace
id|mm-&gt;shared_vm
op_add_assign
id|pages
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
(paren
id|VM_EXEC
op_or
id|VM_WRITE
)paren
)paren
op_eq
id|VM_EXEC
)paren
id|mm-&gt;exec_vm
op_add_assign
id|pages
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|stack_flags
)paren
id|mm-&gt;stack_vm
op_add_assign
id|pages
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
(paren
id|VM_RESERVED
op_or
id|VM_IO
)paren
)paren
id|mm-&gt;reserved_vm
op_add_assign
id|pages
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PROC_FS */
multiline_comment|/*&n; * The caller must hold down_write(current-&gt;mm-&gt;mmap_sem).&n; */
DECL|function|do_mmap_pgoff
r_int
r_int
id|do_mmap_pgoff
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|prot
comma
r_int
r_int
id|flags
comma
r_int
r_int
id|pgoff
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
comma
op_star
id|prev
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
r_int
id|vm_flags
suffix:semicolon
r_int
id|correct_wcount
op_assign
l_int|0
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|rb_node
op_star
op_star
id|rb_link
comma
op_star
id|rb_parent
suffix:semicolon
r_int
id|accountable
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|charged
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
r_if
c_cond
(paren
id|is_file_hugepages
c_func
(paren
id|file
)paren
)paren
id|accountable
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;f_op
op_logical_or
op_logical_neg
id|file-&gt;f_op-&gt;mmap
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
(paren
id|prot
op_amp
id|PROT_EXEC
)paren
op_logical_and
(paren
id|file-&gt;f_vfsmnt-&gt;mnt_flags
op_amp
id|MNT_NOEXEC
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Does the application expect PROT_READ to imply PROT_EXEC?&n;&t; *&n;&t; * (the exception is when the underlying filesystem is noexec&n;&t; *  mounted, in which case we dont add PROT_EXEC.)&n;&t; */
r_if
c_cond
(paren
(paren
id|prot
op_amp
id|PROT_READ
)paren
op_logical_and
(paren
id|current-&gt;personality
op_amp
id|READ_IMPLIES_EXEC
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|file
op_logical_and
(paren
id|file-&gt;f_vfsmnt-&gt;mnt_flags
op_amp
id|MNT_NOEXEC
)paren
)paren
)paren
id|prot
op_or_assign
id|PROT_EXEC
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_return
id|addr
suffix:semicolon
multiline_comment|/* Careful about overflows.. */
id|len
op_assign
id|PAGE_ALIGN
c_func
(paren
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_or
id|len
OG
id|TASK_SIZE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* offset overflow? */
r_if
c_cond
(paren
(paren
id|pgoff
op_plus
(paren
id|len
op_rshift
id|PAGE_SHIFT
)paren
)paren
OL
id|pgoff
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Too many mappings? */
r_if
c_cond
(paren
id|mm-&gt;map_count
OG
id|sysctl_max_map_count
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Obtain the address to map to. we verify (or select) it and ensure&n;&t; * that it represents a valid section of the address space.&n;&t; */
id|addr
op_assign
id|get_unmapped_area
c_func
(paren
id|file
comma
id|addr
comma
id|len
comma
id|pgoff
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_amp
op_complement
id|PAGE_MASK
)paren
r_return
id|addr
suffix:semicolon
multiline_comment|/* Do simple checking here so the lower-level routines won&squot;t have&n;&t; * to. we assume access permissions have been handled by the open&n;&t; * of the memory object, so we don&squot;t do any here.&n;&t; */
id|vm_flags
op_assign
id|calc_vm_prot_bits
c_func
(paren
id|prot
)paren
op_or
id|calc_vm_flag_bits
c_func
(paren
id|flags
)paren
op_or
id|mm-&gt;def_flags
op_or
id|VM_MAYREAD
op_or
id|VM_MAYWRITE
op_or
id|VM_MAYEXEC
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|MAP_LOCKED
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|can_do_mlock
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|vm_flags
op_or_assign
id|VM_LOCKED
suffix:semicolon
)brace
multiline_comment|/* mlock MCL_FUTURE? */
r_if
c_cond
(paren
id|vm_flags
op_amp
id|VM_LOCKED
)paren
(brace
r_int
r_int
id|locked
comma
id|lock_limit
suffix:semicolon
id|locked
op_assign
id|mm-&gt;locked_vm
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|lock_limit
op_assign
id|current-&gt;signal-&gt;rlim
(braket
id|RLIMIT_MEMLOCK
)braket
dot
id|rlim_cur
suffix:semicolon
id|locked
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|locked
OG
id|lock_limit
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_IPC_LOCK
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|inode
op_assign
id|file
ques
c_cond
id|file-&gt;f_dentry-&gt;d_inode
suffix:colon
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
r_switch
c_cond
(paren
id|flags
op_amp
id|MAP_TYPE
)paren
(brace
r_case
id|MAP_SHARED
suffix:colon
r_if
c_cond
(paren
(paren
id|prot
op_amp
id|PROT_WRITE
)paren
op_logical_and
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Make sure we don&squot;t allow writing to an append-only&n;&t;&t;&t; * file..&n;&t;&t;&t; */
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Make sure there are no mandatory locks on the file.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|locks_verify_locked
c_func
(paren
id|inode
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|vm_flags
op_or_assign
id|VM_SHARED
op_or
id|VM_MAYSHARE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
id|vm_flags
op_and_assign
op_complement
(paren
id|VM_MAYWRITE
op_or
id|VM_SHARED
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|MAP_PRIVATE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_else
(brace
r_switch
c_cond
(paren
id|flags
op_amp
id|MAP_TYPE
)paren
(brace
r_case
id|MAP_SHARED
suffix:colon
id|vm_flags
op_or_assign
id|VM_SHARED
op_or
id|VM_MAYSHARE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MAP_PRIVATE
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Set pgoff according to addr for anon_vma.&n;&t;&t;&t; */
id|pgoff
op_assign
id|addr
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
id|error
op_assign
id|security_file_mmap
c_func
(paren
id|file
comma
id|prot
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* Clear old maps */
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|munmap_back
suffix:colon
id|vma
op_assign
id|find_vma_prepare
c_func
(paren
id|mm
comma
id|addr
comma
op_amp
id|prev
comma
op_amp
id|rb_link
comma
op_amp
id|rb_parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma
op_logical_and
id|vma-&gt;vm_start
OL
id|addr
op_plus
id|len
)paren
(brace
r_if
c_cond
(paren
id|do_munmap
c_func
(paren
id|mm
comma
id|addr
comma
id|len
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|munmap_back
suffix:semicolon
)brace
multiline_comment|/* Check against address space limit. */
r_if
c_cond
(paren
(paren
id|mm-&gt;total_vm
op_lshift
id|PAGE_SHIFT
)paren
op_plus
id|len
OG
id|current-&gt;signal-&gt;rlim
(braket
id|RLIMIT_AS
)braket
dot
id|rlim_cur
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|accountable
op_logical_and
(paren
op_logical_neg
(paren
id|flags
op_amp
id|MAP_NORESERVE
)paren
op_logical_or
id|sysctl_overcommit_memory
op_eq
id|OVERCOMMIT_NEVER
)paren
)paren
(brace
r_if
c_cond
(paren
id|vm_flags
op_amp
id|VM_SHARED
)paren
(brace
multiline_comment|/* Check memory availability in shmem_file_setup? */
id|vm_flags
op_or_assign
id|VM_ACCOUNT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vm_flags
op_amp
id|VM_WRITE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Private writable mapping: check memory availability&n;&t;&t;&t; */
id|charged
op_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|security_vm_enough_memory
c_func
(paren
id|charged
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|vm_flags
op_or_assign
id|VM_ACCOUNT
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Can we just expand an old private anonymous mapping?&n;&t; * The VM_SHARED test is necessary because shmem_zero_setup&n;&t; * will create the file object for a shared anonymous map below.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|file
op_logical_and
op_logical_neg
(paren
id|vm_flags
op_amp
id|VM_SHARED
)paren
op_logical_and
id|vma_merge
c_func
(paren
id|mm
comma
id|prev
comma
id|addr
comma
id|addr
op_plus
id|len
comma
id|vm_flags
comma
l_int|NULL
comma
l_int|NULL
comma
id|pgoff
comma
l_int|NULL
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Determine the object being mapped and call the appropriate&n;&t; * specific mapper. the address has already been validated, but&n;&t; * not unmapped, but the maps are removed from the list.&n;&t; */
id|vma
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|unacct_error
suffix:semicolon
)brace
id|memset
c_func
(paren
id|vma
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|vma
)paren
)paren
suffix:semicolon
id|vma-&gt;vm_mm
op_assign
id|mm
suffix:semicolon
id|vma-&gt;vm_start
op_assign
id|addr
suffix:semicolon
id|vma-&gt;vm_end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
id|vma-&gt;vm_flags
op_assign
id|vm_flags
suffix:semicolon
id|vma-&gt;vm_page_prot
op_assign
id|protection_map
(braket
id|vm_flags
op_amp
l_int|0x0f
)braket
suffix:semicolon
id|vma-&gt;vm_pgoff
op_assign
id|pgoff
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|vm_flags
op_amp
(paren
id|VM_GROWSDOWN
op_or
id|VM_GROWSUP
)paren
)paren
r_goto
id|free_vma
suffix:semicolon
r_if
c_cond
(paren
id|vm_flags
op_amp
id|VM_DENYWRITE
)paren
(brace
id|error
op_assign
id|deny_write_access
c_func
(paren
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|free_vma
suffix:semicolon
id|correct_wcount
op_assign
l_int|1
suffix:semicolon
)brace
id|vma-&gt;vm_file
op_assign
id|file
suffix:semicolon
id|get_file
c_func
(paren
id|file
)paren
suffix:semicolon
id|error
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|mmap
c_func
(paren
id|file
comma
id|vma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|unmap_and_free_vma
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vm_flags
op_amp
id|VM_SHARED
)paren
(brace
id|error
op_assign
id|shmem_zero_setup
c_func
(paren
id|vma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|free_vma
suffix:semicolon
)brace
multiline_comment|/* We set VM_ACCOUNT in a shared mapping&squot;s vm_flags, to inform&n;&t; * shmem_zero_setup (perhaps called through /dev/zero&squot;s -&gt;mmap)&n;&t; * that memory reservation must be checked; but that reservation&n;&t; * belongs to shared memory object, not to vma: so now clear it.&n;&t; */
r_if
c_cond
(paren
(paren
id|vm_flags
op_amp
(paren
id|VM_SHARED
op_or
id|VM_ACCOUNT
)paren
)paren
op_eq
(paren
id|VM_SHARED
op_or
id|VM_ACCOUNT
)paren
)paren
id|vma-&gt;vm_flags
op_and_assign
op_complement
id|VM_ACCOUNT
suffix:semicolon
multiline_comment|/* Can addr have changed??&n;&t; *&n;&t; * Answer: Yes, several device drivers can do it in their&n;&t; *         f_op-&gt;mmap method. -DaveM&n;&t; */
id|addr
op_assign
id|vma-&gt;vm_start
suffix:semicolon
id|pgoff
op_assign
id|vma-&gt;vm_pgoff
suffix:semicolon
id|vm_flags
op_assign
id|vma-&gt;vm_flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
op_logical_or
op_logical_neg
id|vma_merge
c_func
(paren
id|mm
comma
id|prev
comma
id|addr
comma
id|vma-&gt;vm_end
comma
id|vma-&gt;vm_flags
comma
l_int|NULL
comma
id|file
comma
id|pgoff
comma
id|vma_policy
c_func
(paren
id|vma
)paren
)paren
)paren
(brace
id|file
op_assign
id|vma-&gt;vm_file
suffix:semicolon
id|vma_link
c_func
(paren
id|mm
comma
id|vma
comma
id|prev
comma
id|rb_link
comma
id|rb_parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|correct_wcount
)paren
id|atomic_inc
c_func
(paren
op_amp
id|inode-&gt;i_writecount
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|file
)paren
(brace
r_if
c_cond
(paren
id|correct_wcount
)paren
id|atomic_inc
c_func
(paren
op_amp
id|inode-&gt;i_writecount
)paren
suffix:semicolon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
)brace
id|mpol_free
c_func
(paren
id|vma_policy
c_func
(paren
id|vma
)paren
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|vma
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|mm-&gt;total_vm
op_add_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|__vm_stat_account
c_func
(paren
id|mm
comma
id|vm_flags
comma
id|file
comma
id|len
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vm_flags
op_amp
id|VM_LOCKED
)paren
(brace
id|mm-&gt;locked_vm
op_add_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|make_pages_present
c_func
(paren
id|addr
comma
id|addr
op_plus
id|len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|MAP_POPULATE
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|sys_remap_file_pages
c_func
(paren
id|addr
comma
id|len
comma
l_int|0
comma
id|pgoff
comma
id|flags
op_amp
id|MAP_NONBLOCK
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
)brace
r_return
id|addr
suffix:semicolon
id|unmap_and_free_vma
suffix:colon
r_if
c_cond
(paren
id|correct_wcount
)paren
id|atomic_inc
c_func
(paren
op_amp
id|inode-&gt;i_writecount
)paren
suffix:semicolon
id|vma-&gt;vm_file
op_assign
l_int|NULL
suffix:semicolon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
multiline_comment|/* Undo any partial mapping done by a device driver. */
id|zap_page_range
c_func
(paren
id|vma
comma
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
comma
l_int|NULL
)paren
suffix:semicolon
id|free_vma
suffix:colon
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|vma
)paren
suffix:semicolon
id|unacct_error
suffix:colon
r_if
c_cond
(paren
id|charged
)paren
id|vm_unacct_memory
c_func
(paren
id|charged
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|variable|do_mmap_pgoff
id|EXPORT_SYMBOL
c_func
(paren
id|do_mmap_pgoff
)paren
suffix:semicolon
multiline_comment|/* Get an address range which is currently unmapped.&n; * For shmat() with addr=0.&n; *&n; * Ugly calling convention alert:&n; * Return value with the low bits set means error value,&n; * ie&n; *&t;if (ret &amp; ~PAGE_MASK)&n; *&t;&t;error = ret;&n; *&n; * This function &quot;knows&quot; that -ENOMEM has the bits set.&n; */
macro_line|#ifndef HAVE_ARCH_UNMAPPED_AREA
r_int
r_int
DECL|function|arch_get_unmapped_area
id|arch_get_unmapped_area
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|pgoff
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
r_int
id|start_addr
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|TASK_SIZE
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|addr
)paren
(brace
id|addr
op_assign
id|PAGE_ALIGN
c_func
(paren
id|addr
)paren
suffix:semicolon
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TASK_SIZE
op_minus
id|len
op_ge
id|addr
op_logical_and
(paren
op_logical_neg
id|vma
op_logical_or
id|addr
op_plus
id|len
op_le
id|vma-&gt;vm_start
)paren
)paren
r_return
id|addr
suffix:semicolon
)brace
id|start_addr
op_assign
id|addr
op_assign
id|mm-&gt;free_area_cache
suffix:semicolon
id|full_search
suffix:colon
r_for
c_loop
(paren
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|addr
)paren
suffix:semicolon
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
)paren
(brace
multiline_comment|/* At this point:  (!vma || addr &lt; vma-&gt;vm_end). */
r_if
c_cond
(paren
id|TASK_SIZE
op_minus
id|len
OL
id|addr
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Start a new search - just in case we missed&n;&t;&t;&t; * some holes.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|start_addr
op_ne
id|TASK_UNMAPPED_BASE
)paren
(brace
id|start_addr
op_assign
id|addr
op_assign
id|TASK_UNMAPPED_BASE
suffix:semicolon
r_goto
id|full_search
suffix:semicolon
)brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|vma
op_logical_or
id|addr
op_plus
id|len
op_le
id|vma-&gt;vm_start
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Remember the place where we stopped the search:&n;&t;&t;&t; */
id|mm-&gt;free_area_cache
op_assign
id|addr
op_plus
id|len
suffix:semicolon
r_return
id|addr
suffix:semicolon
)brace
id|addr
op_assign
id|vma-&gt;vm_end
suffix:semicolon
)brace
)brace
macro_line|#endif&t;
DECL|function|arch_unmap_area
r_void
id|arch_unmap_area
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|area
)paren
(brace
multiline_comment|/*&n;&t; * Is this a new hole at the lowest possible address?&n;&t; */
r_if
c_cond
(paren
id|area-&gt;vm_start
op_ge
id|TASK_UNMAPPED_BASE
op_logical_and
id|area-&gt;vm_start
OL
id|area-&gt;vm_mm-&gt;free_area_cache
)paren
id|area-&gt;vm_mm-&gt;free_area_cache
op_assign
id|area-&gt;vm_start
suffix:semicolon
)brace
multiline_comment|/*&n; * This mmap-allocator allocates new areas top-down from below the&n; * stack&squot;s low limit (the base):&n; */
macro_line|#ifndef HAVE_ARCH_UNMAPPED_AREA_TOPDOWN
r_int
r_int
DECL|function|arch_get_unmapped_area_topdown
id|arch_get_unmapped_area_topdown
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_const
r_int
r_int
id|addr0
comma
r_const
r_int
r_int
id|len
comma
r_const
r_int
r_int
id|pgoff
comma
r_const
r_int
r_int
id|flags
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
comma
op_star
id|prev_vma
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
r_int
r_int
id|base
op_assign
id|mm-&gt;mmap_base
comma
id|addr
op_assign
id|addr0
suffix:semicolon
r_int
id|first_time
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* requested length too big for entire address space */
r_if
c_cond
(paren
id|len
OG
id|TASK_SIZE
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* dont allow allocations above current base */
r_if
c_cond
(paren
id|mm-&gt;free_area_cache
OG
id|base
)paren
id|mm-&gt;free_area_cache
op_assign
id|base
suffix:semicolon
multiline_comment|/* requesting a specific address */
r_if
c_cond
(paren
id|addr
)paren
(brace
id|addr
op_assign
id|PAGE_ALIGN
c_func
(paren
id|addr
)paren
suffix:semicolon
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TASK_SIZE
op_minus
id|len
op_ge
id|addr
op_logical_and
(paren
op_logical_neg
id|vma
op_logical_or
id|addr
op_plus
id|len
op_le
id|vma-&gt;vm_start
)paren
)paren
r_return
id|addr
suffix:semicolon
)brace
id|try_again
suffix:colon
multiline_comment|/* make sure it can fit in the remaining address space */
r_if
c_cond
(paren
id|mm-&gt;free_area_cache
OL
id|len
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/* either no address requested or cant fit in requested address hole */
id|addr
op_assign
(paren
id|mm-&gt;free_area_cache
op_minus
id|len
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * Lookup failure means no vma is above this address,&n;&t;&t; * i.e. return with success:&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma
op_assign
id|find_vma_prev
c_func
(paren
id|mm
comma
id|addr
comma
op_amp
id|prev_vma
)paren
)paren
)paren
r_return
id|addr
suffix:semicolon
multiline_comment|/*&n;&t;&t; * new region fits between prev_vma-&gt;vm_end and&n;&t;&t; * vma-&gt;vm_start, use it:&n;&t;&t; */
r_if
c_cond
(paren
id|addr
op_plus
id|len
op_le
id|vma-&gt;vm_start
op_logical_and
(paren
op_logical_neg
id|prev_vma
op_logical_or
(paren
id|addr
op_ge
id|prev_vma-&gt;vm_end
)paren
)paren
)paren
multiline_comment|/* remember the address as a hint for next time */
r_return
(paren
id|mm-&gt;free_area_cache
op_assign
id|addr
)paren
suffix:semicolon
r_else
multiline_comment|/* pull free_area_cache down to the first hole */
r_if
c_cond
(paren
id|mm-&gt;free_area_cache
op_eq
id|vma-&gt;vm_end
)paren
id|mm-&gt;free_area_cache
op_assign
id|vma-&gt;vm_start
suffix:semicolon
multiline_comment|/* try just below the current vma-&gt;vm_start */
id|addr
op_assign
id|vma-&gt;vm_start
op_minus
id|len
suffix:semicolon
)brace
r_while
c_loop
(paren
id|len
op_le
id|vma-&gt;vm_start
)paren
suffix:semicolon
id|fail
suffix:colon
multiline_comment|/*&n;&t; * if hint left us with no space for the requested&n;&t; * mapping then try again:&n;&t; */
r_if
c_cond
(paren
id|first_time
)paren
(brace
id|mm-&gt;free_area_cache
op_assign
id|base
suffix:semicolon
id|first_time
op_assign
l_int|0
suffix:semicolon
r_goto
id|try_again
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * A failed mmap() very likely causes application failure,&n;&t; * so fall back to the bottom-up function here. This scenario&n;&t; * can happen with large stack limits and large mmap()&n;&t; * allocations.&n;&t; */
id|mm-&gt;free_area_cache
op_assign
id|TASK_UNMAPPED_BASE
suffix:semicolon
id|addr
op_assign
id|arch_get_unmapped_area
c_func
(paren
id|filp
comma
id|addr0
comma
id|len
comma
id|pgoff
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Restore the topdown base:&n;&t; */
id|mm-&gt;free_area_cache
op_assign
id|base
suffix:semicolon
r_return
id|addr
suffix:semicolon
)brace
macro_line|#endif
DECL|function|arch_unmap_area_topdown
r_void
id|arch_unmap_area_topdown
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|area
)paren
(brace
multiline_comment|/*&n;&t; * Is this a new hole at the highest possible address?&n;&t; */
r_if
c_cond
(paren
id|area-&gt;vm_end
OG
id|area-&gt;vm_mm-&gt;free_area_cache
)paren
id|area-&gt;vm_mm-&gt;free_area_cache
op_assign
id|area-&gt;vm_end
suffix:semicolon
)brace
r_int
r_int
DECL|function|get_unmapped_area
id|get_unmapped_area
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|pgoff
comma
r_int
r_int
id|flags
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|MAP_FIXED
)paren
(brace
r_int
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|addr
OG
id|TASK_SIZE
op_minus
id|len
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_amp
op_complement
id|PAGE_MASK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|file
op_logical_and
id|is_file_hugepages
c_func
(paren
id|file
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Check if the given range is hugepage aligned, and&n;&t;&t;&t; * can be made suitable for hugepages.&n;&t;&t;&t; */
id|ret
op_assign
id|prepare_hugepage_range
c_func
(paren
id|addr
comma
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Ensure that a normal request is not falling in a&n;&t;&t;&t; * reserved hugepage range.  For some archs like IA-64,&n;&t;&t;&t; * there is a separate region for hugepages.&n;&t;&t;&t; */
id|ret
op_assign
id|is_hugepage_only_range
c_func
(paren
id|addr
comma
id|len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|addr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file
op_logical_and
id|file-&gt;f_op
op_logical_and
id|file-&gt;f_op-&gt;get_unmapped_area
)paren
r_return
id|file-&gt;f_op
op_member_access_from_pointer
id|get_unmapped_area
c_func
(paren
id|file
comma
id|addr
comma
id|len
comma
id|pgoff
comma
id|flags
)paren
suffix:semicolon
r_return
id|current-&gt;mm
op_member_access_from_pointer
id|get_unmapped_area
c_func
(paren
id|file
comma
id|addr
comma
id|len
comma
id|pgoff
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|get_unmapped_area
id|EXPORT_SYMBOL
c_func
(paren
id|get_unmapped_area
)paren
suffix:semicolon
multiline_comment|/* Look up the first VMA which satisfies  addr &lt; vm_end,  NULL if none. */
DECL|function|find_vma
r_struct
id|vm_area_struct
op_star
id|find_vma
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|mm
)paren
(brace
multiline_comment|/* Check the cache first. */
multiline_comment|/* (Cache hit rate is typically around 35%.) */
id|vma
op_assign
id|mm-&gt;mmap_cache
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma
op_logical_and
id|vma-&gt;vm_end
OG
id|addr
op_logical_and
id|vma-&gt;vm_start
op_le
id|addr
)paren
)paren
(brace
r_struct
id|rb_node
op_star
id|rb_node
suffix:semicolon
id|rb_node
op_assign
id|mm-&gt;mm_rb.rb_node
suffix:semicolon
id|vma
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|rb_node
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma_tmp
suffix:semicolon
id|vma_tmp
op_assign
id|rb_entry
c_func
(paren
id|rb_node
comma
r_struct
id|vm_area_struct
comma
id|vm_rb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma_tmp-&gt;vm_end
OG
id|addr
)paren
(brace
id|vma
op_assign
id|vma_tmp
suffix:semicolon
r_if
c_cond
(paren
id|vma_tmp-&gt;vm_start
op_le
id|addr
)paren
r_break
suffix:semicolon
id|rb_node
op_assign
id|rb_node-&gt;rb_left
suffix:semicolon
)brace
r_else
id|rb_node
op_assign
id|rb_node-&gt;rb_right
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vma
)paren
id|mm-&gt;mmap_cache
op_assign
id|vma
suffix:semicolon
)brace
)brace
r_return
id|vma
suffix:semicolon
)brace
DECL|variable|find_vma
id|EXPORT_SYMBOL
c_func
(paren
id|find_vma
)paren
suffix:semicolon
multiline_comment|/* Same as find_vma, but also return a pointer to the previous VMA in *pprev. */
r_struct
id|vm_area_struct
op_star
DECL|function|find_vma_prev
id|find_vma_prev
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
comma
r_struct
id|vm_area_struct
op_star
op_star
id|pprev
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
l_int|NULL
comma
op_star
id|prev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|rb_node
op_star
id|rb_node
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mm
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Guard against addr being lower than the first VMA */
id|vma
op_assign
id|mm-&gt;mmap
suffix:semicolon
multiline_comment|/* Go through the RB tree quickly. */
id|rb_node
op_assign
id|mm-&gt;mm_rb.rb_node
suffix:semicolon
r_while
c_loop
(paren
id|rb_node
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma_tmp
suffix:semicolon
id|vma_tmp
op_assign
id|rb_entry
c_func
(paren
id|rb_node
comma
r_struct
id|vm_area_struct
comma
id|vm_rb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
OL
id|vma_tmp-&gt;vm_end
)paren
(brace
id|rb_node
op_assign
id|rb_node-&gt;rb_left
suffix:semicolon
)brace
r_else
(brace
id|prev
op_assign
id|vma_tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prev-&gt;vm_next
op_logical_or
(paren
id|addr
OL
id|prev-&gt;vm_next-&gt;vm_end
)paren
)paren
r_break
suffix:semicolon
id|rb_node
op_assign
id|rb_node-&gt;rb_right
suffix:semicolon
)brace
)brace
id|out
suffix:colon
op_star
id|pprev
op_assign
id|prev
suffix:semicolon
r_return
id|prev
ques
c_cond
id|prev-&gt;vm_next
suffix:colon
id|vma
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_STACK_GROWSUP
multiline_comment|/*&n; * vma is the first one with address &gt; vma-&gt;vm_end.  Have to extend vma.&n; */
DECL|function|expand_stack
r_int
id|expand_stack
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
)paren
(brace
r_int
r_int
id|grow
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_GROWSUP
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t; * We must make sure the anon_vma is allocated&n;&t; * so that the anon_vma locking is not a noop.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|anon_vma_prepare
c_func
(paren
id|vma
)paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|anon_vma_lock
c_func
(paren
id|vma
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * vma-&gt;vm_start/vm_end cannot change under us because the caller&n;&t; * is required to hold the mmap_sem in read mode.  We need the&n;&t; * anon_vma lock to serialize against concurrent expand_stacks.&n;&t; */
id|address
op_add_assign
l_int|4
op_plus
id|PAGE_SIZE
op_minus
l_int|1
suffix:semicolon
id|address
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|grow
op_assign
(paren
id|address
op_minus
id|vma-&gt;vm_end
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* Overcommit.. */
r_if
c_cond
(paren
id|security_vm_enough_memory
c_func
(paren
id|grow
)paren
)paren
(brace
id|anon_vma_unlock
c_func
(paren
id|vma
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|address
op_minus
id|vma-&gt;vm_start
OG
id|current-&gt;signal-&gt;rlim
(braket
id|RLIMIT_STACK
)braket
dot
id|rlim_cur
op_logical_or
(paren
(paren
id|vma-&gt;vm_mm-&gt;total_vm
op_plus
id|grow
)paren
op_lshift
id|PAGE_SHIFT
)paren
OG
id|current-&gt;signal-&gt;rlim
(braket
id|RLIMIT_AS
)braket
dot
id|rlim_cur
)paren
(brace
id|anon_vma_unlock
c_func
(paren
id|vma
)paren
suffix:semicolon
id|vm_unacct_memory
c_func
(paren
id|grow
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|vma-&gt;vm_end
op_assign
id|address
suffix:semicolon
id|vma-&gt;vm_mm-&gt;total_vm
op_add_assign
id|grow
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_LOCKED
)paren
id|vma-&gt;vm_mm-&gt;locked_vm
op_add_assign
id|grow
suffix:semicolon
id|__vm_stat_account
c_func
(paren
id|vma-&gt;vm_mm
comma
id|vma-&gt;vm_flags
comma
id|vma-&gt;vm_file
comma
id|grow
)paren
suffix:semicolon
id|anon_vma_unlock
c_func
(paren
id|vma
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_struct
id|vm_area_struct
op_star
DECL|function|find_extend_vma
id|find_extend_vma
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
comma
op_star
id|prev
suffix:semicolon
id|addr
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|vma
op_assign
id|find_vma_prev
c_func
(paren
id|mm
comma
id|addr
comma
op_amp
id|prev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma
op_logical_and
(paren
id|vma-&gt;vm_start
op_le
id|addr
)paren
)paren
r_return
id|vma
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prev
op_logical_or
id|expand_stack
c_func
(paren
id|prev
comma
id|addr
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|prev-&gt;vm_flags
op_amp
id|VM_LOCKED
)paren
(brace
id|make_pages_present
c_func
(paren
id|addr
comma
id|prev-&gt;vm_end
)paren
suffix:semicolon
)brace
r_return
id|prev
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/*&n; * vma is the first one with address &lt; vma-&gt;vm_start.  Have to extend vma.&n; */
DECL|function|expand_stack
r_int
id|expand_stack
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
)paren
(brace
r_int
r_int
id|grow
suffix:semicolon
multiline_comment|/*&n;&t; * We must make sure the anon_vma is allocated&n;&t; * so that the anon_vma locking is not a noop.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|anon_vma_prepare
c_func
(paren
id|vma
)paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|anon_vma_lock
c_func
(paren
id|vma
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * vma-&gt;vm_start/vm_end cannot change under us because the caller&n;&t; * is required to hold the mmap_sem in read mode.  We need the&n;&t; * anon_vma lock to serialize against concurrent expand_stacks.&n;&t; */
id|address
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|grow
op_assign
(paren
id|vma-&gt;vm_start
op_minus
id|address
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* Overcommit.. */
r_if
c_cond
(paren
id|security_vm_enough_memory
c_func
(paren
id|grow
)paren
)paren
(brace
id|anon_vma_unlock
c_func
(paren
id|vma
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vma-&gt;vm_end
op_minus
id|address
OG
id|current-&gt;signal-&gt;rlim
(braket
id|RLIMIT_STACK
)braket
dot
id|rlim_cur
op_logical_or
(paren
(paren
id|vma-&gt;vm_mm-&gt;total_vm
op_plus
id|grow
)paren
op_lshift
id|PAGE_SHIFT
)paren
OG
id|current-&gt;signal-&gt;rlim
(braket
id|RLIMIT_AS
)braket
dot
id|rlim_cur
)paren
(brace
id|anon_vma_unlock
c_func
(paren
id|vma
)paren
suffix:semicolon
id|vm_unacct_memory
c_func
(paren
id|grow
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|vma-&gt;vm_start
op_assign
id|address
suffix:semicolon
id|vma-&gt;vm_pgoff
op_sub_assign
id|grow
suffix:semicolon
id|vma-&gt;vm_mm-&gt;total_vm
op_add_assign
id|grow
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_LOCKED
)paren
id|vma-&gt;vm_mm-&gt;locked_vm
op_add_assign
id|grow
suffix:semicolon
id|__vm_stat_account
c_func
(paren
id|vma-&gt;vm_mm
comma
id|vma-&gt;vm_flags
comma
id|vma-&gt;vm_file
comma
id|grow
)paren
suffix:semicolon
id|anon_vma_unlock
c_func
(paren
id|vma
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_struct
id|vm_area_struct
op_star
DECL|function|find_extend_vma
id|find_extend_vma
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
r_int
id|start
suffix:semicolon
id|addr
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_start
op_le
id|addr
)paren
r_return
id|vma
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_GROWSDOWN
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|start
op_assign
id|vma-&gt;vm_start
suffix:semicolon
r_if
c_cond
(paren
id|expand_stack
c_func
(paren
id|vma
comma
id|addr
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_LOCKED
)paren
(brace
id|make_pages_present
c_func
(paren
id|addr
comma
id|start
)paren
suffix:semicolon
)brace
r_return
id|vma
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Try to free as many page directory entries as we can,&n; * without having to work very hard at actually scanning&n; * the page tables themselves.&n; *&n; * Right now we try to free page tables if we have a nice&n; * PGDIR-aligned area that got free&squot;d up. We could be more&n; * granular if we want to, but this is fast and simple,&n; * and covers the bad cases.&n; *&n; * &quot;prev&quot;, if it exists, points to a vma before the one&n; * we just free&squot;d - but there&squot;s no telling how much before.&n; */
DECL|function|free_pgtables
r_static
r_void
id|free_pgtables
c_func
(paren
r_struct
id|mmu_gather
op_star
id|tlb
comma
r_struct
id|vm_area_struct
op_star
id|prev
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_int
r_int
id|first
op_assign
id|start
op_amp
id|PGDIR_MASK
suffix:semicolon
r_int
r_int
id|last
op_assign
id|end
op_plus
id|PGDIR_SIZE
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|start_index
comma
id|end_index
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|tlb-&gt;mm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prev
)paren
(brace
id|prev
op_assign
id|mm-&gt;mmap
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prev
)paren
r_goto
id|no_mmaps
suffix:semicolon
r_if
c_cond
(paren
id|prev-&gt;vm_end
OG
id|start
)paren
(brace
r_if
c_cond
(paren
id|last
OG
id|prev-&gt;vm_start
)paren
id|last
op_assign
id|prev-&gt;vm_start
suffix:semicolon
r_goto
id|no_mmaps
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|next
op_assign
id|prev-&gt;vm_next
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
(brace
r_if
c_cond
(paren
id|next-&gt;vm_start
OL
id|start
)paren
(brace
id|prev
op_assign
id|next
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|last
OG
id|next-&gt;vm_start
)paren
id|last
op_assign
id|next-&gt;vm_start
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prev-&gt;vm_end
OG
id|first
)paren
id|first
op_assign
id|prev-&gt;vm_end
op_plus
id|PGDIR_SIZE
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|no_mmaps
suffix:colon
r_if
c_cond
(paren
id|last
OL
id|first
)paren
multiline_comment|/* for arches with discontiguous pgd indices */
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If the PGD bits are not consecutive in the virtual address, the&n;&t; * old method of shifting the VA &gt;&gt; by PGDIR_SHIFT doesn&squot;t work.&n;&t; */
id|start_index
op_assign
id|pgd_index
c_func
(paren
id|first
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start_index
OL
id|FIRST_USER_PGD_NR
)paren
id|start_index
op_assign
id|FIRST_USER_PGD_NR
suffix:semicolon
id|end_index
op_assign
id|pgd_index
c_func
(paren
id|last
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end_index
OG
id|start_index
)paren
(brace
id|clear_page_tables
c_func
(paren
id|tlb
comma
id|start_index
comma
id|end_index
op_minus
id|start_index
)paren
suffix:semicolon
id|flush_tlb_pgtables
c_func
(paren
id|mm
comma
id|first
op_amp
id|PGDIR_MASK
comma
id|last
op_amp
id|PGDIR_MASK
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Normal function to fix up a mapping&n; * This function is the default for when an area has no specific&n; * function.  This may be used as part of a more specific routine.&n; *&n; * By the time this function is called, the area struct has been&n; * removed from the process mapping list.&n; */
DECL|function|unmap_vma
r_static
r_void
id|unmap_vma
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|area
)paren
(brace
r_int
id|len
op_assign
id|area-&gt;vm_end
op_minus
id|area-&gt;vm_start
suffix:semicolon
id|area-&gt;vm_mm-&gt;total_vm
op_sub_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|area-&gt;vm_flags
op_amp
id|VM_LOCKED
)paren
id|area-&gt;vm_mm-&gt;locked_vm
op_sub_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|vm_stat_unaccount
c_func
(paren
id|area
)paren
suffix:semicolon
id|area-&gt;vm_mm
op_member_access_from_pointer
id|unmap_area
c_func
(paren
id|area
)paren
suffix:semicolon
id|remove_vm_struct
c_func
(paren
id|area
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Update the VMA and inode share lists.&n; *&n; * Ok - we have the memory areas we should free on the &squot;free&squot; list,&n; * so release them, and do the vma updates.&n; */
DECL|function|unmap_vma_list
r_static
r_void
id|unmap_vma_list
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|mpnt
)paren
(brace
r_do
(brace
r_struct
id|vm_area_struct
op_star
id|next
op_assign
id|mpnt-&gt;vm_next
suffix:semicolon
id|unmap_vma
c_func
(paren
id|mm
comma
id|mpnt
)paren
suffix:semicolon
id|mpnt
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mpnt
op_ne
l_int|NULL
)paren
suffix:semicolon
id|validate_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get rid of page table information in the indicated region.&n; *&n; * Called with the page table lock held.&n; */
DECL|function|unmap_region
r_static
r_void
id|unmap_region
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|vm_area_struct
op_star
id|prev
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_struct
id|mmu_gather
op_star
id|tlb
suffix:semicolon
r_int
r_int
id|nr_accounted
op_assign
l_int|0
suffix:semicolon
id|lru_add_drain
c_func
(paren
)paren
suffix:semicolon
id|tlb
op_assign
id|tlb_gather_mmu
c_func
(paren
id|mm
comma
l_int|0
)paren
suffix:semicolon
id|unmap_vmas
c_func
(paren
op_amp
id|tlb
comma
id|mm
comma
id|vma
comma
id|start
comma
id|end
comma
op_amp
id|nr_accounted
comma
l_int|NULL
)paren
suffix:semicolon
id|vm_unacct_memory
c_func
(paren
id|nr_accounted
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_hugepage_only_range
c_func
(paren
id|start
comma
id|end
op_minus
id|start
)paren
)paren
id|hugetlb_free_pgtables
c_func
(paren
id|tlb
comma
id|prev
comma
id|start
comma
id|end
)paren
suffix:semicolon
r_else
id|free_pgtables
c_func
(paren
id|tlb
comma
id|prev
comma
id|start
comma
id|end
)paren
suffix:semicolon
id|tlb_finish_mmu
c_func
(paren
id|tlb
comma
id|start
comma
id|end
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a list of vma&squot;s touched by the unmap, removing them from the mm&squot;s&n; * vma list as we go..&n; */
r_static
r_void
DECL|function|detach_vmas_to_be_unmapped
id|detach_vmas_to_be_unmapped
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|vm_area_struct
op_star
id|prev
comma
r_int
r_int
id|end
)paren
(brace
r_struct
id|vm_area_struct
op_star
op_star
id|insertion_point
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|tail_vma
op_assign
l_int|NULL
suffix:semicolon
id|insertion_point
op_assign
(paren
id|prev
ques
c_cond
op_amp
id|prev-&gt;vm_next
suffix:colon
op_amp
id|mm-&gt;mmap
)paren
suffix:semicolon
r_do
(brace
id|rb_erase
c_func
(paren
op_amp
id|vma-&gt;vm_rb
comma
op_amp
id|mm-&gt;mm_rb
)paren
suffix:semicolon
id|mm-&gt;map_count
op_decrement
suffix:semicolon
id|tail_vma
op_assign
id|vma
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|vma
op_logical_and
id|vma-&gt;vm_start
OL
id|end
)paren
suffix:semicolon
op_star
id|insertion_point
op_assign
id|vma
suffix:semicolon
id|tail_vma-&gt;vm_next
op_assign
l_int|NULL
suffix:semicolon
id|mm-&gt;mmap_cache
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Kill the cache. */
)brace
multiline_comment|/*&n; * Split a vma into two pieces at address &squot;addr&squot;, a new vma is allocated&n; * either for the first part or the the tail.&n; */
DECL|function|split_vma
r_int
id|split_vma
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|addr
comma
r_int
id|new_below
)paren
(brace
r_struct
id|mempolicy
op_star
id|pol
suffix:semicolon
r_struct
id|vm_area_struct
op_star
r_new
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;map_count
op_ge
id|sysctl_max_map_count
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_new
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* most fields are the same, copy all, and then fixup */
op_star
r_new
op_assign
op_star
id|vma
suffix:semicolon
r_if
c_cond
(paren
id|new_below
)paren
r_new
op_member_access_from_pointer
id|vm_end
op_assign
id|addr
suffix:semicolon
r_else
(brace
r_new
op_member_access_from_pointer
id|vm_start
op_assign
id|addr
suffix:semicolon
r_new
op_member_access_from_pointer
id|vm_pgoff
op_add_assign
(paren
(paren
id|addr
op_minus
id|vma-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
)brace
id|pol
op_assign
id|mpol_copy
c_func
(paren
id|vma_policy
c_func
(paren
id|vma
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|pol
)paren
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
r_new
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|pol
)paren
suffix:semicolon
)brace
id|vma_set_policy
c_func
(paren
r_new
comma
id|pol
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|vm_file
)paren
id|get_file
c_func
(paren
r_new
op_member_access_from_pointer
id|vm_file
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|vm_ops
op_logical_and
r_new
op_member_access_from_pointer
id|vm_ops-&gt;open
)paren
r_new
op_member_access_from_pointer
id|vm_ops
op_member_access_from_pointer
id|open
c_func
(paren
r_new
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_below
)paren
id|vma_adjust
c_func
(paren
id|vma
comma
id|addr
comma
id|vma-&gt;vm_end
comma
id|vma-&gt;vm_pgoff
op_plus
(paren
(paren
id|addr
op_minus
r_new
op_member_access_from_pointer
id|vm_start
)paren
op_rshift
id|PAGE_SHIFT
)paren
comma
r_new
)paren
suffix:semicolon
r_else
id|vma_adjust
c_func
(paren
id|vma
comma
id|vma-&gt;vm_start
comma
id|addr
comma
id|vma-&gt;vm_pgoff
comma
r_new
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Munmap is split into 2 main parts -- this part which finds&n; * what needs doing, and the areas themselves, which do the&n; * work.  This now handles partial unmappings.&n; * Jeremy Fitzhardinge &lt;jeremy@goop.org&gt;&n; */
DECL|function|do_munmap
r_int
id|do_munmap
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
id|len
)paren
(brace
r_int
r_int
id|end
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|mpnt
comma
op_star
id|prev
comma
op_star
id|last
suffix:semicolon
r_if
c_cond
(paren
(paren
id|start
op_amp
op_complement
id|PAGE_MASK
)paren
op_logical_or
id|start
OG
id|TASK_SIZE
op_logical_or
id|len
OG
id|TASK_SIZE
op_minus
id|start
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|PAGE_ALIGN
c_func
(paren
id|len
)paren
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Find the first overlapping VMA */
id|mpnt
op_assign
id|find_vma_prev
c_func
(paren
id|mm
comma
id|start
comma
op_amp
id|prev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mpnt
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* we have  start &lt; mpnt-&gt;vm_end  */
r_if
c_cond
(paren
id|is_vm_hugetlb_page
c_func
(paren
id|mpnt
)paren
)paren
(brace
r_int
id|ret
op_assign
id|is_aligned_hugepage_range
c_func
(paren
id|start
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* if it doesn&squot;t overlap, we have nothing.. */
id|end
op_assign
id|start
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_start
op_ge
id|end
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If we need to split any vma, do it now to save pain later.&n;&t; *&n;&t; * Note: mremap&squot;s move_vma VM_ACCOUNT handling assumes a partially&n;&t; * unmapped vm_area_struct will remain in use: so lower split_vma&n;&t; * places tmp vma above, and higher split_vma places tmp vma below.&n;&t; */
r_if
c_cond
(paren
id|start
OG
id|mpnt-&gt;vm_start
)paren
(brace
r_if
c_cond
(paren
id|split_vma
c_func
(paren
id|mm
comma
id|mpnt
comma
id|start
comma
l_int|0
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|prev
op_assign
id|mpnt
suffix:semicolon
)brace
multiline_comment|/* Does it split the last one? */
id|last
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last
op_logical_and
id|end
OG
id|last-&gt;vm_start
)paren
(brace
r_if
c_cond
(paren
id|split_vma
c_func
(paren
id|mm
comma
id|last
comma
id|end
comma
l_int|1
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|mpnt
op_assign
id|prev
ques
c_cond
id|prev-&gt;vm_next
suffix:colon
id|mm-&gt;mmap
suffix:semicolon
multiline_comment|/*&n;&t; * Remove the vma&squot;s, and unmap the actual pages&n;&t; */
id|detach_vmas_to_be_unmapped
c_func
(paren
id|mm
comma
id|mpnt
comma
id|prev
comma
id|end
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|unmap_region
c_func
(paren
id|mm
comma
id|mpnt
comma
id|prev
comma
id|start
comma
id|end
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
multiline_comment|/* Fix up all other VM information */
id|unmap_vma_list
c_func
(paren
id|mm
comma
id|mpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|do_munmap
id|EXPORT_SYMBOL
c_func
(paren
id|do_munmap
)paren
suffix:semicolon
DECL|function|sys_munmap
id|asmlinkage
r_int
id|sys_munmap
c_func
(paren
r_int
r_int
id|addr
comma
r_int
id|len
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
id|profile_munmap
c_func
(paren
id|addr
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|ret
op_assign
id|do_munmap
c_func
(paren
id|mm
comma
id|addr
comma
id|len
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *  this is really a simplified &quot;do_mmap&quot;.  it only handles&n; *  anonymous maps.  eventually we may be able to do some&n; *  brk-specific accounting here.&n; */
DECL|function|do_brk
r_int
r_int
id|do_brk
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
comma
op_star
id|prev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|rb_node
op_star
op_star
id|rb_link
comma
op_star
id|rb_parent
suffix:semicolon
id|pgoff_t
id|pgoff
op_assign
id|addr
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|len
op_assign
id|PAGE_ALIGN
c_func
(paren
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_return
id|addr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
op_plus
id|len
)paren
OG
id|TASK_SIZE
op_logical_or
(paren
id|addr
op_plus
id|len
)paren
OL
id|addr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * mlock MCL_FUTURE?&n;&t; */
r_if
c_cond
(paren
id|mm-&gt;def_flags
op_amp
id|VM_LOCKED
)paren
(brace
r_int
r_int
id|locked
comma
id|lock_limit
suffix:semicolon
id|locked
op_assign
id|mm-&gt;locked_vm
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|lock_limit
op_assign
id|current-&gt;signal-&gt;rlim
(braket
id|RLIMIT_MEMLOCK
)braket
dot
id|rlim_cur
suffix:semicolon
id|locked
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|locked
OG
id|lock_limit
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_IPC_LOCK
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clear old maps.  this also does some error checking for us&n;&t; */
id|munmap_back
suffix:colon
id|vma
op_assign
id|find_vma_prepare
c_func
(paren
id|mm
comma
id|addr
comma
op_amp
id|prev
comma
op_amp
id|rb_link
comma
op_amp
id|rb_parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma
op_logical_and
id|vma-&gt;vm_start
OL
id|addr
op_plus
id|len
)paren
(brace
r_if
c_cond
(paren
id|do_munmap
c_func
(paren
id|mm
comma
id|addr
comma
id|len
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|munmap_back
suffix:semicolon
)brace
multiline_comment|/* Check against address space limits *after* clearing old maps... */
r_if
c_cond
(paren
(paren
id|mm-&gt;total_vm
op_lshift
id|PAGE_SHIFT
)paren
op_plus
id|len
OG
id|current-&gt;signal-&gt;rlim
(braket
id|RLIMIT_AS
)braket
dot
id|rlim_cur
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;map_count
OG
id|sysctl_max_map_count
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|security_vm_enough_memory
c_func
(paren
id|len
op_rshift
id|PAGE_SHIFT
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|flags
op_assign
id|VM_DATA_DEFAULT_FLAGS
op_or
id|VM_ACCOUNT
op_or
id|mm-&gt;def_flags
suffix:semicolon
multiline_comment|/* Can we just expand an old private anonymous mapping? */
r_if
c_cond
(paren
id|vma_merge
c_func
(paren
id|mm
comma
id|prev
comma
id|addr
comma
id|addr
op_plus
id|len
comma
id|flags
comma
l_int|NULL
comma
l_int|NULL
comma
id|pgoff
comma
l_int|NULL
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * create a vma struct for an anonymous mapping&n;&t; */
id|vma
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
(brace
id|vm_unacct_memory
c_func
(paren
id|len
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|vma
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|vma
)paren
)paren
suffix:semicolon
id|vma-&gt;vm_mm
op_assign
id|mm
suffix:semicolon
id|vma-&gt;vm_start
op_assign
id|addr
suffix:semicolon
id|vma-&gt;vm_end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
id|vma-&gt;vm_pgoff
op_assign
id|pgoff
suffix:semicolon
id|vma-&gt;vm_flags
op_assign
id|flags
suffix:semicolon
id|vma-&gt;vm_page_prot
op_assign
id|protection_map
(braket
id|flags
op_amp
l_int|0x0f
)braket
suffix:semicolon
id|vma_link
c_func
(paren
id|mm
comma
id|vma
comma
id|prev
comma
id|rb_link
comma
id|rb_parent
)paren
suffix:semicolon
id|out
suffix:colon
id|mm-&gt;total_vm
op_add_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|VM_LOCKED
)paren
(brace
id|mm-&gt;locked_vm
op_add_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|make_pages_present
c_func
(paren
id|addr
comma
id|addr
op_plus
id|len
)paren
suffix:semicolon
)brace
r_return
id|addr
suffix:semicolon
)brace
DECL|variable|do_brk
id|EXPORT_SYMBOL
c_func
(paren
id|do_brk
)paren
suffix:semicolon
multiline_comment|/* Release all mmaps. */
DECL|function|exit_mmap
r_void
id|exit_mmap
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|mmu_gather
op_star
id|tlb
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_int
r_int
id|nr_accounted
op_assign
l_int|0
suffix:semicolon
id|lru_add_drain
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
id|tlb
op_assign
id|tlb_gather_mmu
c_func
(paren
id|mm
comma
l_int|1
)paren
suffix:semicolon
id|flush_cache_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
multiline_comment|/* Use ~0UL here to ensure all VMAs in the mm are unmapped */
id|mm-&gt;map_count
op_sub_assign
id|unmap_vmas
c_func
(paren
op_amp
id|tlb
comma
id|mm
comma
id|mm-&gt;mmap
comma
l_int|0
comma
op_complement
l_int|0UL
comma
op_amp
id|nr_accounted
comma
l_int|NULL
)paren
suffix:semicolon
id|vm_unacct_memory
c_func
(paren
id|nr_accounted
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|mm-&gt;map_count
)paren
suffix:semicolon
multiline_comment|/* This is just debugging */
id|clear_page_tables
c_func
(paren
id|tlb
comma
id|FIRST_USER_PGD_NR
comma
id|USER_PTRS_PER_PGD
)paren
suffix:semicolon
id|tlb_finish_mmu
c_func
(paren
id|tlb
comma
l_int|0
comma
id|MM_VM_SIZE
c_func
(paren
id|mm
)paren
)paren
suffix:semicolon
id|vma
op_assign
id|mm-&gt;mmap
suffix:semicolon
id|mm-&gt;mmap
op_assign
id|mm-&gt;mmap_cache
op_assign
l_int|NULL
suffix:semicolon
id|mm-&gt;mm_rb
op_assign
id|RB_ROOT
suffix:semicolon
id|mm-&gt;rss
op_assign
l_int|0
suffix:semicolon
id|mm-&gt;total_vm
op_assign
l_int|0
suffix:semicolon
id|mm-&gt;locked_vm
op_assign
l_int|0
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Walk the list again, actually closing and freeing it&n;&t; * without holding any MM locks.&n;&t; */
r_while
c_loop
(paren
id|vma
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|next
op_assign
id|vma-&gt;vm_next
suffix:semicolon
id|remove_vm_struct
c_func
(paren
id|vma
)paren
suffix:semicolon
id|vma
op_assign
id|next
suffix:semicolon
)brace
)brace
multiline_comment|/* Insert vm structure into process list sorted by address&n; * and into the inode&squot;s i_mmap tree.  If vm_file is non-NULL&n; * then i_mmap_lock is taken here.&n; */
DECL|function|insert_vm_struct
r_int
id|insert_vm_struct
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|__vma
comma
op_star
id|prev
suffix:semicolon
r_struct
id|rb_node
op_star
op_star
id|rb_link
comma
op_star
id|rb_parent
suffix:semicolon
multiline_comment|/*&n;&t; * The vm_pgoff of a purely anonymous vma should be irrelevant&n;&t; * until its first write fault, when page&squot;s anon_vma and index&n;&t; * are set.  But now set the vm_pgoff it will almost certainly&n;&t; * end up with (unless mremap moves it elsewhere before that&n;&t; * first wfault), so /proc/pid/maps tells a consistent story.&n;&t; *&n;&t; * By setting it to reflect the virtual start address of the&n;&t; * vma, merges and splits can happen in a seamless way, just&n;&t; * using the existing file pgoff checks and manipulations.&n;&t; * Similarly in do_mmap_pgoff and in do_brk.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|vma-&gt;vm_file
)paren
(brace
id|BUG_ON
c_func
(paren
id|vma-&gt;anon_vma
)paren
suffix:semicolon
id|vma-&gt;vm_pgoff
op_assign
id|vma-&gt;vm_start
op_rshift
id|PAGE_SHIFT
suffix:semicolon
)brace
id|__vma
op_assign
id|find_vma_prepare
c_func
(paren
id|mm
comma
id|vma-&gt;vm_start
comma
op_amp
id|prev
comma
op_amp
id|rb_link
comma
op_amp
id|rb_parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__vma
op_logical_and
id|__vma-&gt;vm_start
OL
id|vma-&gt;vm_end
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|vma_link
c_func
(paren
id|mm
comma
id|vma
comma
id|prev
comma
id|rb_link
comma
id|rb_parent
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy the vma structure to a new location in the same mm,&n; * prior to moving page table entries, to effect an mremap move.&n; */
DECL|function|copy_vma
r_struct
id|vm_area_struct
op_star
id|copy_vma
c_func
(paren
r_struct
id|vm_area_struct
op_star
op_star
id|vmap
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
comma
id|pgoff_t
id|pgoff
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
op_star
id|vmap
suffix:semicolon
r_int
r_int
id|vma_start
op_assign
id|vma-&gt;vm_start
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|new_vma
comma
op_star
id|prev
suffix:semicolon
r_struct
id|rb_node
op_star
op_star
id|rb_link
comma
op_star
id|rb_parent
suffix:semicolon
r_struct
id|mempolicy
op_star
id|pol
suffix:semicolon
multiline_comment|/*&n;&t; * If anonymous vma has not yet been faulted, update new pgoff&n;&t; * to match new location, to increase its chance of merging.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|vma-&gt;vm_file
op_logical_and
op_logical_neg
id|vma-&gt;anon_vma
)paren
id|pgoff
op_assign
id|addr
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|find_vma_prepare
c_func
(paren
id|mm
comma
id|addr
comma
op_amp
id|prev
comma
op_amp
id|rb_link
comma
op_amp
id|rb_parent
)paren
suffix:semicolon
id|new_vma
op_assign
id|vma_merge
c_func
(paren
id|mm
comma
id|prev
comma
id|addr
comma
id|addr
op_plus
id|len
comma
id|vma-&gt;vm_flags
comma
id|vma-&gt;anon_vma
comma
id|vma-&gt;vm_file
comma
id|pgoff
comma
id|vma_policy
c_func
(paren
id|vma
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_vma
)paren
(brace
multiline_comment|/*&n;&t;&t; * Source vma may have been merged into new_vma&n;&t;&t; */
r_if
c_cond
(paren
id|vma_start
op_ge
id|new_vma-&gt;vm_start
op_logical_and
id|vma_start
OL
id|new_vma-&gt;vm_end
)paren
op_star
id|vmap
op_assign
id|new_vma
suffix:semicolon
)brace
r_else
(brace
id|new_vma
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_vma
)paren
(brace
op_star
id|new_vma
op_assign
op_star
id|vma
suffix:semicolon
id|pol
op_assign
id|mpol_copy
c_func
(paren
id|vma_policy
c_func
(paren
id|vma
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|pol
)paren
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|vm_area_cachep
comma
id|new_vma
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|vma_set_policy
c_func
(paren
id|new_vma
comma
id|pol
)paren
suffix:semicolon
id|new_vma-&gt;vm_start
op_assign
id|addr
suffix:semicolon
id|new_vma-&gt;vm_end
op_assign
id|addr
op_plus
id|len
suffix:semicolon
id|new_vma-&gt;vm_pgoff
op_assign
id|pgoff
suffix:semicolon
r_if
c_cond
(paren
id|new_vma-&gt;vm_file
)paren
id|get_file
c_func
(paren
id|new_vma-&gt;vm_file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_vma-&gt;vm_ops
op_logical_and
id|new_vma-&gt;vm_ops-&gt;open
)paren
id|new_vma-&gt;vm_ops
op_member_access_from_pointer
id|open
c_func
(paren
id|new_vma
)paren
suffix:semicolon
id|vma_link
c_func
(paren
id|mm
comma
id|new_vma
comma
id|prev
comma
id|rb_link
comma
id|rb_parent
)paren
suffix:semicolon
)brace
)brace
r_return
id|new_vma
suffix:semicolon
)brace
eof
