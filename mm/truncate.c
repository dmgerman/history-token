multiline_comment|/*&n; * mm/truncate.c - code for taking down pages from address_spaces&n; *&n; * Copyright (C) 2002, Linus Torvalds&n; *&n; * 10Sep2002&t;akpm@zip.com.au&n; *&t;&t;Initial version.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/pagevec.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;&t;/* grr. try_to_release_page,&n;&t;&t;&t;&t;   block_invalidatepage */
DECL|function|do_invalidatepage
r_static
r_int
id|do_invalidatepage
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
)paren
(brace
r_int
(paren
op_star
id|invalidatepage
)paren
(paren
r_struct
id|page
op_star
comma
r_int
r_int
)paren
suffix:semicolon
id|invalidatepage
op_assign
id|page-&gt;mapping-&gt;a_ops-&gt;invalidatepage
suffix:semicolon
r_if
c_cond
(paren
id|invalidatepage
op_eq
l_int|NULL
)paren
id|invalidatepage
op_assign
id|block_invalidatepage
suffix:semicolon
r_return
(paren
op_star
id|invalidatepage
)paren
(paren
id|page
comma
id|offset
)paren
suffix:semicolon
)brace
DECL|function|truncate_partial_page
r_static
r_inline
r_void
id|truncate_partial_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|partial
)paren
(brace
id|memclear_highpage_flush
c_func
(paren
id|page
comma
id|partial
comma
id|PAGE_CACHE_SIZE
op_minus
id|partial
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PagePrivate
c_func
(paren
id|page
)paren
)paren
id|do_invalidatepage
c_func
(paren
id|page
comma
id|partial
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * If truncate cannot remove the fs-private metadata from the page, the page&n; * becomes anonymous.  It will be left on the LRU and may even be mapped into&n; * user pagetables if we&squot;re racing with filemap_nopage().&n; *&n; * We need to bale out if page-&gt;mapping is no longer equal to the original&n; * mapping.  This happens a) when the VM reclaimed the page while we waited on&n; * its lock, b) when a concurrent invalidate_inode_pages got there first and&n; * c) when tmpfs swizzles a page between a tmpfs inode and swapper_space.&n; */
r_static
r_void
DECL|function|truncate_complete_page
id|truncate_complete_page
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
id|page-&gt;mapping
op_ne
id|mapping
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|PagePrivate
c_func
(paren
id|page
)paren
)paren
id|do_invalidatepage
c_func
(paren
id|page
comma
l_int|0
)paren
suffix:semicolon
id|clear_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|ClearPageMappedToDisk
c_func
(paren
id|page
)paren
suffix:semicolon
id|remove_from_page_cache
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* pagecache ref */
)brace
multiline_comment|/*&n; * This is for invalidate_inode_pages().  That function can be called at&n; * any time, and is not supposed to throw away dirty pages.  But pages can&n; * be marked dirty at any time too.  So we re-check the dirtiness inside&n; * -&gt;tree_lock.  That provides exclusion against the __set_page_dirty&n; * functions.&n; *&n; * Returns non-zero if the page was successfully invalidated.&n; */
r_static
r_int
DECL|function|invalidate_complete_page
id|invalidate_complete_page
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
id|page-&gt;mapping
op_ne
id|mapping
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|PagePrivate
c_func
(paren
id|page
)paren
op_logical_and
op_logical_neg
id|try_to_release_page
c_func
(paren
id|page
comma
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageDirty
c_func
(paren
id|page
)paren
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
id|PagePrivate
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|__remove_from_page_cache
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* pagecache ref */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * truncate_inode_pages - truncate *all* the pages from an offset&n; * @mapping: mapping to truncate&n; * @lstart: offset from which to truncate&n; *&n; * Truncate the page cache at a set offset, removing the pages that are beyond&n; * that offset (and zeroing out partial pages).&n; *&n; * Truncate takes two passes - the first pass is nonblocking.  It will not&n; * block on page locks and it will not block on writeback.  The second pass&n; * will wait.  This is to prevent as much IO as possible in the affected region.&n; * The first pass will remove most pages, so the search cost of the second pass&n; * is low.&n; *&n; * When looking at page-&gt;index outside the page lock we need to be careful to&n; * copy it into a local to avoid races (it could change at any time).&n; *&n; * We pass down the cache-hot hint to the page freeing code.  Even if the&n; * mapping is large, it is probably the case that the final pages are the most&n; * recently touched, and freeing happens in ascending file offset order.&n; *&n; * Called under (and serialised by) inode-&gt;i_sem.&n; */
DECL|function|truncate_inode_pages
r_void
id|truncate_inode_pages
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
id|loff_t
id|lstart
)paren
(brace
r_const
id|pgoff_t
id|start
op_assign
(paren
id|lstart
op_plus
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_const
r_int
id|partial
op_assign
id|lstart
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_struct
id|pagevec
id|pvec
suffix:semicolon
id|pgoff_t
id|next
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|mapping-&gt;nrpages
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|pagevec_init
c_func
(paren
op_amp
id|pvec
comma
l_int|0
)paren
suffix:semicolon
id|next
op_assign
id|start
suffix:semicolon
r_while
c_loop
(paren
id|pagevec_lookup
c_func
(paren
op_amp
id|pvec
comma
id|mapping
comma
id|next
comma
id|PAGEVEC_SIZE
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pagevec_count
c_func
(paren
op_amp
id|pvec
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|pvec.pages
(braket
id|i
)braket
suffix:semicolon
id|pgoff_t
id|page_index
op_assign
id|page-&gt;index
suffix:semicolon
r_if
c_cond
(paren
id|page_index
OG
id|next
)paren
id|next
op_assign
id|page_index
suffix:semicolon
id|next
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|TestSetPageLocked
c_func
(paren
id|page
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|truncate_complete_page
c_func
(paren
id|mapping
comma
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|pagevec_release
c_func
(paren
op_amp
id|pvec
)paren
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|partial
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|find_lock_page
c_func
(paren
id|mapping
comma
id|start
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
id|wait_on_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
id|truncate_partial_page
c_func
(paren
id|page
comma
id|partial
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
id|next
op_assign
id|start
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagevec_lookup
c_func
(paren
op_amp
id|pvec
comma
id|mapping
comma
id|next
comma
id|PAGEVEC_SIZE
)paren
)paren
(brace
r_if
c_cond
(paren
id|next
op_eq
id|start
)paren
r_break
suffix:semicolon
id|next
op_assign
id|start
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pagevec_count
c_func
(paren
op_amp
id|pvec
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|pvec.pages
(braket
id|i
)braket
suffix:semicolon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|wait_on_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;index
OG
id|next
)paren
id|next
op_assign
id|page-&gt;index
suffix:semicolon
id|next
op_increment
suffix:semicolon
id|truncate_complete_page
c_func
(paren
id|mapping
comma
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|pagevec_release
c_func
(paren
op_amp
id|pvec
)paren
suffix:semicolon
)brace
)brace
DECL|variable|truncate_inode_pages
id|EXPORT_SYMBOL
c_func
(paren
id|truncate_inode_pages
)paren
suffix:semicolon
multiline_comment|/**&n; * invalidate_mapping_pages - Invalidate all the unlocked pages of one inode&n; * @mapping: the address_space which holds the pages to invalidate&n; * @start: the offset &squot;from&squot; which to invalidate&n; * @end: the offset &squot;to&squot; which to invalidate (inclusive)&n; *&n; * This function only removes the unlocked pages, if you want to&n; * remove all the pages of one inode, you must call truncate_inode_pages.&n; *&n; * invalidate_mapping_pages() will not block on IO activity. It will not&n; * invalidate pages which are dirty, locked, under writeback or mapped into&n; * pagetables.&n; */
DECL|function|invalidate_mapping_pages
r_int
r_int
id|invalidate_mapping_pages
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
id|pgoff_t
id|start
comma
id|pgoff_t
id|end
)paren
(brace
r_struct
id|pagevec
id|pvec
suffix:semicolon
id|pgoff_t
id|next
op_assign
id|start
suffix:semicolon
r_int
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|pagevec_init
c_func
(paren
op_amp
id|pvec
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|next
op_le
id|end
op_logical_and
id|pagevec_lookup
c_func
(paren
op_amp
id|pvec
comma
id|mapping
comma
id|next
comma
id|PAGEVEC_SIZE
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pagevec_count
c_func
(paren
op_amp
id|pvec
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|pvec.pages
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|TestSetPageLocked
c_func
(paren
id|page
)paren
)paren
(brace
id|next
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page-&gt;index
OG
id|next
)paren
id|next
op_assign
id|page-&gt;index
suffix:semicolon
id|next
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|PageDirty
c_func
(paren
id|page
)paren
op_logical_or
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
r_goto
id|unlock
suffix:semicolon
r_if
c_cond
(paren
id|page_mapped
c_func
(paren
id|page
)paren
)paren
r_goto
id|unlock
suffix:semicolon
id|ret
op_add_assign
id|invalidate_complete_page
c_func
(paren
id|mapping
comma
id|page
)paren
suffix:semicolon
id|unlock
suffix:colon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next
OG
id|end
)paren
r_break
suffix:semicolon
)brace
id|pagevec_release
c_func
(paren
op_amp
id|pvec
)paren
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|invalidate_inode_pages
r_int
r_int
id|invalidate_inode_pages
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
)paren
(brace
r_return
id|invalidate_mapping_pages
c_func
(paren
id|mapping
comma
l_int|0
comma
op_complement
l_int|0UL
)paren
suffix:semicolon
)brace
DECL|variable|invalidate_inode_pages
id|EXPORT_SYMBOL
c_func
(paren
id|invalidate_inode_pages
)paren
suffix:semicolon
multiline_comment|/**&n; * invalidate_inode_pages2 - remove all pages from an address_space&n; * @mapping - the address_space&n; *&n; * Any pages which are found to be mapped into pagetables are unmapped prior to&n; * invalidation.&n; *&n; * Returns -EIO if any pages could not be invalidated.&n; */
DECL|function|invalidate_inode_pages2
r_int
id|invalidate_inode_pages2
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
)paren
(brace
r_struct
id|pagevec
id|pvec
suffix:semicolon
id|pgoff_t
id|next
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|did_full_unmap
op_assign
l_int|0
suffix:semicolon
id|pagevec_init
c_func
(paren
op_amp
id|pvec
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|ret
op_logical_and
id|pagevec_lookup
c_func
(paren
op_amp
id|pvec
comma
id|mapping
comma
id|next
comma
id|PAGEVEC_SIZE
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|ret
op_logical_and
id|i
OL
id|pagevec_count
c_func
(paren
op_amp
id|pvec
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|pvec.pages
(braket
id|i
)braket
suffix:semicolon
r_int
id|was_dirty
suffix:semicolon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;mapping
op_ne
id|mapping
)paren
(brace
multiline_comment|/* truncate race? */
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|wait_on_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
id|next
op_assign
id|page-&gt;index
op_plus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|page_mapped
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|did_full_unmap
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Zap the rest of the file in one hit.&n;&t;&t;&t;&t;&t; * FIXME: invalidate_inode_pages2()&n;&t;&t;&t;&t;&t; * should take start/end offsets.&n;&t;&t;&t;&t;&t; */
id|unmap_mapping_range
c_func
(paren
id|mapping
comma
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|did_full_unmap
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Just zap this page&n;&t;&t;&t;&t;&t; */
id|unmap_mapping_range
c_func
(paren
id|mapping
comma
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
comma
(paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|was_dirty
op_assign
id|test_clear_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|invalidate_complete_page
c_func
(paren
id|mapping
comma
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
id|was_dirty
)paren
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|pagevec_release
c_func
(paren
op_amp
id|pvec
)paren
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|invalidate_inode_pages2
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|invalidate_inode_pages2
)paren
suffix:semicolon
eof
