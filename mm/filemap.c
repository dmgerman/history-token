multiline_comment|/*&n; *&t;linux/mm/filemap.c&n; *&n; * Copyright (C) 1994-1999  Linus Torvalds&n; */
multiline_comment|/*&n; * This file handles the generic file mmap semantics used by&n; * most &quot;normal&quot; filesystems (but you don&squot;t /have/ to use this:&n; * the NFS filesystem used to do this differently, for example)&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/aio.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/uio.h&gt;
macro_line|#include &lt;linux/hash.h&gt;
macro_line|#include &lt;linux/writeback.h&gt;
macro_line|#include &lt;linux/pagevec.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/security.h&gt;
multiline_comment|/*&n; * This is needed for the following functions:&n; *  - try_to_release_page&n; *  - block_invalidatepage&n; *  - generic_osync_inode&n; *&n; * FIXME: remove all knowledge of the buffer layer from the core VM&n; */
macro_line|#include &lt;linux/buffer_head.h&gt; /* for generic_osync_inode */
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/mman.h&gt;
multiline_comment|/*&n; * Shared mappings implemented 30.11.1994. It&squot;s not fully working yet,&n; * though.&n; *&n; * Shared mappings now work. 15.8.1995  Bruno.&n; *&n; * finished &squot;unifying&squot; the page and buffer cache and SMP-threaded the&n; * page-cache, 21.05.1999, Ingo Molnar &lt;mingo@redhat.com&gt;&n; *&n; * SMP-threaded pagemap-LRU 1999, Andrea Arcangeli &lt;andrea@suse.de&gt;&n; */
multiline_comment|/*&n; * Lock ordering:&n; *&n; *  -&gt;i_shared_sem&t;&t;(vmtruncate)&n; *    -&gt;private_lock&t;&t;(__free_pte-&gt;__set_page_dirty_buffers)&n; *      -&gt;swap_list_lock&n; *        -&gt;swap_device_lock&t;(exclusive_swap_page, others)&n; *          -&gt;mapping-&gt;tree_lock&n; *&n; *  -&gt;i_sem&n; *    -&gt;i_shared_sem&t;&t;(truncate-&gt;unmap_mapping_range)&n; *&n; *  -&gt;mmap_sem&n; *    -&gt;i_shared_sem&t;&t;(various places)&n; *&n; *  -&gt;mmap_sem&n; *    -&gt;lock_page&t;&t;(access_process_vm)&n; *&n; *  -&gt;mmap_sem&n; *    -&gt;i_sem&t;&t;&t;(msync)&n; *&n; *  -&gt;i_sem&n; *    -&gt;i_alloc_sem             (various)&n; *&n; *  -&gt;inode_lock&n; *    -&gt;sb_lock&t;&t;&t;(fs/fs-writeback.c)&n; *    -&gt;mapping-&gt;tree_lock&t;(__sync_single_inode)&n; *&n; *  -&gt;page_table_lock&n; *    -&gt;swap_device_lock&t;(try_to_unmap_one)&n; *    -&gt;private_lock&t;&t;(try_to_unmap_one)&n; *    -&gt;tree_lock&t;&t;(try_to_unmap_one)&n; *    -&gt;zone.lru_lock&t;&t;(follow_page-&gt;mark_page_accessed)&n; *&n; *  -&gt;task-&gt;proc_lock&n; *    -&gt;dcache_lock&t;&t;(proc_pid_lookup)&n; */
multiline_comment|/*&n; * Remove a page from the page cache and free it. Caller has to make&n; * sure the page is locked and that nobody else uses it - or that usage&n; * is safe.  The caller must hold a write_lock on the mapping&squot;s tree_lock.&n; */
DECL|function|__remove_from_page_cache
r_void
id|__remove_from_page_cache
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page-&gt;mapping
suffix:semicolon
id|radix_tree_delete
c_func
(paren
op_amp
id|mapping-&gt;page_tree
comma
id|page-&gt;index
)paren
suffix:semicolon
id|page-&gt;mapping
op_assign
l_int|NULL
suffix:semicolon
id|mapping-&gt;nrpages
op_decrement
suffix:semicolon
id|pagecache_acct
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|remove_from_page_cache
r_void
id|remove_from_page_cache
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page-&gt;mapping
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
)paren
id|PAGE_BUG
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
id|__remove_from_page_cache
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
)brace
DECL|function|sync_page
r_static
r_inline
r_int
id|sync_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
id|smp_mb
c_func
(paren
)paren
suffix:semicolon
id|mapping
op_assign
id|page_mapping
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mapping
)paren
(brace
r_if
c_cond
(paren
id|mapping-&gt;a_ops
op_logical_and
id|mapping-&gt;a_ops-&gt;sync_page
)paren
r_return
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|sync_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|page
)paren
)paren
(brace
id|swap_unplug_io_fn
c_func
(paren
l_int|NULL
comma
id|page
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * filemap_fdatawrite - start writeback against all of a mapping&squot;s dirty pages&n; * @mapping: address space structure to write&n; *&n; * If sync_mode is WB_SYNC_ALL then this is a &quot;data integrity&quot; operation, as&n; * opposed to a regular memory * cleansing writeback.  The difference between&n; * these two operations is that if a dirty page/buffer is encountered, it must&n; * be waited upon, and not just skipped over.&n; */
DECL|function|__filemap_fdatawrite
r_static
r_int
id|__filemap_fdatawrite
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
id|sync_mode
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|writeback_control
id|wbc
op_assign
(brace
dot
id|sync_mode
op_assign
id|sync_mode
comma
dot
id|nr_to_write
op_assign
id|mapping-&gt;nrpages
op_star
l_int|2
comma
)brace
suffix:semicolon
r_if
c_cond
(paren
id|mapping-&gt;backing_dev_info-&gt;memory_backed
)paren
r_return
l_int|0
suffix:semicolon
id|ret
op_assign
id|do_writepages
c_func
(paren
id|mapping
comma
op_amp
id|wbc
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|filemap_fdatawrite
r_int
id|filemap_fdatawrite
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
)paren
(brace
r_return
id|__filemap_fdatawrite
c_func
(paren
id|mapping
comma
id|WB_SYNC_ALL
)paren
suffix:semicolon
)brace
DECL|variable|filemap_fdatawrite
id|EXPORT_SYMBOL
c_func
(paren
id|filemap_fdatawrite
)paren
suffix:semicolon
multiline_comment|/*&n; * This is a mostly non-blocking flush.  Not suitable for data-integrity&n; * purposes - I/O may not be started against all dirty pages.&n; */
DECL|function|filemap_flush
r_int
id|filemap_flush
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
)paren
(brace
r_return
id|__filemap_fdatawrite
c_func
(paren
id|mapping
comma
id|WB_SYNC_NONE
)paren
suffix:semicolon
)brace
DECL|variable|filemap_flush
id|EXPORT_SYMBOL
c_func
(paren
id|filemap_flush
)paren
suffix:semicolon
multiline_comment|/*&n; * Wait for writeback to complete against pages indexed by start-&gt;end&n; * inclusive&n; */
DECL|function|wait_on_page_writeback_range
r_static
r_int
id|wait_on_page_writeback_range
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
id|pgoff_t
id|start
comma
id|pgoff_t
id|end
)paren
(brace
r_struct
id|pagevec
id|pvec
suffix:semicolon
r_int
id|nr_pages
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|pgoff_t
id|index
suffix:semicolon
r_if
c_cond
(paren
id|end
OL
id|start
)paren
r_return
l_int|0
suffix:semicolon
id|pagevec_init
c_func
(paren
op_amp
id|pvec
comma
l_int|0
)paren
suffix:semicolon
id|index
op_assign
id|start
suffix:semicolon
r_while
c_loop
(paren
(paren
id|nr_pages
op_assign
id|pagevec_lookup_tag
c_func
(paren
op_amp
id|pvec
comma
id|mapping
comma
op_amp
id|index
comma
id|PAGECACHE_TAG_WRITEBACK
comma
id|min
c_func
(paren
id|end
op_minus
id|index
comma
(paren
id|pgoff_t
)paren
id|PAGEVEC_SIZE
op_minus
l_int|1
)paren
op_plus
l_int|1
)paren
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|pvec.pages
(braket
id|i
)braket
suffix:semicolon
id|wait_on_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageError
c_func
(paren
id|page
)paren
)paren
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
id|pagevec_release
c_func
(paren
op_amp
id|pvec
)paren
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Check for outstanding write errors */
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|AS_ENOSPC
comma
op_amp
id|mapping-&gt;flags
)paren
)paren
id|ret
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|AS_EIO
comma
op_amp
id|mapping-&gt;flags
)paren
)paren
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * filemap_fdatawait - walk the list of under-writeback pages of the given&n; *     address space and wait for all of them.&n; *&n; * @mapping: address space structure to wait for&n; */
DECL|function|filemap_fdatawait
r_int
id|filemap_fdatawait
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
)paren
(brace
r_return
id|wait_on_page_writeback_range
c_func
(paren
id|mapping
comma
l_int|0
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
DECL|variable|filemap_fdatawait
id|EXPORT_SYMBOL
c_func
(paren
id|filemap_fdatawait
)paren
suffix:semicolon
DECL|function|filemap_write_and_wait
r_int
id|filemap_write_and_wait
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mapping-&gt;nrpages
)paren
(brace
id|retval
op_assign
id|filemap_fdatawrite
c_func
(paren
id|mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
l_int|0
)paren
id|retval
op_assign
id|filemap_fdatawait
c_func
(paren
id|mapping
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is used to add newly allocated pagecache pages:&n; * the page is new, so we can just run SetPageLocked() against it.&n; * The other page state flags were set by rmqueue().&n; *&n; * This function does not add the page to the LRU.  The caller must do that.&n; */
DECL|function|add_to_page_cache
r_int
id|add_to_page_cache
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|address_space
op_star
id|mapping
comma
id|pgoff_t
id|offset
comma
r_int
id|gfp_mask
)paren
(brace
r_int
id|error
op_assign
id|radix_tree_preload
c_func
(paren
id|gfp_mask
op_amp
op_complement
id|__GFP_HIGHMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
(brace
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
id|error
op_assign
id|radix_tree_insert
c_func
(paren
op_amp
id|mapping-&gt;page_tree
comma
id|offset
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|SetPageLocked
c_func
(paren
id|page
)paren
suffix:semicolon
id|page-&gt;mapping
op_assign
id|mapping
suffix:semicolon
id|page-&gt;index
op_assign
id|offset
suffix:semicolon
id|mapping-&gt;nrpages
op_increment
suffix:semicolon
id|pagecache_acct
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
id|radix_tree_preload_end
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|variable|add_to_page_cache
id|EXPORT_SYMBOL
c_func
(paren
id|add_to_page_cache
)paren
suffix:semicolon
DECL|function|add_to_page_cache_lru
r_int
id|add_to_page_cache_lru
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|address_space
op_star
id|mapping
comma
id|pgoff_t
id|offset
comma
r_int
id|gfp_mask
)paren
(brace
r_int
id|ret
op_assign
id|add_to_page_cache
c_func
(paren
id|page
comma
id|mapping
comma
id|offset
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|lru_cache_add
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * In order to wait for pages to become available there must be&n; * waitqueues associated with pages. By using a hash table of&n; * waitqueues where the bucket discipline is to maintain all&n; * waiters on the same queue and wake all when any of the pages&n; * become available, and for the woken contexts to check to be&n; * sure the appropriate page became available, this saves space&n; * at a cost of &quot;thundering herd&quot; phenomena during rare hash&n; * collisions.&n; */
DECL|struct|page_wait_queue
r_struct
id|page_wait_queue
(brace
DECL|member|page
r_struct
id|page
op_star
id|page
suffix:semicolon
DECL|member|bit
r_int
id|bit
suffix:semicolon
DECL|member|wait
id|wait_queue_t
id|wait
suffix:semicolon
)brace
suffix:semicolon
DECL|function|page_wake_function
r_static
r_int
id|page_wake_function
c_func
(paren
id|wait_queue_t
op_star
id|wait
comma
r_int
id|mode
comma
r_int
id|sync
comma
r_void
op_star
id|key
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|key
suffix:semicolon
r_struct
id|page_wait_queue
op_star
id|wq
suffix:semicolon
id|wq
op_assign
id|container_of
c_func
(paren
id|wait
comma
r_struct
id|page_wait_queue
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wq-&gt;page
op_ne
id|page
op_logical_or
id|test_bit
c_func
(paren
id|wq-&gt;bit
comma
op_amp
id|page-&gt;flags
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
id|autoremove_wake_function
c_func
(paren
id|wait
comma
id|mode
comma
id|sync
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|macro|__DEFINE_PAGE_WAIT
mdefine_line|#define __DEFINE_PAGE_WAIT(name, p, b, f)&t;&t;&t;&t;&bslash;&n;&t;struct page_wait_queue name = {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;.page&t;= p,&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;.bit&t;= b,&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;.wait&t;= {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;.task&t;= current,&t;&t;&t;&t;&bslash;&n;&t;&t;&t;.func&t;= page_wake_function,&t;&t;&t;&bslash;&n;&t;&t;&t;.flags&t;= f,&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;.task_list = LIST_HEAD_INIT(name.wait.task_list),&bslash;&n;&t;&t;},&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;}
DECL|macro|DEFINE_PAGE_WAIT
mdefine_line|#define DEFINE_PAGE_WAIT(name, p, b)&t;__DEFINE_PAGE_WAIT(name, p, b, 0)
DECL|macro|DEFINE_PAGE_WAIT_EXCLUSIVE
mdefine_line|#define DEFINE_PAGE_WAIT_EXCLUSIVE(name, p, b)&t;&t;&t;&t;&bslash;&n;&t;&t;__DEFINE_PAGE_WAIT(name, p, b, WQ_FLAG_EXCLUSIVE)
DECL|function|page_waitqueue
r_static
id|wait_queue_head_t
op_star
id|page_waitqueue
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_const
r_struct
id|zone
op_star
id|zone
op_assign
id|page_zone
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
op_amp
id|zone-&gt;wait_table
(braket
id|hash_ptr
c_func
(paren
id|page
comma
id|zone-&gt;wait_table_bits
)paren
)braket
suffix:semicolon
)brace
DECL|function|wake_up_page
r_static
r_void
id|wake_up_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_const
r_int
r_int
id|mode
op_assign
id|TASK_UNINTERRUPTIBLE
op_or
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|wait_queue_head_t
op_star
id|waitqueue
op_assign
id|page_waitqueue
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
id|waitqueue
)paren
)paren
id|__wake_up
c_func
(paren
id|waitqueue
comma
id|mode
comma
l_int|1
comma
id|page
)paren
suffix:semicolon
)brace
DECL|function|wait_on_page_bit
r_void
id|fastcall
id|wait_on_page_bit
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|bit_nr
)paren
(brace
id|wait_queue_head_t
op_star
id|waitqueue
op_assign
id|page_waitqueue
c_func
(paren
id|page
)paren
suffix:semicolon
id|DEFINE_PAGE_WAIT
c_func
(paren
id|wait
comma
id|page
comma
id|bit_nr
)paren
suffix:semicolon
r_do
(brace
id|prepare_to_wait
c_func
(paren
id|waitqueue
comma
op_amp
id|wait.wait
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|bit_nr
comma
op_amp
id|page-&gt;flags
)paren
)paren
(brace
id|sync_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|io_schedule
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|test_bit
c_func
(paren
id|bit_nr
comma
op_amp
id|page-&gt;flags
)paren
)paren
suffix:semicolon
id|finish_wait
c_func
(paren
id|waitqueue
comma
op_amp
id|wait.wait
)paren
suffix:semicolon
)brace
DECL|variable|wait_on_page_bit
id|EXPORT_SYMBOL
c_func
(paren
id|wait_on_page_bit
)paren
suffix:semicolon
multiline_comment|/**&n; * unlock_page() - unlock a locked page&n; *&n; * @page: the page&n; *&n; * Unlocks the page and wakes up sleepers in ___wait_on_page_locked().&n; * Also wakes sleepers in wait_on_page_writeback() because the wakeup&n; * mechananism between PageLocked pages and PageWriteback pages is shared.&n; * But that&squot;s OK - sleepers in wait_on_page_writeback() just go back to sleep.&n; *&n; * The first mb is necessary to safely close the critical section opened by the&n; * TestSetPageLocked(), the second mb is necessary to enforce ordering between&n; * the clear_bit and the read of the waitqueue (to avoid SMP races with a&n; * parallel wait_on_page_locked()).&n; */
DECL|function|unlock_page
r_void
id|fastcall
id|unlock_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|smp_mb__before_clear_bit
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TestClearPageLocked
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|smp_mb__after_clear_bit
c_func
(paren
)paren
suffix:semicolon
id|wake_up_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|variable|unlock_page
id|EXPORT_SYMBOL
c_func
(paren
id|unlock_page
)paren
suffix:semicolon
DECL|variable|lock_page
id|EXPORT_SYMBOL
c_func
(paren
id|lock_page
)paren
suffix:semicolon
multiline_comment|/*&n; * End writeback against a page.&n; */
DECL|function|end_page_writeback
r_void
id|end_page_writeback
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|TestClearPageReclaim
c_func
(paren
id|page
)paren
op_logical_or
id|rotate_reclaimable_page
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_clear_page_writeback
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|smp_mb__after_clear_bit
c_func
(paren
)paren
suffix:semicolon
)brace
id|wake_up_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|variable|end_page_writeback
id|EXPORT_SYMBOL
c_func
(paren
id|end_page_writeback
)paren
suffix:semicolon
multiline_comment|/*&n; * Get a lock on the page, assuming we need to sleep to get it.&n; *&n; * Ugly: running sync_page() in state TASK_UNINTERRUPTIBLE is scary.  If some&n; * random driver&squot;s requestfn sets TASK_RUNNING, we could busywait.  However&n; * chances are that on the second loop, the block layer&squot;s plug list is empty,&n; * so sync_page() will then return in state TASK_UNINTERRUPTIBLE.&n; */
DECL|function|__lock_page
r_void
id|fastcall
id|__lock_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|wait_queue_head_t
op_star
id|wqh
op_assign
id|page_waitqueue
c_func
(paren
id|page
)paren
suffix:semicolon
id|DEFINE_PAGE_WAIT_EXCLUSIVE
c_func
(paren
id|wait
comma
id|page
comma
id|PG_locked
)paren
suffix:semicolon
r_while
c_loop
(paren
id|TestSetPageLocked
c_func
(paren
id|page
)paren
)paren
(brace
id|prepare_to_wait_exclusive
c_func
(paren
id|wqh
comma
op_amp
id|wait.wait
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageLocked
c_func
(paren
id|page
)paren
)paren
(brace
id|sync_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|io_schedule
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|finish_wait
c_func
(paren
id|wqh
comma
op_amp
id|wait.wait
)paren
suffix:semicolon
)brace
DECL|variable|__lock_page
id|EXPORT_SYMBOL
c_func
(paren
id|__lock_page
)paren
suffix:semicolon
multiline_comment|/*&n; * a rather lightweight function, finding and getting a reference to a&n; * hashed page atomically.&n; */
DECL|function|find_get_page
r_struct
id|page
op_star
id|find_get_page
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
r_int
id|offset
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
multiline_comment|/*&n;&t; * We scan the hash list read-only. Addition to and removal from&n;&t; * the hash-list needs a held write-lock.&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
id|page
op_assign
id|radix_tree_lookup
c_func
(paren
op_amp
id|mapping-&gt;page_tree
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
r_return
id|page
suffix:semicolon
)brace
DECL|variable|find_get_page
id|EXPORT_SYMBOL
c_func
(paren
id|find_get_page
)paren
suffix:semicolon
multiline_comment|/*&n; * Same as above, but trylock it instead of incrementing the count.&n; */
DECL|function|find_trylock_page
r_struct
id|page
op_star
id|find_trylock_page
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
r_int
id|offset
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
id|page
op_assign
id|radix_tree_lookup
c_func
(paren
op_amp
id|mapping-&gt;page_tree
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
op_logical_and
id|TestSetPageLocked
c_func
(paren
id|page
)paren
)paren
id|page
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
r_return
id|page
suffix:semicolon
)brace
DECL|variable|find_trylock_page
id|EXPORT_SYMBOL
c_func
(paren
id|find_trylock_page
)paren
suffix:semicolon
multiline_comment|/**&n; * find_lock_page - locate, pin and lock a pagecache page&n; *&n; * @mapping - the address_space to search&n; * @offset - the page index&n; *&n; * Locates the desired pagecache page, locks it, increments its reference&n; * count and returns its address.&n; *&n; * Returns zero if the page was not present. find_lock_page() may sleep.&n; */
DECL|function|find_lock_page
r_struct
id|page
op_star
id|find_lock_page
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
r_int
id|offset
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
id|repeat
suffix:colon
id|page
op_assign
id|radix_tree_lookup
c_func
(paren
op_amp
id|mapping-&gt;page_tree
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TestSetPageLocked
c_func
(paren
id|page
)paren
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
multiline_comment|/* Has the page been truncated while we slept? */
r_if
c_cond
(paren
id|page-&gt;mapping
op_ne
id|mapping
op_logical_or
id|page-&gt;index
op_ne
id|offset
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
r_return
id|page
suffix:semicolon
)brace
DECL|variable|find_lock_page
id|EXPORT_SYMBOL
c_func
(paren
id|find_lock_page
)paren
suffix:semicolon
multiline_comment|/**&n; * find_or_create_page - locate or add a pagecache page&n; *&n; * @mapping - the page&squot;s address_space&n; * @index - the page&squot;s index into the mapping&n; * @gfp_mask - page allocation mode&n; *&n; * Locates a page in the pagecache.  If the page is not present, a new page&n; * is allocated using @gfp_mask and is added to the pagecache and to the VM&squot;s&n; * LRU list.  The returned page is locked and has its reference count&n; * incremented.&n; *&n; * find_or_create_page() may sleep, even if @gfp_flags specifies an atomic&n; * allocation!&n; *&n; * find_or_create_page() returns the desired page&squot;s address, or zero on&n; * memory exhaustion.&n; */
DECL|function|find_or_create_page
r_struct
id|page
op_star
id|find_or_create_page
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
r_int
id|index
comma
r_int
r_int
id|gfp_mask
)paren
(brace
r_struct
id|page
op_star
id|page
comma
op_star
id|cached_page
op_assign
l_int|NULL
suffix:semicolon
r_int
id|err
suffix:semicolon
id|repeat
suffix:colon
id|page
op_assign
id|find_lock_page
c_func
(paren
id|mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cached_page
)paren
(brace
id|cached_page
op_assign
id|alloc_page
c_func
(paren
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cached_page
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
id|err
op_assign
id|add_to_page_cache_lru
c_func
(paren
id|cached_page
comma
id|mapping
comma
id|index
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|page
op_assign
id|cached_page
suffix:semicolon
id|cached_page
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EEXIST
)paren
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cached_page
)paren
id|page_cache_release
c_func
(paren
id|cached_page
)paren
suffix:semicolon
r_return
id|page
suffix:semicolon
)brace
DECL|variable|find_or_create_page
id|EXPORT_SYMBOL
c_func
(paren
id|find_or_create_page
)paren
suffix:semicolon
multiline_comment|/**&n; * find_get_pages - gang pagecache lookup&n; * @mapping:&t;The address_space to search&n; * @start:&t;The starting page index&n; * @nr_pages:&t;The maximum number of pages&n; * @pages:&t;Where the resulting pages are placed&n; *&n; * find_get_pages() will search for and return a group of up to&n; * @nr_pages pages in the mapping.  The pages are placed at @pages.&n; * find_get_pages() takes a reference against the returned pages.&n; *&n; * The search returns a group of mapping-contiguous pages with ascending&n; * indexes.  There may be holes in the indices due to not-present pages.&n; *&n; * find_get_pages() returns the number of pages which were found.&n; */
DECL|function|find_get_pages
r_int
id|find_get_pages
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
id|pgoff_t
id|start
comma
r_int
r_int
id|nr_pages
comma
r_struct
id|page
op_star
op_star
id|pages
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|ret
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
id|ret
op_assign
id|radix_tree_gang_lookup
c_func
(paren
op_amp
id|mapping-&gt;page_tree
comma
(paren
r_void
op_star
op_star
)paren
id|pages
comma
id|start
comma
id|nr_pages
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ret
suffix:semicolon
id|i
op_increment
)paren
id|page_cache_get
c_func
(paren
id|pages
(braket
id|i
)braket
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Like find_get_pages, except we only return pages which are tagged with&n; * `tag&squot;.   We update *index to index the next page for the traversal.&n; */
DECL|function|find_get_pages_tag
r_int
id|find_get_pages_tag
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
id|pgoff_t
op_star
id|index
comma
r_int
id|tag
comma
r_int
r_int
id|nr_pages
comma
r_struct
id|page
op_star
op_star
id|pages
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|ret
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
id|ret
op_assign
id|radix_tree_gang_lookup_tag
c_func
(paren
op_amp
id|mapping-&gt;page_tree
comma
(paren
r_void
op_star
op_star
)paren
id|pages
comma
op_star
id|index
comma
id|nr_pages
comma
id|tag
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ret
suffix:semicolon
id|i
op_increment
)paren
id|page_cache_get
c_func
(paren
id|pages
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
op_star
id|index
op_assign
id|pages
(braket
id|ret
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|index
op_plus
l_int|1
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|mapping-&gt;tree_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Same as grab_cache_page, but do not wait if the page is unavailable.&n; * This is intended for speculative data generators, where the data can&n; * be regenerated if the page couldn&squot;t be grabbed.  This routine should&n; * be safe to call while holding the lock for another page.&n; *&n; * Clear __GFP_FS when allocating the page to avoid recursion into the fs&n; * and deadlock against the caller&squot;s locked page.&n; */
r_struct
id|page
op_star
DECL|function|grab_cache_page_nowait
id|grab_cache_page_nowait
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
r_int
id|index
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|find_get_page
c_func
(paren
id|mapping
comma
id|index
)paren
suffix:semicolon
r_int
id|gfp_mask
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|TestSetPageLocked
c_func
(paren
id|page
)paren
)paren
r_return
id|page
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|gfp_mask
op_assign
id|mapping_gfp_mask
c_func
(paren
id|mapping
)paren
op_amp
op_complement
id|__GFP_FS
suffix:semicolon
id|page
op_assign
id|alloc_pages
c_func
(paren
id|gfp_mask
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
op_logical_and
id|add_to_page_cache_lru
c_func
(paren
id|page
comma
id|mapping
comma
id|index
comma
id|gfp_mask
)paren
)paren
(brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|page
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|page
suffix:semicolon
)brace
DECL|variable|grab_cache_page_nowait
id|EXPORT_SYMBOL
c_func
(paren
id|grab_cache_page_nowait
)paren
suffix:semicolon
multiline_comment|/*&n; * This is a generic file read routine, and uses the&n; * mapping-&gt;a_ops-&gt;readpage() function for the actual low-level&n; * stuff.&n; *&n; * This is really ugly. But the goto&squot;s actually try to clarify some&n; * of the logic when it comes to error handling etc.&n; * - note the struct file * is only passed for the use of readpage&n; */
DECL|function|do_generic_mapping_read
r_void
id|do_generic_mapping_read
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_struct
id|file_ra_state
op_star
id|_ra
comma
r_struct
id|file
op_star
id|filp
comma
id|loff_t
op_star
id|ppos
comma
id|read_descriptor_t
op_star
id|desc
comma
id|read_actor_t
id|actor
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
r_int
r_int
id|index
comma
id|offset
suffix:semicolon
r_struct
id|page
op_star
id|cached_page
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|file_ra_state
id|ra
op_assign
op_star
id|_ra
suffix:semicolon
id|cached_page
op_assign
l_int|NULL
suffix:semicolon
id|index
op_assign
op_star
id|ppos
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|offset
op_assign
op_star
id|ppos
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|end_index
comma
id|nr
comma
id|ret
suffix:semicolon
id|loff_t
id|isize
op_assign
id|i_size_read
c_func
(paren
id|inode
)paren
suffix:semicolon
id|end_index
op_assign
id|isize
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|index
OG
id|end_index
)paren
r_break
suffix:semicolon
id|nr
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
id|end_index
)paren
(brace
id|nr
op_assign
id|isize
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_le
id|offset
)paren
r_break
suffix:semicolon
)brace
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
id|page_cache_readahead
c_func
(paren
id|mapping
comma
op_amp
id|ra
comma
id|filp
comma
id|index
)paren
suffix:semicolon
id|nr
op_assign
id|nr
op_minus
id|offset
suffix:semicolon
id|find_page
suffix:colon
id|page
op_assign
id|find_get_page
c_func
(paren
id|mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|page
op_eq
l_int|NULL
)paren
)paren
(brace
id|handle_ra_miss
c_func
(paren
id|mapping
comma
op_amp
id|ra
comma
id|index
)paren
suffix:semicolon
r_goto
id|no_cached_page
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|page_not_up_to_date
suffix:semicolon
id|page_ok
suffix:colon
multiline_comment|/* If users can be writing to this page using arbitrary&n;&t;&t; * virtual addresses, take care about potential aliasing&n;&t;&t; * before reading the page on the kernel side.&n;&t;&t; */
r_if
c_cond
(paren
id|mapping_writably_mapped
c_func
(paren
id|mapping
)paren
)paren
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Mark the page accessed if we read the beginning.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|offset
)paren
id|mark_page_accessed
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Ok, we have the page, and it&squot;s up-to-date, so&n;&t;&t; * now we can copy it to user space...&n;&t;&t; *&n;&t;&t; * The actor routine returns how many bytes were actually used..&n;&t;&t; * NOTE! This may not be the same as how much of a user buffer&n;&t;&t; * we filled up (we may be padding etc), so we can only update&n;&t;&t; * &quot;pos&quot; here (the actor routine has to update the user buffer&n;&t;&t; * pointers and the remaining count).&n;&t;&t; */
id|ret
op_assign
id|actor
c_func
(paren
id|desc
comma
id|page
comma
id|offset
comma
id|nr
)paren
suffix:semicolon
id|offset
op_add_assign
id|ret
suffix:semicolon
id|index
op_add_assign
id|offset
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|offset
op_and_assign
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|nr
op_logical_and
id|desc-&gt;count
)paren
r_continue
suffix:semicolon
r_break
suffix:semicolon
id|page_not_up_to_date
suffix:colon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|page_ok
suffix:semicolon
multiline_comment|/* Get exclusive access to the page ... */
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Did it get unhashed before we got the lock? */
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;mapping
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Did somebody else fill it already? */
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|page_ok
suffix:semicolon
)brace
id|readpage
suffix:colon
multiline_comment|/* ... and start the actual read. The read will unlock the page. */
id|error
op_assign
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|readpage
c_func
(paren
id|filp
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|page_ok
suffix:semicolon
id|wait_on_page_locked
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|page_ok
suffix:semicolon
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* UHHUH! A synchronous read error occurred. Report it */
id|desc-&gt;error
op_assign
id|error
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_break
suffix:semicolon
id|no_cached_page
suffix:colon
multiline_comment|/*&n;&t;&t; * Ok, it wasn&squot;t cached, so we need to create a new&n;&t;&t; * page..&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cached_page
)paren
(brace
id|cached_page
op_assign
id|page_cache_alloc_cold
c_func
(paren
id|mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cached_page
)paren
(brace
id|desc-&gt;error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|error
op_assign
id|add_to_page_cache_lru
c_func
(paren
id|cached_page
comma
id|mapping
comma
id|index
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|EEXIST
)paren
r_goto
id|find_page
suffix:semicolon
id|desc-&gt;error
op_assign
id|error
suffix:semicolon
r_break
suffix:semicolon
)brace
id|page
op_assign
id|cached_page
suffix:semicolon
id|cached_page
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|readpage
suffix:semicolon
)brace
op_star
id|_ra
op_assign
id|ra
suffix:semicolon
op_star
id|ppos
op_assign
(paren
(paren
id|loff_t
)paren
id|index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|cached_page
)paren
id|page_cache_release
c_func
(paren
id|cached_page
)paren
suffix:semicolon
id|file_accessed
c_func
(paren
id|filp
)paren
suffix:semicolon
)brace
DECL|variable|do_generic_mapping_read
id|EXPORT_SYMBOL
c_func
(paren
id|do_generic_mapping_read
)paren
suffix:semicolon
DECL|function|file_read_actor
r_int
id|file_read_actor
c_func
(paren
id|read_descriptor_t
op_star
id|desc
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|size
)paren
(brace
r_char
op_star
id|kaddr
suffix:semicolon
r_int
r_int
id|left
comma
id|count
op_assign
id|desc-&gt;count
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|count
)paren
id|size
op_assign
id|count
suffix:semicolon
multiline_comment|/*&n;&t; * Faults on the destination of a read are common, so do it before&n;&t; * taking the kmap.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|fault_in_pages_writeable
c_func
(paren
id|desc-&gt;buf
comma
id|size
)paren
)paren
(brace
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|left
op_assign
id|__copy_to_user
c_func
(paren
id|desc-&gt;buf
comma
id|kaddr
op_plus
id|offset
comma
id|size
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|left
op_eq
l_int|0
)paren
r_goto
id|success
suffix:semicolon
)brace
multiline_comment|/* Do it the slow way */
id|kaddr
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|left
op_assign
id|__copy_to_user
c_func
(paren
id|desc-&gt;buf
comma
id|kaddr
op_plus
id|offset
comma
id|size
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|left
)paren
(brace
id|size
op_sub_assign
id|left
suffix:semicolon
id|desc-&gt;error
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
id|success
suffix:colon
id|desc-&gt;count
op_assign
id|count
op_minus
id|size
suffix:semicolon
id|desc-&gt;written
op_add_assign
id|size
suffix:semicolon
id|desc-&gt;buf
op_add_assign
id|size
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the &quot;read()&quot; routine for all filesystems&n; * that can use the page cache directly.&n; */
id|ssize_t
DECL|function|__generic_file_aio_read
id|__generic_file_aio_read
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_const
r_struct
id|iovec
op_star
id|iov
comma
r_int
r_int
id|nr_segs
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|file
op_star
id|filp
op_assign
id|iocb-&gt;ki_filp
suffix:semicolon
id|ssize_t
id|retval
suffix:semicolon
r_int
r_int
id|seg
suffix:semicolon
r_int
id|count
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|seg
op_assign
l_int|0
suffix:semicolon
id|seg
OL
id|nr_segs
suffix:semicolon
id|seg
op_increment
)paren
(brace
r_const
r_struct
id|iovec
op_star
id|iv
op_assign
op_amp
id|iov
(braket
id|seg
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If any segment has a negative length, or the cumulative&n;&t;&t; * length ever wraps negative then return -EINVAL.&n;&t;&t; */
id|count
op_add_assign
id|iv-&gt;iov_len
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|ssize_t
)paren
(paren
id|count
op_or
id|iv-&gt;iov_len
)paren
OL
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|iv-&gt;iov_base
comma
id|iv-&gt;iov_len
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|seg
op_eq
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|nr_segs
op_assign
id|seg
suffix:semicolon
id|count
op_sub_assign
id|iv-&gt;iov_len
suffix:semicolon
multiline_comment|/* This segment is no good */
r_break
suffix:semicolon
)brace
multiline_comment|/* coalesce the iovecs and go direct-to-BIO for O_DIRECT */
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_DIRECT
)paren
(brace
id|loff_t
id|pos
op_assign
op_star
id|ppos
comma
id|size
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|mapping
op_assign
id|filp-&gt;f_mapping
suffix:semicolon
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* skip atime */
id|size
op_assign
id|i_size_read
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|size
)paren
(brace
id|retval
op_assign
id|generic_file_direct_IO
c_func
(paren
id|READ
comma
id|iocb
comma
id|iov
comma
id|pos
comma
id|nr_segs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ge
l_int|0
op_logical_and
op_logical_neg
id|is_sync_kiocb
c_func
(paren
id|iocb
)paren
)paren
id|retval
op_assign
op_minus
id|EIOCBQUEUED
suffix:semicolon
r_if
c_cond
(paren
id|retval
OG
l_int|0
)paren
op_star
id|ppos
op_assign
id|pos
op_plus
id|retval
suffix:semicolon
)brace
id|file_accessed
c_func
(paren
id|filp
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
r_for
c_loop
(paren
id|seg
op_assign
l_int|0
suffix:semicolon
id|seg
OL
id|nr_segs
suffix:semicolon
id|seg
op_increment
)paren
(brace
id|read_descriptor_t
id|desc
suffix:semicolon
id|desc.written
op_assign
l_int|0
suffix:semicolon
id|desc.buf
op_assign
id|iov
(braket
id|seg
)braket
dot
id|iov_base
suffix:semicolon
id|desc.count
op_assign
id|iov
(braket
id|seg
)braket
dot
id|iov_len
suffix:semicolon
r_if
c_cond
(paren
id|desc.count
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|desc.error
op_assign
l_int|0
suffix:semicolon
id|do_generic_file_read
c_func
(paren
id|filp
comma
id|ppos
comma
op_amp
id|desc
comma
id|file_read_actor
)paren
suffix:semicolon
id|retval
op_add_assign
id|desc.written
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
(brace
id|retval
op_assign
id|desc.error
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|__generic_file_aio_read
id|EXPORT_SYMBOL
c_func
(paren
id|__generic_file_aio_read
)paren
suffix:semicolon
id|ssize_t
DECL|function|generic_file_aio_read
id|generic_file_aio_read
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_char
id|__user
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
id|pos
)paren
(brace
r_struct
id|iovec
id|local_iov
op_assign
(brace
dot
id|iov_base
op_assign
id|buf
comma
dot
id|iov_len
op_assign
id|count
)brace
suffix:semicolon
id|BUG_ON
c_func
(paren
id|iocb-&gt;ki_pos
op_ne
id|pos
)paren
suffix:semicolon
r_return
id|__generic_file_aio_read
c_func
(paren
id|iocb
comma
op_amp
id|local_iov
comma
l_int|1
comma
op_amp
id|iocb-&gt;ki_pos
)paren
suffix:semicolon
)brace
DECL|variable|generic_file_aio_read
id|EXPORT_SYMBOL
c_func
(paren
id|generic_file_aio_read
)paren
suffix:semicolon
id|ssize_t
DECL|function|generic_file_read
id|generic_file_read
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
id|__user
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|iovec
id|local_iov
op_assign
(brace
dot
id|iov_base
op_assign
id|buf
comma
dot
id|iov_len
op_assign
id|count
)brace
suffix:semicolon
r_struct
id|kiocb
id|kiocb
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
id|init_sync_kiocb
c_func
(paren
op_amp
id|kiocb
comma
id|filp
)paren
suffix:semicolon
id|ret
op_assign
id|__generic_file_aio_read
c_func
(paren
op_amp
id|kiocb
comma
op_amp
id|local_iov
comma
l_int|1
comma
id|ppos
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
id|EIOCBQUEUED
op_eq
id|ret
)paren
id|ret
op_assign
id|wait_on_sync_kiocb
c_func
(paren
op_amp
id|kiocb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|generic_file_read
id|EXPORT_SYMBOL
c_func
(paren
id|generic_file_read
)paren
suffix:semicolon
DECL|function|file_send_actor
r_int
id|file_send_actor
c_func
(paren
id|read_descriptor_t
op_star
id|desc
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|size
)paren
(brace
id|ssize_t
id|written
suffix:semicolon
r_int
r_int
id|count
op_assign
id|desc-&gt;count
suffix:semicolon
r_struct
id|file
op_star
id|file
op_assign
(paren
r_struct
id|file
op_star
)paren
id|desc-&gt;buf
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|count
)paren
id|size
op_assign
id|count
suffix:semicolon
id|written
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|sendpage
c_func
(paren
id|file
comma
id|page
comma
id|offset
comma
id|size
comma
op_amp
id|file-&gt;f_pos
comma
id|size
OL
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|written
OL
l_int|0
)paren
(brace
id|desc-&gt;error
op_assign
id|written
suffix:semicolon
id|written
op_assign
l_int|0
suffix:semicolon
)brace
id|desc-&gt;count
op_assign
id|count
op_minus
id|written
suffix:semicolon
id|desc-&gt;written
op_add_assign
id|written
suffix:semicolon
r_return
id|written
suffix:semicolon
)brace
DECL|function|generic_file_sendfile
id|ssize_t
id|generic_file_sendfile
c_func
(paren
r_struct
id|file
op_star
id|in_file
comma
id|loff_t
op_star
id|ppos
comma
r_int
id|count
comma
id|read_actor_t
id|actor
comma
r_void
id|__user
op_star
id|target
)paren
(brace
id|read_descriptor_t
id|desc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_return
l_int|0
suffix:semicolon
id|desc.written
op_assign
l_int|0
suffix:semicolon
id|desc.count
op_assign
id|count
suffix:semicolon
id|desc.buf
op_assign
id|target
suffix:semicolon
id|desc.error
op_assign
l_int|0
suffix:semicolon
id|do_generic_file_read
c_func
(paren
id|in_file
comma
id|ppos
comma
op_amp
id|desc
comma
id|actor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|desc.written
)paren
r_return
id|desc.written
suffix:semicolon
r_return
id|desc.error
suffix:semicolon
)brace
DECL|variable|generic_file_sendfile
id|EXPORT_SYMBOL
c_func
(paren
id|generic_file_sendfile
)paren
suffix:semicolon
r_static
id|ssize_t
DECL|function|do_readahead
id|do_readahead
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|index
comma
r_int
r_int
id|nr
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mapping
op_logical_or
op_logical_neg
id|mapping-&gt;a_ops
op_logical_or
op_logical_neg
id|mapping-&gt;a_ops-&gt;readpage
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|force_page_cache_readahead
c_func
(paren
id|mapping
comma
id|filp
comma
id|index
comma
id|max_sane_readahead
c_func
(paren
id|nr
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_readahead
id|asmlinkage
id|ssize_t
id|sys_readahead
c_func
(paren
r_int
id|fd
comma
id|loff_t
id|offset
comma
r_int
id|count
)paren
(brace
id|ssize_t
id|ret
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
id|ret
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|file-&gt;f_mapping
suffix:semicolon
r_int
r_int
id|start
op_assign
id|offset
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_int
r_int
id|end
op_assign
(paren
id|offset
op_plus
id|count
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_int
r_int
id|len
op_assign
id|end
op_minus
id|start
op_plus
l_int|1
suffix:semicolon
id|ret
op_assign
id|do_readahead
c_func
(paren
id|mapping
comma
id|file
comma
id|start
comma
id|len
)paren
suffix:semicolon
)brace
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MMU
multiline_comment|/*&n; * This adds the requested page to the page cache if it isn&squot;t already there,&n; * and schedules an I/O to read in its contents from disk.&n; */
r_static
r_int
id|FASTCALL
c_func
(paren
id|page_cache_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|offset
)paren
)paren
suffix:semicolon
DECL|function|page_cache_read
r_static
r_int
id|fastcall
id|page_cache_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|offset
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|file-&gt;f_mapping
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|error
suffix:semicolon
id|page
op_assign
id|page_cache_alloc_cold
c_func
(paren
id|mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|error
op_assign
id|add_to_page_cache_lru
c_func
(paren
id|page
comma
id|mapping
comma
id|offset
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|readpage
c_func
(paren
id|file
comma
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We arrive here in the unlikely event that someone &n;&t; * raced with us and added our page to the cache first&n;&t; * or we are out of memory for radix-tree nodes.&n;&t; */
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|error
op_eq
op_minus
id|EEXIST
ques
c_cond
l_int|0
suffix:colon
id|error
suffix:semicolon
)brace
DECL|macro|MMAP_LOTSAMISS
mdefine_line|#define MMAP_LOTSAMISS  (100)
multiline_comment|/*&n; * filemap_nopage() is invoked via the vma operations vector for a&n; * mapped memory region to read in file data during a page fault.&n; *&n; * The goto&squot;s are kind of ugly, but this streamlines the normal case of having&n; * it in the page cache, and handles the special cases reasonably without&n; * having a lot of duplicated code.&n; */
DECL|function|filemap_nopage
r_struct
id|page
op_star
id|filemap_nopage
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|area
comma
r_int
r_int
id|address
comma
r_int
op_star
id|type
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|file
op_star
id|file
op_assign
id|area-&gt;vm_file
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|file-&gt;f_mapping
suffix:semicolon
r_struct
id|file_ra_state
op_star
id|ra
op_assign
op_amp
id|file-&gt;f_ra
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|size
comma
id|pgoff
comma
id|endoff
suffix:semicolon
r_int
id|did_readaround
op_assign
l_int|0
comma
id|majmin
op_assign
id|VM_FAULT_MINOR
suffix:semicolon
id|pgoff
op_assign
(paren
(paren
id|address
op_minus
id|area-&gt;vm_start
)paren
op_rshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|area-&gt;vm_pgoff
suffix:semicolon
id|endoff
op_assign
(paren
(paren
id|area-&gt;vm_end
op_minus
id|area-&gt;vm_start
)paren
op_rshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|area-&gt;vm_pgoff
suffix:semicolon
id|retry_all
suffix:colon
id|size
op_assign
(paren
id|i_size_read
c_func
(paren
id|inode
)paren
op_plus
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|pgoff
op_ge
id|size
)paren
r_goto
id|outside_data_content
suffix:semicolon
multiline_comment|/* If we don&squot;t want any read-ahead, don&squot;t bother */
r_if
c_cond
(paren
id|VM_RandomReadHint
c_func
(paren
id|area
)paren
)paren
r_goto
id|no_cached_page
suffix:semicolon
multiline_comment|/*&n;&t; * The &quot;size&quot; of the file, as far as mmap is concerned, isn&squot;t bigger&n;&t; * than the mapping&n;&t; */
r_if
c_cond
(paren
id|size
OG
id|endoff
)paren
id|size
op_assign
id|endoff
suffix:semicolon
multiline_comment|/*&n;&t; * The readahead code wants to be told about each and every page&n;&t; * so it can build and shrink its windows appropriately&n;&t; *&n;&t; * For sequential accesses, we use the generic readahead logic.&n;&t; */
r_if
c_cond
(paren
id|VM_SequentialReadHint
c_func
(paren
id|area
)paren
)paren
id|page_cache_readahead
c_func
(paren
id|mapping
comma
id|ra
comma
id|file
comma
id|pgoff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do we have something in the page cache already?&n;&t; */
id|retry_find
suffix:colon
id|page
op_assign
id|find_get_page
c_func
(paren
id|mapping
comma
id|pgoff
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
r_int
r_int
id|ra_pages
suffix:semicolon
r_if
c_cond
(paren
id|VM_SequentialReadHint
c_func
(paren
id|area
)paren
)paren
(brace
id|handle_ra_miss
c_func
(paren
id|mapping
comma
id|ra
comma
id|pgoff
)paren
suffix:semicolon
r_goto
id|no_cached_page
suffix:semicolon
)brace
id|ra-&gt;mmap_miss
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Do we miss much more than hit in this file? If so,&n;&t;&t; * stop bothering with read-ahead. It will only hurt.&n;&t;&t; */
r_if
c_cond
(paren
id|ra-&gt;mmap_miss
OG
id|ra-&gt;mmap_hit
op_plus
id|MMAP_LOTSAMISS
)paren
r_goto
id|no_cached_page
suffix:semicolon
multiline_comment|/*&n;&t;&t; * To keep the pgmajfault counter straight, we need to&n;&t;&t; * check did_readaround, as this is an inner loop.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|did_readaround
)paren
(brace
id|majmin
op_assign
id|VM_FAULT_MAJOR
suffix:semicolon
id|inc_page_state
c_func
(paren
id|pgmajfault
)paren
suffix:semicolon
)brace
id|did_readaround
op_assign
l_int|1
suffix:semicolon
id|ra_pages
op_assign
id|max_sane_readahead
c_func
(paren
id|file-&gt;f_ra.ra_pages
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ra_pages
)paren
(brace
r_int
id|start
suffix:semicolon
id|start
op_assign
id|pgoff
op_minus
id|ra_pages
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|pgoff
OL
l_int|0
)paren
id|pgoff
op_assign
l_int|0
suffix:semicolon
id|do_page_cache_readahead
c_func
(paren
id|mapping
comma
id|file
comma
id|pgoff
comma
id|ra_pages
)paren
suffix:semicolon
)brace
id|page
op_assign
id|find_get_page
c_func
(paren
id|mapping
comma
id|pgoff
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|no_cached_page
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|did_readaround
)paren
id|ra-&gt;mmap_hit
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, found a page in the page cache, now we need to check&n;&t; * that it&squot;s up-to-date.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|page_not_uptodate
suffix:semicolon
id|success
suffix:colon
multiline_comment|/*&n;&t; * Found the page and have a reference on it.&n;&t; */
id|mark_page_accessed
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
)paren
op_star
id|type
op_assign
id|majmin
suffix:semicolon
r_return
id|page
suffix:semicolon
id|outside_data_content
suffix:colon
multiline_comment|/*&n;&t; * An external ptracer can access pages that normally aren&squot;t&n;&t; * accessible..&n;&t; */
r_if
c_cond
(paren
id|area-&gt;vm_mm
op_eq
id|current-&gt;mm
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Fall through to the non-read-ahead case */
id|no_cached_page
suffix:colon
multiline_comment|/*&n;&t; * We&squot;re only likely to ever get here if MADV_RANDOM is in&n;&t; * effect.&n;&t; */
id|error
op_assign
id|page_cache_read
c_func
(paren
id|file
comma
id|pgoff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The page we want has now been added to the page cache.&n;&t; * In the unlikely event that someone removed it in the&n;&t; * meantime, we&squot;ll just come back here and read it again.&n;&t; */
r_if
c_cond
(paren
id|error
op_ge
l_int|0
)paren
r_goto
id|retry_find
suffix:semicolon
multiline_comment|/*&n;&t; * An error return from page_cache_read can result if the&n;&t; * system is low on memory, or a problem occurs while trying&n;&t; * to schedule I/O.&n;&t; */
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|ENOMEM
)paren
r_return
id|NOPAGE_OOM
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
id|page_not_uptodate
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|did_readaround
)paren
(brace
id|majmin
op_assign
id|VM_FAULT_MAJOR
suffix:semicolon
id|inc_page_state
c_func
(paren
id|pgmajfault
)paren
suffix:semicolon
)brace
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Did it get unhashed while we waited for it? */
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;mapping
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|retry_all
suffix:semicolon
)brace
multiline_comment|/* Did somebody else get it up-to-date? */
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|success
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|readpage
c_func
(paren
id|file
comma
id|page
)paren
)paren
(brace
id|wait_on_page_locked
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|success
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Umm, take care of errors if the page isn&squot;t up-to-date.&n;&t; * Try to re-read it _once_. We do this synchronously,&n;&t; * because there really aren&squot;t any performance issues here&n;&t; * and we need to check for errors.&n;&t; */
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Somebody truncated the page on us? */
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;mapping
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|retry_all
suffix:semicolon
)brace
multiline_comment|/* Somebody else successfully read it in? */
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|success
suffix:semicolon
)brace
id|ClearPageError
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|readpage
c_func
(paren
id|file
comma
id|page
)paren
)paren
(brace
id|wait_on_page_locked
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|success
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Things didn&squot;t work out. Return zero to tell the&n;&t; * mm layer so, possibly freeing the page cache page first.&n;&t; */
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|variable|filemap_nopage
id|EXPORT_SYMBOL
c_func
(paren
id|filemap_nopage
)paren
suffix:semicolon
DECL|function|filemap_getpage
r_static
r_struct
id|page
op_star
id|filemap_getpage
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|pgoff
comma
r_int
id|nonblock
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|file-&gt;f_mapping
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Do we have something in the page cache already?&n;&t; */
id|retry_find
suffix:colon
id|page
op_assign
id|find_get_page
c_func
(paren
id|mapping
comma
id|pgoff
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
r_if
c_cond
(paren
id|nonblock
)paren
r_return
l_int|NULL
suffix:semicolon
r_goto
id|no_cached_page
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Ok, found a page in the page cache, now we need to check&n;&t; * that it&squot;s up-to-date.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|page_not_uptodate
suffix:semicolon
id|success
suffix:colon
multiline_comment|/*&n;&t; * Found the page and have a reference on it.&n;&t; */
id|mark_page_accessed
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|page
suffix:semicolon
id|no_cached_page
suffix:colon
id|error
op_assign
id|page_cache_read
c_func
(paren
id|file
comma
id|pgoff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The page we want has now been added to the page cache.&n;&t; * In the unlikely event that someone removed it in the&n;&t; * meantime, we&squot;ll just come back here and read it again.&n;&t; */
r_if
c_cond
(paren
id|error
op_ge
l_int|0
)paren
r_goto
id|retry_find
suffix:semicolon
multiline_comment|/*&n;&t; * An error return from page_cache_read can result if the&n;&t; * system is low on memory, or a problem occurs while trying&n;&t; * to schedule I/O.&n;&t; */
r_return
l_int|NULL
suffix:semicolon
id|page_not_uptodate
suffix:colon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Did it get unhashed while we waited for it? */
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;mapping
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
multiline_comment|/* Did somebody else get it up-to-date? */
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|success
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|readpage
c_func
(paren
id|file
comma
id|page
)paren
)paren
(brace
id|wait_on_page_locked
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|success
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Umm, take care of errors if the page isn&squot;t up-to-date.&n;&t; * Try to re-read it _once_. We do this synchronously,&n;&t; * because there really aren&squot;t any performance issues here&n;&t; * and we need to check for errors.&n;&t; */
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Somebody truncated the page on us? */
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;mapping
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
multiline_comment|/* Somebody else successfully read it in? */
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|success
suffix:semicolon
)brace
id|ClearPageError
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|readpage
c_func
(paren
id|file
comma
id|page
)paren
)paren
(brace
id|wait_on_page_locked
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|success
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Things didn&squot;t work out. Return zero to tell the&n;&t; * mm layer so, possibly freeing the page cache page first.&n;&t; */
id|err
suffix:colon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|filemap_populate
r_static
r_int
id|filemap_populate
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
comma
id|pgprot_t
id|prot
comma
r_int
r_int
id|pgoff
comma
r_int
id|nonblock
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|vma-&gt;vm_file
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|file-&gt;f_mapping
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nonblock
)paren
id|force_page_cache_readahead
c_func
(paren
id|mapping
comma
id|vma-&gt;vm_file
comma
id|pgoff
comma
id|len
op_rshift
id|PAGE_CACHE_SHIFT
)paren
suffix:semicolon
id|repeat
suffix:colon
id|size
op_assign
(paren
id|i_size_read
c_func
(paren
id|inode
)paren
op_plus
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|pgoff
op_plus
(paren
id|len
op_rshift
id|PAGE_CACHE_SHIFT
)paren
OG
id|size
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|page
op_assign
id|filemap_getpage
c_func
(paren
id|file
comma
id|pgoff
comma
id|nonblock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
op_logical_and
op_logical_neg
id|nonblock
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
id|err
op_assign
id|install_page
c_func
(paren
id|mm
comma
id|vma
comma
id|addr
comma
id|page
comma
id|prot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * If a nonlinear mapping then store the file page offset&n;&t;&t; * in the pte.&n;&t;&t; */
r_if
c_cond
(paren
id|pgoff
op_ne
id|linear_page_index
c_func
(paren
id|vma
comma
id|addr
)paren
)paren
(brace
id|err
op_assign
id|install_file_pte
c_func
(paren
id|mm
comma
id|vma
comma
id|addr
comma
id|pgoff
comma
id|prot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
)brace
)brace
id|len
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|pgoff
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|len
)paren
r_goto
id|repeat
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|generic_file_vm_ops
r_static
r_struct
id|vm_operations_struct
id|generic_file_vm_ops
op_assign
(brace
dot
id|nopage
op_assign
id|filemap_nopage
comma
dot
id|populate
op_assign
id|filemap_populate
comma
)brace
suffix:semicolon
multiline_comment|/* This is used for a general mmap of a disk file */
DECL|function|generic_file_mmap
r_int
id|generic_file_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|file-&gt;f_mapping
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mapping-&gt;a_ops-&gt;readpage
)paren
r_return
op_minus
id|ENOEXEC
suffix:semicolon
id|file_accessed
c_func
(paren
id|file
)paren
suffix:semicolon
id|vma-&gt;vm_ops
op_assign
op_amp
id|generic_file_vm_ops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This is for filesystems which do not implement -&gt;writepage.&n; */
DECL|function|generic_file_readonly_mmap
r_int
id|generic_file_readonly_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_if
c_cond
(paren
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_SHARED
)paren
op_logical_and
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_MAYWRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|generic_file_mmap
c_func
(paren
id|file
comma
id|vma
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|function|generic_file_mmap
r_int
id|generic_file_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|generic_file_readonly_mmap
r_int
id|generic_file_readonly_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_MMU */
DECL|variable|generic_file_mmap
id|EXPORT_SYMBOL
c_func
(paren
id|generic_file_mmap
)paren
suffix:semicolon
DECL|variable|generic_file_readonly_mmap
id|EXPORT_SYMBOL
c_func
(paren
id|generic_file_readonly_mmap
)paren
suffix:semicolon
DECL|function|__read_cache_page
r_static
r_inline
r_struct
id|page
op_star
id|__read_cache_page
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
r_int
id|index
comma
r_int
(paren
op_star
id|filler
)paren
(paren
r_void
op_star
comma
r_struct
id|page
op_star
)paren
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|page
op_star
id|page
comma
op_star
id|cached_page
op_assign
l_int|NULL
suffix:semicolon
r_int
id|err
suffix:semicolon
id|repeat
suffix:colon
id|page
op_assign
id|find_get_page
c_func
(paren
id|mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cached_page
)paren
(brace
id|cached_page
op_assign
id|page_cache_alloc_cold
c_func
(paren
id|mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cached_page
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|err
op_assign
id|add_to_page_cache_lru
c_func
(paren
id|cached_page
comma
id|mapping
comma
id|index
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EEXIST
)paren
r_goto
id|repeat
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
multiline_comment|/* Presumably ENOMEM for radix tree node */
id|page_cache_release
c_func
(paren
id|cached_page
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
id|page
op_assign
id|cached_page
suffix:semicolon
id|cached_page
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
id|filler
c_func
(paren
id|data
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|page
op_assign
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cached_page
)paren
id|page_cache_release
c_func
(paren
id|cached_page
)paren
suffix:semicolon
r_return
id|page
suffix:semicolon
)brace
multiline_comment|/*&n; * Read into the page cache. If a page already exists,&n; * and PageUptodate() is not set, try to fill the page.&n; */
DECL|function|read_cache_page
r_struct
id|page
op_star
id|read_cache_page
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
r_int
id|index
comma
r_int
(paren
op_star
id|filler
)paren
(paren
r_void
op_star
comma
r_struct
id|page
op_star
)paren
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|err
suffix:semicolon
id|retry
suffix:colon
id|page
op_assign
id|__read_cache_page
c_func
(paren
id|mapping
comma
id|index
comma
id|filler
comma
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
r_goto
id|out
suffix:semicolon
id|mark_page_accessed
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|out
suffix:semicolon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;mapping
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|err
op_assign
id|filler
c_func
(paren
id|data
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|page
op_assign
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|page
suffix:semicolon
)brace
DECL|variable|read_cache_page
id|EXPORT_SYMBOL
c_func
(paren
id|read_cache_page
)paren
suffix:semicolon
multiline_comment|/*&n; * If the page was newly created, increment its refcount and add it to the&n; * caller&squot;s lru-buffering pagevec.  This function is specifically for&n; * generic_file_write().&n; */
r_static
r_inline
r_struct
id|page
op_star
DECL|function|__grab_cache_page
id|__grab_cache_page
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
r_int
id|index
comma
r_struct
id|page
op_star
op_star
id|cached_page
comma
r_struct
id|pagevec
op_star
id|lru_pvec
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|repeat
suffix:colon
id|page
op_assign
id|find_lock_page
c_func
(paren
id|mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|cached_page
)paren
(brace
op_star
id|cached_page
op_assign
id|page_cache_alloc
c_func
(paren
id|mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|cached_page
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
id|err
op_assign
id|add_to_page_cache
c_func
(paren
op_star
id|cached_page
comma
id|mapping
comma
id|index
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EEXIST
)paren
r_goto
id|repeat
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
(brace
id|page
op_assign
op_star
id|cached_page
suffix:semicolon
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagevec_add
c_func
(paren
id|lru_pvec
comma
id|page
)paren
)paren
id|__pagevec_lru_add
c_func
(paren
id|lru_pvec
)paren
suffix:semicolon
op_star
id|cached_page
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|page
suffix:semicolon
)brace
multiline_comment|/*&n; * The logic we want is&n; *&n; *&t;if suid or (sgid and xgrp)&n; *&t;&t;remove privs&n; */
DECL|function|remove_suid
r_int
id|remove_suid
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
id|mode_t
id|mode
op_assign
id|dentry-&gt;d_inode-&gt;i_mode
suffix:semicolon
r_int
id|kill
op_assign
l_int|0
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* suid always must be killed */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|mode
op_amp
id|S_ISUID
)paren
)paren
id|kill
op_assign
id|ATTR_KILL_SUID
suffix:semicolon
multiline_comment|/*&n;&t; * sgid without any exec bits is just a mandatory locking mark; leave&n;&t; * it alone.  If some exec bits are set, it&squot;s a real sgid; kill it.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|mode
op_amp
id|S_ISGID
)paren
op_logical_and
(paren
id|mode
op_amp
id|S_IXGRP
)paren
)paren
)paren
id|kill
op_or_assign
id|ATTR_KILL_SGID
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|kill
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_FSETID
)paren
)paren
)paren
(brace
r_struct
id|iattr
id|newattrs
suffix:semicolon
id|newattrs.ia_valid
op_assign
id|ATTR_FORCE
op_or
id|kill
suffix:semicolon
id|result
op_assign
id|notify_change
c_func
(paren
id|dentry
comma
op_amp
id|newattrs
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|variable|remove_suid
id|EXPORT_SYMBOL
c_func
(paren
id|remove_suid
)paren
suffix:semicolon
multiline_comment|/*&n; * Copy as much as we can into the page and return the number of bytes which&n; * were sucessfully copied.  If a fault is encountered then clear the page&n; * out to (offset+bytes) and return the number of bytes which were copied.&n; */
r_static
r_inline
r_int
DECL|function|filemap_copy_from_user
id|filemap_copy_from_user
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_const
r_char
id|__user
op_star
id|buf
comma
r_int
id|bytes
)paren
(brace
r_char
op_star
id|kaddr
suffix:semicolon
r_int
id|left
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|left
op_assign
id|__copy_from_user
c_func
(paren
id|kaddr
op_plus
id|offset
comma
id|buf
comma
id|bytes
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|left
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Do it the slow way */
id|kaddr
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|left
op_assign
id|__copy_from_user
c_func
(paren
id|kaddr
op_plus
id|offset
comma
id|buf
comma
id|bytes
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
id|bytes
op_minus
id|left
suffix:semicolon
)brace
r_static
r_int
DECL|function|__filemap_copy_from_user_iovec
id|__filemap_copy_from_user_iovec
c_func
(paren
r_char
op_star
id|vaddr
comma
r_const
r_struct
id|iovec
op_star
id|iov
comma
r_int
id|base
comma
r_int
id|bytes
)paren
(brace
r_int
id|copied
op_assign
l_int|0
comma
id|left
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|bytes
)paren
(brace
r_char
id|__user
op_star
id|buf
op_assign
id|iov-&gt;iov_base
op_plus
id|base
suffix:semicolon
r_int
id|copy
op_assign
id|min
c_func
(paren
id|bytes
comma
id|iov-&gt;iov_len
op_minus
id|base
)paren
suffix:semicolon
id|base
op_assign
l_int|0
suffix:semicolon
id|left
op_assign
id|__copy_from_user
c_func
(paren
id|vaddr
comma
id|buf
comma
id|copy
)paren
suffix:semicolon
id|copied
op_add_assign
id|copy
suffix:semicolon
id|bytes
op_sub_assign
id|copy
suffix:semicolon
id|vaddr
op_add_assign
id|copy
suffix:semicolon
id|iov
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|left
)paren
)paren
(brace
multiline_comment|/* zero the rest of the target like __copy_from_user */
r_if
c_cond
(paren
id|bytes
)paren
id|memset
c_func
(paren
id|vaddr
comma
l_int|0
comma
id|bytes
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|copied
op_minus
id|left
suffix:semicolon
)brace
multiline_comment|/*&n; * This has the same sideeffects and return value as filemap_copy_from_user().&n; * The difference is that on a fault we need to memset the remainder of the&n; * page (out to offset+bytes), to emulate filemap_copy_from_user()&squot;s&n; * single-segment behaviour.&n; */
r_static
r_inline
r_int
DECL|function|filemap_copy_from_user_iovec
id|filemap_copy_from_user_iovec
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_const
r_struct
id|iovec
op_star
id|iov
comma
r_int
id|base
comma
r_int
id|bytes
)paren
(brace
r_char
op_star
id|kaddr
suffix:semicolon
r_int
id|copied
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|copied
op_assign
id|__filemap_copy_from_user_iovec
c_func
(paren
id|kaddr
op_plus
id|offset
comma
id|iov
comma
id|base
comma
id|bytes
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copied
op_ne
id|bytes
)paren
(brace
id|kaddr
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|copied
op_assign
id|__filemap_copy_from_user_iovec
c_func
(paren
id|kaddr
op_plus
id|offset
comma
id|iov
comma
id|base
comma
id|bytes
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
id|copied
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|filemap_set_next_iovec
id|filemap_set_next_iovec
c_func
(paren
r_const
r_struct
id|iovec
op_star
op_star
id|iovp
comma
r_int
op_star
id|basep
comma
r_int
id|bytes
)paren
(brace
r_const
r_struct
id|iovec
op_star
id|iov
op_assign
op_star
id|iovp
suffix:semicolon
r_int
id|base
op_assign
op_star
id|basep
suffix:semicolon
r_while
c_loop
(paren
id|bytes
)paren
(brace
r_int
id|copy
op_assign
id|min
c_func
(paren
id|bytes
comma
id|iov-&gt;iov_len
op_minus
id|base
)paren
suffix:semicolon
id|bytes
op_sub_assign
id|copy
suffix:semicolon
id|base
op_add_assign
id|copy
suffix:semicolon
r_if
c_cond
(paren
id|iov-&gt;iov_len
op_eq
id|base
)paren
(brace
id|iov
op_increment
suffix:semicolon
id|base
op_assign
l_int|0
suffix:semicolon
)brace
)brace
op_star
id|iovp
op_assign
id|iov
suffix:semicolon
op_star
id|basep
op_assign
id|base
suffix:semicolon
)brace
multiline_comment|/*&n; * Performs necessary checks before doing a write&n; *&n; * Can adjust writing position aor amount of bytes to write.&n; * Returns appropriate error code that caller should return or&n; * zero in case that write should be allowed.&n; */
DECL|function|generic_write_checks
r_inline
r_int
id|generic_write_checks
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
op_star
id|pos
comma
r_int
op_star
id|count
comma
r_int
id|isblk
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_mapping-&gt;host
suffix:semicolon
r_int
r_int
id|limit
op_assign
id|current-&gt;rlim
(braket
id|RLIMIT_FSIZE
)braket
dot
id|rlim_cur
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_star
id|pos
OL
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|file-&gt;f_error
)paren
)paren
(brace
r_int
id|err
op_assign
id|file-&gt;f_error
suffix:semicolon
id|file-&gt;f_error
op_assign
l_int|0
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|isblk
)paren
(brace
multiline_comment|/* FIXME: this is for backwards compatibility with 2.4 */
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_APPEND
)paren
op_star
id|pos
op_assign
id|i_size_read
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|limit
op_ne
id|RLIM_INFINITY
)paren
(brace
r_if
c_cond
(paren
op_star
id|pos
op_ge
id|limit
)paren
(brace
id|send_sig
c_func
(paren
id|SIGXFSZ
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|EFBIG
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|count
OG
id|limit
op_minus
(paren
id|typeof
c_func
(paren
id|limit
)paren
)paren
op_star
id|pos
)paren
(brace
op_star
id|count
op_assign
id|limit
op_minus
(paren
id|typeof
c_func
(paren
id|limit
)paren
)paren
op_star
id|pos
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * LFS rule&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_star
id|pos
op_plus
op_star
id|count
OG
id|MAX_NON_LFS
op_logical_and
op_logical_neg
(paren
id|file-&gt;f_flags
op_amp
id|O_LARGEFILE
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_star
id|pos
op_ge
id|MAX_NON_LFS
)paren
(brace
id|send_sig
c_func
(paren
id|SIGXFSZ
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|EFBIG
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|count
OG
id|MAX_NON_LFS
op_minus
(paren
r_int
r_int
)paren
op_star
id|pos
)paren
(brace
op_star
id|count
op_assign
id|MAX_NON_LFS
op_minus
(paren
r_int
r_int
)paren
op_star
id|pos
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Are we about to exceed the fs block limit ?&n;&t; *&n;&t; * If we have written data it becomes a short write.  If we have&n;&t; * exceeded without writing data we send a signal and return EFBIG.&n;&t; * Linus frestrict idea will clean these up nicely..&n;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|isblk
)paren
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_star
id|pos
op_ge
id|inode-&gt;i_sb-&gt;s_maxbytes
)paren
)paren
(brace
r_if
c_cond
(paren
op_star
id|count
op_logical_or
op_star
id|pos
OG
id|inode-&gt;i_sb-&gt;s_maxbytes
)paren
(brace
id|send_sig
c_func
(paren
id|SIGXFSZ
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|EFBIG
suffix:semicolon
)brace
multiline_comment|/* zero-length writes at -&gt;s_maxbytes are OK */
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_star
id|pos
op_plus
op_star
id|count
OG
id|inode-&gt;i_sb-&gt;s_maxbytes
)paren
)paren
op_star
id|count
op_assign
id|inode-&gt;i_sb-&gt;s_maxbytes
op_minus
op_star
id|pos
suffix:semicolon
)brace
r_else
(brace
id|loff_t
id|isize
suffix:semicolon
r_if
c_cond
(paren
id|bdev_read_only
c_func
(paren
id|I_BDEV
c_func
(paren
id|inode
)paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|isize
op_assign
id|i_size_read
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pos
op_ge
id|isize
)paren
(brace
r_if
c_cond
(paren
op_star
id|count
op_logical_or
op_star
id|pos
OG
id|isize
)paren
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pos
op_plus
op_star
id|count
OG
id|isize
)paren
op_star
id|count
op_assign
id|isize
op_minus
op_star
id|pos
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|generic_write_checks
id|EXPORT_SYMBOL
c_func
(paren
id|generic_write_checks
)paren
suffix:semicolon
multiline_comment|/*&n; * Write to a file through the page cache. &n; * Called under i_sem for S_ISREG files.&n; *&n; * We put everything into the page cache prior to writing it. This is not a&n; * problem when writing full pages. With partial pages, however, we first have&n; * to read the data into the cache, then dirty the page, and finally schedule&n; * it for writing by marking it dirty.&n; *&t;&t;&t;&t;&t;&t;&t;okir@monad.swb.de&n; */
id|ssize_t
DECL|function|generic_file_aio_write_nolock
id|generic_file_aio_write_nolock
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_const
r_struct
id|iovec
op_star
id|iov
comma
r_int
r_int
id|nr_segs
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|iocb-&gt;ki_filp
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|file-&gt;f_mapping
suffix:semicolon
r_struct
id|address_space_operations
op_star
id|a_ops
op_assign
id|mapping-&gt;a_ops
suffix:semicolon
r_int
id|ocount
suffix:semicolon
multiline_comment|/* original count */
r_int
id|count
suffix:semicolon
multiline_comment|/* after file limit checks */
r_struct
id|inode
op_star
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
id|loff_t
id|pos
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_struct
id|page
op_star
id|cached_page
op_assign
l_int|NULL
suffix:semicolon
r_const
r_int
id|isblk
op_assign
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
suffix:semicolon
id|ssize_t
id|written
suffix:semicolon
id|ssize_t
id|err
suffix:semicolon
r_int
id|bytes
suffix:semicolon
r_struct
id|pagevec
id|lru_pvec
suffix:semicolon
r_const
r_struct
id|iovec
op_star
id|cur_iov
op_assign
id|iov
suffix:semicolon
multiline_comment|/* current iovec */
r_int
id|iov_base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* offset in the current iovec */
r_int
r_int
id|seg
suffix:semicolon
r_char
id|__user
op_star
id|buf
suffix:semicolon
id|ocount
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|seg
op_assign
l_int|0
suffix:semicolon
id|seg
OL
id|nr_segs
suffix:semicolon
id|seg
op_increment
)paren
(brace
r_const
r_struct
id|iovec
op_star
id|iv
op_assign
op_amp
id|iov
(braket
id|seg
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If any segment has a negative length, or the cumulative&n;&t;&t; * length ever wraps negative then return -EINVAL.&n;&t;&t; */
id|ocount
op_add_assign
id|iv-&gt;iov_len
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|ssize_t
)paren
(paren
id|ocount
op_or
id|iv-&gt;iov_len
)paren
OL
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|iv-&gt;iov_base
comma
id|iv-&gt;iov_len
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|seg
op_eq
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|nr_segs
op_assign
id|seg
suffix:semicolon
id|ocount
op_sub_assign
id|iv-&gt;iov_len
suffix:semicolon
multiline_comment|/* This segment is no good */
r_break
suffix:semicolon
)brace
id|count
op_assign
id|ocount
suffix:semicolon
id|pos
op_assign
op_star
id|ppos
suffix:semicolon
id|pagevec_init
c_func
(paren
op_amp
id|lru_pvec
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* We can write back this queue in page reclaim */
id|current-&gt;backing_dev_info
op_assign
id|mapping-&gt;backing_dev_info
suffix:semicolon
id|written
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|generic_write_checks
c_func
(paren
id|file
comma
op_amp
id|pos
comma
op_amp
id|count
comma
id|isblk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|remove_suid
c_func
(paren
id|file-&gt;f_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|inode_update_time
c_func
(paren
id|inode
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* coalesce the iovecs and go direct-to-BIO for O_DIRECT */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|file-&gt;f_flags
op_amp
id|O_DIRECT
)paren
)paren
(brace
r_if
c_cond
(paren
id|count
op_ne
id|ocount
)paren
id|nr_segs
op_assign
id|iov_shorten
c_func
(paren
(paren
r_struct
id|iovec
op_star
)paren
id|iov
comma
id|nr_segs
comma
id|count
)paren
suffix:semicolon
id|written
op_assign
id|generic_file_direct_IO
c_func
(paren
id|WRITE
comma
id|iocb
comma
id|iov
comma
id|pos
comma
id|nr_segs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|written
OG
l_int|0
)paren
(brace
id|loff_t
id|end
op_assign
id|pos
op_plus
id|written
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|i_size_read
c_func
(paren
id|inode
)paren
op_logical_and
op_logical_neg
id|isblk
)paren
(brace
id|i_size_write
c_func
(paren
id|inode
comma
id|end
)paren
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
op_star
id|ppos
op_assign
id|end
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Sync the fs metadata but not the minor inode changes and&n;&t;&t; * of course not the data as we did direct DMA for the IO.&n;&t;&t; * i_sem is held, which protects generic_osync_inode() from&n;&t;&t; * livelocking.&n;&t;&t; */
r_if
c_cond
(paren
id|written
op_ge
l_int|0
op_logical_and
id|file-&gt;f_flags
op_amp
id|O_SYNC
)paren
id|status
op_assign
id|generic_osync_inode
c_func
(paren
id|inode
comma
id|mapping
comma
id|OSYNC_METADATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|written
op_eq
id|count
op_logical_and
op_logical_neg
id|is_sync_kiocb
c_func
(paren
id|iocb
)paren
)paren
id|written
op_assign
op_minus
id|EIOCBQUEUED
suffix:semicolon
r_if
c_cond
(paren
id|written
OL
l_int|0
op_logical_or
id|written
op_eq
id|count
)paren
r_goto
id|out_status
suffix:semicolon
multiline_comment|/*&n;&t;&t; * direct-io write to a hole: fall through to buffered I/O&n;&t;&t; * for completing the rest of the request.&n;&t;&t; */
id|pos
op_add_assign
id|written
suffix:semicolon
id|count
op_sub_assign
id|written
suffix:semicolon
)brace
id|buf
op_assign
id|iov-&gt;iov_base
suffix:semicolon
r_do
(brace
r_int
r_int
id|index
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_int
id|copied
suffix:semicolon
id|offset
op_assign
(paren
id|pos
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* Within page */
id|index
op_assign
id|pos
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|bytes
op_assign
id|PAGE_CACHE_SIZE
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|bytes
OG
id|count
)paren
id|bytes
op_assign
id|count
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Bring in the user page that we will copy from _first_.&n;&t;&t; * Otherwise there&squot;s a nasty deadlock on copying from the&n;&t;&t; * same page as we&squot;re writing to, without it being marked&n;&t;&t; * up-to-date.&n;&t;&t; */
id|fault_in_pages_readable
c_func
(paren
id|buf
comma
id|bytes
)paren
suffix:semicolon
id|page
op_assign
id|__grab_cache_page
c_func
(paren
id|mapping
comma
id|index
comma
op_amp
id|cached_page
comma
op_amp
id|lru_pvec
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
id|status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|status
op_assign
id|a_ops
op_member_access_from_pointer
id|prepare_write
c_func
(paren
id|file
comma
id|page
comma
id|offset
comma
id|offset
op_plus
id|bytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|status
)paren
)paren
(brace
id|loff_t
id|isize
op_assign
id|i_size_read
c_func
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * prepare_write() may have instantiated a few blocks&n;&t;&t;&t; * outside i_size.  Trim these off again.&n;&t;&t;&t; */
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_plus
id|bytes
OG
id|isize
)paren
id|vmtruncate
c_func
(paren
id|inode
comma
id|isize
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|nr_segs
op_eq
l_int|1
)paren
)paren
id|copied
op_assign
id|filemap_copy_from_user
c_func
(paren
id|page
comma
id|offset
comma
id|buf
comma
id|bytes
)paren
suffix:semicolon
r_else
id|copied
op_assign
id|filemap_copy_from_user_iovec
c_func
(paren
id|page
comma
id|offset
comma
id|cur_iov
comma
id|iov_base
comma
id|bytes
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|status
op_assign
id|a_ops
op_member_access_from_pointer
id|commit_write
c_func
(paren
id|file
comma
id|page
comma
id|offset
comma
id|offset
op_plus
id|bytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|copied
OG
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
id|status
op_assign
id|copied
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ge
l_int|0
)paren
(brace
id|written
op_add_assign
id|status
suffix:semicolon
id|count
op_sub_assign
id|status
suffix:semicolon
id|pos
op_add_assign
id|status
suffix:semicolon
id|buf
op_add_assign
id|status
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|nr_segs
OG
l_int|1
)paren
)paren
id|filemap_set_next_iovec
c_func
(paren
op_amp
id|cur_iov
comma
op_amp
id|iov_base
comma
id|status
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|copied
op_ne
id|bytes
)paren
)paren
r_if
c_cond
(paren
id|status
op_ge
l_int|0
)paren
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|mark_page_accessed
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_break
suffix:semicolon
id|balance_dirty_pages_ratelimited
c_func
(paren
id|mapping
)paren
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
)paren
suffix:semicolon
op_star
id|ppos
op_assign
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|cached_page
)paren
id|page_cache_release
c_func
(paren
id|cached_page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * For now, when the user asks for O_SYNC, we&squot;ll actually give O_DSYNC&n;&t; */
r_if
c_cond
(paren
id|status
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|file-&gt;f_flags
op_amp
id|O_SYNC
)paren
op_logical_or
id|IS_SYNC
c_func
(paren
id|inode
)paren
)paren
id|status
op_assign
id|generic_osync_inode
c_func
(paren
id|inode
comma
id|mapping
comma
id|OSYNC_METADATA
op_or
id|OSYNC_DATA
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we get here for O_DIRECT writes then we must have fallen through&n;&t; * to buffered writes (block instantiation inside i_size).  So we sync&n;&t; * the file data here, to try to honour O_DIRECT expectations.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|file-&gt;f_flags
op_amp
id|O_DIRECT
)paren
op_logical_and
id|written
)paren
id|status
op_assign
id|filemap_write_and_wait
c_func
(paren
id|mapping
)paren
suffix:semicolon
id|out_status
suffix:colon
id|err
op_assign
id|written
ques
c_cond
id|written
suffix:colon
id|status
suffix:semicolon
id|out
suffix:colon
id|pagevec_lru_add
c_func
(paren
op_amp
id|lru_pvec
)paren
suffix:semicolon
id|current-&gt;backing_dev_info
op_assign
l_int|0
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|generic_file_aio_write_nolock
id|EXPORT_SYMBOL
c_func
(paren
id|generic_file_aio_write_nolock
)paren
suffix:semicolon
id|ssize_t
DECL|function|generic_file_write_nolock
id|generic_file_write_nolock
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_struct
id|iovec
op_star
id|iov
comma
r_int
r_int
id|nr_segs
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|kiocb
id|kiocb
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
id|init_sync_kiocb
c_func
(paren
op_amp
id|kiocb
comma
id|file
)paren
suffix:semicolon
id|ret
op_assign
id|generic_file_aio_write_nolock
c_func
(paren
op_amp
id|kiocb
comma
id|iov
comma
id|nr_segs
comma
id|ppos
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
id|EIOCBQUEUED
op_eq
id|ret
)paren
id|ret
op_assign
id|wait_on_sync_kiocb
c_func
(paren
op_amp
id|kiocb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|generic_file_write_nolock
id|EXPORT_SYMBOL
c_func
(paren
id|generic_file_write_nolock
)paren
suffix:semicolon
DECL|function|generic_file_aio_write
id|ssize_t
id|generic_file_aio_write
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_const
r_char
id|__user
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
id|pos
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|iocb-&gt;ki_filp
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_mapping-&gt;host
suffix:semicolon
id|ssize_t
id|err
suffix:semicolon
r_struct
id|iovec
id|local_iov
op_assign
(brace
dot
id|iov_base
op_assign
(paren
r_void
id|__user
op_star
)paren
id|buf
comma
dot
id|iov_len
op_assign
id|count
)brace
suffix:semicolon
id|BUG_ON
c_func
(paren
id|iocb-&gt;ki_pos
op_ne
id|pos
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|err
op_assign
id|generic_file_aio_write_nolock
c_func
(paren
id|iocb
comma
op_amp
id|local_iov
comma
l_int|1
comma
op_amp
id|iocb-&gt;ki_pos
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|generic_file_aio_write
id|EXPORT_SYMBOL
c_func
(paren
id|generic_file_aio_write
)paren
suffix:semicolon
DECL|function|generic_file_write
id|ssize_t
id|generic_file_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
id|__user
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_mapping-&gt;host
suffix:semicolon
id|ssize_t
id|err
suffix:semicolon
r_struct
id|iovec
id|local_iov
op_assign
(brace
dot
id|iov_base
op_assign
(paren
r_void
id|__user
op_star
)paren
id|buf
comma
dot
id|iov_len
op_assign
id|count
)brace
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|err
op_assign
id|generic_file_write_nolock
c_func
(paren
id|file
comma
op_amp
id|local_iov
comma
l_int|1
comma
id|ppos
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|generic_file_write
id|EXPORT_SYMBOL
c_func
(paren
id|generic_file_write
)paren
suffix:semicolon
DECL|function|generic_file_readv
id|ssize_t
id|generic_file_readv
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_const
r_struct
id|iovec
op_star
id|iov
comma
r_int
r_int
id|nr_segs
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|kiocb
id|kiocb
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
id|init_sync_kiocb
c_func
(paren
op_amp
id|kiocb
comma
id|filp
)paren
suffix:semicolon
id|ret
op_assign
id|__generic_file_aio_read
c_func
(paren
op_amp
id|kiocb
comma
id|iov
comma
id|nr_segs
comma
id|ppos
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
id|EIOCBQUEUED
op_eq
id|ret
)paren
id|ret
op_assign
id|wait_on_sync_kiocb
c_func
(paren
op_amp
id|kiocb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|generic_file_readv
id|EXPORT_SYMBOL
c_func
(paren
id|generic_file_readv
)paren
suffix:semicolon
DECL|function|generic_file_writev
id|ssize_t
id|generic_file_writev
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_struct
id|iovec
op_star
id|iov
comma
r_int
r_int
id|nr_segs
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_mapping-&gt;host
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|ret
op_assign
id|generic_file_write_nolock
c_func
(paren
id|file
comma
id|iov
comma
id|nr_segs
comma
id|ppos
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|generic_file_writev
id|EXPORT_SYMBOL
c_func
(paren
id|generic_file_writev
)paren
suffix:semicolon
multiline_comment|/*&n; * Called under i_sem for writes to S_ISREG files&n; */
id|ssize_t
DECL|function|generic_file_direct_IO
id|generic_file_direct_IO
c_func
(paren
r_int
id|rw
comma
r_struct
id|kiocb
op_star
id|iocb
comma
r_const
r_struct
id|iovec
op_star
id|iov
comma
id|loff_t
id|offset
comma
r_int
r_int
id|nr_segs
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|iocb-&gt;ki_filp
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|file-&gt;f_mapping
suffix:semicolon
id|ssize_t
id|retval
suffix:semicolon
id|retval
op_assign
id|filemap_write_and_wait
c_func
(paren
id|mapping
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
l_int|0
)paren
(brace
id|retval
op_assign
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|direct_IO
c_func
(paren
id|rw
comma
id|iocb
comma
id|iov
comma
id|offset
comma
id|nr_segs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_eq
id|WRITE
op_logical_and
id|mapping-&gt;nrpages
)paren
id|invalidate_inode_pages2
c_func
(paren
id|mapping
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|generic_file_direct_IO
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|generic_file_direct_IO
)paren
suffix:semicolon
eof
