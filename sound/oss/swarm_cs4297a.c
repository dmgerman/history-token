multiline_comment|/*******************************************************************************&n;*&n;*      &quot;swarm_cs4297a.c&quot; --  Cirrus Logic-Crystal CS4297a linux audio driver.&n;*&n;*      Copyright (C) 2001  Broadcom Corporation.&n;*      Copyright (C) 2000,2001  Cirrus Logic Corp.  &n;*            -- adapted from drivers by Thomas Sailer, &n;*            -- but don&squot;t bug him; Problems should go to:&n;*            -- tom woller (twoller@crystal.cirrus.com) or&n;*               (audio@crystal.cirrus.com).&n;*            -- adapted from cs4281 PCI driver for cs4297a on&n;*               BCM1250 Synchronous Serial interface&n;*               (Kip Walker, Broadcom Corp.)&n;*      Copyright (C) 2004  Maciej W. Rozycki&n;*      Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)&n;*&n;*      This program is free software; you can redistribute it and/or modify&n;*      it under the terms of the GNU General Public License as published by&n;*      the Free Software Foundation; either version 2 of the License, or&n;*      (at your option) any later version.&n;*&n;*      This program is distributed in the hope that it will be useful,&n;*      but WITHOUT ANY WARRANTY; without even the implied warranty of&n;*      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;*      GNU General Public License for more details.&n;*&n;*      You should have received a copy of the GNU General Public License&n;*      along with this program; if not, write to the Free Software&n;*      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;*&n;* Module command line parameters:&n;*   none&n;*&n;*  Supported devices:&n;*  /dev/dsp    standard /dev/dsp device, (mostly) OSS compatible&n;*  /dev/mixer  standard /dev/mixer device, (mostly) OSS compatible&n;*  /dev/midi   simple MIDI UART interface, no ioctl&n;*&n;* Modification History&n;* 08/20/00 trw - silence and no stopping DAC until release&n;* 08/23/00 trw - added CS_DBG statements, fix interrupt hang issue on DAC stop.&n;* 09/18/00 trw - added 16bit only record with conversion &n;* 09/24/00 trw - added Enhanced Full duplex (separate simultaneous &n;*                capture/playback rates)&n;* 10/03/00 trw - fixed mmap (fixed GRECORD and the XMMS mmap test plugin  &n;*                libOSSm.so)&n;* 10/11/00 trw - modified for 2.4.0-test9 kernel enhancements (NR_MAP removal)&n;* 11/03/00 trw - fixed interrupt loss/stutter, added debug.&n;* 11/10/00 bkz - added __devinit to cs4297a_hw_init()&n;* 11/10/00 trw - fixed SMP and capture spinlock hang.&n;* 12/04/00 trw - cleaned up CSDEBUG flags and added &quot;defaultorder&quot; moduleparm.&n;* 12/05/00 trw - fixed polling (myth2), and added underrun swptr fix.&n;* 12/08/00 trw - added PM support. &n;* 12/14/00 trw - added wrapper code, builds under 2.4.0, 2.2.17-20, 2.2.17-8 &n;*&t;&t; (RH/Dell base), 2.2.18, 2.2.12.  cleaned up code mods by ident.&n;* 12/19/00 trw - added PM support for 2.2 base (apm_callback). other PM cleanup.&n;* 12/21/00 trw - added fractional &quot;defaultorder&quot; inputs. if &gt;100 then use &n;*&t;&t; defaultorder-100 as power of 2 for the buffer size. example:&n;*&t;&t; 106 = 2^(106-100) = 2^6 = 64 bytes for the buffer size.&n;*&n;*******************************************************************************/
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sound.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/soundcard.h&gt;
macro_line|#include &lt;linux/ac97_codec.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/sibyte/sb1250_regs.h&gt;
macro_line|#include &lt;asm/sibyte/sb1250_int.h&gt;
macro_line|#include &lt;asm/sibyte/sb1250_dma.h&gt;
macro_line|#include &lt;asm/sibyte/sb1250_scd.h&gt;
macro_line|#include &lt;asm/sibyte/sb1250_syncser.h&gt;
macro_line|#include &lt;asm/sibyte/sb1250_mac.h&gt;
macro_line|#include &lt;asm/sibyte/sb1250.h&gt;
r_struct
id|cs4297a_state
suffix:semicolon
r_static
r_void
id|stop_dac
c_func
(paren
r_struct
id|cs4297a_state
op_star
id|s
)paren
suffix:semicolon
r_static
r_void
id|stop_adc
c_func
(paren
r_struct
id|cs4297a_state
op_star
id|s
)paren
suffix:semicolon
r_static
r_void
id|start_dac
c_func
(paren
r_struct
id|cs4297a_state
op_star
id|s
)paren
suffix:semicolon
r_static
r_void
id|start_adc
c_func
(paren
r_struct
id|cs4297a_state
op_star
id|s
)paren
suffix:semicolon
DECL|macro|OSS_DOCUMENTED_MIXER_SEMANTICS
macro_line|#undef OSS_DOCUMENTED_MIXER_SEMANTICS
singleline_comment|// --------------------------------------------------------------------- 
DECL|macro|CS4297a_MAGIC
mdefine_line|#define CS4297a_MAGIC           0xf00beef1
singleline_comment|// buffer order determines the size of the dma buffer for the driver.
singleline_comment|// under Linux, a smaller buffer allows more responsiveness from many of the 
singleline_comment|// applications (e.g. games).  A larger buffer allows some of the apps (esound) 
singleline_comment|// to not underrun the dma buffer as easily.  As default, use 32k (order=3)
singleline_comment|// rather than 64k as some of the games work more responsively.
singleline_comment|// log base 2( buff sz = 32k).
singleline_comment|//static unsigned long defaultorder = 3;
singleline_comment|//MODULE_PARM(defaultorder, &quot;i&quot;);
singleline_comment|//
singleline_comment|// Turn on/off debugging compilation by commenting out &quot;#define CSDEBUG&quot;
singleline_comment|//
DECL|macro|CSDEBUG
mdefine_line|#define CSDEBUG 0
macro_line|#if CSDEBUG
DECL|macro|CSDEBUG_INTERFACE
mdefine_line|#define CSDEBUG_INTERFACE 1
macro_line|#else
DECL|macro|CSDEBUG_INTERFACE
macro_line|#undef CSDEBUG_INTERFACE
macro_line|#endif
singleline_comment|//
singleline_comment|// cs_debugmask areas
singleline_comment|//
DECL|macro|CS_INIT
mdefine_line|#define CS_INIT&t; &t;0x00000001&t;
singleline_comment|// initialization and probe functions
DECL|macro|CS_ERROR
mdefine_line|#define CS_ERROR &t;0x00000002&t;
singleline_comment|// tmp debugging bit placeholder
DECL|macro|CS_INTERRUPT
mdefine_line|#define CS_INTERRUPT&t;0x00000004&t;
singleline_comment|// interrupt handler (separate from all other)
DECL|macro|CS_FUNCTION
mdefine_line|#define CS_FUNCTION &t;0x00000008&t;
singleline_comment|// enter/leave functions
DECL|macro|CS_WAVE_WRITE
mdefine_line|#define CS_WAVE_WRITE &t;0x00000010&t;
singleline_comment|// write information for wave
DECL|macro|CS_WAVE_READ
mdefine_line|#define CS_WAVE_READ &t;0x00000020&t;
singleline_comment|// read information for wave
DECL|macro|CS_AC97
mdefine_line|#define CS_AC97         0x00000040      
singleline_comment|// AC97 register access
DECL|macro|CS_DESCR
mdefine_line|#define CS_DESCR        0x00000080      
singleline_comment|// descriptor management
DECL|macro|CS_OPEN
mdefine_line|#define CS_OPEN&t;&t;0x00000400&t;
singleline_comment|// all open functions in the driver
DECL|macro|CS_RELEASE
mdefine_line|#define CS_RELEASE&t;0x00000800&t;
singleline_comment|// all release functions in the driver
DECL|macro|CS_PARMS
mdefine_line|#define CS_PARMS&t;0x00001000&t;
singleline_comment|// functional and operational parameters
DECL|macro|CS_IOCTL
mdefine_line|#define CS_IOCTL&t;0x00002000&t;
singleline_comment|// ioctl (non-mixer)
DECL|macro|CS_TMP
mdefine_line|#define CS_TMP&t;&t;0x10000000&t;
singleline_comment|// tmp debug mask bit
singleline_comment|//
singleline_comment|// CSDEBUG is usual mode is set to 1, then use the
singleline_comment|// cs_debuglevel and cs_debugmask to turn on or off debugging.
singleline_comment|// Debug level of 1 has been defined to be kernel errors and info
singleline_comment|// that should be printed on any released driver.
singleline_comment|//
macro_line|#if CSDEBUG
DECL|macro|CS_DBGOUT
mdefine_line|#define CS_DBGOUT(mask,level,x) if((cs_debuglevel &gt;= (level)) &amp;&amp; ((mask) &amp; cs_debugmask) ) {x;}
macro_line|#else
DECL|macro|CS_DBGOUT
mdefine_line|#define CS_DBGOUT(mask,level,x)
macro_line|#endif
macro_line|#if CSDEBUG
DECL|variable|cs_debuglevel
r_static
r_int
r_int
id|cs_debuglevel
op_assign
l_int|4
suffix:semicolon
singleline_comment|// levels range from 1-9
DECL|variable|cs_debugmask
r_static
r_int
r_int
id|cs_debugmask
op_assign
id|CS_INIT
multiline_comment|/*| CS_IOCTL*/
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|cs_debuglevel
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|cs_debugmask
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#endif
DECL|macro|CS_TRUE
mdefine_line|#define CS_TRUE &t;1
DECL|macro|CS_FALSE
mdefine_line|#define CS_FALSE &t;0
DECL|macro|CS_TYPE_ADC
mdefine_line|#define CS_TYPE_ADC 0
DECL|macro|CS_TYPE_DAC
mdefine_line|#define CS_TYPE_DAC 1
DECL|macro|SER_BASE
mdefine_line|#define SER_BASE    (A_SER_BASE_1 + KSEG1)
DECL|macro|SS_CSR
mdefine_line|#define SS_CSR(t)   (SER_BASE+t)
DECL|macro|SS_TXTBL
mdefine_line|#define SS_TXTBL(t) (SER_BASE+R_SER_TX_TABLE_BASE+(t*8))
DECL|macro|SS_RXTBL
mdefine_line|#define SS_RXTBL(t) (SER_BASE+R_SER_RX_TABLE_BASE+(t*8))
DECL|macro|FRAME_BYTES
mdefine_line|#define FRAME_BYTES            32
DECL|macro|FRAME_SAMPLE_BYTES
mdefine_line|#define FRAME_SAMPLE_BYTES      4
multiline_comment|/* Should this be variable? */
DECL|macro|SAMPLE_BUF_SIZE
mdefine_line|#define SAMPLE_BUF_SIZE        (16*1024)
DECL|macro|SAMPLE_FRAME_COUNT
mdefine_line|#define SAMPLE_FRAME_COUNT     (SAMPLE_BUF_SIZE / FRAME_SAMPLE_BYTES)
multiline_comment|/* The driver can explode/shrink the frames to/from a smaller sample&n;   buffer */
DECL|macro|DMA_BLOAT_FACTOR
mdefine_line|#define DMA_BLOAT_FACTOR       1
DECL|macro|DMA_DESCR
mdefine_line|#define DMA_DESCR              (SAMPLE_FRAME_COUNT / DMA_BLOAT_FACTOR)
DECL|macro|DMA_BUF_SIZE
mdefine_line|#define DMA_BUF_SIZE           (DMA_DESCR * FRAME_BYTES)
multiline_comment|/* Use the maxmium count (255 == 5.1 ms between interrupts) */
DECL|macro|DMA_INT_CNT
mdefine_line|#define DMA_INT_CNT            ((1 &lt;&lt; S_DMA_INT_PKTCNT) - 1)
multiline_comment|/* Figure this out: how many TX DMAs ahead to schedule a reg access */
DECL|macro|REG_LATENCY
mdefine_line|#define REG_LATENCY            150
DECL|macro|FRAME_TX_US
mdefine_line|#define FRAME_TX_US             20
DECL|macro|SERDMA_NEXTBUF
mdefine_line|#define SERDMA_NEXTBUF(d,f) (((d)-&gt;f+1) % (d)-&gt;ringsz)
DECL|variable|invalid_magic
r_static
r_const
r_char
id|invalid_magic
(braket
)braket
op_assign
id|KERN_CRIT
l_string|&quot;cs4297a: invalid magic value&bslash;n&quot;
suffix:semicolon
DECL|macro|VALIDATE_STATE
mdefine_line|#define VALIDATE_STATE(s)                          &bslash;&n;({                                                 &bslash;&n;        if (!(s) || (s)-&gt;magic != CS4297a_MAGIC) { &bslash;&n;                printk(invalid_magic);             &bslash;&n;                return -ENXIO;                     &bslash;&n;        }                                          &bslash;&n;})
DECL|variable|cs4297a_devs
r_struct
id|list_head
id|cs4297a_devs
op_assign
(brace
op_amp
id|cs4297a_devs
comma
op_amp
id|cs4297a_devs
)brace
suffix:semicolon
DECL|struct|serdma_descr_s
r_typedef
r_struct
id|serdma_descr_s
(brace
DECL|member|descr_a
id|u64
id|descr_a
suffix:semicolon
DECL|member|descr_b
id|u64
id|descr_b
suffix:semicolon
DECL|typedef|serdma_descr_t
)brace
id|serdma_descr_t
suffix:semicolon
DECL|typedef|paddr_t
r_typedef
r_int
r_int
id|paddr_t
suffix:semicolon
DECL|struct|serdma_s
r_typedef
r_struct
id|serdma_s
(brace
DECL|member|ringsz
r_int
id|ringsz
suffix:semicolon
DECL|member|descrtab
id|serdma_descr_t
op_star
id|descrtab
suffix:semicolon
DECL|member|descrtab_end
id|serdma_descr_t
op_star
id|descrtab_end
suffix:semicolon
DECL|member|descrtab_phys
id|paddr_t
id|descrtab_phys
suffix:semicolon
DECL|member|descr_add
id|serdma_descr_t
op_star
id|descr_add
suffix:semicolon
DECL|member|descr_rem
id|serdma_descr_t
op_star
id|descr_rem
suffix:semicolon
DECL|member|dma_buf
id|u64
op_star
id|dma_buf
suffix:semicolon
singleline_comment|// buffer for DMA contents (frames)
DECL|member|dma_buf_phys
id|paddr_t
id|dma_buf_phys
suffix:semicolon
DECL|member|sample_buf
id|u16
op_star
id|sample_buf
suffix:semicolon
singleline_comment|// tmp buffer for sample conversions
DECL|member|sb_swptr
id|u16
op_star
id|sb_swptr
suffix:semicolon
DECL|member|sb_hwptr
id|u16
op_star
id|sb_hwptr
suffix:semicolon
DECL|member|sb_end
id|u16
op_star
id|sb_end
suffix:semicolon
DECL|member|dmaaddr
id|dma_addr_t
id|dmaaddr
suffix:semicolon
singleline_comment|//        unsigned buforder;&t;// Log base 2 of &squot;dma_buf&squot; size in bytes..
DECL|member|numfrag
r_int
id|numfrag
suffix:semicolon
singleline_comment|// # of &squot;fragments&squot; in the buffer.
DECL|member|fragshift
r_int
id|fragshift
suffix:semicolon
singleline_comment|// Log base 2 of fragment size.
DECL|member|hwptr
DECL|member|swptr
r_int
id|hwptr
comma
id|swptr
suffix:semicolon
DECL|member|total_bytes
r_int
id|total_bytes
suffix:semicolon
singleline_comment|// # bytes process since open.
DECL|member|blocks
r_int
id|blocks
suffix:semicolon
singleline_comment|// last returned blocks value GETOPTR
DECL|member|wakeup
r_int
id|wakeup
suffix:semicolon
singleline_comment|// interrupt occurred on block 
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|underrun
r_int
id|underrun
suffix:semicolon
singleline_comment|// underrun flag
DECL|member|error
r_int
id|error
suffix:semicolon
singleline_comment|// over/underrun 
DECL|member|wait
id|wait_queue_head_t
id|wait
suffix:semicolon
DECL|member|reg_wait
id|wait_queue_head_t
id|reg_wait
suffix:semicolon
singleline_comment|// redundant, but makes calculations easier 
DECL|member|fragsize
r_int
id|fragsize
suffix:semicolon
singleline_comment|// 2**fragshift..
DECL|member|sbufsz
r_int
id|sbufsz
suffix:semicolon
singleline_comment|// 2**buforder.
DECL|member|fragsamples
r_int
id|fragsamples
suffix:semicolon
singleline_comment|// OSS stuff 
DECL|member|mapped
r_int
id|mapped
suffix:colon
l_int|1
suffix:semicolon
singleline_comment|// Buffer mapped in cs4297a_mmap()?
DECL|member|ready
r_int
id|ready
suffix:colon
l_int|1
suffix:semicolon
singleline_comment|// prog_dmabuf_dac()/adc() successful?
DECL|member|endcleared
r_int
id|endcleared
suffix:colon
l_int|1
suffix:semicolon
DECL|member|type
r_int
id|type
suffix:colon
l_int|1
suffix:semicolon
singleline_comment|// adc or dac buffer (CS_TYPE_XXX)
DECL|member|ossfragshift
r_int
id|ossfragshift
suffix:semicolon
DECL|member|ossmaxfrags
r_int
id|ossmaxfrags
suffix:semicolon
DECL|member|subdivision
r_int
id|subdivision
suffix:semicolon
DECL|typedef|serdma_t
)brace
id|serdma_t
suffix:semicolon
DECL|struct|cs4297a_state
r_struct
id|cs4297a_state
(brace
singleline_comment|// magic 
DECL|member|magic
r_int
r_int
id|magic
suffix:semicolon
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
singleline_comment|// soundcore stuff 
DECL|member|dev_audio
r_int
id|dev_audio
suffix:semicolon
DECL|member|dev_mixer
r_int
id|dev_mixer
suffix:semicolon
singleline_comment|// hardware resources 
DECL|member|irq
r_int
r_int
id|irq
suffix:semicolon
r_struct
(brace
DECL|member|rx_ovrrn
r_int
r_int
id|rx_ovrrn
suffix:semicolon
multiline_comment|/* FIFO */
DECL|member|rx_overflow
r_int
r_int
id|rx_overflow
suffix:semicolon
multiline_comment|/* staging buffer */
DECL|member|tx_underrun
r_int
r_int
id|tx_underrun
suffix:semicolon
DECL|member|rx_bad
r_int
r_int
id|rx_bad
suffix:semicolon
DECL|member|rx_good
r_int
r_int
id|rx_good
suffix:semicolon
DECL|member|stats
)brace
id|stats
suffix:semicolon
singleline_comment|// mixer registers 
r_struct
(brace
DECL|member|vol
r_int
r_int
id|vol
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|recsrc
r_int
r_int
id|recsrc
suffix:semicolon
DECL|member|modcnt
r_int
r_int
id|modcnt
suffix:semicolon
DECL|member|micpreamp
r_int
r_int
id|micpreamp
suffix:semicolon
DECL|member|mix
)brace
id|mix
suffix:semicolon
singleline_comment|// wave stuff   
DECL|struct|properties
r_struct
id|properties
(brace
DECL|member|fmt
r_int
id|fmt
suffix:semicolon
DECL|member|fmt_original
r_int
id|fmt_original
suffix:semicolon
singleline_comment|// original requested format
DECL|member|channels
r_int
id|channels
suffix:semicolon
DECL|member|rate
r_int
id|rate
suffix:semicolon
DECL|member|prop_dac
DECL|member|prop_adc
)brace
id|prop_dac
comma
id|prop_adc
suffix:semicolon
DECL|member|conversion
r_int
id|conversion
suffix:colon
l_int|1
suffix:semicolon
singleline_comment|// conversion from 16 to 8 bit in progress
DECL|member|ena
r_int
id|ena
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|open_sem
r_struct
id|semaphore
id|open_sem
suffix:semicolon
DECL|member|open_sem_adc
r_struct
id|semaphore
id|open_sem_adc
suffix:semicolon
DECL|member|open_sem_dac
r_struct
id|semaphore
id|open_sem_dac
suffix:semicolon
DECL|member|open_mode
id|mode_t
id|open_mode
suffix:semicolon
DECL|member|open_wait
id|wait_queue_head_t
id|open_wait
suffix:semicolon
DECL|member|open_wait_adc
id|wait_queue_head_t
id|open_wait_adc
suffix:semicolon
DECL|member|open_wait_dac
id|wait_queue_head_t
id|open_wait_dac
suffix:semicolon
DECL|member|dmaaddr_sample_buf
id|dma_addr_t
id|dmaaddr_sample_buf
suffix:semicolon
DECL|member|buforder_sample_buf
r_int
id|buforder_sample_buf
suffix:semicolon
singleline_comment|// Log base 2 of &squot;dma_buf&squot; size in bytes..
DECL|member|dma_dac
DECL|member|dma_adc
id|serdma_t
id|dma_dac
comma
id|dma_adc
suffix:semicolon
DECL|member|read_value
r_volatile
id|u16
id|read_value
suffix:semicolon
DECL|member|read_reg
r_volatile
id|u16
id|read_reg
suffix:semicolon
DECL|member|reg_request
r_volatile
id|u64
id|reg_request
suffix:semicolon
)brace
suffix:semicolon
macro_line|#if 1
DECL|macro|prog_codec
mdefine_line|#define prog_codec(a,b)
DECL|macro|dealloc_dmabuf
mdefine_line|#define dealloc_dmabuf(a,b);
macro_line|#endif
DECL|function|prog_dmabuf_adc
r_static
r_int
id|prog_dmabuf_adc
c_func
(paren
r_struct
id|cs4297a_state
op_star
id|s
)paren
(brace
id|s-&gt;dma_adc.ready
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|prog_dmabuf_dac
r_static
r_int
id|prog_dmabuf_dac
c_func
(paren
r_struct
id|cs4297a_state
op_star
id|s
)paren
(brace
id|s-&gt;dma_dac.ready
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|clear_advance
r_static
r_void
id|clear_advance
c_func
(paren
r_void
op_star
id|buf
comma
r_int
id|bsize
comma
r_int
id|bptr
comma
r_int
id|len
comma
r_int
r_char
id|c
)paren
(brace
r_if
c_cond
(paren
id|bptr
op_plus
id|len
OG
id|bsize
)paren
(brace
r_int
id|x
op_assign
id|bsize
op_minus
id|bptr
suffix:semicolon
id|memset
c_func
(paren
(paren
(paren
r_char
op_star
)paren
id|buf
)paren
op_plus
id|bptr
comma
id|c
comma
id|x
)paren
suffix:semicolon
id|bptr
op_assign
l_int|0
suffix:semicolon
id|len
op_sub_assign
id|x
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_WRITE
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: clear_advance(): memset %d at 0x%.8x for %d size &bslash;n&quot;
comma
(paren
r_int
)paren
id|c
comma
(paren
r_int
)paren
(paren
(paren
r_char
op_star
)paren
id|buf
)paren
op_plus
id|bptr
comma
id|len
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
(paren
r_char
op_star
)paren
id|buf
)paren
op_plus
id|bptr
comma
id|c
comma
id|len
)paren
suffix:semicolon
)brace
macro_line|#if CSDEBUG
singleline_comment|// DEBUG ROUTINES
DECL|macro|SOUND_MIXER_CS_GETDBGLEVEL
mdefine_line|#define SOUND_MIXER_CS_GETDBGLEVEL &t;_SIOWR(&squot;M&squot;,120, int)
DECL|macro|SOUND_MIXER_CS_SETDBGLEVEL
mdefine_line|#define SOUND_MIXER_CS_SETDBGLEVEL &t;_SIOWR(&squot;M&squot;,121, int)
DECL|macro|SOUND_MIXER_CS_GETDBGMASK
mdefine_line|#define SOUND_MIXER_CS_GETDBGMASK &t;_SIOWR(&squot;M&squot;,122, int)
DECL|macro|SOUND_MIXER_CS_SETDBGMASK
mdefine_line|#define SOUND_MIXER_CS_SETDBGMASK &t;_SIOWR(&squot;M&squot;,123, int)
DECL|function|cs_printioctl
r_static
r_void
id|cs_printioctl
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_char
id|vidx
suffix:semicolon
singleline_comment|// Index of mixtable1[] member is Device ID 
singleline_comment|// and must be &lt;= SOUND_MIXER_NRDEVICES.
singleline_comment|// Value of array member is index into s-&gt;mix.vol[]
r_static
r_const
r_int
r_char
id|mixtable1
(braket
id|SOUND_MIXER_NRDEVICES
)braket
op_assign
(brace
(braket
id|SOUND_MIXER_PCM
)braket
op_assign
l_int|1
comma
singleline_comment|// voice 
(braket
id|SOUND_MIXER_LINE1
)braket
op_assign
l_int|2
comma
singleline_comment|// AUX
(braket
id|SOUND_MIXER_CD
)braket
op_assign
l_int|3
comma
singleline_comment|// CD 
(braket
id|SOUND_MIXER_LINE
)braket
op_assign
l_int|4
comma
singleline_comment|// Line 
(braket
id|SOUND_MIXER_SYNTH
)braket
op_assign
l_int|5
comma
singleline_comment|// FM
(braket
id|SOUND_MIXER_MIC
)braket
op_assign
l_int|6
comma
singleline_comment|// Mic 
(braket
id|SOUND_MIXER_SPEAKER
)braket
op_assign
l_int|7
comma
singleline_comment|// Speaker 
(braket
id|SOUND_MIXER_RECLEV
)braket
op_assign
l_int|8
comma
singleline_comment|// Recording level 
(braket
id|SOUND_MIXER_VOLUME
)braket
op_assign
l_int|9
singleline_comment|// Master Volume 
)brace
suffix:semicolon
r_switch
c_cond
(paren
id|x
)paren
(brace
r_case
id|SOUND_MIXER_CS_GETDBGMASK
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_CS_GETDBGMASK:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_CS_GETDBGLEVEL
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_CS_GETDBGLEVEL:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_CS_SETDBGMASK
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_CS_SETDBGMASK:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_CS_SETDBGLEVEL
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_CS_SETDBGLEVEL:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OSS_GETVERSION
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;OSS_GETVERSION:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SYNC
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SYNC:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETDUPLEX
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETDUPLEX:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETCAPS
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETCAPS:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_RESET
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_RESET:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SPEED
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SPEED:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_STEREO
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_STEREO:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_CHANNELS
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_CHANNELS:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETFMTS
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETFMTS:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFMT
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETFMT:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_POST
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_POST:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETTRIGGER
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETTRIGGER:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETTRIGGER
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETTRIGGER:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOSPACE
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETOSPACE:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETISPACE
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETISPACE:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_NONBLOCK
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_NONBLOCK:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETODELAY
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETODELAY:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETIPTR
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETIPTR:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOPTR
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETOPTR:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETBLKSIZE
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETBLKSIZE:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFRAGMENT
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETFRAGMENT:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SUBDIVIDE
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SUBDIVIDE:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_RATE
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_PCM_READ_RATE:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_CHANNELS
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_PCM_READ_CHANNELS:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_BITS
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_PCM_READ_BITS:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_WRITE_FILTER
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_PCM_WRITE_FILTER:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETSYNCRO
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETSYNCRO:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_FILTER
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_PCM_READ_FILTER:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_PRIVATE1
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_PRIVATE1:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_PRIVATE2
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_PRIVATE2:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_PRIVATE3
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_PRIVATE3:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_PRIVATE4
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_PRIVATE4:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_PRIVATE5
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_PRIVATE5:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_INFO
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_INFO:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_OLD_MIXER_INFO
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_OLD_MIXER_INFO:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_switch
c_cond
(paren
id|_IOC_NR
c_func
(paren
id|x
)paren
)paren
(brace
r_case
id|SOUND_MIXER_VOLUME
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_VOLUME:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_SPEAKER
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_SPEAKER:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_RECLEV
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_RECLEV:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_MIC
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_MIC:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_SYNTH
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_SYNTH:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_RECSRC
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_RECSRC:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_DEVMASK
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_DEVMASK:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_RECMASK
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_RECMASK:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_STEREODEVS
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_STEREODEVS:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_CAPS
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;SOUND_MIXER_CAPS:&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|i
op_assign
id|_IOC_NR
c_func
(paren
id|x
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|SOUND_MIXER_NRDEVICES
op_logical_or
op_logical_neg
(paren
id|vidx
op_assign
id|mixtable1
(braket
id|i
)braket
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
(paren
l_string|&quot;UNKNOWN IOCTL: 0x%.8x NR=%d&bslash;n&quot;
comma
id|x
comma
id|i
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
(paren
l_string|&quot;SOUND_MIXER_IOCTL AC9x: 0x%.8x NR=%d&bslash;n&quot;
comma
id|x
comma
id|i
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
DECL|function|ser_init
r_static
r_int
id|ser_init
c_func
(paren
r_struct
id|cs4297a_state
op_star
id|s
)paren
(brace
r_int
id|i
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: Setting up serial parameters&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|M_SYNCSER_CMD_RX_RESET
op_or
id|M_SYNCSER_CMD_TX_RESET
comma
id|SS_CSR
c_func
(paren
id|R_SER_CMD
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|M_SYNCSER_MSB_FIRST
comma
id|SS_CSR
c_func
(paren
id|R_SER_MODE
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|32
comma
id|SS_CSR
c_func
(paren
id|R_SER_MINFRM_SZ
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|32
comma
id|SS_CSR
c_func
(paren
id|R_SER_MAXFRM_SZ
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|1
comma
id|SS_CSR
c_func
(paren
id|R_SER_TX_RD_THRSH
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|4
comma
id|SS_CSR
c_func
(paren
id|R_SER_TX_WR_THRSH
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|8
comma
id|SS_CSR
c_func
(paren
id|R_SER_RX_RD_THRSH
)paren
)paren
suffix:semicolon
multiline_comment|/* This looks good from experimentation */
id|__raw_writeq
c_func
(paren
(paren
id|M_SYNCSER_TXSYNC_INT
op_or
id|V_SYNCSER_TXSYNC_DLY
c_func
(paren
l_int|0
)paren
op_or
id|M_SYNCSER_TXCLK_EXT
op_or
id|M_SYNCSER_RXSYNC_INT
op_or
id|V_SYNCSER_RXSYNC_DLY
c_func
(paren
l_int|1
)paren
op_or
id|M_SYNCSER_RXCLK_EXT
op_or
id|M_SYNCSER_RXSYNC_EDGE
)paren
comma
id|SS_CSR
c_func
(paren
id|R_SER_LINE_MODE
)paren
)paren
suffix:semicolon
multiline_comment|/* This looks good from experimentation */
id|__raw_writeq
c_func
(paren
id|V_SYNCSER_SEQ_COUNT
c_func
(paren
l_int|14
)paren
op_or
id|M_SYNCSER_SEQ_ENABLE
op_or
id|M_SYNCSER_SEQ_STROBE
comma
id|SS_TXTBL
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|V_SYNCSER_SEQ_COUNT
c_func
(paren
l_int|15
)paren
op_or
id|M_SYNCSER_SEQ_ENABLE
op_or
id|M_SYNCSER_SEQ_BYTE
comma
id|SS_TXTBL
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|V_SYNCSER_SEQ_COUNT
c_func
(paren
l_int|13
)paren
op_or
id|M_SYNCSER_SEQ_ENABLE
op_or
id|M_SYNCSER_SEQ_BYTE
comma
id|SS_TXTBL
c_func
(paren
l_int|2
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|V_SYNCSER_SEQ_COUNT
c_func
(paren
l_int|0
)paren
op_or
id|M_SYNCSER_SEQ_ENABLE
op_or
id|M_SYNCSER_SEQ_STROBE
op_or
id|M_SYNCSER_SEQ_LAST
comma
id|SS_TXTBL
c_func
(paren
l_int|3
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|V_SYNCSER_SEQ_COUNT
c_func
(paren
l_int|14
)paren
op_or
id|M_SYNCSER_SEQ_ENABLE
op_or
id|M_SYNCSER_SEQ_STROBE
comma
id|SS_RXTBL
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|V_SYNCSER_SEQ_COUNT
c_func
(paren
l_int|15
)paren
op_or
id|M_SYNCSER_SEQ_ENABLE
op_or
id|M_SYNCSER_SEQ_BYTE
comma
id|SS_RXTBL
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|V_SYNCSER_SEQ_COUNT
c_func
(paren
l_int|13
)paren
op_or
id|M_SYNCSER_SEQ_ENABLE
op_or
id|M_SYNCSER_SEQ_BYTE
comma
id|SS_RXTBL
c_func
(paren
l_int|2
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|V_SYNCSER_SEQ_COUNT
c_func
(paren
l_int|0
)paren
op_or
id|M_SYNCSER_SEQ_ENABLE
op_or
id|M_SYNCSER_SEQ_STROBE
op_or
id|M_SYNCSER_SEQ_LAST
comma
id|SS_RXTBL
c_func
(paren
l_int|3
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|4
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Just in case... */
id|__raw_writeq
c_func
(paren
id|M_SYNCSER_SEQ_LAST
comma
id|SS_TXTBL
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|M_SYNCSER_SEQ_LAST
comma
id|SS_RXTBL
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|init_serdma
r_static
r_int
id|init_serdma
c_func
(paren
id|serdma_t
op_star
id|dma
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: desc - %d sbufsize - %d dbufsize - %d&bslash;n&quot;
comma
id|DMA_DESCR
comma
id|SAMPLE_BUF_SIZE
comma
id|DMA_BUF_SIZE
)paren
)paren
suffix:semicolon
multiline_comment|/* Descriptors */
id|dma-&gt;ringsz
op_assign
id|DMA_DESCR
suffix:semicolon
id|dma-&gt;descrtab
op_assign
id|kmalloc
c_func
(paren
id|dma-&gt;ringsz
op_star
r_sizeof
(paren
id|serdma_descr_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dma-&gt;descrtab
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: kmalloc descrtab failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dma-&gt;descrtab
comma
l_int|0
comma
id|dma-&gt;ringsz
op_star
r_sizeof
(paren
id|serdma_descr_t
)paren
)paren
suffix:semicolon
id|dma-&gt;descrtab_end
op_assign
id|dma-&gt;descrtab
op_plus
id|dma-&gt;ringsz
suffix:semicolon
multiline_comment|/* XXX bloddy mess, use proper DMA API here ...  */
id|dma-&gt;descrtab_phys
op_assign
id|CPHYSADDR
c_func
(paren
(paren
r_int
)paren
id|dma-&gt;descrtab
)paren
suffix:semicolon
id|dma-&gt;descr_add
op_assign
id|dma-&gt;descr_rem
op_assign
id|dma-&gt;descrtab
suffix:semicolon
multiline_comment|/* Frame buffer area */
id|dma-&gt;dma_buf
op_assign
id|kmalloc
c_func
(paren
id|DMA_BUF_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dma-&gt;dma_buf
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: kmalloc dma_buf failed&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dma-&gt;descrtab
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dma-&gt;dma_buf
comma
l_int|0
comma
id|DMA_BUF_SIZE
)paren
suffix:semicolon
id|dma-&gt;dma_buf_phys
op_assign
id|CPHYSADDR
c_func
(paren
(paren
r_int
)paren
id|dma-&gt;dma_buf
)paren
suffix:semicolon
multiline_comment|/* Samples buffer area */
id|dma-&gt;sbufsz
op_assign
id|SAMPLE_BUF_SIZE
suffix:semicolon
id|dma-&gt;sample_buf
op_assign
id|kmalloc
c_func
(paren
id|dma-&gt;sbufsz
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dma-&gt;sample_buf
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: kmalloc sample_buf failed&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dma-&gt;descrtab
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dma-&gt;dma_buf
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|dma-&gt;sb_swptr
op_assign
id|dma-&gt;sb_hwptr
op_assign
id|dma-&gt;sample_buf
suffix:semicolon
id|dma-&gt;sb_end
op_assign
(paren
id|u16
op_star
)paren
(paren
(paren
r_void
op_star
)paren
id|dma-&gt;sample_buf
op_plus
id|dma-&gt;sbufsz
)paren
suffix:semicolon
id|dma-&gt;fragsize
op_assign
id|dma-&gt;sbufsz
op_rshift
l_int|1
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: descrtab - %08x dma_buf - %x sample_buf - %x&bslash;n&quot;
comma
(paren
r_int
)paren
id|dma-&gt;descrtab
comma
(paren
r_int
)paren
id|dma-&gt;dma_buf
comma
(paren
r_int
)paren
id|dma-&gt;sample_buf
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dma_init
r_static
r_int
id|dma_init
c_func
(paren
r_struct
id|cs4297a_state
op_star
id|s
)paren
(brace
r_int
id|i
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: Setting up DMA&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|init_serdma
c_func
(paren
op_amp
id|s-&gt;dma_adc
)paren
op_logical_or
id|init_serdma
c_func
(paren
op_amp
id|s-&gt;dma_dac
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|__raw_readq
c_func
(paren
id|SS_CSR
c_func
(paren
id|R_SER_DMA_DSCR_COUNT_RX
)paren
)paren
op_logical_or
id|__raw_readq
c_func
(paren
id|SS_CSR
c_func
(paren
id|R_SER_DMA_DSCR_COUNT_TX
)paren
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;DMA state corrupted?!&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize now - the descr/buffer pairings will never&n;           change... */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DMA_DESCR
suffix:semicolon
id|i
op_increment
)paren
(brace
id|s-&gt;dma_dac.descrtab
(braket
id|i
)braket
dot
id|descr_a
op_assign
id|M_DMA_SERRX_SOP
op_or
id|V_DMA_DSCRA_A_SIZE
c_func
(paren
l_int|1
)paren
op_or
(paren
id|s-&gt;dma_dac.dma_buf_phys
op_plus
id|i
op_star
id|FRAME_BYTES
)paren
suffix:semicolon
id|s-&gt;dma_dac.descrtab
(braket
id|i
)braket
dot
id|descr_b
op_assign
id|V_DMA_DSCRB_PKT_SIZE
c_func
(paren
id|FRAME_BYTES
)paren
suffix:semicolon
id|s-&gt;dma_adc.descrtab
(braket
id|i
)braket
dot
id|descr_a
op_assign
id|V_DMA_DSCRA_A_SIZE
c_func
(paren
l_int|1
)paren
op_or
(paren
id|s-&gt;dma_adc.dma_buf_phys
op_plus
id|i
op_star
id|FRAME_BYTES
)paren
suffix:semicolon
id|s-&gt;dma_adc.descrtab
(braket
id|i
)braket
dot
id|descr_b
op_assign
l_int|0
suffix:semicolon
)brace
id|__raw_writeq
c_func
(paren
(paren
id|M_DMA_EOP_INT_EN
op_or
id|V_DMA_INT_PKTCNT
c_func
(paren
id|DMA_INT_CNT
)paren
op_or
id|V_DMA_RINGSZ
c_func
(paren
id|DMA_DESCR
)paren
op_or
id|M_DMA_TDX_EN
)paren
comma
id|SS_CSR
c_func
(paren
id|R_SER_DMA_CONFIG0_RX
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|M_DMA_L2CA
comma
id|SS_CSR
c_func
(paren
id|R_SER_DMA_CONFIG1_RX
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|s-&gt;dma_adc.descrtab_phys
comma
id|SS_CSR
c_func
(paren
id|R_SER_DMA_DSCR_BASE_RX
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|V_DMA_RINGSZ
c_func
(paren
id|DMA_DESCR
)paren
comma
id|SS_CSR
c_func
(paren
id|R_SER_DMA_CONFIG0_TX
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|M_DMA_L2CA
op_or
id|M_DMA_NO_DSCR_UPDT
comma
id|SS_CSR
c_func
(paren
id|R_SER_DMA_CONFIG1_TX
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|s-&gt;dma_dac.descrtab_phys
comma
id|SS_CSR
c_func
(paren
id|R_SER_DMA_DSCR_BASE_TX
)paren
)paren
suffix:semicolon
multiline_comment|/* Prep the receive DMA descriptor ring */
id|__raw_writeq
c_func
(paren
id|DMA_DESCR
comma
id|SS_CSR
c_func
(paren
id|R_SER_DMA_DSCR_COUNT_RX
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|M_SYNCSER_DMA_RX_EN
op_or
id|M_SYNCSER_DMA_TX_EN
comma
id|SS_CSR
c_func
(paren
id|R_SER_DMA_ENABLE
)paren
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
(paren
id|M_SYNCSER_RX_SYNC_ERR
op_or
id|M_SYNCSER_RX_OVERRUN
op_or
id|M_SYNCSER_RX_EOP_COUNT
)paren
comma
id|SS_CSR
c_func
(paren
id|R_SER_INT_MASK
)paren
)paren
suffix:semicolon
multiline_comment|/* Enable the rx/tx; let the codec warm up to the sync and&n;           start sending good frames before the receive FIFO is&n;           enabled */
id|__raw_writeq
c_func
(paren
id|M_SYNCSER_CMD_TX_EN
comma
id|SS_CSR
c_func
(paren
id|R_SER_CMD
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|M_SYNCSER_CMD_RX_EN
op_or
id|M_SYNCSER_CMD_TX_EN
comma
id|SS_CSR
c_func
(paren
id|R_SER_CMD
)paren
)paren
suffix:semicolon
multiline_comment|/* XXXKW is this magic? (the &quot;1&quot; part) */
r_while
c_loop
(paren
(paren
id|__raw_readq
c_func
(paren
id|SS_CSR
c_func
(paren
id|R_SER_STATUS
)paren
)paren
op_amp
l_int|0xf1
)paren
op_ne
l_int|1
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: status: %08x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
(paren
id|__raw_readq
c_func
(paren
id|SS_CSR
c_func
(paren
id|R_SER_STATUS
)paren
)paren
op_amp
l_int|0xffffffff
)paren
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|serdma_reg_access
r_static
r_int
id|serdma_reg_access
c_func
(paren
r_struct
id|cs4297a_state
op_star
id|s
comma
id|u64
id|data
)paren
(brace
id|serdma_t
op_star
id|d
op_assign
op_amp
id|s-&gt;dma_dac
suffix:semicolon
id|u64
op_star
id|data_p
suffix:semicolon
r_int
id|swptr
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|serdma_descr_t
op_star
id|descr
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;reg_request
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: attempt to issue multiple reg_access&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;ena
op_amp
id|FMODE_WRITE
)paren
(brace
multiline_comment|/* Since a writer has the DSP open, we have to mux the&n;                   request in */
id|s-&gt;reg_request
op_assign
id|data
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|s-&gt;dma_dac.reg_wait
)paren
suffix:semicolon
multiline_comment|/* XXXKW how can I deal with the starvation case where&n;                   the opener isn&squot;t writing? */
)brace
r_else
(brace
multiline_comment|/* Be safe when changing ring pointers */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;hwptr
op_ne
id|d-&gt;swptr
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: reg access found bookkeeping error (hw/sw = %d/%d&bslash;n&quot;
comma
id|d-&gt;hwptr
comma
id|d-&gt;swptr
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|swptr
op_assign
id|d-&gt;swptr
suffix:semicolon
id|d-&gt;hwptr
op_assign
id|d-&gt;swptr
op_assign
(paren
id|d-&gt;swptr
op_plus
l_int|1
)paren
op_mod
id|d-&gt;ringsz
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|descr
op_assign
op_amp
id|d-&gt;descrtab
(braket
id|swptr
)braket
suffix:semicolon
id|data_p
op_assign
op_amp
id|d-&gt;dma_buf
(braket
id|swptr
op_star
l_int|4
)braket
suffix:semicolon
op_star
id|data_p
op_assign
id|cpu_to_be64
c_func
(paren
id|data
)paren
suffix:semicolon
id|__raw_writeq
c_func
(paren
l_int|1
comma
id|SS_CSR
c_func
(paren
id|R_SER_DMA_DSCR_COUNT_TX
)paren
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_DESCR
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: add_tx  %p (%x -&gt; %x)&bslash;n&quot;
comma
id|data_p
comma
id|swptr
comma
id|d-&gt;hwptr
)paren
)paren
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|6
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: serdma_reg_access()-&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//****************************************************************************
singleline_comment|// &quot;cs4297a_read_ac97&quot; -- Reads an AC97 register
singleline_comment|//****************************************************************************
DECL|function|cs4297a_read_ac97
r_static
r_int
id|cs4297a_read_ac97
c_func
(paren
r_struct
id|cs4297a_state
op_star
id|s
comma
id|u32
id|offset
comma
id|u32
op_star
id|value
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_AC97
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: read reg %2x&bslash;n&quot;
comma
id|offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serdma_reg_access
c_func
(paren
id|s
comma
(paren
l_int|0xCLL
op_lshift
l_int|60
)paren
op_or
(paren
l_int|1LL
op_lshift
l_int|47
)paren
op_or
(paren
(paren
id|u64
)paren
(paren
id|offset
op_amp
l_int|0x7F
)paren
op_lshift
l_int|40
)paren
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|s-&gt;dma_adc.reg_wait
)paren
suffix:semicolon
op_star
id|value
op_assign
id|s-&gt;read_value
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_AC97
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: rdr reg %x -&gt; %x&bslash;n&quot;
comma
id|s-&gt;read_reg
comma
id|s-&gt;read_value
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//****************************************************************************
singleline_comment|// &quot;cs4297a_write_ac97()&quot;-- writes an AC97 register
singleline_comment|//****************************************************************************
DECL|function|cs4297a_write_ac97
r_static
r_int
id|cs4297a_write_ac97
c_func
(paren
r_struct
id|cs4297a_state
op_star
id|s
comma
id|u32
id|offset
comma
id|u32
id|value
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_AC97
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: write reg %2x -&gt; %04x&bslash;n&quot;
comma
id|offset
comma
id|value
)paren
)paren
suffix:semicolon
r_return
(paren
id|serdma_reg_access
c_func
(paren
id|s
comma
(paren
l_int|0xELL
op_lshift
l_int|60
)paren
op_or
(paren
(paren
id|u64
)paren
(paren
id|offset
op_amp
l_int|0x7F
)paren
op_lshift
l_int|40
)paren
op_or
(paren
(paren
id|value
op_amp
l_int|0xffff
)paren
op_lshift
l_int|12
)paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|stop_dac
r_static
r_void
id|stop_dac
c_func
(paren
r_struct
id|cs4297a_state
op_star
id|s
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_WRITE
comma
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: stop_dac():&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|s-&gt;ena
op_and_assign
op_complement
id|FMODE_WRITE
suffix:semicolon
macro_line|#if 0
multiline_comment|/* XXXKW what do I really want here?  My theory for now is&n;           that I just flip the &quot;ena&quot; bit, and the interrupt handler&n;           will stop processing the xmit channel */
id|__raw_writeq
c_func
(paren
(paren
id|s-&gt;ena
op_amp
id|FMODE_READ
)paren
ques
c_cond
id|M_SYNCSER_DMA_RX_EN
suffix:colon
l_int|0
comma
id|SS_CSR
c_func
(paren
id|R_SER_DMA_ENABLE
)paren
)paren
suffix:semicolon
macro_line|#endif
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|start_dac
r_static
r_void
id|start_dac
c_func
(paren
r_struct
id|cs4297a_state
op_star
id|s
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: start_dac()+&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|s-&gt;ena
op_amp
id|FMODE_WRITE
)paren
op_logical_and
(paren
id|s-&gt;dma_dac.mapped
op_logical_or
(paren
id|s-&gt;dma_dac.count
OG
l_int|0
op_logical_and
id|s-&gt;dma_dac.ready
)paren
)paren
)paren
(brace
id|s-&gt;ena
op_or_assign
id|FMODE_WRITE
suffix:semicolon
multiline_comment|/* XXXKW what do I really want here?  My theory for&n;                   now is that I just flip the &quot;ena&quot; bit, and the&n;                   interrupt handler will start processing the xmit&n;                   channel */
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_WRITE
op_or
id|CS_PARMS
comma
l_int|8
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: start_dac(): start dma&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: start_dac()-&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
DECL|function|stop_adc
r_static
r_void
id|stop_adc
c_func
(paren
r_struct
id|cs4297a_state
op_star
id|s
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: stop_adc()+&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|s-&gt;ena
op_and_assign
op_complement
id|FMODE_READ
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;conversion
op_eq
l_int|1
)paren
(brace
id|s-&gt;conversion
op_assign
l_int|0
suffix:semicolon
id|s-&gt;prop_adc.fmt
op_assign
id|s-&gt;prop_adc.fmt_original
suffix:semicolon
)brace
multiline_comment|/* Nothing to do really, I need to keep the DMA going&n;           XXXKW when do I get here, and is there more I should do? */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: stop_adc()-&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
DECL|function|start_adc
r_static
r_void
id|start_adc
c_func
(paren
r_struct
id|cs4297a_state
op_star
id|s
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: start_adc()+&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|s-&gt;ena
op_amp
id|FMODE_READ
)paren
op_logical_and
(paren
id|s-&gt;dma_adc.mapped
op_logical_or
id|s-&gt;dma_adc.count
op_le
(paren
r_int
)paren
(paren
id|s-&gt;dma_adc.sbufsz
op_minus
l_int|2
op_star
id|s-&gt;dma_adc.fragsize
)paren
)paren
op_logical_and
id|s-&gt;dma_adc.ready
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;prop_adc.fmt
op_amp
id|AFMT_S8
op_logical_or
id|s-&gt;prop_adc.fmt
op_amp
id|AFMT_U8
)paren
(brace
singleline_comment|// 
singleline_comment|// now only use 16 bit capture, due to truncation issue
singleline_comment|// in the chip, noticable distortion occurs.
singleline_comment|// allocate buffer and then convert from 16 bit to 
singleline_comment|// 8 bit for the user buffer.
singleline_comment|//
id|s-&gt;prop_adc.fmt_original
op_assign
id|s-&gt;prop_adc.fmt
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;prop_adc.fmt
op_amp
id|AFMT_S8
)paren
(brace
id|s-&gt;prop_adc.fmt
op_and_assign
op_complement
id|AFMT_S8
suffix:semicolon
id|s-&gt;prop_adc.fmt
op_or_assign
id|AFMT_S16_LE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;prop_adc.fmt
op_amp
id|AFMT_U8
)paren
(brace
id|s-&gt;prop_adc.fmt
op_and_assign
op_complement
id|AFMT_U8
suffix:semicolon
id|s-&gt;prop_adc.fmt
op_or_assign
id|AFMT_U16_LE
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// prog_dmabuf_adc performs a stop_adc() but that is
singleline_comment|// ok since we really haven&squot;t started the DMA yet.
singleline_comment|//
id|prog_codec
c_func
(paren
id|s
comma
id|CS_TYPE_ADC
)paren
suffix:semicolon
id|prog_dmabuf_adc
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;conversion
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|s-&gt;ena
op_or_assign
id|FMODE_READ
suffix:semicolon
multiline_comment|/* Nothing to do really, I am probably already&n;                   DMAing...  XXXKW when do I get here, and is there&n;                   more I should do? */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
comma
l_int|6
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: start_adc(): start adc&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: start_adc()-&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
singleline_comment|// call with spinlock held! 
DECL|function|cs4297a_update_ptr
r_static
r_void
id|cs4297a_update_ptr
c_func
(paren
r_struct
id|cs4297a_state
op_star
id|s
comma
r_int
id|intflag
)paren
(brace
r_int
id|good_diff
comma
id|diff
comma
id|diff2
suffix:semicolon
id|u64
op_star
id|data_p
comma
id|data
suffix:semicolon
id|u32
op_star
id|s_ptr
suffix:semicolon
r_int
id|hwptr
suffix:semicolon
id|u32
id|status
suffix:semicolon
id|serdma_t
op_star
id|d
suffix:semicolon
id|serdma_descr_t
op_star
id|descr
suffix:semicolon
singleline_comment|// update ADC pointer 
id|status
op_assign
id|intflag
ques
c_cond
id|__raw_readq
c_func
(paren
id|SS_CSR
c_func
(paren
id|R_SER_STATUS
)paren
)paren
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s-&gt;ena
op_amp
id|FMODE_READ
)paren
op_logical_or
(paren
id|status
op_amp
(paren
id|M_SYNCSER_RX_EOP_COUNT
)paren
)paren
)paren
(brace
id|d
op_assign
op_amp
id|s-&gt;dma_adc
suffix:semicolon
id|hwptr
op_assign
(paren
r_int
)paren
(paren
(paren
(paren
id|__raw_readq
c_func
(paren
id|SS_CSR
c_func
(paren
id|R_SER_DMA_CUR_DSCR_ADDR_RX
)paren
)paren
op_amp
id|M_DMA_CURDSCR_ADDR
)paren
op_minus
id|d-&gt;descrtab_phys
)paren
op_div
r_sizeof
(paren
id|serdma_descr_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;ena
op_amp
id|FMODE_READ
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: upd_rcv sw-&gt;hw-&gt;hw %x/%x/%x (int-%d)n&quot;
comma
id|d-&gt;swptr
comma
id|d-&gt;hwptr
comma
id|hwptr
comma
id|intflag
)paren
)paren
suffix:semicolon
multiline_comment|/* Number of DMA buffers available for software: */
id|diff2
op_assign
id|diff
op_assign
(paren
id|d-&gt;ringsz
op_plus
id|hwptr
op_minus
id|d-&gt;hwptr
)paren
op_mod
id|d-&gt;ringsz
suffix:semicolon
id|d-&gt;hwptr
op_assign
id|hwptr
suffix:semicolon
id|good_diff
op_assign
l_int|0
suffix:semicolon
id|s_ptr
op_assign
(paren
id|u32
op_star
)paren
op_amp
(paren
id|d-&gt;dma_buf
(braket
id|d-&gt;swptr
op_star
l_int|4
)braket
)paren
suffix:semicolon
id|descr
op_assign
op_amp
id|d-&gt;descrtab
(braket
id|d-&gt;swptr
)braket
suffix:semicolon
r_while
c_loop
(paren
id|diff2
op_decrement
)paren
(brace
id|u64
id|data
op_assign
id|be64_to_cpu
c_func
(paren
op_star
(paren
id|u64
op_star
)paren
id|s_ptr
)paren
suffix:semicolon
id|u64
id|descr_a
suffix:semicolon
id|u16
id|left
comma
id|right
suffix:semicolon
id|descr_a
op_assign
id|descr-&gt;descr_a
suffix:semicolon
id|descr-&gt;descr_a
op_and_assign
op_complement
id|M_DMA_SERRX_SOP
suffix:semicolon
r_if
c_cond
(paren
(paren
id|descr_a
op_amp
id|M_DMA_DSCRA_A_ADDR
)paren
op_ne
id|CPHYSADDR
c_func
(paren
(paren
r_int
)paren
id|s_ptr
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: RX Bad address (read)&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|data
op_amp
l_int|0x9800000000000000
)paren
op_ne
l_int|0x9800000000000000
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|descr_a
op_amp
id|M_DMA_SERRX_SOP
)paren
)paren
op_logical_or
(paren
id|G_DMA_DSCRB_PKT_SIZE
c_func
(paren
id|descr-&gt;descr_b
)paren
op_ne
id|FRAME_BYTES
)paren
)paren
(brace
id|s-&gt;stats.rx_bad
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cs4297a: RX Bad attributes (read)&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|s-&gt;stats.rx_good
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data
op_rshift
l_int|61
)paren
op_eq
l_int|7
)paren
(brace
id|s-&gt;read_value
op_assign
(paren
id|data
op_rshift
l_int|12
)paren
op_amp
l_int|0xffff
suffix:semicolon
id|s-&gt;read_reg
op_assign
(paren
id|data
op_rshift
l_int|40
)paren
op_amp
l_int|0x7f
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|d-&gt;reg_wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|d-&gt;count
op_logical_and
(paren
id|d-&gt;sb_hwptr
op_eq
id|d-&gt;sb_swptr
)paren
)paren
(brace
id|s-&gt;stats.rx_overflow
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cs4297a: RX overflow&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|good_diff
op_increment
suffix:semicolon
id|left
op_assign
(paren
(paren
id|be32_to_cpu
c_func
(paren
id|s_ptr
(braket
l_int|1
)braket
)paren
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|be32_to_cpu
c_func
(paren
id|s_ptr
(braket
l_int|2
)braket
)paren
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|right
op_assign
(paren
id|be32_to_cpu
c_func
(paren
id|s_ptr
(braket
l_int|2
)braket
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0xffff
suffix:semicolon
op_star
id|d-&gt;sb_hwptr
op_increment
op_assign
id|cpu_to_be16
c_func
(paren
id|left
)paren
suffix:semicolon
op_star
id|d-&gt;sb_hwptr
op_increment
op_assign
id|cpu_to_be16
c_func
(paren
id|right
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;sb_hwptr
op_eq
id|d-&gt;sb_end
)paren
id|d-&gt;sb_hwptr
op_assign
id|d-&gt;sample_buf
suffix:semicolon
id|descr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|descr
op_eq
id|d-&gt;descrtab_end
)paren
(brace
id|descr
op_assign
id|d-&gt;descrtab
suffix:semicolon
id|s_ptr
op_assign
(paren
id|u32
op_star
)paren
id|s-&gt;dma_adc.dma_buf
suffix:semicolon
)brace
r_else
(brace
id|s_ptr
op_add_assign
l_int|8
suffix:semicolon
)brace
)brace
id|d-&gt;total_bytes
op_add_assign
id|good_diff
op_star
id|FRAME_SAMPLE_BYTES
suffix:semicolon
id|d-&gt;count
op_add_assign
id|good_diff
op_star
id|FRAME_SAMPLE_BYTES
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;count
OG
id|d-&gt;sbufsz
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: bogus receive overflow!!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|d-&gt;swptr
op_assign
(paren
id|d-&gt;swptr
op_plus
id|diff
)paren
op_mod
id|d-&gt;ringsz
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|diff
comma
id|SS_CSR
c_func
(paren
id|R_SER_DMA_DSCR_COUNT_RX
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;mapped
)paren
(brace
r_if
c_cond
(paren
id|d-&gt;count
op_ge
(paren
r_int
)paren
id|d-&gt;fragsize
)paren
id|wake_up
c_func
(paren
op_amp
id|d-&gt;wait
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|d-&gt;count
OG
l_int|0
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_READ
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: update count -&gt; %d&bslash;n&quot;
comma
id|d-&gt;count
)paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|d-&gt;wait
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* Receive is going even if no one is&n;                           listening (for register accesses and to&n;                           avoid FIFO overrun) */
id|diff2
op_assign
id|diff
op_assign
(paren
id|hwptr
op_plus
id|d-&gt;ringsz
op_minus
id|d-&gt;hwptr
)paren
op_mod
id|d-&gt;ringsz
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|diff
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: RX full or empty?&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|descr
op_assign
op_amp
id|d-&gt;descrtab
(braket
id|d-&gt;swptr
)braket
suffix:semicolon
id|data_p
op_assign
op_amp
id|d-&gt;dma_buf
(braket
id|d-&gt;swptr
op_star
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Force this to happen at least once; I got&n;                           here because of an interrupt, so there must&n;                           be a buffer to process. */
r_do
(brace
id|data
op_assign
id|be64_to_cpu
c_func
(paren
op_star
id|data_p
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|descr-&gt;descr_a
op_amp
id|M_DMA_DSCRA_A_ADDR
)paren
op_ne
id|CPHYSADDR
c_func
(paren
(paren
r_int
)paren
id|data_p
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: RX Bad address %d (%llx %lx)&bslash;n&quot;
comma
id|d-&gt;swptr
comma
(paren
r_int
r_int
)paren
(paren
id|descr-&gt;descr_a
op_amp
id|M_DMA_DSCRA_A_ADDR
)paren
comma
(paren
r_int
)paren
id|CPHYSADDR
c_func
(paren
(paren
r_int
)paren
id|data_p
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|data
op_amp
(paren
l_int|1LL
op_lshift
l_int|63
)paren
)paren
op_logical_or
op_logical_neg
(paren
id|descr-&gt;descr_a
op_amp
id|M_DMA_SERRX_SOP
)paren
op_logical_or
(paren
id|G_DMA_DSCRB_PKT_SIZE
c_func
(paren
id|descr-&gt;descr_b
)paren
op_ne
id|FRAME_BYTES
)paren
)paren
(brace
id|s-&gt;stats.rx_bad
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cs4297a: RX Bad attributes&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|s-&gt;stats.rx_good
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data
op_rshift
l_int|61
)paren
op_eq
l_int|7
)paren
(brace
id|s-&gt;read_value
op_assign
(paren
id|data
op_rshift
l_int|12
)paren
op_amp
l_int|0xffff
suffix:semicolon
id|s-&gt;read_reg
op_assign
(paren
id|data
op_rshift
l_int|40
)paren
op_amp
l_int|0x7f
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|d-&gt;reg_wait
)paren
suffix:semicolon
)brace
)brace
id|descr-&gt;descr_a
op_and_assign
op_complement
id|M_DMA_SERRX_SOP
suffix:semicolon
id|descr
op_increment
suffix:semicolon
id|d-&gt;swptr
op_increment
suffix:semicolon
id|data_p
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|descr
op_eq
id|d-&gt;descrtab_end
)paren
(brace
id|descr
op_assign
id|d-&gt;descrtab
suffix:semicolon
id|d-&gt;swptr
op_assign
l_int|0
suffix:semicolon
id|data_p
op_assign
id|d-&gt;dma_buf
suffix:semicolon
)brace
id|__raw_writeq
c_func
(paren
l_int|1
comma
id|SS_CSR
c_func
(paren
id|R_SER_DMA_DSCR_COUNT_RX
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|diff
)paren
suffix:semicolon
id|d-&gt;hwptr
op_assign
id|hwptr
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_DESCR
comma
l_int|6
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: hw/sw %x/%x&bslash;n&quot;
comma
id|d-&gt;hwptr
comma
id|d-&gt;swptr
)paren
)paren
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
comma
l_int|8
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_update_ptr(): s=0x%.8x hwptr=%d total_bytes=%d count=%d &bslash;n&quot;
comma
(paren
r_int
)paren
id|s
comma
id|d-&gt;hwptr
comma
id|d-&gt;total_bytes
comma
id|d-&gt;count
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* XXXKW worry about s-&gt;reg_request -- there is a starvation&n;           case if s-&gt;ena has FMODE_WRITE on, but the client isn&squot;t&n;           doing writes */
singleline_comment|// update DAC pointer 
singleline_comment|//
singleline_comment|// check for end of buffer, means that we are going to wait for another interrupt
singleline_comment|// to allow silence to fill the fifos on the part, to keep pops down to a minimum.
singleline_comment|//
r_if
c_cond
(paren
id|s-&gt;ena
op_amp
id|FMODE_WRITE
)paren
(brace
id|serdma_t
op_star
id|d
op_assign
op_amp
id|s-&gt;dma_dac
suffix:semicolon
id|hwptr
op_assign
(paren
r_int
)paren
(paren
(paren
(paren
id|__raw_readq
c_func
(paren
id|SS_CSR
c_func
(paren
id|R_SER_DMA_CUR_DSCR_ADDR_TX
)paren
)paren
op_amp
id|M_DMA_CURDSCR_ADDR
)paren
op_minus
id|d-&gt;descrtab_phys
)paren
op_div
r_sizeof
(paren
id|serdma_descr_t
)paren
)paren
suffix:semicolon
id|diff
op_assign
(paren
id|d-&gt;ringsz
op_plus
id|hwptr
op_minus
id|d-&gt;hwptr
)paren
op_mod
id|d-&gt;ringsz
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_WRITE
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_update_ptr(): hw/hw/sw %x/%x/%x diff %d count %d&bslash;n&quot;
comma
id|d-&gt;hwptr
comma
id|hwptr
comma
id|d-&gt;swptr
comma
id|diff
comma
id|d-&gt;count
)paren
)paren
suffix:semicolon
id|d-&gt;hwptr
op_assign
id|hwptr
suffix:semicolon
multiline_comment|/* XXXKW stereo? conversion? Just assume 2 16-bit samples for now */
id|d-&gt;total_bytes
op_add_assign
id|diff
op_star
id|FRAME_SAMPLE_BYTES
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;mapped
)paren
(brace
id|d-&gt;count
op_add_assign
id|diff
op_star
id|FRAME_SAMPLE_BYTES
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;count
op_ge
id|d-&gt;fragsize
)paren
(brace
id|d-&gt;wakeup
op_assign
l_int|1
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|d-&gt;wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;count
OG
id|d-&gt;sbufsz
)paren
id|d-&gt;count
op_and_assign
id|d-&gt;sbufsz
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|d-&gt;count
op_sub_assign
id|diff
op_star
id|FRAME_SAMPLE_BYTES
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;count
op_le
l_int|0
)paren
(brace
singleline_comment|//
singleline_comment|// fill with silence, and do not shut down the DAC.
singleline_comment|// Continue to play silence until the _release.
singleline_comment|//
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_WRITE
comma
l_int|6
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_update_ptr(): memset %d at 0x%.8x for %d size &bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|s-&gt;prop_dac.fmt
op_amp
(paren
id|AFMT_U8
op_or
id|AFMT_U16_LE
)paren
)paren
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
comma
(paren
r_int
)paren
id|d-&gt;dma_buf
comma
id|d-&gt;ringsz
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|d-&gt;dma_buf
comma
l_int|0
comma
id|d-&gt;ringsz
op_star
id|FRAME_BYTES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;count
OL
l_int|0
)paren
(brace
id|d-&gt;underrun
op_assign
l_int|1
suffix:semicolon
id|s-&gt;stats.tx_underrun
op_increment
suffix:semicolon
id|d-&gt;count
op_assign
l_int|0
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_ERROR
comma
l_int|9
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_update_ptr(): underrun&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|d-&gt;count
op_le
(paren
r_int
)paren
id|d-&gt;fragsize
op_logical_and
op_logical_neg
id|d-&gt;endcleared
)paren
(brace
multiline_comment|/* XXXKW what is this for? */
id|clear_advance
c_func
(paren
id|d-&gt;dma_buf
comma
id|d-&gt;sbufsz
comma
id|d-&gt;swptr
comma
id|d-&gt;fragsize
comma
l_int|0
)paren
suffix:semicolon
id|d-&gt;endcleared
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|d-&gt;count
op_le
(paren
r_int
)paren
id|d-&gt;sbufsz
op_div
l_int|2
)paren
op_logical_or
id|intflag
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_WRITE
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: update count -&gt; %d&bslash;n&quot;
comma
id|d-&gt;count
)paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|d-&gt;wait
)paren
suffix:semicolon
)brace
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_PARMS
comma
l_int|8
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_update_ptr(): s=0x%.8x hwptr=%d total_bytes=%d count=%d &bslash;n&quot;
comma
(paren
r_int
)paren
id|s
comma
id|d-&gt;hwptr
comma
id|d-&gt;total_bytes
comma
id|d-&gt;count
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|mixer_ioctl
r_static
r_int
id|mixer_ioctl
c_func
(paren
r_struct
id|cs4297a_state
op_star
id|s
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
singleline_comment|// Index to mixer_src[] is value of AC97 Input Mux Select Reg.
singleline_comment|// Value of array member is recording source Device ID Mask.
r_static
r_const
r_int
r_int
id|mixer_src
(braket
l_int|8
)braket
op_assign
(brace
id|SOUND_MASK_MIC
comma
id|SOUND_MASK_CD
comma
l_int|0
comma
id|SOUND_MASK_LINE1
comma
id|SOUND_MASK_LINE
comma
id|SOUND_MASK_VOLUME
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
singleline_comment|// Index of mixtable1[] member is Device ID 
singleline_comment|// and must be &lt;= SOUND_MIXER_NRDEVICES.
singleline_comment|// Value of array member is index into s-&gt;mix.vol[]
r_static
r_const
r_int
r_char
id|mixtable1
(braket
id|SOUND_MIXER_NRDEVICES
)braket
op_assign
(brace
(braket
id|SOUND_MIXER_PCM
)braket
op_assign
l_int|1
comma
singleline_comment|// voice 
(braket
id|SOUND_MIXER_LINE1
)braket
op_assign
l_int|2
comma
singleline_comment|// AUX
(braket
id|SOUND_MIXER_CD
)braket
op_assign
l_int|3
comma
singleline_comment|// CD 
(braket
id|SOUND_MIXER_LINE
)braket
op_assign
l_int|4
comma
singleline_comment|// Line 
(braket
id|SOUND_MIXER_SYNTH
)braket
op_assign
l_int|5
comma
singleline_comment|// FM
(braket
id|SOUND_MIXER_MIC
)braket
op_assign
l_int|6
comma
singleline_comment|// Mic 
(braket
id|SOUND_MIXER_SPEAKER
)braket
op_assign
l_int|7
comma
singleline_comment|// Speaker 
(braket
id|SOUND_MIXER_RECLEV
)braket
op_assign
l_int|8
comma
singleline_comment|// Recording level 
(braket
id|SOUND_MIXER_VOLUME
)braket
op_assign
l_int|9
singleline_comment|// Master Volume 
)brace
suffix:semicolon
r_static
r_const
r_int
id|mixreg
(braket
)braket
op_assign
(brace
id|AC97_PCMOUT_VOL
comma
id|AC97_AUX_VOL
comma
id|AC97_CD_VOL
comma
id|AC97_LINEIN_VOL
)brace
suffix:semicolon
r_int
r_char
id|l
comma
id|r
comma
id|rl
comma
id|rr
comma
id|vidx
suffix:semicolon
r_int
r_char
id|attentbl
(braket
l_int|11
)braket
op_assign
(brace
l_int|63
comma
l_int|42
comma
l_int|26
comma
l_int|17
comma
l_int|14
comma
l_int|11
comma
l_int|8
comma
l_int|6
comma
l_int|4
comma
l_int|2
comma
l_int|0
)brace
suffix:semicolon
r_int
id|temp1
suffix:semicolon
r_int
id|i
comma
id|val
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: mixer_ioctl(): s=0x%.8x cmd=0x%.8x&bslash;n&quot;
comma
(paren
r_int
)paren
id|s
comma
id|cmd
)paren
)paren
suffix:semicolon
macro_line|#if CSDEBUG
id|cs_printioctl
c_func
(paren
id|cmd
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if CSDEBUG_INTERFACE
r_if
c_cond
(paren
(paren
id|cmd
op_eq
id|SOUND_MIXER_CS_GETDBGMASK
)paren
op_logical_or
(paren
id|cmd
op_eq
id|SOUND_MIXER_CS_SETDBGMASK
)paren
op_logical_or
(paren
id|cmd
op_eq
id|SOUND_MIXER_CS_GETDBGLEVEL
)paren
op_logical_or
(paren
id|cmd
op_eq
id|SOUND_MIXER_CS_SETDBGLEVEL
)paren
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SOUND_MIXER_CS_GETDBGMASK
suffix:colon
r_return
id|put_user
c_func
(paren
id|cs_debugmask
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_CS_GETDBGLEVEL
suffix:colon
r_return
id|put_user
c_func
(paren
id|cs_debuglevel
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_CS_SETDBGMASK
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|cs_debugmask
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SOUND_MIXER_CS_SETDBGLEVEL
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|cs_debuglevel
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: mixer_ioctl(): ERROR unknown debug cmd&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|cmd
op_eq
id|SOUND_MIXER_PRIVATE1
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|SOUND_MIXER_PRIVATE2
)paren
(brace
singleline_comment|// enable/disable/query spatializer 
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
op_minus
l_int|1
)paren
(brace
id|temp1
op_assign
(paren
id|val
op_amp
l_int|0x3f
)paren
op_rshift
l_int|2
suffix:semicolon
id|cs4297a_write_ac97
c_func
(paren
id|s
comma
id|AC97_3D_CONTROL
comma
id|temp1
)paren
suffix:semicolon
id|cs4297a_read_ac97
c_func
(paren
id|s
comma
id|AC97_GENERAL_PURPOSE
comma
op_amp
id|temp1
)paren
suffix:semicolon
id|cs4297a_write_ac97
c_func
(paren
id|s
comma
id|AC97_GENERAL_PURPOSE
comma
id|temp1
op_or
l_int|0x2000
)paren
suffix:semicolon
)brace
id|cs4297a_read_ac97
c_func
(paren
id|s
comma
id|AC97_3D_CONTROL
comma
op_amp
id|temp1
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
(paren
id|temp1
op_lshift
l_int|2
)paren
op_or
l_int|3
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|SOUND_MIXER_INFO
)paren
(brace
id|mixer_info
id|info
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|info
comma
l_int|0
comma
r_sizeof
(paren
id|info
)paren
)paren
suffix:semicolon
id|strlcpy
c_func
(paren
id|info.id
comma
l_string|&quot;CS4297a&quot;
comma
r_sizeof
(paren
id|info.id
)paren
)paren
suffix:semicolon
id|strlcpy
c_func
(paren
id|info.name
comma
l_string|&quot;Crystal CS4297a&quot;
comma
r_sizeof
(paren
id|info.name
)paren
)paren
suffix:semicolon
id|info.modify_counter
op_assign
id|s-&gt;mix.modcnt
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|SOUND_OLD_MIXER_INFO
)paren
(brace
id|_old_mixer_info
id|info
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|info
comma
l_int|0
comma
r_sizeof
(paren
id|info
)paren
)paren
suffix:semicolon
id|strlcpy
c_func
(paren
id|info.id
comma
l_string|&quot;CS4297a&quot;
comma
r_sizeof
(paren
id|info.id
)paren
)paren
suffix:semicolon
id|strlcpy
c_func
(paren
id|info.name
comma
l_string|&quot;Crystal CS4297a&quot;
comma
r_sizeof
(paren
id|info.name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|OSS_GETVERSION
)paren
r_return
id|put_user
c_func
(paren
id|SOUND_VERSION
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_IOC_TYPE
c_func
(paren
id|cmd
)paren
op_ne
l_char|&squot;M&squot;
op_logical_or
id|_SIOC_SIZE
c_func
(paren
id|cmd
)paren
op_ne
r_sizeof
(paren
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
singleline_comment|// If ioctl has only the SIOC_READ bit(bit 31)
singleline_comment|// on, process the only-read commands. 
r_if
c_cond
(paren
id|_SIOC_DIR
c_func
(paren
id|cmd
)paren
op_eq
id|_SIOC_READ
)paren
(brace
r_switch
c_cond
(paren
id|_IOC_NR
c_func
(paren
id|cmd
)paren
)paren
(brace
r_case
id|SOUND_MIXER_RECSRC
suffix:colon
singleline_comment|// Arg contains a bit for each recording source 
id|cs4297a_read_ac97
c_func
(paren
id|s
comma
id|AC97_RECORD_SELECT
comma
op_amp
id|temp1
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|mixer_src
(braket
id|temp1
op_amp
l_int|7
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_DEVMASK
suffix:colon
singleline_comment|// Arg contains a bit for each supported device 
r_return
id|put_user
c_func
(paren
id|SOUND_MASK_PCM
op_or
id|SOUND_MASK_LINE
op_or
id|SOUND_MASK_VOLUME
op_or
id|SOUND_MASK_RECLEV
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_RECMASK
suffix:colon
singleline_comment|// Arg contains a bit for each supported recording source 
r_return
id|put_user
c_func
(paren
id|SOUND_MASK_LINE
op_or
id|SOUND_MASK_VOLUME
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_STEREODEVS
suffix:colon
singleline_comment|// Mixer channels supporting stereo 
r_return
id|put_user
c_func
(paren
id|SOUND_MASK_PCM
op_or
id|SOUND_MASK_LINE
op_or
id|SOUND_MASK_VOLUME
op_or
id|SOUND_MASK_RECLEV
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_CAPS
suffix:colon
r_return
id|put_user
c_func
(paren
id|SOUND_CAP_EXCL_INPUT
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
id|i
op_assign
id|_IOC_NR
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|SOUND_MIXER_NRDEVICES
op_logical_or
op_logical_neg
(paren
id|vidx
op_assign
id|mixtable1
(braket
id|i
)braket
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|s-&gt;mix.vol
(braket
id|vidx
op_minus
l_int|1
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// If ioctl doesn&squot;t have both the SIOC_READ and 
singleline_comment|// the SIOC_WRITE bit set, return invalid.
r_if
c_cond
(paren
id|_SIOC_DIR
c_func
(paren
id|cmd
)paren
op_ne
(paren
id|_SIOC_READ
op_or
id|_SIOC_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
singleline_comment|// Increment the count of volume writes.
id|s-&gt;mix.modcnt
op_increment
suffix:semicolon
singleline_comment|// Isolate the command; it must be a write.
r_switch
c_cond
(paren
id|_IOC_NR
c_func
(paren
id|cmd
)paren
)paren
(brace
r_case
id|SOUND_MIXER_RECSRC
suffix:colon
singleline_comment|// Arg contains a bit for each recording source 
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|i
op_assign
id|hweight32
c_func
(paren
id|val
)paren
suffix:semicolon
singleline_comment|// i = # bits on in val.
r_if
c_cond
(paren
id|i
op_ne
l_int|1
)paren
singleline_comment|// One &amp; only 1 bit must be on.
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|mixer_src
)paren
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|val
op_eq
id|mixer_src
(braket
id|i
)braket
)paren
(brace
id|temp1
op_assign
(paren
id|i
op_lshift
l_int|8
)paren
op_or
id|i
suffix:semicolon
id|cs4297a_write_ac97
c_func
(paren
id|s
comma
id|AC97_RECORD_SELECT
comma
id|temp1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SOUND_MIXER_VOLUME
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|l
op_assign
id|val
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
l_int|100
)paren
id|l
op_assign
l_int|100
suffix:semicolon
singleline_comment|// Max soundcard.h vol is 100.
r_if
c_cond
(paren
id|l
OL
l_int|6
)paren
(brace
id|rl
op_assign
l_int|63
suffix:semicolon
id|l
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|rl
op_assign
id|attentbl
(braket
(paren
l_int|10
op_star
id|l
)paren
op_div
l_int|100
)braket
suffix:semicolon
singleline_comment|// Convert 0-100 vol to 63-0 atten.
id|r
op_assign
(paren
id|val
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|r
OG
l_int|100
)paren
id|r
op_assign
l_int|100
suffix:semicolon
singleline_comment|// Max right volume is 100, too
r_if
c_cond
(paren
id|r
OL
l_int|6
)paren
(brace
id|rr
op_assign
l_int|63
suffix:semicolon
id|r
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|rr
op_assign
id|attentbl
(braket
(paren
l_int|10
op_star
id|r
)paren
op_div
l_int|100
)braket
suffix:semicolon
singleline_comment|// Convert volume to attenuation.
r_if
c_cond
(paren
(paren
id|rl
OG
l_int|60
)paren
op_logical_and
(paren
id|rr
OG
l_int|60
)paren
)paren
singleline_comment|// If both l &amp; r are &squot;low&squot;,          
id|temp1
op_assign
l_int|0x8000
suffix:semicolon
singleline_comment|//  turn on the mute bit.
r_else
id|temp1
op_assign
l_int|0
suffix:semicolon
id|temp1
op_or_assign
(paren
id|rl
op_lshift
l_int|8
)paren
op_or
id|rr
suffix:semicolon
id|cs4297a_write_ac97
c_func
(paren
id|s
comma
id|AC97_MASTER_VOL_STEREO
comma
id|temp1
)paren
suffix:semicolon
id|cs4297a_write_ac97
c_func
(paren
id|s
comma
id|AC97_PHONE_VOL
comma
id|temp1
)paren
suffix:semicolon
macro_line|#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
id|s-&gt;mix.vol
(braket
l_int|8
)braket
op_assign
(paren
(paren
r_int
r_int
)paren
id|r
op_lshift
l_int|8
)paren
op_or
id|l
suffix:semicolon
macro_line|#else
id|s-&gt;mix.vol
(braket
l_int|8
)braket
op_assign
id|val
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|s-&gt;mix.vol
(braket
l_int|8
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_SPEAKER
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|l
op_assign
id|val
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
l_int|100
)paren
id|l
op_assign
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|l
OL
l_int|3
)paren
(brace
id|rl
op_assign
l_int|0
suffix:semicolon
id|l
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|rl
op_assign
(paren
id|l
op_star
l_int|2
op_minus
l_int|5
)paren
op_div
l_int|13
suffix:semicolon
singleline_comment|// Convert 0-100 range to 0-15.
id|l
op_assign
(paren
id|rl
op_star
l_int|13
op_plus
l_int|5
)paren
op_div
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rl
OL
l_int|3
)paren
(brace
id|temp1
op_assign
l_int|0x8000
suffix:semicolon
id|rl
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|temp1
op_assign
l_int|0
suffix:semicolon
id|rl
op_assign
l_int|15
op_minus
id|rl
suffix:semicolon
singleline_comment|// Convert volume to attenuation.
id|temp1
op_or_assign
id|rl
op_lshift
l_int|1
suffix:semicolon
id|cs4297a_write_ac97
c_func
(paren
id|s
comma
id|AC97_PCBEEP_VOL
comma
id|temp1
)paren
suffix:semicolon
macro_line|#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
id|s-&gt;mix.vol
(braket
l_int|6
)braket
op_assign
id|l
op_lshift
l_int|8
suffix:semicolon
macro_line|#else
id|s-&gt;mix.vol
(braket
l_int|6
)braket
op_assign
id|val
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|s-&gt;mix.vol
(braket
l_int|6
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_RECLEV
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|l
op_assign
id|val
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
l_int|100
)paren
id|l
op_assign
l_int|100
suffix:semicolon
id|r
op_assign
(paren
id|val
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|r
OG
l_int|100
)paren
id|r
op_assign
l_int|100
suffix:semicolon
id|rl
op_assign
(paren
id|l
op_star
l_int|2
op_minus
l_int|5
)paren
op_div
l_int|13
suffix:semicolon
singleline_comment|// Convert 0-100 scale to 0-15.
id|rr
op_assign
(paren
id|r
op_star
l_int|2
op_minus
l_int|5
)paren
op_div
l_int|13
suffix:semicolon
r_if
c_cond
(paren
id|rl
OL
l_int|3
op_logical_and
id|rr
OL
l_int|3
)paren
id|temp1
op_assign
l_int|0x8000
suffix:semicolon
r_else
id|temp1
op_assign
l_int|0
suffix:semicolon
id|temp1
op_assign
id|temp1
op_or
(paren
id|rl
op_lshift
l_int|8
)paren
op_or
id|rr
suffix:semicolon
id|cs4297a_write_ac97
c_func
(paren
id|s
comma
id|AC97_RECORD_GAIN
comma
id|temp1
)paren
suffix:semicolon
macro_line|#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
id|s-&gt;mix.vol
(braket
l_int|7
)braket
op_assign
(paren
(paren
r_int
r_int
)paren
id|r
op_lshift
l_int|8
)paren
op_or
id|l
suffix:semicolon
macro_line|#else
id|s-&gt;mix.vol
(braket
l_int|7
)braket
op_assign
id|val
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|s-&gt;mix.vol
(braket
l_int|7
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_MIC
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|l
op_assign
id|val
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
l_int|100
)paren
id|l
op_assign
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|l
OL
l_int|1
)paren
(brace
id|l
op_assign
l_int|0
suffix:semicolon
id|rl
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|rl
op_assign
(paren
(paren
r_int
)paren
id|l
op_star
l_int|5
op_minus
l_int|4
)paren
op_div
l_int|16
suffix:semicolon
singleline_comment|// Convert 0-100 range to 0-31.
id|l
op_assign
(paren
id|rl
op_star
l_int|16
op_plus
l_int|4
)paren
op_div
l_int|5
suffix:semicolon
)brace
id|cs4297a_read_ac97
c_func
(paren
id|s
comma
id|AC97_MIC_VOL
comma
op_amp
id|temp1
)paren
suffix:semicolon
id|temp1
op_and_assign
l_int|0x40
suffix:semicolon
singleline_comment|// Isolate 20db gain bit.
r_if
c_cond
(paren
id|rl
OL
l_int|3
)paren
(brace
id|temp1
op_or_assign
l_int|0x8000
suffix:semicolon
id|rl
op_assign
l_int|0
suffix:semicolon
)brace
id|rl
op_assign
l_int|31
op_minus
id|rl
suffix:semicolon
singleline_comment|// Convert volume to attenuation.
id|temp1
op_or_assign
id|rl
suffix:semicolon
id|cs4297a_write_ac97
c_func
(paren
id|s
comma
id|AC97_MIC_VOL
comma
id|temp1
)paren
suffix:semicolon
macro_line|#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
id|s-&gt;mix.vol
(braket
l_int|5
)braket
op_assign
id|val
op_lshift
l_int|8
suffix:semicolon
macro_line|#else
id|s-&gt;mix.vol
(braket
l_int|5
)braket
op_assign
id|val
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|s-&gt;mix.vol
(braket
l_int|5
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_SYNTH
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|l
op_assign
id|val
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
l_int|100
)paren
id|l
op_assign
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|r
op_assign
(paren
id|val
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|r
OG
l_int|100
)paren
id|r
op_assign
l_int|100
suffix:semicolon
id|rl
op_assign
(paren
id|l
op_star
l_int|2
op_minus
l_int|11
)paren
op_div
l_int|3
suffix:semicolon
singleline_comment|// Convert 0-100 range to 0-63.
id|rr
op_assign
(paren
id|r
op_star
l_int|2
op_minus
l_int|11
)paren
op_div
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|rl
OL
l_int|3
)paren
singleline_comment|// If l is low, turn on
id|temp1
op_assign
l_int|0x0080
suffix:semicolon
singleline_comment|//  the mute bit.
r_else
id|temp1
op_assign
l_int|0
suffix:semicolon
id|rl
op_assign
l_int|63
op_minus
id|rl
suffix:semicolon
singleline_comment|// Convert vol to attenuation.
singleline_comment|//&t;&t;writel(temp1 | rl, s-&gt;pBA0 + FMLVC);
r_if
c_cond
(paren
id|rr
OL
l_int|3
)paren
singleline_comment|//  If rr is low, turn on
id|temp1
op_assign
l_int|0x0080
suffix:semicolon
singleline_comment|//   the mute bit.
r_else
id|temp1
op_assign
l_int|0
suffix:semicolon
id|rr
op_assign
l_int|63
op_minus
id|rr
suffix:semicolon
singleline_comment|// Convert vol to attenuation.
singleline_comment|//&t;&t;writel(temp1 | rr, s-&gt;pBA0 + FMRVC);
macro_line|#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
id|s-&gt;mix.vol
(braket
l_int|4
)braket
op_assign
(paren
id|r
op_lshift
l_int|8
)paren
op_or
id|l
suffix:semicolon
macro_line|#else
id|s-&gt;mix.vol
(braket
l_int|4
)braket
op_assign
id|val
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|s-&gt;mix.vol
(braket
l_int|4
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: mixer_ioctl(): default&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|i
op_assign
id|_IOC_NR
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|SOUND_MIXER_NRDEVICES
op_logical_or
op_logical_neg
(paren
id|vidx
op_assign
id|mixtable1
(braket
id|i
)braket
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|l
op_assign
id|val
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
l_int|100
)paren
id|l
op_assign
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|l
OL
l_int|1
)paren
(brace
id|l
op_assign
l_int|0
suffix:semicolon
id|rl
op_assign
l_int|31
suffix:semicolon
)brace
r_else
id|rl
op_assign
(paren
id|attentbl
(braket
(paren
id|l
op_star
l_int|10
)paren
op_div
l_int|100
)braket
)paren
op_rshift
l_int|1
suffix:semicolon
id|r
op_assign
(paren
id|val
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|r
OG
l_int|100
)paren
id|r
op_assign
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|1
)paren
(brace
id|r
op_assign
l_int|0
suffix:semicolon
id|rr
op_assign
l_int|31
suffix:semicolon
)brace
r_else
id|rr
op_assign
(paren
id|attentbl
(braket
(paren
id|r
op_star
l_int|10
)paren
op_div
l_int|100
)braket
)paren
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rl
OG
l_int|30
)paren
op_logical_and
(paren
id|rr
OG
l_int|30
)paren
)paren
id|temp1
op_assign
l_int|0x8000
suffix:semicolon
r_else
id|temp1
op_assign
l_int|0
suffix:semicolon
id|temp1
op_assign
id|temp1
op_or
(paren
id|rl
op_lshift
l_int|8
)paren
op_or
id|rr
suffix:semicolon
id|cs4297a_write_ac97
c_func
(paren
id|s
comma
id|mixreg
(braket
id|vidx
op_minus
l_int|1
)braket
comma
id|temp1
)paren
suffix:semicolon
macro_line|#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS
id|s-&gt;mix.vol
(braket
id|vidx
op_minus
l_int|1
)braket
op_assign
(paren
(paren
r_int
r_int
)paren
id|r
op_lshift
l_int|8
)paren
op_or
id|l
suffix:semicolon
macro_line|#else
id|s-&gt;mix.vol
(braket
id|vidx
op_minus
l_int|1
)braket
op_assign
id|val
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|s-&gt;mix.vol
(braket
id|vidx
op_minus
l_int|1
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// --------------------------------------------------------------------- 
DECL|function|cs4297a_open_mixdev
r_static
r_int
id|cs4297a_open_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
op_assign
id|iminor
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|cs4297a_state
op_star
id|s
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_OPEN
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_open_mixdev()+&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|entry
comma
op_amp
id|cs4297a_devs
)paren
(brace
id|s
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|cs4297a_state
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dev_mixer
op_eq
id|minor
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|s
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_OPEN
op_or
id|CS_ERROR
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_open_mixdev()- -ENODEV&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
id|s
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_OPEN
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_open_mixdev()- 0&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|nonseekable_open
c_func
(paren
id|inode
comma
id|file
)paren
suffix:semicolon
)brace
DECL|function|cs4297a_release_mixdev
r_static
r_int
id|cs4297a_release_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|cs4297a_state
op_star
id|s
op_assign
(paren
r_struct
id|cs4297a_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cs4297a_ioctl_mixdev
r_static
r_int
id|cs4297a_ioctl_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_return
id|mixer_ioctl
c_func
(paren
(paren
r_struct
id|cs4297a_state
op_star
)paren
id|file-&gt;private_data
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
singleline_comment|// ******************************************************************************************
singleline_comment|//   Mixer file operations struct.
singleline_comment|// ******************************************************************************************
DECL|variable|cs4297a_mixer_fops
r_static
multiline_comment|/*const */
r_struct
id|file_operations
id|cs4297a_mixer_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|llseek
op_assign
id|no_llseek
comma
dot
id|ioctl
op_assign
id|cs4297a_ioctl_mixdev
comma
dot
id|open
op_assign
id|cs4297a_open_mixdev
comma
dot
id|release
op_assign
id|cs4297a_release_mixdev
comma
)brace
suffix:semicolon
singleline_comment|// --------------------------------------------------------------------- 
DECL|function|drain_adc
r_static
r_int
id|drain_adc
c_func
(paren
r_struct
id|cs4297a_state
op_star
id|s
comma
r_int
id|nonblock
)paren
(brace
multiline_comment|/* This routine serves no purpose currently - any samples&n;           sitting in the receive queue will just be processed by the&n;           background consumer.  This would be different if DMA&n;           actually stopped when there were no clients. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|drain_dac
r_static
r_int
id|drain_dac
c_func
(paren
r_struct
id|cs4297a_state
op_star
id|s
comma
r_int
id|nonblock
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|hwptr
suffix:semicolon
r_int
id|tmo
suffix:semicolon
r_int
id|count
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.mapped
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nonblock
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|s-&gt;dma_dac.wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|count
op_assign
id|__raw_readq
c_func
(paren
id|SS_CSR
c_func
(paren
id|R_SER_DMA_DSCR_COUNT_TX
)paren
)paren
)paren
op_logical_or
(paren
id|s-&gt;dma_dac.count
OG
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
multiline_comment|/* XXXKW is this calculation working? */
id|tmo
op_assign
(paren
(paren
id|count
op_star
id|FRAME_TX_US
)paren
op_star
id|HZ
)paren
op_div
l_int|1000000
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|tmo
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* XXXKW do I care if there is a signal pending? */
)brace
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Reset the bookkeeping */
id|hwptr
op_assign
(paren
r_int
)paren
(paren
(paren
(paren
id|__raw_readq
c_func
(paren
id|SS_CSR
c_func
(paren
id|R_SER_DMA_CUR_DSCR_ADDR_TX
)paren
)paren
op_amp
id|M_DMA_CURDSCR_ADDR
)paren
op_minus
id|s-&gt;dma_dac.descrtab_phys
)paren
op_div
r_sizeof
(paren
id|serdma_descr_t
)paren
)paren
suffix:semicolon
id|s-&gt;dma_dac.hwptr
op_assign
id|s-&gt;dma_dac.swptr
op_assign
id|hwptr
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|s-&gt;dma_dac.wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// --------------------------------------------------------------------- 
DECL|function|cs4297a_read
r_static
id|ssize_t
id|cs4297a_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|cs4297a_state
op_star
id|s
op_assign
(paren
r_struct
id|cs4297a_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|cnt
comma
id|count_fr
comma
id|cnt_by
suffix:semicolon
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_WAVE_READ
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_read()+ %d &bslash;n&quot;
comma
id|count
)paren
)paren
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_adc.mapped
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_adc.ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf_adc
c_func
(paren
id|s
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
singleline_comment|//
singleline_comment|// &quot;count&quot; is the amount of bytes to read (from app), is decremented each loop
singleline_comment|//      by the amount of bytes that have been returned to the user buffer.
singleline_comment|// &quot;cnt&quot; is the running total of each read from the buffer (changes each loop)
singleline_comment|// &quot;buffer&quot; points to the app&squot;s buffer
singleline_comment|// &quot;ret&quot; keeps a running total of the amount of bytes that have been copied
singleline_comment|//      to the user buffer.
singleline_comment|// &quot;copied&quot; is the total bytes copied into the user buffer for each loop.
singleline_comment|//
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_READ
comma
l_int|8
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;_read() count&gt;0 count=%d .count=%d .swptr=%d .hwptr=%d &bslash;n&quot;
comma
id|count
comma
id|s-&gt;dma_adc.count
comma
id|s-&gt;dma_adc.swptr
comma
id|s-&gt;dma_adc.hwptr
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* cnt will be the number of available samples (16-bit&n;                   stereo); it starts out as the maxmimum consequetive&n;                   samples */
id|cnt
op_assign
(paren
id|s-&gt;dma_adc.sb_end
op_minus
id|s-&gt;dma_adc.sb_swptr
)paren
op_div
l_int|2
suffix:semicolon
id|count_fr
op_assign
id|s-&gt;dma_adc.count
op_div
id|FRAME_SAMPLE_BYTES
suffix:semicolon
singleline_comment|// dma_adc.count is the current total bytes that have not been read.
singleline_comment|// if the amount of unread bytes from the current sw pointer to the
singleline_comment|// end of the buffer is greater than the current total bytes that
singleline_comment|// have not been read, then set the &quot;cnt&quot; (unread bytes) to the
singleline_comment|// amount of unread bytes.  
r_if
c_cond
(paren
id|count_fr
OL
id|cnt
)paren
id|cnt
op_assign
id|count_fr
suffix:semicolon
id|cnt_by
op_assign
id|cnt
op_star
id|FRAME_SAMPLE_BYTES
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
singleline_comment|//
singleline_comment|// if we are converting from 8/16 then we need to copy
singleline_comment|// twice the number of 16 bit bytes then 8 bit bytes.
singleline_comment|// 
r_if
c_cond
(paren
id|s-&gt;conversion
)paren
(brace
r_if
c_cond
(paren
id|cnt_by
OG
(paren
id|count
op_star
l_int|2
)paren
)paren
(brace
id|cnt
op_assign
(paren
id|count
op_star
l_int|2
)paren
op_div
id|FRAME_SAMPLE_BYTES
suffix:semicolon
id|cnt_by
op_assign
id|count
op_star
l_int|2
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|cnt_by
OG
id|count
)paren
(brace
id|cnt
op_assign
id|count
op_div
id|FRAME_SAMPLE_BYTES
suffix:semicolon
id|cnt_by
op_assign
id|count
suffix:semicolon
)brace
)brace
singleline_comment|//
singleline_comment|// &quot;cnt&quot; NOW is the smaller of the amount that will be read,
singleline_comment|// and the amount that is requested in this read (or partial).
singleline_comment|// if there are no bytes in the buffer to read, then start the
singleline_comment|// ADC and wait for the interrupt handler to wake us up.
singleline_comment|//
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
singleline_comment|// start up the dma engine and then continue back to the top of
singleline_comment|// the loop when wake up occurs.
id|start_adc
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EAGAIN
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|s-&gt;dma_adc.wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|ERESTARTSYS
suffix:semicolon
r_continue
suffix:semicolon
)brace
singleline_comment|// there are bytes in the buffer to read.
singleline_comment|// copy from the hw buffer over to the user buffer.
singleline_comment|// user buffer is designated by &quot;buffer&quot;
singleline_comment|// virtual address to copy from is dma_buf+swptr
singleline_comment|// the &quot;cnt&quot; is the number of bytes to read.
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_READ
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;_read() copy_to cnt=%d count=%d &quot;
comma
id|cnt_by
comma
id|count
)paren
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_READ
comma
l_int|8
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot; .sbufsz=%d .count=%d buffer=0x%.8x ret=%d&bslash;n&quot;
comma
id|s-&gt;dma_adc.sbufsz
comma
id|s-&gt;dma_adc.count
comma
(paren
r_int
)paren
id|buffer
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
(paren
id|buffer
comma
(paren
(paren
r_void
op_star
)paren
id|s-&gt;dma_adc.sb_swptr
)paren
comma
id|cnt_by
)paren
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EFAULT
suffix:semicolon
id|copied
op_assign
id|cnt_by
suffix:semicolon
multiline_comment|/* Return the descriptors */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: upd_rcv sw-&gt;hw %x/%x&bslash;n&quot;
comma
id|s-&gt;dma_adc.swptr
comma
id|s-&gt;dma_adc.hwptr
)paren
)paren
suffix:semicolon
id|s-&gt;dma_adc.count
op_sub_assign
id|cnt_by
suffix:semicolon
id|s-&gt;dma_adc.sb_swptr
op_add_assign
id|cnt
op_star
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_adc.sb_swptr
op_eq
id|s-&gt;dma_adc.sb_end
)paren
id|s-&gt;dma_adc.sb_swptr
op_assign
id|s-&gt;dma_adc.sample_buf
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_sub_assign
id|copied
suffix:semicolon
id|buffer
op_add_assign
id|copied
suffix:semicolon
id|ret
op_add_assign
id|copied
suffix:semicolon
id|start_adc
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_WAVE_READ
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_read()- %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|cs4297a_write
r_static
id|ssize_t
id|cs4297a_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|cs4297a_state
op_star
id|s
op_assign
(paren
r_struct
id|cs4297a_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|swptr
comma
id|hwptr
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_WAVE_WRITE
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_write()+ count=%d&bslash;n&quot;
comma
id|count
)paren
)paren
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.mapped
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_dac.ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf_dac
c_func
(paren
id|s
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|serdma_t
op_star
id|d
op_assign
op_amp
id|s-&gt;dma_dac
suffix:semicolon
r_int
id|copy_cnt
suffix:semicolon
id|u32
op_star
id|s_tmpl
suffix:semicolon
id|u32
op_star
id|t_tmpl
suffix:semicolon
id|u32
id|left
comma
id|right
suffix:semicolon
r_int
id|swap
op_assign
(paren
id|s-&gt;prop_dac.fmt
op_eq
id|AFMT_S16_LE
)paren
op_logical_or
(paren
id|s-&gt;prop_dac.fmt
op_eq
id|AFMT_U16_LE
)paren
suffix:semicolon
multiline_comment|/* XXXXXX this is broken for BLOAT_FACTOR */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;count
OL
l_int|0
)paren
(brace
id|d-&gt;count
op_assign
l_int|0
suffix:semicolon
id|d-&gt;swptr
op_assign
id|d-&gt;hwptr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|d-&gt;underrun
)paren
(brace
id|d-&gt;underrun
op_assign
l_int|0
suffix:semicolon
id|hwptr
op_assign
(paren
r_int
)paren
(paren
(paren
(paren
id|__raw_readq
c_func
(paren
id|SS_CSR
c_func
(paren
id|R_SER_DMA_CUR_DSCR_ADDR_TX
)paren
)paren
op_amp
id|M_DMA_CURDSCR_ADDR
)paren
op_minus
id|d-&gt;descrtab_phys
)paren
op_div
r_sizeof
(paren
id|serdma_descr_t
)paren
)paren
suffix:semicolon
id|d-&gt;swptr
op_assign
id|d-&gt;hwptr
op_assign
id|hwptr
suffix:semicolon
)brace
id|swptr
op_assign
id|d-&gt;swptr
suffix:semicolon
id|cnt
op_assign
id|d-&gt;sbufsz
op_minus
(paren
id|swptr
op_star
id|FRAME_SAMPLE_BYTES
)paren
suffix:semicolon
multiline_comment|/* Will this write fill up the buffer? */
r_if
c_cond
(paren
id|d-&gt;count
op_plus
id|cnt
OG
id|d-&gt;sbufsz
)paren
id|cnt
op_assign
id|d-&gt;sbufsz
op_minus
id|d-&gt;count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|count
)paren
id|cnt
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
id|start_dac
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EAGAIN
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|d-&gt;wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|ERESTARTSYS
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|d-&gt;sample_buf
comma
id|buffer
comma
id|cnt
)paren
)paren
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|EFAULT
suffix:semicolon
id|copy_cnt
op_assign
id|cnt
suffix:semicolon
id|s_tmpl
op_assign
(paren
id|u32
op_star
)paren
id|d-&gt;sample_buf
suffix:semicolon
id|t_tmpl
op_assign
(paren
id|u32
op_star
)paren
(paren
id|d-&gt;dma_buf
op_plus
(paren
id|swptr
op_star
l_int|4
)paren
)paren
suffix:semicolon
multiline_comment|/* XXXKW assuming 16-bit stereo! */
r_do
(brace
id|u32
id|tmp
suffix:semicolon
id|t_tmpl
(braket
l_int|0
)braket
op_assign
id|cpu_to_be32
c_func
(paren
l_int|0x98000000
)paren
suffix:semicolon
id|tmp
op_assign
id|be32_to_cpu
c_func
(paren
id|s_tmpl
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|left
op_assign
id|tmp
op_amp
l_int|0xffff
suffix:semicolon
id|right
op_assign
id|tmp
op_rshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|swap
)paren
(brace
id|left
op_assign
id|swab16
c_func
(paren
id|left
)paren
suffix:semicolon
id|right
op_assign
id|swab16
c_func
(paren
id|right
)paren
suffix:semicolon
)brace
id|t_tmpl
(braket
l_int|1
)braket
op_assign
id|cpu_to_be32
c_func
(paren
id|left
op_rshift
l_int|8
)paren
suffix:semicolon
id|t_tmpl
(braket
l_int|2
)braket
op_assign
id|cpu_to_be32
c_func
(paren
(paren
(paren
id|left
op_amp
l_int|0xff
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|right
op_lshift
l_int|4
)paren
)paren
suffix:semicolon
id|s_tmpl
op_increment
suffix:semicolon
id|t_tmpl
op_add_assign
l_int|8
suffix:semicolon
id|copy_cnt
op_sub_assign
l_int|4
suffix:semicolon
)brace
r_while
c_loop
(paren
id|copy_cnt
)paren
suffix:semicolon
multiline_comment|/* Mux in any pending read/write accesses */
r_if
c_cond
(paren
id|s-&gt;reg_request
)paren
(brace
op_star
(paren
id|u64
op_star
)paren
(paren
id|d-&gt;dma_buf
op_plus
(paren
id|swptr
op_star
l_int|4
)paren
)paren
op_or_assign
id|cpu_to_be64
c_func
(paren
id|s-&gt;reg_request
)paren
suffix:semicolon
id|s-&gt;reg_request
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|s-&gt;dma_dac.reg_wait
)paren
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_WAVE_WRITE
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: copy in %d to swptr %x&bslash;n&quot;
comma
id|cnt
comma
id|swptr
)paren
)paren
suffix:semicolon
id|swptr
op_assign
(paren
id|swptr
op_plus
(paren
id|cnt
op_div
id|FRAME_SAMPLE_BYTES
)paren
)paren
op_mod
id|d-&gt;ringsz
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|cnt
op_div
id|FRAME_SAMPLE_BYTES
comma
id|SS_CSR
c_func
(paren
id|R_SER_DMA_DSCR_COUNT_TX
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|d-&gt;swptr
op_assign
id|swptr
suffix:semicolon
id|d-&gt;count
op_add_assign
id|cnt
suffix:semicolon
id|d-&gt;endcleared
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_sub_assign
id|cnt
suffix:semicolon
id|buffer
op_add_assign
id|cnt
suffix:semicolon
id|ret
op_add_assign
id|cnt
suffix:semicolon
id|start_dac
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_WAVE_WRITE
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_write()- %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|cs4297a_poll
r_static
r_int
r_int
id|cs4297a_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|poll_table_struct
op_star
id|wait
)paren
(brace
r_struct
id|cs4297a_state
op_star
id|s
op_assign
(paren
r_struct
id|cs4297a_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_WAVE_WRITE
op_or
id|CS_WAVE_READ
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_poll()+&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_WAVE_WRITE
op_or
id|CS_WAVE_READ
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_poll() wait on FMODE_WRITE&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_dac.ready
op_logical_and
id|prog_dmabuf_dac
c_func
(paren
id|s
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|s-&gt;dma_dac.wait
comma
id|wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_WAVE_WRITE
op_or
id|CS_WAVE_READ
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_poll() wait on FMODE_READ&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_dac.ready
op_logical_and
id|prog_dmabuf_adc
c_func
(paren
id|s
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|s-&gt;dma_adc.wait
comma
id|wait
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs4297a_update_ptr
c_func
(paren
id|s
comma
id|CS_FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;dma_dac.mapped
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;dma_dac.count
op_ge
(paren
r_int
)paren
id|s-&gt;dma_dac.fragsize
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;dma_dac.wakeup
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
r_else
id|mask
op_assign
l_int|0
suffix:semicolon
id|s-&gt;dma_dac.wakeup
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|s-&gt;dma_dac.sbufsz
op_div
l_int|2
)paren
op_ge
id|s-&gt;dma_dac.count
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;dma_adc.mapped
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;dma_adc.count
op_ge
(paren
r_int
)paren
id|s-&gt;dma_adc.fragsize
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|s-&gt;dma_adc.count
OG
l_int|0
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_WAVE_WRITE
op_or
id|CS_WAVE_READ
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_poll()- 0x%.8x&bslash;n&quot;
comma
id|mask
)paren
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
DECL|function|cs4297a_mmap
r_static
r_int
id|cs4297a_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
multiline_comment|/* XXXKW currently no mmap support */
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cs4297a_ioctl
r_static
r_int
id|cs4297a_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|cs4297a_state
op_star
id|s
op_assign
(paren
r_struct
id|cs4297a_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|audio_buf_info
id|abinfo
suffix:semicolon
id|count_info
id|cinfo
suffix:semicolon
r_int
id|val
comma
id|mapped
comma
id|ret
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_ioctl(): file=0x%.8x cmd=0x%.8x&bslash;n&quot;
comma
(paren
r_int
)paren
id|file
comma
id|cmd
)paren
)paren
suffix:semicolon
macro_line|#if CSDEBUG
id|cs_printioctl
c_func
(paren
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
id|mapped
op_assign
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
op_logical_and
id|s-&gt;dma_dac.mapped
)paren
op_logical_or
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
op_logical_and
id|s-&gt;dma_adc.mapped
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|OSS_GETVERSION
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
op_or
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_ioctl(): SOUND_VERSION=0x%.8x&bslash;n&quot;
comma
id|SOUND_VERSION
)paren
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|SOUND_VERSION
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SYNC
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_ioctl(): DSP_SYNC&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
r_return
id|drain_dac
c_func
(paren
id|s
comma
l_int|0
multiline_comment|/*file-&gt;f_flags &amp; O_NONBLOCK */
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SETDUPLEX
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETCAPS
suffix:colon
r_return
id|put_user
c_func
(paren
id|DSP_CAP_DUPLEX
op_or
id|DSP_CAP_REALTIME
op_or
id|DSP_CAP_TRIGGER
op_or
id|DSP_CAP_MMAP
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_RESET
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_ioctl(): DSP_RESET&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
id|s-&gt;irq
)paren
suffix:semicolon
id|s-&gt;dma_dac.count
op_assign
id|s-&gt;dma_dac.total_bytes
op_assign
id|s-&gt;dma_dac.blocks
op_assign
id|s-&gt;dma_dac.wakeup
op_assign
l_int|0
suffix:semicolon
id|s-&gt;dma_dac.swptr
op_assign
id|s-&gt;dma_dac.hwptr
op_assign
(paren
r_int
)paren
(paren
(paren
(paren
id|__raw_readq
c_func
(paren
id|SS_CSR
c_func
(paren
id|R_SER_DMA_CUR_DSCR_ADDR_TX
)paren
)paren
op_amp
id|M_DMA_CURDSCR_ADDR
)paren
op_minus
id|s-&gt;dma_dac.descrtab_phys
)paren
op_div
r_sizeof
(paren
id|serdma_descr_t
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
id|s-&gt;irq
)paren
suffix:semicolon
id|s-&gt;dma_adc.count
op_assign
id|s-&gt;dma_adc.total_bytes
op_assign
id|s-&gt;dma_adc.blocks
op_assign
id|s-&gt;dma_dac.wakeup
op_assign
l_int|0
suffix:semicolon
id|s-&gt;dma_adc.swptr
op_assign
id|s-&gt;dma_adc.hwptr
op_assign
(paren
r_int
)paren
(paren
(paren
(paren
id|__raw_readq
c_func
(paren
id|SS_CSR
c_func
(paren
id|R_SER_DMA_CUR_DSCR_ADDR_RX
)paren
)paren
op_amp
id|M_DMA_CURDSCR_ADDR
)paren
op_minus
id|s-&gt;dma_adc.descrtab_phys
)paren
op_div
r_sizeof
(paren
id|serdma_descr_t
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SPEED
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
op_or
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_ioctl(): DSP_SPEED val=%d -&gt; 48000&bslash;n&quot;
comma
id|val
)paren
)paren
suffix:semicolon
id|val
op_assign
l_int|48000
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_STEREO
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
op_or
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_ioctl(): DSP_STEREO val=%d&bslash;n&quot;
comma
id|val
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_adc.ready
op_assign
l_int|0
suffix:semicolon
id|s-&gt;prop_adc.channels
op_assign
id|val
ques
c_cond
l_int|2
suffix:colon
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_dac.ready
op_assign
l_int|0
suffix:semicolon
id|s-&gt;prop_dac.channels
op_assign
id|val
ques
c_cond
l_int|2
suffix:colon
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_CHANNELS
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
op_or
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_ioctl(): DSP_CHANNELS val=%d&bslash;n&quot;
comma
id|val
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_adc.ready
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|2
)paren
id|s-&gt;prop_adc.channels
op_assign
l_int|2
suffix:semicolon
r_else
id|s-&gt;prop_adc.channels
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_dac.ready
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|2
)paren
id|s-&gt;prop_dac.channels
op_assign
l_int|2
suffix:semicolon
r_else
id|s-&gt;prop_dac.channels
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
id|val
op_assign
id|s-&gt;prop_dac.channels
suffix:semicolon
r_else
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
id|val
op_assign
id|s-&gt;prop_adc.channels
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETFMTS
suffix:colon
singleline_comment|// Returns a mask 
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
op_or
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_ioctl(): DSP_GETFMT val=0x%.8x&bslash;n&quot;
comma
id|AFMT_S16_LE
op_or
id|AFMT_U16_LE
op_or
id|AFMT_S8
op_or
id|AFMT_U8
)paren
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|AFMT_S16_LE
op_or
id|AFMT_U16_LE
op_or
id|AFMT_S8
op_or
id|AFMT_U8
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFMT
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
op_or
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_ioctl(): DSP_SETFMT val=0x%.8x&bslash;n&quot;
comma
id|val
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
id|AFMT_QUERY
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_adc.ready
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
id|AFMT_S16_LE
op_logical_and
id|val
op_ne
id|AFMT_U16_LE
op_logical_and
id|val
op_ne
id|AFMT_S8
op_logical_and
id|val
op_ne
id|AFMT_U8
)paren
id|val
op_assign
id|AFMT_U8
suffix:semicolon
id|s-&gt;prop_adc.fmt
op_assign
id|val
suffix:semicolon
id|s-&gt;prop_adc.fmt_original
op_assign
id|s-&gt;prop_adc.fmt
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;dma_dac.ready
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
id|AFMT_S16_LE
op_logical_and
id|val
op_ne
id|AFMT_U16_LE
op_logical_and
id|val
op_ne
id|AFMT_S8
op_logical_and
id|val
op_ne
id|AFMT_U8
)paren
id|val
op_assign
id|AFMT_U8
suffix:semicolon
id|s-&gt;prop_dac.fmt
op_assign
id|val
suffix:semicolon
id|s-&gt;prop_dac.fmt_original
op_assign
id|s-&gt;prop_dac.fmt
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
id|val
op_assign
id|s-&gt;prop_dac.fmt_original
suffix:semicolon
r_else
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
id|val
op_assign
id|s-&gt;prop_adc.fmt_original
suffix:semicolon
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
op_or
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_ioctl(): DSP_SETFMT return val=0x%.8x&bslash;n&quot;
comma
id|val
)paren
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_POST
suffix:colon
id|CS_DBGOUT
c_func
(paren
id|CS_IOCTL
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_ioctl(): DSP_POST&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETTRIGGER
suffix:colon
id|val
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|s-&gt;ena
op_amp
id|FMODE_READ
)paren
id|val
op_or_assign
id|PCM_ENABLE_INPUT
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|s-&gt;ena
op_amp
id|FMODE_WRITE
)paren
id|val
op_or_assign
id|PCM_ENABLE_OUTPUT
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETTRIGGER
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
id|val
op_amp
id|PCM_ENABLE_INPUT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_adc.ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf_adc
c_func
(paren
id|s
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|start_adc
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_else
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|val
op_amp
id|PCM_ENABLE_OUTPUT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_dac.ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf_dac
c_func
(paren
id|s
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|start_dac
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_else
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOSPACE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_dac.ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf_dac
c_func
(paren
id|s
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs4297a_update_ptr
c_func
(paren
id|s
comma
id|CS_FALSE
)paren
suffix:semicolon
id|abinfo.fragsize
op_assign
id|s-&gt;dma_dac.fragsize
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.mapped
)paren
id|abinfo.bytes
op_assign
id|s-&gt;dma_dac.sbufsz
suffix:semicolon
r_else
id|abinfo.bytes
op_assign
id|s-&gt;dma_dac.sbufsz
op_minus
id|s-&gt;dma_dac.count
suffix:semicolon
id|abinfo.fragstotal
op_assign
id|s-&gt;dma_dac.numfrag
suffix:semicolon
id|abinfo.fragments
op_assign
id|abinfo.bytes
op_rshift
id|s-&gt;dma_dac.fragshift
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_PARMS
comma
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_ioctl(): GETOSPACE .fragsize=%d .bytes=%d .fragstotal=%d .fragments=%d&bslash;n&quot;
comma
id|abinfo.fragsize
comma
id|abinfo.bytes
comma
id|abinfo.fragstotal
comma
id|abinfo.fragments
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|abinfo
comma
r_sizeof
(paren
id|abinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETISPACE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_adc.ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf_adc
c_func
(paren
id|s
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs4297a_update_ptr
c_func
(paren
id|s
comma
id|CS_FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;conversion
)paren
(brace
id|abinfo.fragsize
op_assign
id|s-&gt;dma_adc.fragsize
op_div
l_int|2
suffix:semicolon
id|abinfo.bytes
op_assign
id|s-&gt;dma_adc.count
op_div
l_int|2
suffix:semicolon
id|abinfo.fragstotal
op_assign
id|s-&gt;dma_adc.numfrag
suffix:semicolon
id|abinfo.fragments
op_assign
id|abinfo.bytes
op_rshift
(paren
id|s-&gt;dma_adc.fragshift
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|abinfo.fragsize
op_assign
id|s-&gt;dma_adc.fragsize
suffix:semicolon
id|abinfo.bytes
op_assign
id|s-&gt;dma_adc.count
suffix:semicolon
id|abinfo.fragstotal
op_assign
id|s-&gt;dma_adc.numfrag
suffix:semicolon
id|abinfo.fragments
op_assign
id|abinfo.bytes
op_rshift
id|s-&gt;dma_adc.fragshift
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|abinfo
comma
r_sizeof
(paren
id|abinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_NONBLOCK
suffix:colon
id|file-&gt;f_flags
op_or_assign
id|O_NONBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETODELAY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_dac.ready
op_logical_and
id|prog_dmabuf_dac
c_func
(paren
id|s
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs4297a_update_ptr
c_func
(paren
id|s
comma
id|CS_FALSE
)paren
suffix:semicolon
id|val
op_assign
id|s-&gt;dma_dac.count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETIPTR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_adc.ready
op_logical_and
id|prog_dmabuf_adc
c_func
(paren
id|s
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs4297a_update_ptr
c_func
(paren
id|s
comma
id|CS_FALSE
)paren
suffix:semicolon
id|cinfo.bytes
op_assign
id|s-&gt;dma_adc.total_bytes
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_adc.mapped
)paren
(brace
id|cinfo.blocks
op_assign
(paren
id|cinfo.bytes
op_rshift
id|s-&gt;dma_adc.fragshift
)paren
op_minus
id|s-&gt;dma_adc.blocks
suffix:semicolon
id|s-&gt;dma_adc.blocks
op_assign
id|cinfo.bytes
op_rshift
id|s-&gt;dma_adc.fragshift
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|s-&gt;conversion
)paren
(brace
id|cinfo.blocks
op_assign
id|s-&gt;dma_adc.count
op_div
l_int|2
op_rshift
(paren
id|s-&gt;dma_adc.fragshift
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
id|cinfo.blocks
op_assign
id|s-&gt;dma_adc.count
op_rshift
id|s-&gt;dma_adc
dot
id|fragshift
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;conversion
)paren
id|cinfo.ptr
op_assign
id|s-&gt;dma_adc.hwptr
op_div
l_int|2
suffix:semicolon
r_else
id|cinfo.ptr
op_assign
id|s-&gt;dma_adc.hwptr
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_adc.mapped
)paren
id|s-&gt;dma_adc.count
op_and_assign
id|s-&gt;dma_adc.fragsize
op_minus
l_int|1
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|cinfo
comma
r_sizeof
(paren
id|cinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOPTR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;dma_dac.ready
op_logical_and
id|prog_dmabuf_dac
c_func
(paren
id|s
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|cs4297a_update_ptr
c_func
(paren
id|s
comma
id|CS_FALSE
)paren
suffix:semicolon
id|cinfo.bytes
op_assign
id|s-&gt;dma_dac.total_bytes
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.mapped
)paren
(brace
id|cinfo.blocks
op_assign
(paren
id|cinfo.bytes
op_rshift
id|s-&gt;dma_dac.fragshift
)paren
op_minus
id|s-&gt;dma_dac.blocks
suffix:semicolon
id|s-&gt;dma_dac.blocks
op_assign
id|cinfo.bytes
op_rshift
id|s-&gt;dma_dac.fragshift
suffix:semicolon
)brace
r_else
(brace
id|cinfo.blocks
op_assign
id|s-&gt;dma_dac.count
op_rshift
id|s-&gt;dma_dac.fragshift
suffix:semicolon
)brace
id|cinfo.ptr
op_assign
id|s-&gt;dma_dac.hwptr
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;dma_dac.mapped
)paren
id|s-&gt;dma_dac.count
op_and_assign
id|s-&gt;dma_dac.fragsize
op_minus
l_int|1
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|cinfo
comma
r_sizeof
(paren
id|cinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETBLKSIZE
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
(paren
id|val
op_assign
id|prog_dmabuf_dac
c_func
(paren
id|s
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|s-&gt;dma_dac.fragsize
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|val
op_assign
id|prog_dmabuf_adc
c_func
(paren
id|s
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;conversion
)paren
r_return
id|put_user
c_func
(paren
id|s-&gt;dma_adc.fragsize
op_div
l_int|2
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_else
r_return
id|put_user
c_func
(paren
id|s-&gt;dma_adc.fragsize
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFRAGMENT
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
singleline_comment|// Say OK, but do nothing.
r_case
id|SNDCTL_DSP_SUBDIVIDE
suffix:colon
r_if
c_cond
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
op_logical_and
id|s-&gt;dma_adc.subdivision
)paren
op_logical_or
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
op_logical_and
id|s-&gt;dma_dac.subdivision
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
l_int|1
op_logical_and
id|val
op_ne
l_int|2
op_logical_and
id|val
op_ne
l_int|4
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
id|s-&gt;dma_adc.subdivision
op_assign
id|val
suffix:semicolon
r_else
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
id|s-&gt;dma_dac.subdivision
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SOUND_PCM_READ_RATE
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
r_return
id|put_user
c_func
(paren
id|s-&gt;prop_adc.rate
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
r_return
id|put_user
c_func
(paren
id|s-&gt;prop_dac.rate
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_CHANNELS
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
r_return
id|put_user
c_func
(paren
id|s-&gt;prop_adc.channels
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
r_return
id|put_user
c_func
(paren
id|s-&gt;prop_dac.channels
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_BITS
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
r_return
id|put_user
c_func
(paren
(paren
id|s-&gt;prop_adc
dot
id|fmt
op_amp
(paren
id|AFMT_S8
op_or
id|AFMT_U8
)paren
)paren
ques
c_cond
l_int|8
suffix:colon
l_int|16
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
r_return
id|put_user
c_func
(paren
(paren
id|s-&gt;prop_dac
dot
id|fmt
op_amp
(paren
id|AFMT_S8
op_or
id|AFMT_U8
)paren
)paren
ques
c_cond
l_int|8
suffix:colon
l_int|16
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_WRITE_FILTER
suffix:colon
r_case
id|SNDCTL_DSP_SETSYNCRO
suffix:colon
r_case
id|SOUND_PCM_READ_FILTER
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|mixer_ioctl
c_func
(paren
id|s
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
DECL|function|cs4297a_release
r_static
r_int
id|cs4297a_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|cs4297a_state
op_star
id|s
op_assign
(paren
r_struct
id|cs4297a_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_RELEASE
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_release(): inode=0x%.8x file=0x%.8x f_mode=0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|inode
comma
(paren
r_int
)paren
id|file
comma
id|file-&gt;f_mode
)paren
)paren
suffix:semicolon
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|drain_dac
c_func
(paren
id|s
comma
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|s-&gt;open_sem_dac
)paren
suffix:semicolon
id|stop_dac
c_func
(paren
id|s
)paren
suffix:semicolon
id|dealloc_dmabuf
c_func
(paren
id|s
comma
op_amp
id|s-&gt;dma_dac
)paren
suffix:semicolon
id|s-&gt;open_mode
op_and_assign
op_complement
id|FMODE_WRITE
suffix:semicolon
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem_dac
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|s-&gt;open_wait_dac
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|drain_adc
c_func
(paren
id|s
comma
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|s-&gt;open_sem_adc
)paren
suffix:semicolon
id|stop_adc
c_func
(paren
id|s
)paren
suffix:semicolon
id|dealloc_dmabuf
c_func
(paren
id|s
comma
op_amp
id|s-&gt;dma_adc
)paren
suffix:semicolon
id|s-&gt;open_mode
op_and_assign
op_complement
id|FMODE_READ
suffix:semicolon
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem_adc
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|s-&gt;open_wait_adc
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cs4297a_open
r_static
r_int
id|cs4297a_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
op_assign
id|iminor
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|cs4297a_state
op_star
id|s
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_OPEN
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_open(): inode=0x%.8x file=0x%.8x f_mode=0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|inode
comma
(paren
r_int
)paren
id|file
comma
id|file-&gt;f_mode
)paren
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_OPEN
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: status = %08x&bslash;n&quot;
comma
(paren
r_int
)paren
id|__raw_readq
c_func
(paren
id|SS_CSR
c_func
(paren
id|R_SER_STATUS_DEBUG
)paren
)paren
)paren
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|entry
comma
op_amp
id|cs4297a_devs
)paren
(brace
id|s
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|cs4297a_state
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|s-&gt;dev_audio
op_xor
id|minor
)paren
op_amp
op_complement
l_int|0xf
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry
op_eq
op_amp
id|cs4297a_devs
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_OPEN
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_open(): Error - unable to find audio state struct&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|VALIDATE_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
id|s
suffix:semicolon
singleline_comment|// wait for device to become free 
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
(paren
id|FMODE_WRITE
op_or
id|FMODE_READ
)paren
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_OPEN
op_or
id|CS_ERROR
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_open(): Error - must open READ and/or WRITE&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|__raw_readq
c_func
(paren
id|SS_CSR
c_func
(paren
id|R_SER_DMA_DSCR_COUNT_TX
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: TX pipe needs to drain&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|__raw_readq
c_func
(paren
id|SS_CSR
c_func
(paren
id|R_SER_DMA_DSCR_COUNT_TX
)paren
)paren
)paren
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|s-&gt;open_sem_dac
)paren
suffix:semicolon
r_while
c_loop
(paren
id|s-&gt;open_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem_dac
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem_dac
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|s-&gt;open_wait_dac
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;open - sig pending&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|s-&gt;open_sem_dac
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|down
c_func
(paren
op_amp
id|s-&gt;open_sem_adc
)paren
suffix:semicolon
r_while
c_loop
(paren
id|s-&gt;open_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem_adc
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem_adc
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|s-&gt;open_wait_adc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;open - sig pending&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|s-&gt;open_sem_adc
)paren
suffix:semicolon
)brace
)brace
id|s-&gt;open_mode
op_or_assign
id|file-&gt;f_mode
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|s-&gt;prop_adc.fmt
op_assign
id|AFMT_S16_BE
suffix:semicolon
id|s-&gt;prop_adc.fmt_original
op_assign
id|s-&gt;prop_adc.fmt
suffix:semicolon
id|s-&gt;prop_adc.channels
op_assign
l_int|2
suffix:semicolon
id|s-&gt;prop_adc.rate
op_assign
l_int|48000
suffix:semicolon
id|s-&gt;conversion
op_assign
l_int|0
suffix:semicolon
id|s-&gt;ena
op_and_assign
op_complement
id|FMODE_READ
suffix:semicolon
id|s-&gt;dma_adc.ossfragshift
op_assign
id|s-&gt;dma_adc.ossmaxfrags
op_assign
id|s-&gt;dma_adc.subdivision
op_assign
l_int|0
suffix:semicolon
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem_adc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prog_dmabuf_adc
c_func
(paren
id|s
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_OPEN
op_or
id|CS_ERROR
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: adc Program dmabufs failed.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|cs4297a_release
c_func
(paren
id|inode
comma
id|file
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|s-&gt;prop_dac.fmt
op_assign
id|AFMT_S16_BE
suffix:semicolon
id|s-&gt;prop_dac.fmt_original
op_assign
id|s-&gt;prop_dac.fmt
suffix:semicolon
id|s-&gt;prop_dac.channels
op_assign
l_int|2
suffix:semicolon
id|s-&gt;prop_dac.rate
op_assign
l_int|48000
suffix:semicolon
id|s-&gt;conversion
op_assign
l_int|0
suffix:semicolon
id|s-&gt;ena
op_and_assign
op_complement
id|FMODE_WRITE
suffix:semicolon
id|s-&gt;dma_dac.ossfragshift
op_assign
id|s-&gt;dma_dac.ossmaxfrags
op_assign
id|s-&gt;dma_dac.subdivision
op_assign
l_int|0
suffix:semicolon
id|up
c_func
(paren
op_amp
id|s-&gt;open_sem_dac
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prog_dmabuf_dac
c_func
(paren
id|s
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_OPEN
op_or
id|CS_ERROR
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: dac Program dmabufs failed.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|cs4297a_release
c_func
(paren
id|inode
comma
id|file
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
id|CS_DBGOUT
c_func
(paren
id|CS_FUNCTION
op_or
id|CS_OPEN
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_open()- 0&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|nonseekable_open
c_func
(paren
id|inode
comma
id|file
)paren
suffix:semicolon
)brace
singleline_comment|// ******************************************************************************************
singleline_comment|//   Wave (audio) file operations struct.
singleline_comment|// ******************************************************************************************
DECL|variable|cs4297a_audio_fops
r_static
multiline_comment|/*const */
r_struct
id|file_operations
id|cs4297a_audio_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|llseek
op_assign
id|no_llseek
comma
dot
id|read
op_assign
id|cs4297a_read
comma
dot
id|write
op_assign
id|cs4297a_write
comma
dot
id|poll
op_assign
id|cs4297a_poll
comma
dot
id|ioctl
op_assign
id|cs4297a_ioctl
comma
dot
id|mmap
op_assign
id|cs4297a_mmap
comma
dot
id|open
op_assign
id|cs4297a_open
comma
dot
id|release
op_assign
id|cs4297a_release
comma
)brace
suffix:semicolon
DECL|function|cs4297a_interrupt
r_static
r_void
id|cs4297a_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|cs4297a_state
op_star
id|s
op_assign
(paren
r_struct
id|cs4297a_state
op_star
)paren
id|dev_id
suffix:semicolon
id|u32
id|status
suffix:semicolon
id|status
op_assign
id|__raw_readq
c_func
(paren
id|SS_CSR
c_func
(paren
id|R_SER_STATUS_DEBUG
)paren
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_INTERRUPT
comma
l_int|6
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_interrupt() HISR=0x%.8x&bslash;n&quot;
comma
id|status
)paren
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* XXXKW what check *should* be done here? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
(paren
id|M_SYNCSER_RX_EOP_COUNT
op_or
id|M_SYNCSER_RX_OVERRUN
op_or
id|M_SYNCSER_RX_SYNC_ERR
)paren
)paren
)paren
(brace
id|status
op_assign
id|__raw_readq
c_func
(paren
id|SS_CSR
c_func
(paren
id|R_SER_STATUS
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: unexpected interrupt (status %08x)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|status
op_amp
id|M_SYNCSER_RX_SYNC_ERR
)paren
(brace
id|status
op_assign
id|__raw_readq
c_func
(paren
id|SS_CSR
c_func
(paren
id|R_SER_STATUS
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: rx sync error (status %08x)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|M_SYNCSER_RX_OVERRUN
)paren
(brace
r_int
id|newptr
comma
id|i
suffix:semicolon
id|s-&gt;stats.rx_ovrrn
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: receive FIFO overrun&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Fix things up: get the receive descriptor pool&n;                   clean and give them back to the hardware */
r_while
c_loop
(paren
id|__raw_readq
c_func
(paren
id|SS_CSR
c_func
(paren
id|R_SER_DMA_DSCR_COUNT_RX
)paren
)paren
)paren
suffix:semicolon
id|newptr
op_assign
(paren
r_int
)paren
(paren
(paren
(paren
id|__raw_readq
c_func
(paren
id|SS_CSR
c_func
(paren
id|R_SER_DMA_CUR_DSCR_ADDR_RX
)paren
)paren
op_amp
id|M_DMA_CURDSCR_ADDR
)paren
op_minus
id|s-&gt;dma_adc.descrtab_phys
)paren
op_div
r_sizeof
(paren
id|serdma_descr_t
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DMA_DESCR
suffix:semicolon
id|i
op_increment
)paren
(brace
id|s-&gt;dma_adc.descrtab
(braket
id|i
)braket
dot
id|descr_a
op_and_assign
op_complement
id|M_DMA_SERRX_SOP
suffix:semicolon
)brace
id|s-&gt;dma_adc.swptr
op_assign
id|s-&gt;dma_adc.hwptr
op_assign
id|newptr
suffix:semicolon
id|s-&gt;dma_adc.count
op_assign
l_int|0
suffix:semicolon
id|s-&gt;dma_adc.sb_swptr
op_assign
id|s-&gt;dma_adc.sb_hwptr
op_assign
id|s-&gt;dma_adc.sample_buf
suffix:semicolon
id|__raw_writeq
c_func
(paren
id|DMA_DESCR
comma
id|SS_CSR
c_func
(paren
id|R_SER_DMA_DSCR_COUNT_RX
)paren
)paren
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
id|cs4297a_update_ptr
c_func
(paren
id|s
comma
id|CS_TRUE
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_INTERRUPT
comma
l_int|6
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_interrupt()-&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_struct
id|initvol
(brace
r_int
id|mixch
suffix:semicolon
r_int
id|vol
suffix:semicolon
)brace
id|initvol
(braket
)braket
id|__initdata
op_assign
(brace
(brace
id|SOUND_MIXER_WRITE_VOLUME
comma
l_int|0x4040
)brace
comma
(brace
id|SOUND_MIXER_WRITE_PCM
comma
l_int|0x4040
)brace
comma
(brace
id|SOUND_MIXER_WRITE_SYNTH
comma
l_int|0x4040
)brace
comma
(brace
id|SOUND_MIXER_WRITE_CD
comma
l_int|0x4040
)brace
comma
(brace
id|SOUND_MIXER_WRITE_LINE
comma
l_int|0x4040
)brace
comma
(brace
id|SOUND_MIXER_WRITE_LINE1
comma
l_int|0x4040
)brace
comma
(brace
id|SOUND_MIXER_WRITE_RECLEV
comma
l_int|0x0000
)brace
comma
(brace
id|SOUND_MIXER_WRITE_SPEAKER
comma
l_int|0x4040
)brace
comma
(brace
id|SOUND_MIXER_WRITE_MIC
comma
l_int|0x0000
)brace
)brace
suffix:semicolon
macro_line|#endif
DECL|function|cs4297a_init
r_static
r_int
id|__init
id|cs4297a_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|cs4297a_state
op_star
id|s
suffix:semicolon
id|u32
id|pwr
comma
id|id
suffix:semicolon
id|mm_segment_t
id|fs
suffix:semicolon
r_int
id|rval
suffix:semicolon
macro_line|#ifndef CONFIG_BCM_CS4297A_CSWARM
id|u64
id|cfg
suffix:semicolon
r_int
id|mdio_val
suffix:semicolon
macro_line|#endif
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
op_or
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_init_module()+ &bslash;n&quot;
)paren
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_BCM_CS4297A_CSWARM
id|mdio_val
op_assign
id|__raw_readq
c_func
(paren
id|KSEG1
op_plus
id|A_MAC_REGISTER
c_func
(paren
l_int|2
comma
id|R_MAC_MDIO
)paren
)paren
op_amp
(paren
id|M_MAC_MDIO_DIR
op_or
id|M_MAC_MDIO_OUT
)paren
suffix:semicolon
multiline_comment|/* Check syscfg for synchronous serial on port 1 */
id|cfg
op_assign
id|__raw_readq
c_func
(paren
id|KSEG1
op_plus
id|A_SCD_SYSTEM_CFG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cfg
op_amp
id|M_SYS_SER1_ENABLE
)paren
)paren
(brace
id|__raw_writeq
c_func
(paren
id|cfg
op_or
id|M_SYS_SER1_ENABLE
comma
id|KSEG1
op_plus
id|A_SCD_SYSTEM_CFG
)paren
suffix:semicolon
id|cfg
op_assign
id|__raw_readq
c_func
(paren
id|KSEG1
op_plus
id|A_SCD_SYSTEM_CFG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cfg
op_amp
id|M_SYS_SER1_ENABLE
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: serial port 1 not configured for synchronous operation&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: serial port 1 switching to synchronous operation&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Force the codec (on SWARM) to reset by clearing&n;                   GENO, preserving MDIO (no effect on CSWARM) */
id|__raw_writeq
c_func
(paren
id|mdio_val
comma
id|KSEG1
op_plus
id|A_MAC_REGISTER
c_func
(paren
l_int|2
comma
id|R_MAC_MDIO
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
multiline_comment|/* Now set GENO */
id|__raw_writeq
c_func
(paren
id|mdio_val
op_or
id|M_MAC_GENC
comma
id|KSEG1
op_plus
id|A_MAC_REGISTER
c_func
(paren
l_int|2
comma
id|R_MAC_MDIO
)paren
)paren
suffix:semicolon
multiline_comment|/* Give the codec some time to finish resetting (start the bit clock) */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|s
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|cs4297a_state
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: probe() no memory for state struct.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|s
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|cs4297a_state
)paren
)paren
suffix:semicolon
id|s-&gt;magic
op_assign
id|CS4297a_MAGIC
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|s-&gt;dma_adc.wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|s-&gt;dma_dac.wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|s-&gt;dma_adc.reg_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|s-&gt;dma_dac.reg_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|s-&gt;open_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|s-&gt;open_wait_adc
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|s-&gt;open_wait_dac
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|s-&gt;open_sem_adc
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|s-&gt;open_sem_dac
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
id|s-&gt;irq
op_assign
id|K_INT_SER_1
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
(paren
id|s-&gt;irq
comma
id|cs4297a_interrupt
comma
l_int|0
comma
l_string|&quot;Crystal CS4297a&quot;
comma
id|s
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
op_or
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: irq %u in use&bslash;n&quot;
comma
id|s-&gt;irq
)paren
)paren
suffix:semicolon
r_goto
id|err_irq
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|s-&gt;dev_audio
op_assign
id|register_sound_dsp
c_func
(paren
op_amp
id|cs4297a_audio_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
op_or
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: probe() register_sound_dsp() failed.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_goto
id|err_dev1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|s-&gt;dev_mixer
op_assign
id|register_sound_mixer
c_func
(paren
op_amp
id|cs4297a_mixer_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
op_or
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: probe() register_sound_mixer() failed.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_goto
id|err_dev2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ser_init
c_func
(paren
id|s
)paren
op_logical_or
id|dma_init
c_func
(paren
id|s
)paren
)paren
(brace
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
op_or
id|CS_ERROR
comma
l_int|1
comma
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cs4297a: ser_init failed.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_goto
id|err_dev3
suffix:semicolon
)brace
r_do
(brace
id|udelay
c_func
(paren
l_int|4000
)paren
suffix:semicolon
id|rval
op_assign
id|cs4297a_read_ac97
c_func
(paren
id|s
comma
id|AC97_POWER_CONTROL
comma
op_amp
id|pwr
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|rval
op_logical_and
(paren
id|pwr
op_ne
l_int|0xf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rval
)paren
(brace
r_char
op_star
id|sb1250_duart_present
suffix:semicolon
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
macro_line|#if 0
id|val
op_assign
id|SOUND_MASK_LINE
suffix:semicolon
id|mixer_ioctl
c_func
(paren
id|s
comma
id|SOUND_MIXER_WRITE_RECSRC
comma
(paren
r_int
r_int
)paren
op_amp
id|val
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|initvol
)paren
op_div
r_sizeof
(paren
id|initvol
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|val
op_assign
id|initvol
(braket
id|i
)braket
dot
id|vol
suffix:semicolon
id|mixer_ioctl
c_func
(paren
id|s
comma
id|initvol
(braket
id|i
)braket
dot
id|mixch
comma
(paren
r_int
r_int
)paren
op_amp
id|val
)paren
suffix:semicolon
)brace
singleline_comment|//                cs4297a_write_ac97(s, 0x18, 0x0808);
macro_line|#else
singleline_comment|//                cs4297a_write_ac97(s, 0x5e, 0x180);
id|cs4297a_write_ac97
c_func
(paren
id|s
comma
l_int|0x02
comma
l_int|0x0808
)paren
suffix:semicolon
id|cs4297a_write_ac97
c_func
(paren
id|s
comma
l_int|0x18
comma
l_int|0x0808
)paren
suffix:semicolon
macro_line|#endif
id|set_fs
c_func
(paren
id|fs
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|s-&gt;list
comma
op_amp
id|cs4297a_devs
)paren
suffix:semicolon
id|cs4297a_read_ac97
c_func
(paren
id|s
comma
id|AC97_VENDOR_ID1
comma
op_amp
id|id
)paren
suffix:semicolon
id|sb1250_duart_present
op_assign
id|symbol_get
c_func
(paren
id|sb1250_duart_present
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb1250_duart_present
)paren
id|sb1250_duart_present
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: initialized (vendor id = %x)&bslash;n&quot;
comma
id|id
)paren
suffix:semicolon
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
op_or
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cs4297a_init_module()-&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|err_dev3
suffix:colon
id|unregister_sound_mixer
c_func
(paren
id|s-&gt;dev_mixer
)paren
suffix:semicolon
id|err_dev2
suffix:colon
id|unregister_sound_dsp
c_func
(paren
id|s-&gt;dev_audio
)paren
suffix:semicolon
id|err_dev1
suffix:colon
id|free_irq
c_func
(paren
id|s-&gt;irq
comma
id|s
)paren
suffix:semicolon
id|err_irq
suffix:colon
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: initialization failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|cs4297a_cleanup
r_static
r_void
id|__exit
id|cs4297a_cleanup
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;          XXXKW &n;           disable_irq, free_irq&n;           drain DMA queue&n;           disable DMA&n;           disable TX/RX&n;           free memory&n;        */
id|CS_DBGOUT
c_func
(paren
id|CS_INIT
op_or
id|CS_FUNCTION
comma
l_int|2
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs4297a: cleanup_cs4297a() finished&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
singleline_comment|// --------------------------------------------------------------------- 
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Kip Walker, Broadcom Corp.&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Cirrus Logic CS4297a Driver for Broadcom SWARM board&quot;
)paren
suffix:semicolon
singleline_comment|// --------------------------------------------------------------------- 
DECL|variable|cs4297a_init
id|module_init
c_func
(paren
id|cs4297a_init
)paren
suffix:semicolon
DECL|variable|cs4297a_cleanup
id|module_exit
c_func
(paren
id|cs4297a_cleanup
)paren
suffix:semicolon
eof
