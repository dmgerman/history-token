multiline_comment|/*&n; *&t;ALI  ali5455 and friends ICH driver for Linux&n; *&t;LEI HU &lt;Lei_Hu@ali.com.tw&gt;&n; *&n; *  Built from:&n; *&t;drivers/sound/i810_audio&n; *&n; *  &t;The ALi 5455 is similar but not quite identical to the Intel ICH&n; *&t;series of controllers. Its easier to keep the driver separated from&n; *&t;the i810 driver.&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; *&n; *&t;This program is distributed in the hope that it will be useful,&n; *&t;but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *&t;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *&t;GNU General Public License for more details.&n; *&n; *&t;You should have received a copy of the GNU General Public License&n; *&t;along with this program; if not, write to the Free Software&n; *&t;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; *&n; *&t;ALi 5455 theory of operation&n; *&n; *&t;The chipset provides three DMA channels that talk to an AC97&n; *&t;CODEC (AC97 is a digital/analog mixer standard). At its simplest&n; *&t;you get 48Khz audio with basic volume and mixer controls. At the&n; *&t;best you get rate adaption in the codec. We set the card up so&n; *&t;that we never take completion interrupts but instead keep the card&n; *&t;chasing its tail around a ring buffer. This is needed for mmap&n; *&t;mode audio and happens to work rather well for non-mmap modes too.&n; *&n; *&t;The board has one output channel for PCM audio (supported) and&n; *&t;a stereo line in and mono microphone input. Again these are normally&n; *&t;locked to 48Khz only. Right now recording is not finished.&n; *&n; *&t;There is no midi support, no synth support. Use timidity. To get&n; *&t;esd working you need to use esd -r 48000 as it won&squot;t probe 48KHz&n; *&t;by default. mpg123 can&squot;t handle 48Khz only audio so use xmms.&n; *&n; *&t;If you need to force a specific rate set the clocking= option&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sound.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/soundcard.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/ac97_codec.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#ifndef PCI_DEVICE_ID_ALI_5455
DECL|macro|PCI_DEVICE_ID_ALI_5455
mdefine_line|#define PCI_DEVICE_ID_ALI_5455&t;0x5455
macro_line|#endif
macro_line|#ifndef PCI_VENDOR_ID_ALI
DECL|macro|PCI_VENDOR_ID_ALI
mdefine_line|#define PCI_VENDOR_ID_ALI&t;0x10b9
macro_line|#endif
DECL|variable|strict_clocking
r_static
r_int
id|strict_clocking
op_assign
l_int|0
suffix:semicolon
DECL|variable|clocking
r_static
r_int
r_int
id|clocking
op_assign
l_int|0
suffix:semicolon
DECL|variable|codec_pcmout_share_spdif_locked
r_static
r_int
r_int
id|codec_pcmout_share_spdif_locked
op_assign
l_int|0
suffix:semicolon
DECL|variable|codec_independent_spdif_locked
r_static
r_int
r_int
id|codec_independent_spdif_locked
op_assign
l_int|0
suffix:semicolon
DECL|variable|controller_pcmout_share_spdif_locked
r_static
r_int
r_int
id|controller_pcmout_share_spdif_locked
op_assign
l_int|0
suffix:semicolon
DECL|variable|controller_independent_spdif_locked
r_static
r_int
r_int
id|controller_independent_spdif_locked
op_assign
l_int|0
suffix:semicolon
DECL|variable|globel
r_static
r_int
r_int
id|globel
op_assign
l_int|0
suffix:semicolon
DECL|macro|ADC_RUNNING
mdefine_line|#define ADC_RUNNING&t;1
DECL|macro|DAC_RUNNING
mdefine_line|#define DAC_RUNNING&t;2
DECL|macro|CODEC_SPDIFOUT_RUNNING
mdefine_line|#define CODEC_SPDIFOUT_RUNNING 8
DECL|macro|CONTROLLER_SPDIFOUT_RUNNING
mdefine_line|#define CONTROLLER_SPDIFOUT_RUNNING 4
DECL|macro|SPDIF_ENABLE_OUTPUT
mdefine_line|#define SPDIF_ENABLE_OUTPUT&t;4&t;/* bits 0,1 are PCM */
DECL|macro|ALI5455_FMT_16BIT
mdefine_line|#define ALI5455_FMT_16BIT&t;1
DECL|macro|ALI5455_FMT_STEREO
mdefine_line|#define ALI5455_FMT_STEREO&t;2
DECL|macro|ALI5455_FMT_MASK
mdefine_line|#define ALI5455_FMT_MASK&t;3
DECL|macro|SPDIF_ON
mdefine_line|#define SPDIF_ON&t;0x0004
DECL|macro|SURR_ON
mdefine_line|#define SURR_ON&t;&t;0x0010
DECL|macro|CENTER_LFE_ON
mdefine_line|#define CENTER_LFE_ON&t;0x0020
DECL|macro|VOL_MUTED
mdefine_line|#define VOL_MUTED&t;0x8000
DECL|macro|ALI_SPDIF_OUT_CH_STATUS
mdefine_line|#define ALI_SPDIF_OUT_CH_STATUS 0xbf
multiline_comment|/* the 810&squot;s array of pointers to data buffers */
DECL|struct|sg_item
r_struct
id|sg_item
(brace
DECL|macro|BUSADDR_MASK
mdefine_line|#define BUSADDR_MASK&t;0xFFFFFFFE
DECL|member|busaddr
id|u32
id|busaddr
suffix:semicolon
DECL|macro|CON_IOC
mdefine_line|#define CON_IOC &t;0x80000000&t;/* interrupt on completion */
DECL|macro|CON_BUFPAD
mdefine_line|#define CON_BUFPAD&t;0x40000000&t;/* pad underrun with last sample, else 0 */
DECL|macro|CON_BUFLEN_MASK
mdefine_line|#define CON_BUFLEN_MASK&t;0x0000ffff&t;/* buffer length in samples */
DECL|member|control
id|u32
id|control
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* an instance of the ali channel */
DECL|macro|SG_LEN
mdefine_line|#define SG_LEN 32
DECL|struct|ali_channel
r_struct
id|ali_channel
(brace
multiline_comment|/* these sg guys should probably be allocated&n;&t;   separately as nocache. Must be 8 byte aligned */
DECL|member|sg
r_struct
id|sg_item
id|sg
(braket
id|SG_LEN
)braket
suffix:semicolon
multiline_comment|/* 32*8 */
DECL|member|offset
id|u32
id|offset
suffix:semicolon
multiline_comment|/* 4 */
DECL|member|port
id|u32
id|port
suffix:semicolon
multiline_comment|/* 4 */
DECL|member|used
id|u32
id|used
suffix:semicolon
DECL|member|num
id|u32
id|num
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * we have 3 separate dma engines.  pcm in, pcm out, and mic.&n; * each dma engine has controlling registers.  These goofy&n; * names are from the datasheet, but make it easy to write&n; * code while leafing through it.&n; */
DECL|macro|ENUM_ENGINE
mdefine_line|#define ENUM_ENGINE(PRE,DIG) &t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;enum {&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;PRE##_BDBAR =&t;0x##DIG##0,&t;&t;/* Buffer Descriptor list Base Address */&t;&bslash;&n;&t;PRE##_CIV =&t;0x##DIG##4,&t;&t;/* Current Index Value */&t;&t;&t;&bslash;&n;&t;PRE##_LVI =&t;0x##DIG##5,&t;&t;/* Last Valid Index */&t;&t;&t;&t;&bslash;&n;&t;PRE##_SR =&t;0x##DIG##6,&t;&t;/* Status Register */&t;&t;&t;&t;&bslash;&n;&t;PRE##_PICB =&t;0x##DIG##8,&t;&t;/* Position In Current Buffer */&t;&t;&bslash;&n;&t;PRE##_CR =&t;0x##DIG##b&t;&t;/* Control Register */&t;&t;&t;&t;&bslash;&n;}
id|ENUM_ENGINE
c_func
(paren
id|OFF
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Offsets */
id|ENUM_ENGINE
c_func
(paren
id|PI
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* PCM In */
id|ENUM_ENGINE
c_func
(paren
id|PO
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/* PCM Out */
id|ENUM_ENGINE
c_func
(paren
id|MC
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* Mic In */
id|ENUM_ENGINE
c_func
(paren
id|CODECSPDIFOUT
comma
l_int|7
)paren
suffix:semicolon
multiline_comment|/* CODEC SPDIF OUT  */
id|ENUM_ENGINE
c_func
(paren
id|CONTROLLERSPDIFIN
comma
id|A
)paren
suffix:semicolon
multiline_comment|/* CONTROLLER SPDIF In */
id|ENUM_ENGINE
c_func
(paren
id|CONTROLLERSPDIFOUT
comma
id|B
)paren
suffix:semicolon
multiline_comment|/* CONTROLLER SPDIF OUT */
r_enum
(brace
DECL|enumerator|ALI_SCR
id|ALI_SCR
op_assign
l_int|0x00
comma
multiline_comment|/* System Control Register */
DECL|enumerator|ALI_SSR
id|ALI_SSR
op_assign
l_int|0x04
comma
multiline_comment|/* System Status Register  */
DECL|enumerator|ALI_DMACR
id|ALI_DMACR
op_assign
l_int|0x08
comma
multiline_comment|/* DMA Control Register    */
DECL|enumerator|ALI_FIFOCR1
id|ALI_FIFOCR1
op_assign
l_int|0x0c
comma
multiline_comment|/* FIFO Control Register 1  */
DECL|enumerator|ALI_INTERFACECR
id|ALI_INTERFACECR
op_assign
l_int|0x10
comma
multiline_comment|/* Interface Control Register */
DECL|enumerator|ALI_INTERRUPTCR
id|ALI_INTERRUPTCR
op_assign
l_int|0x14
comma
multiline_comment|/* Interrupt control Register */
DECL|enumerator|ALI_INTERRUPTSR
id|ALI_INTERRUPTSR
op_assign
l_int|0x18
comma
multiline_comment|/* Interrupt  Status Register */
DECL|enumerator|ALI_FIFOCR2
id|ALI_FIFOCR2
op_assign
l_int|0x1c
comma
multiline_comment|/* FIFO Control Register 2   */
DECL|enumerator|ALI_CPR
id|ALI_CPR
op_assign
l_int|0x20
comma
multiline_comment|/* Command Port Register     */
DECL|enumerator|ALI_SPR
id|ALI_SPR
op_assign
l_int|0x24
comma
multiline_comment|/* Status Port Register      */
DECL|enumerator|ALI_FIFOCR3
id|ALI_FIFOCR3
op_assign
l_int|0x2c
comma
multiline_comment|/* FIFO Control Register 3  */
DECL|enumerator|ALI_TTSR
id|ALI_TTSR
op_assign
l_int|0x30
comma
multiline_comment|/* Transmit Tag Slot Register */
DECL|enumerator|ALI_RTSR
id|ALI_RTSR
op_assign
l_int|0x34
comma
multiline_comment|/* Receive Tag Slot  Register */
DECL|enumerator|ALI_CSPSR
id|ALI_CSPSR
op_assign
l_int|0x38
comma
multiline_comment|/* Command/Status Port Status Register */
DECL|enumerator|ALI_CAS
id|ALI_CAS
op_assign
l_int|0x3c
comma
multiline_comment|/* Codec Write Semaphore Register */
DECL|enumerator|ALI_SPDIFCSR
id|ALI_SPDIFCSR
op_assign
l_int|0xf8
comma
multiline_comment|/* spdif channel status register  */
DECL|enumerator|ALI_SPDIFICS
id|ALI_SPDIFICS
op_assign
l_int|0xfc
multiline_comment|/* spdif interface control/status  */
)brace
suffix:semicolon
singleline_comment|// x-status register(x:pcm in ,pcm out, mic in,)
multiline_comment|/* interrupts for a dma engine */
DECL|macro|DMA_INT_FIFO
mdefine_line|#define DMA_INT_FIFO&t;&t;(1&lt;&lt;4)&t;/* fifo under/over flow */
DECL|macro|DMA_INT_COMPLETE
mdefine_line|#define DMA_INT_COMPLETE&t;(1&lt;&lt;3)&t;/* buffer read/write complete and ioc set */
DECL|macro|DMA_INT_LVI
mdefine_line|#define DMA_INT_LVI&t;&t;(1&lt;&lt;2)&t;/* last valid done */
DECL|macro|DMA_INT_CELV
mdefine_line|#define DMA_INT_CELV&t;&t;(1&lt;&lt;1)&t;/* last valid is current */
DECL|macro|DMA_INT_DCH
mdefine_line|#define DMA_INT_DCH&t;&t;(1)&t;/* DMA Controller Halted (happens on LVI interrupts) */&t;
singleline_comment|//not eqult intel
DECL|macro|DMA_INT_MASK
mdefine_line|#define DMA_INT_MASK (DMA_INT_FIFO|DMA_INT_COMPLETE|DMA_INT_LVI)
multiline_comment|/* interrupts for the whole chip */
singleline_comment|// by interrupt status register finish
DECL|macro|INT_SPDIFOUT
mdefine_line|#define INT_SPDIFOUT   (1&lt;&lt;23)&t;/* controller spdif out INTERRUPT */
DECL|macro|INT_SPDIFIN
mdefine_line|#define INT_SPDIFIN   (1&lt;&lt;22)
DECL|macro|INT_CODECSPDIFOUT
mdefine_line|#define INT_CODECSPDIFOUT   (1&lt;&lt;19)
DECL|macro|INT_MICIN
mdefine_line|#define INT_MICIN   (1&lt;&lt;18)
DECL|macro|INT_PCMOUT
mdefine_line|#define INT_PCMOUT   (1&lt;&lt;17)
DECL|macro|INT_PCMIN
mdefine_line|#define INT_PCMIN   (1&lt;&lt;16)
DECL|macro|INT_CPRAIS
mdefine_line|#define INT_CPRAIS   (1&lt;&lt;7)
DECL|macro|INT_SPRAIS
mdefine_line|#define INT_SPRAIS   (1&lt;&lt;5)
DECL|macro|INT_GPIO
mdefine_line|#define INT_GPIO    (1&lt;&lt;1)
DECL|macro|INT_MASK
mdefine_line|#define INT_MASK   (INT_SPDIFOUT|INT_CODECSPDIFOUT|INT_MICIN|INT_PCMOUT|INT_PCMIN)
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION &quot;0.02ac&quot;
multiline_comment|/* magic numbers to protect our data structures */
DECL|macro|ALI5455_CARD_MAGIC
mdefine_line|#define ALI5455_CARD_MAGIC&t;&t;0x5072696E&t;/* &quot;Prin&quot; */
DECL|macro|ALI5455_STATE_MAGIC
mdefine_line|#define ALI5455_STATE_MAGIC&t;&t;0x63657373&t;/* &quot;cess&quot; */
DECL|macro|ALI5455_DMA_MASK
mdefine_line|#define ALI5455_DMA_MASK&t;&t;0xffffffff&t;/* DMA buffer mask for pci_alloc_consist */
DECL|macro|NR_HW_CH
mdefine_line|#define NR_HW_CH&t;&t;&t;5&t;
singleline_comment|//I think 5 channel
multiline_comment|/* maxinum number of AC97 codecs connected, AC97 2.0 defined 4 */
DECL|macro|NR_AC97
mdefine_line|#define NR_AC97&t;&t;2
multiline_comment|/* Please note that an 8bit mono stream is not valid on this card, you must have a 16bit */
multiline_comment|/* stream at a minimum for this card to be happy */
DECL|variable|sample_size
r_static
r_const
r_int
id|sample_size
(braket
)braket
op_assign
(brace
l_int|1
comma
l_int|2
comma
l_int|2
comma
l_int|4
)brace
suffix:semicolon
multiline_comment|/* Samples are 16bit values, so we are shifting to a word, not to a byte, hence shift */
multiline_comment|/* values are one less than might be expected */
DECL|variable|sample_shift
r_static
r_const
r_int
id|sample_shift
(braket
)braket
op_assign
(brace
op_minus
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|1
)brace
suffix:semicolon
DECL|macro|ALI5455
mdefine_line|#define ALI5455
DECL|variable|card_names
r_static
r_char
op_star
id|card_names
(braket
)braket
op_assign
(brace
l_string|&quot;ALI 5455&quot;
)brace
suffix:semicolon
DECL|variable|ali_pci_tbl
r_static
r_struct
id|pci_device_id
id|ali_pci_tbl
(braket
)braket
op_assign
(brace
(brace
id|PCI_VENDOR_ID_ALI
comma
id|PCI_DEVICE_ID_ALI_5455
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|ALI5455
)brace
comma
(brace
l_int|0
comma
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|ali_pci_tbl
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PM
DECL|macro|PM_SUSPENDED
mdefine_line|#define PM_SUSPENDED(card) (card-&gt;pm_suspended)
macro_line|#else
DECL|macro|PM_SUSPENDED
mdefine_line|#define PM_SUSPENDED(card) (0)
macro_line|#endif
multiline_comment|/* &quot;software&quot; or virtual channel, an instance of opened /dev/dsp */
DECL|struct|ali_state
r_struct
id|ali_state
(brace
DECL|member|magic
r_int
r_int
id|magic
suffix:semicolon
DECL|member|card
r_struct
id|ali_card
op_star
id|card
suffix:semicolon
multiline_comment|/* Card info */
multiline_comment|/* single open lock mechanism, only used for recording */
DECL|member|open_sem
r_struct
id|semaphore
id|open_sem
suffix:semicolon
DECL|member|open_wait
id|wait_queue_head_t
id|open_wait
suffix:semicolon
multiline_comment|/* file mode */
DECL|member|open_mode
id|mode_t
id|open_mode
suffix:semicolon
multiline_comment|/* virtual channel number */
DECL|member|virt
r_int
id|virt
suffix:semicolon
macro_line|#ifdef CONFIG_PM
DECL|member|pm_saved_dac_rate
DECL|member|pm_saved_adc_rate
r_int
r_int
id|pm_saved_dac_rate
comma
id|pm_saved_adc_rate
suffix:semicolon
macro_line|#endif
DECL|struct|dmabuf
r_struct
id|dmabuf
(brace
multiline_comment|/* wave sample stuff */
DECL|member|rate
r_int
r_int
id|rate
suffix:semicolon
DECL|member|fmt
DECL|member|enable
DECL|member|trigger
r_int
r_char
id|fmt
comma
id|enable
comma
id|trigger
suffix:semicolon
multiline_comment|/* hardware channel */
DECL|member|read_channel
r_struct
id|ali_channel
op_star
id|read_channel
suffix:semicolon
DECL|member|write_channel
r_struct
id|ali_channel
op_star
id|write_channel
suffix:semicolon
DECL|member|codec_spdifout_channel
r_struct
id|ali_channel
op_star
id|codec_spdifout_channel
suffix:semicolon
DECL|member|controller_spdifout_channel
r_struct
id|ali_channel
op_star
id|controller_spdifout_channel
suffix:semicolon
multiline_comment|/* OSS buffer management stuff */
DECL|member|rawbuf
r_void
op_star
id|rawbuf
suffix:semicolon
DECL|member|dma_handle
id|dma_addr_t
id|dma_handle
suffix:semicolon
DECL|member|buforder
r_int
id|buforder
suffix:semicolon
DECL|member|numfrag
r_int
id|numfrag
suffix:semicolon
DECL|member|fragshift
r_int
id|fragshift
suffix:semicolon
multiline_comment|/* our buffer acts like a circular ring */
DECL|member|hwptr
r_int
id|hwptr
suffix:semicolon
multiline_comment|/* where dma last started, updated by update_ptr */
DECL|member|swptr
r_int
id|swptr
suffix:semicolon
multiline_comment|/* where driver last clear/filled, updated by read/write */
DECL|member|count
r_int
id|count
suffix:semicolon
multiline_comment|/* bytes to be consumed or been generated by dma machine */
DECL|member|total_bytes
r_int
id|total_bytes
suffix:semicolon
multiline_comment|/* total bytes dmaed by hardware */
DECL|member|error
r_int
id|error
suffix:semicolon
multiline_comment|/* number of over/underruns */
DECL|member|wait
id|wait_queue_head_t
id|wait
suffix:semicolon
multiline_comment|/* put process on wait queue when no more space in buffer */
multiline_comment|/* redundant, but makes calculations easier */
multiline_comment|/* what the hardware uses */
DECL|member|dmasize
r_int
id|dmasize
suffix:semicolon
DECL|member|fragsize
r_int
id|fragsize
suffix:semicolon
DECL|member|fragsamples
r_int
id|fragsamples
suffix:semicolon
multiline_comment|/* what we tell the user to expect */
DECL|member|userfrags
r_int
id|userfrags
suffix:semicolon
DECL|member|userfragsize
r_int
id|userfragsize
suffix:semicolon
multiline_comment|/* OSS stuff */
DECL|member|mapped
r_int
id|mapped
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ready
r_int
id|ready
suffix:colon
l_int|1
suffix:semicolon
DECL|member|update_flag
r_int
id|update_flag
suffix:semicolon
DECL|member|ossfragsize
r_int
id|ossfragsize
suffix:semicolon
DECL|member|ossmaxfrags
r_int
id|ossmaxfrags
suffix:semicolon
DECL|member|subdivision
r_int
id|subdivision
suffix:semicolon
DECL|member|dmabuf
)brace
id|dmabuf
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|ali_card
r_struct
id|ali_card
(brace
DECL|member|channel
r_struct
id|ali_channel
id|channel
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|magic
r_int
r_int
id|magic
suffix:semicolon
multiline_comment|/* We keep ali5455 cards in a linked list */
DECL|member|next
r_struct
id|ali_card
op_star
id|next
suffix:semicolon
multiline_comment|/* The ali has a certain amount of cross channel interaction&n;&t;   so we use a single per card lock */
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|ac97_lock
id|spinlock_t
id|ac97_lock
suffix:semicolon
multiline_comment|/* PCI device stuff */
DECL|member|pci_dev
r_struct
id|pci_dev
op_star
id|pci_dev
suffix:semicolon
DECL|member|pci_id
id|u16
id|pci_id
suffix:semicolon
macro_line|#ifdef CONFIG_PM
DECL|member|pm_suspended
id|u16
id|pm_suspended
suffix:semicolon
DECL|member|pm_save_state
id|u32
id|pm_save_state
(braket
l_int|64
op_div
r_sizeof
(paren
id|u32
)paren
)braket
suffix:semicolon
DECL|member|pm_saved_mixer_settings
r_int
id|pm_saved_mixer_settings
(braket
id|SOUND_MIXER_NRDEVICES
)braket
(braket
id|NR_AC97
)braket
suffix:semicolon
macro_line|#endif
multiline_comment|/* soundcore stuff */
DECL|member|dev_audio
r_int
id|dev_audio
suffix:semicolon
multiline_comment|/* structures for abstraction of hardware facilities, codecs, banks and channels */
DECL|member|ac97_codec
r_struct
id|ac97_codec
op_star
id|ac97_codec
(braket
id|NR_AC97
)braket
suffix:semicolon
DECL|member|states
r_struct
id|ali_state
op_star
id|states
(braket
id|NR_HW_CH
)braket
suffix:semicolon
DECL|member|ac97_features
id|u16
id|ac97_features
suffix:semicolon
DECL|member|ac97_status
id|u16
id|ac97_status
suffix:semicolon
DECL|member|channels
id|u16
id|channels
suffix:semicolon
multiline_comment|/* hardware resources */
DECL|member|iobase
r_int
r_int
id|iobase
suffix:semicolon
DECL|member|irq
id|u32
id|irq
suffix:semicolon
multiline_comment|/* Function support */
DECL|member|alloc_pcm_channel
r_struct
id|ali_channel
op_star
(paren
op_star
id|alloc_pcm_channel
)paren
(paren
r_struct
id|ali_card
op_star
)paren
suffix:semicolon
DECL|member|alloc_rec_pcm_channel
r_struct
id|ali_channel
op_star
(paren
op_star
id|alloc_rec_pcm_channel
)paren
(paren
r_struct
id|ali_card
op_star
)paren
suffix:semicolon
DECL|member|alloc_rec_mic_channel
r_struct
id|ali_channel
op_star
(paren
op_star
id|alloc_rec_mic_channel
)paren
(paren
r_struct
id|ali_card
op_star
)paren
suffix:semicolon
DECL|member|alloc_codec_spdifout_channel
r_struct
id|ali_channel
op_star
(paren
op_star
id|alloc_codec_spdifout_channel
)paren
(paren
r_struct
id|ali_card
op_star
)paren
suffix:semicolon
DECL|member|alloc_controller_spdifout_channel
r_struct
id|ali_channel
op_star
(paren
op_star
id|alloc_controller_spdifout_channel
)paren
(paren
r_struct
id|ali_card
op_star
)paren
suffix:semicolon
DECL|member|free_pcm_channel
r_void
(paren
op_star
id|free_pcm_channel
)paren
(paren
r_struct
id|ali_card
op_star
comma
r_int
id|chan
)paren
suffix:semicolon
multiline_comment|/* We have a *very* long init time possibly, so use this to block */
multiline_comment|/* attempts to open our devices before we are ready (stops oops&squot;es) */
DECL|member|initializing
r_int
id|initializing
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|devs
r_static
r_struct
id|ali_card
op_star
id|devs
op_assign
l_int|NULL
suffix:semicolon
r_static
r_int
id|ali_open_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|ali_ioctl_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
id|u16
id|ali_ac97_get
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
)paren
suffix:semicolon
r_static
r_void
id|ali_ac97_set
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
comma
id|u16
id|data
)paren
suffix:semicolon
DECL|function|ali_alloc_pcm_channel
r_static
r_struct
id|ali_channel
op_star
id|ali_alloc_pcm_channel
c_func
(paren
r_struct
id|ali_card
op_star
id|card
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|used
op_eq
l_int|1
)paren
r_return
l_int|NULL
suffix:semicolon
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|used
op_assign
l_int|1
suffix:semicolon
r_return
op_amp
id|card-&gt;channel
(braket
l_int|1
)braket
suffix:semicolon
)brace
DECL|function|ali_alloc_rec_pcm_channel
r_static
r_struct
id|ali_channel
op_star
id|ali_alloc_rec_pcm_channel
c_func
(paren
r_struct
id|ali_card
op_star
id|card
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|used
op_eq
l_int|1
)paren
r_return
l_int|NULL
suffix:semicolon
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|used
op_assign
l_int|1
suffix:semicolon
r_return
op_amp
id|card-&gt;channel
(braket
l_int|0
)braket
suffix:semicolon
)brace
DECL|function|ali_alloc_rec_mic_channel
r_static
r_struct
id|ali_channel
op_star
id|ali_alloc_rec_mic_channel
c_func
(paren
r_struct
id|ali_card
op_star
id|card
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;channel
(braket
l_int|2
)braket
dot
id|used
op_eq
l_int|1
)paren
r_return
l_int|NULL
suffix:semicolon
id|card-&gt;channel
(braket
l_int|2
)braket
dot
id|used
op_assign
l_int|1
suffix:semicolon
r_return
op_amp
id|card-&gt;channel
(braket
l_int|2
)braket
suffix:semicolon
)brace
DECL|function|ali_alloc_codec_spdifout_channel
r_static
r_struct
id|ali_channel
op_star
id|ali_alloc_codec_spdifout_channel
c_func
(paren
r_struct
id|ali_card
op_star
id|card
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;channel
(braket
l_int|3
)braket
dot
id|used
op_eq
l_int|1
)paren
r_return
l_int|NULL
suffix:semicolon
id|card-&gt;channel
(braket
l_int|3
)braket
dot
id|used
op_assign
l_int|1
suffix:semicolon
r_return
op_amp
id|card-&gt;channel
(braket
l_int|3
)braket
suffix:semicolon
)brace
DECL|function|ali_alloc_controller_spdifout_channel
r_static
r_struct
id|ali_channel
op_star
id|ali_alloc_controller_spdifout_channel
c_func
(paren
r_struct
id|ali_card
op_star
id|card
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;channel
(braket
l_int|4
)braket
dot
id|used
op_eq
l_int|1
)paren
r_return
l_int|NULL
suffix:semicolon
id|card-&gt;channel
(braket
l_int|4
)braket
dot
id|used
op_assign
l_int|1
suffix:semicolon
r_return
op_amp
id|card-&gt;channel
(braket
l_int|4
)braket
suffix:semicolon
)brace
DECL|function|ali_free_pcm_channel
r_static
r_void
id|ali_free_pcm_channel
c_func
(paren
r_struct
id|ali_card
op_star
id|card
comma
r_int
id|channel
)paren
(brace
id|card-&gt;channel
(braket
id|channel
)braket
dot
id|used
op_assign
l_int|0
suffix:semicolon
)brace
singleline_comment|//add support  codec spdif out 
DECL|function|ali_valid_spdif_rate
r_static
r_int
id|ali_valid_spdif_rate
c_func
(paren
r_struct
id|ac97_codec
op_star
id|codec
comma
r_int
id|rate
)paren
(brace
r_int
r_int
id|id
op_assign
l_int|0L
suffix:semicolon
id|id
op_assign
(paren
id|ali_ac97_get
c_func
(paren
id|codec
comma
id|AC97_VENDOR_ID1
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|id
op_or_assign
id|ali_ac97_get
c_func
(paren
id|codec
comma
id|AC97_VENDOR_ID2
)paren
op_amp
l_int|0xffff
suffix:semicolon
r_switch
c_cond
(paren
id|id
)paren
(brace
r_case
l_int|0x41445361
suffix:colon
multiline_comment|/* AD1886 */
r_if
c_cond
(paren
id|rate
op_eq
l_int|48000
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x414c4720
suffix:colon
multiline_comment|/* ALC650 */
r_if
c_cond
(paren
id|rate
op_eq
l_int|48000
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* all other codecs, until we know otherwiae */
r_if
c_cond
(paren
id|rate
op_eq
l_int|48000
op_logical_or
id|rate
op_eq
l_int|44100
op_logical_or
id|rate
op_eq
l_int|32000
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* ali_set_spdif_output&n; * &n; *  Configure the S/PDIF output transmitter. When we turn on&n; *  S/PDIF, we turn off the analog output. This may not be&n; *  the right thing to do.&n; *&n; *  Assumptions:&n; *     The DSP sample rate must already be set to a supported&n; *     S/PDIF rate (32kHz, 44.1kHz, or 48kHz) or we abort.&n; */
DECL|function|ali_set_spdif_output
r_static
r_void
id|ali_set_spdif_output
c_func
(paren
r_struct
id|ali_state
op_star
id|state
comma
r_int
id|slots
comma
r_int
id|rate
)paren
(brace
r_int
id|vol
suffix:semicolon
r_int
id|aud_reg
suffix:semicolon
r_struct
id|ac97_codec
op_star
id|codec
op_assign
id|state-&gt;card-&gt;ac97_codec
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|state-&gt;card-&gt;ac97_features
op_amp
l_int|4
)paren
)paren
(brace
id|state-&gt;card-&gt;ac97_status
op_and_assign
op_complement
id|SPDIF_ON
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|slots
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Turn off S/PDIF */
id|aud_reg
op_assign
id|ali_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
comma
(paren
id|aud_reg
op_amp
op_complement
id|AC97_EA_SPDIF
)paren
)paren
suffix:semicolon
multiline_comment|/* If the volume wasn&squot;t muted before we turned on S/PDIF, unmute it */
r_if
c_cond
(paren
op_logical_neg
(paren
id|state-&gt;card-&gt;ac97_status
op_amp
id|VOL_MUTED
)paren
)paren
(brace
id|aud_reg
op_assign
id|ali_ac97_get
c_func
(paren
id|codec
comma
id|AC97_MASTER_VOL_STEREO
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_MASTER_VOL_STEREO
comma
(paren
id|aud_reg
op_amp
op_complement
id|VOL_MUTED
)paren
)paren
suffix:semicolon
)brace
id|state-&gt;card-&gt;ac97_status
op_and_assign
op_complement
(paren
id|VOL_MUTED
op_or
id|SPDIF_ON
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|vol
op_assign
id|ali_ac97_get
c_func
(paren
id|codec
comma
id|AC97_MASTER_VOL_STEREO
)paren
suffix:semicolon
id|state-&gt;card-&gt;ac97_status
op_assign
id|vol
op_amp
id|VOL_MUTED
suffix:semicolon
multiline_comment|/* Set S/PDIF transmitter sample rate */
id|aud_reg
op_assign
id|ali_ac97_get
c_func
(paren
id|codec
comma
id|AC97_SPDIF_CONTROL
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|rate
)paren
(brace
r_case
l_int|32000
suffix:colon
id|aud_reg
op_assign
(paren
id|aud_reg
op_amp
id|AC97_SC_SPSR_MASK
)paren
op_or
id|AC97_SC_SPSR_32K
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|44100
suffix:colon
id|aud_reg
op_assign
(paren
id|aud_reg
op_amp
id|AC97_SC_SPSR_MASK
)paren
op_or
id|AC97_SC_SPSR_44K
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|48000
suffix:colon
id|aud_reg
op_assign
(paren
id|aud_reg
op_amp
id|AC97_SC_SPSR_MASK
)paren
op_or
id|AC97_SC_SPSR_48K
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* turn off S/PDIF */
id|aud_reg
op_assign
id|ali_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
comma
(paren
id|aud_reg
op_amp
op_complement
id|AC97_EA_SPDIF
)paren
)paren
suffix:semicolon
id|state-&gt;card-&gt;ac97_status
op_and_assign
op_complement
id|SPDIF_ON
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_SPDIF_CONTROL
comma
id|aud_reg
)paren
suffix:semicolon
id|aud_reg
op_assign
id|ali_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
)paren
suffix:semicolon
id|aud_reg
op_assign
(paren
id|aud_reg
op_amp
id|AC97_EA_SLOT_MASK
)paren
op_or
id|slots
op_or
id|AC97_EA_SPDIF
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
comma
id|aud_reg
)paren
suffix:semicolon
id|aud_reg
op_assign
id|ali_ac97_get
c_func
(paren
id|codec
comma
id|AC97_POWER_CONTROL
)paren
suffix:semicolon
id|aud_reg
op_or_assign
l_int|0x0002
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_POWER_CONTROL
comma
id|aud_reg
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|state-&gt;card-&gt;ac97_status
op_or_assign
id|SPDIF_ON
suffix:semicolon
multiline_comment|/* Check to make sure the configuration is valid */
id|aud_reg
op_assign
id|ali_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|aud_reg
op_amp
l_int|0x0400
)paren
)paren
(brace
multiline_comment|/* turn off S/PDIF */
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
comma
(paren
id|aud_reg
op_amp
op_complement
id|AC97_EA_SPDIF
)paren
)paren
suffix:semicolon
id|state-&gt;card-&gt;ac97_status
op_and_assign
op_complement
id|SPDIF_ON
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
id|aud_reg
op_assign
id|ali_ac97_get
c_func
(paren
id|codec
comma
l_int|0x6a
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
l_int|0x6a
comma
(paren
id|aud_reg
op_amp
l_int|0xefff
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Mute the analog output */
multiline_comment|/* Should this only mute the PCM volume??? */
)brace
)brace
multiline_comment|/* ali_set_dac_channels&n; *&n; *  Configure the codec&squot;s multi-channel DACs&n; *&n; *  The logic is backwards. Setting the bit to 1 turns off the DAC. &n; *&n; *  What about the ICH? We currently configure it using the&n; *  SNDCTL_DSP_CHANNELS ioctl.  If we&squot;re turnning on the DAC, &n; *  does that imply that we want the ICH set to support&n; *  these channels?&n; *  &n; *  TODO:&n; *    vailidate that the codec really supports these DACs&n; *    before turning them on. &n; */
DECL|function|ali_set_dac_channels
r_static
r_void
id|ali_set_dac_channels
c_func
(paren
r_struct
id|ali_state
op_star
id|state
comma
r_int
id|channel
)paren
(brace
r_int
id|aud_reg
suffix:semicolon
r_struct
id|ac97_codec
op_star
id|codec
op_assign
id|state-&gt;card-&gt;ac97_codec
(braket
l_int|0
)braket
suffix:semicolon
id|aud_reg
op_assign
id|ali_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
)paren
suffix:semicolon
id|aud_reg
op_or_assign
id|AC97_EA_PRI
op_or
id|AC97_EA_PRJ
op_or
id|AC97_EA_PRK
suffix:semicolon
id|state-&gt;card-&gt;ac97_status
op_and_assign
op_complement
(paren
id|SURR_ON
op_or
id|CENTER_LFE_ON
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|channel
)paren
(brace
r_case
l_int|2
suffix:colon
multiline_comment|/* always enabled */
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|aud_reg
op_and_assign
op_complement
id|AC97_EA_PRJ
suffix:semicolon
id|state-&gt;card-&gt;ac97_status
op_or_assign
id|SURR_ON
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|aud_reg
op_and_assign
op_complement
(paren
id|AC97_EA_PRJ
op_or
id|AC97_EA_PRI
op_or
id|AC97_EA_PRK
)paren
suffix:semicolon
id|state-&gt;card-&gt;ac97_status
op_or_assign
id|SURR_ON
op_or
id|CENTER_LFE_ON
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
comma
id|aud_reg
)paren
suffix:semicolon
)brace
multiline_comment|/* set playback sample rate */
DECL|function|ali_set_dac_rate
r_static
r_int
r_int
id|ali_set_dac_rate
c_func
(paren
r_struct
id|ali_state
op_star
id|state
comma
r_int
r_int
id|rate
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|u32
id|new_rate
suffix:semicolon
r_struct
id|ac97_codec
op_star
id|codec
op_assign
id|state-&gt;card-&gt;ac97_codec
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|state-&gt;card-&gt;ac97_features
op_amp
l_int|0x0001
)paren
)paren
(brace
id|dmabuf-&gt;rate
op_assign
id|clocking
suffix:semicolon
r_return
id|clocking
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rate
OG
l_int|48000
)paren
id|rate
op_assign
l_int|48000
suffix:semicolon
r_if
c_cond
(paren
id|rate
OL
l_int|8000
)paren
id|rate
op_assign
l_int|8000
suffix:semicolon
id|dmabuf-&gt;rate
op_assign
id|rate
suffix:semicolon
multiline_comment|/*&n;&t; *      Adjust for misclocked crap&n;&t; */
id|rate
op_assign
(paren
id|rate
op_star
id|clocking
)paren
op_div
l_int|48000
suffix:semicolon
r_if
c_cond
(paren
id|strict_clocking
op_logical_and
id|rate
OL
l_int|8000
)paren
(brace
id|rate
op_assign
l_int|8000
suffix:semicolon
id|dmabuf-&gt;rate
op_assign
(paren
id|rate
op_star
l_int|48000
)paren
op_div
id|clocking
suffix:semicolon
)brace
id|new_rate
op_assign
id|ac97_set_dac_rate
c_func
(paren
id|codec
comma
id|rate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_rate
op_ne
id|rate
)paren
(brace
id|dmabuf-&gt;rate
op_assign
(paren
id|new_rate
op_star
l_int|48000
)paren
op_div
id|clocking
suffix:semicolon
)brace
id|rate
op_assign
id|new_rate
suffix:semicolon
r_return
id|dmabuf-&gt;rate
suffix:semicolon
)brace
multiline_comment|/* set recording sample rate */
DECL|function|ali_set_adc_rate
r_static
r_int
r_int
id|ali_set_adc_rate
c_func
(paren
r_struct
id|ali_state
op_star
id|state
comma
r_int
r_int
id|rate
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|u32
id|new_rate
suffix:semicolon
r_struct
id|ac97_codec
op_star
id|codec
op_assign
id|state-&gt;card-&gt;ac97_codec
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|state-&gt;card-&gt;ac97_features
op_amp
l_int|0x0001
)paren
)paren
(brace
id|dmabuf-&gt;rate
op_assign
id|clocking
suffix:semicolon
r_return
id|clocking
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rate
OG
l_int|48000
)paren
id|rate
op_assign
l_int|48000
suffix:semicolon
r_if
c_cond
(paren
id|rate
OL
l_int|8000
)paren
id|rate
op_assign
l_int|8000
suffix:semicolon
id|dmabuf-&gt;rate
op_assign
id|rate
suffix:semicolon
multiline_comment|/*&n;&t; *      Adjust for misclocked crap&n;&t; */
id|rate
op_assign
(paren
id|rate
op_star
id|clocking
)paren
op_div
l_int|48000
suffix:semicolon
r_if
c_cond
(paren
id|strict_clocking
op_logical_and
id|rate
OL
l_int|8000
)paren
(brace
id|rate
op_assign
l_int|8000
suffix:semicolon
id|dmabuf-&gt;rate
op_assign
(paren
id|rate
op_star
l_int|48000
)paren
op_div
id|clocking
suffix:semicolon
)brace
id|new_rate
op_assign
id|ac97_set_adc_rate
c_func
(paren
id|codec
comma
id|rate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_rate
op_ne
id|rate
)paren
(brace
id|dmabuf-&gt;rate
op_assign
(paren
id|new_rate
op_star
l_int|48000
)paren
op_div
id|clocking
suffix:semicolon
id|rate
op_assign
id|new_rate
suffix:semicolon
)brace
r_return
id|dmabuf-&gt;rate
suffix:semicolon
)brace
multiline_comment|/* set codec independent spdifout sample rate */
DECL|function|ali_set_codecspdifout_rate
r_static
r_int
r_int
id|ali_set_codecspdifout_rate
c_func
(paren
r_struct
id|ali_state
op_star
id|state
comma
r_int
r_int
id|rate
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|state-&gt;card-&gt;ac97_features
op_amp
l_int|0x0001
)paren
)paren
(brace
id|dmabuf-&gt;rate
op_assign
id|clocking
suffix:semicolon
r_return
id|clocking
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rate
OG
l_int|48000
)paren
id|rate
op_assign
l_int|48000
suffix:semicolon
r_if
c_cond
(paren
id|rate
OL
l_int|8000
)paren
id|rate
op_assign
l_int|8000
suffix:semicolon
id|dmabuf-&gt;rate
op_assign
id|rate
suffix:semicolon
r_return
id|dmabuf-&gt;rate
suffix:semicolon
)brace
multiline_comment|/* set  controller independent spdif out function sample rate */
DECL|function|ali_set_spdifout_rate
r_static
r_void
id|ali_set_spdifout_rate
c_func
(paren
r_struct
id|ali_state
op_star
id|state
comma
r_int
r_int
id|rate
)paren
(brace
r_int
r_char
id|ch_st_sel
suffix:semicolon
r_int
r_int
id|status_rate
suffix:semicolon
r_switch
c_cond
(paren
id|rate
)paren
(brace
r_case
l_int|44100
suffix:colon
id|status_rate
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|32000
suffix:colon
id|status_rate
op_assign
l_int|0x300
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|48000
suffix:colon
r_default
suffix:colon
id|status_rate
op_assign
l_int|0x200
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ch_st_sel
op_assign
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_SPDIFICS
)paren
op_amp
id|ALI_SPDIF_OUT_CH_STATUS
suffix:semicolon
singleline_comment|//select spdif_out
id|ch_st_sel
op_or_assign
l_int|0x80
suffix:semicolon
singleline_comment|//select right
id|outb
c_func
(paren
id|ch_st_sel
comma
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_SPDIFICS
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|status_rate
op_or
l_int|0x20
comma
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_SPDIFCSR
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|ch_st_sel
op_and_assign
(paren
op_complement
l_int|0x80
)paren
suffix:semicolon
singleline_comment|//select left
id|outb
c_func
(paren
id|ch_st_sel
comma
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_SPDIFICS
)paren
)paren
suffix:semicolon
id|outw
c_func
(paren
id|status_rate
op_or
l_int|0x10
comma
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_SPDIFCSR
op_plus
l_int|2
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* get current playback/recording dma buffer pointer (byte offset from LBA),&n;   called with spinlock held! */
DECL|function|ali_get_dma_addr
r_static
r_inline
r_int
id|ali_get_dma_addr
c_func
(paren
r_struct
id|ali_state
op_star
id|state
comma
r_int
id|rec
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|civ
comma
id|offset
comma
id|port
comma
id|port_picb
suffix:semicolon
r_int
r_int
id|data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;enable
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rec
op_eq
l_int|1
)paren
id|port
op_assign
id|state-&gt;card-&gt;iobase
op_plus
id|dmabuf-&gt;read_channel-&gt;port
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rec
op_eq
l_int|2
)paren
id|port
op_assign
id|state-&gt;card-&gt;iobase
op_plus
id|dmabuf-&gt;codec_spdifout_channel-&gt;port
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rec
op_eq
l_int|3
)paren
id|port
op_assign
id|state-&gt;card-&gt;iobase
op_plus
id|dmabuf-&gt;controller_spdifout_channel-&gt;port
suffix:semicolon
r_else
id|port
op_assign
id|state-&gt;card-&gt;iobase
op_plus
id|dmabuf-&gt;write_channel-&gt;port
suffix:semicolon
id|port_picb
op_assign
id|port
op_plus
id|OFF_PICB
suffix:semicolon
r_do
(brace
id|civ
op_assign
id|inb
c_func
(paren
id|port
op_plus
id|OFF_CIV
)paren
op_amp
l_int|31
suffix:semicolon
id|offset
op_assign
id|inw
c_func
(paren
id|port_picb
)paren
suffix:semicolon
multiline_comment|/* Must have a delay here! */
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Reread both registers and make sure that that total&n;&t;&t; * offset from the first reading to the second is 0.&n;&t;&t; * There is an issue with SiS hardware where it will count&n;&t;&t; * picb down to 0, then update civ to the next value,&n;&t;&t; * then set the new picb to fragsize bytes.  We can catch&n;&t;&t; * it between the civ update and the picb update, making&n;&t;&t; * it look as though we are 1 fragsize ahead of where we&n;&t;&t; * are.  The next to we get the address though, it will&n;&t;&t; * be back in thdelay is more than long enough&n;&t;&t; * that we won&squot;t have to worry about the chip still being&n;&t;&t; * out of sync with reality ;-)&n;&t;&t; */
)brace
r_while
c_loop
(paren
id|civ
op_ne
(paren
id|inb
c_func
(paren
id|port
op_plus
id|OFF_CIV
)paren
op_amp
l_int|31
)paren
op_logical_or
id|offset
op_ne
id|inw
c_func
(paren
id|port_picb
)paren
)paren
suffix:semicolon
id|data
op_assign
(paren
(paren
id|civ
op_plus
l_int|1
)paren
op_star
id|dmabuf-&gt;fragsize
op_minus
(paren
l_int|2
op_star
id|offset
)paren
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
r_if
c_cond
(paren
id|inw
c_func
(paren
id|port_picb
)paren
op_eq
l_int|0
)paren
id|data
op_sub_assign
l_int|2048
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
multiline_comment|/* Stop recording (lock held) */
DECL|function|__stop_adc
r_static
r_inline
r_void
id|__stop_adc
c_func
(paren
r_struct
id|ali_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|ali_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
id|dmabuf-&gt;enable
op_and_assign
op_complement
id|ADC_RUNNING
suffix:semicolon
id|outl
c_func
(paren
(paren
l_int|1
op_lshift
l_int|18
)paren
op_or
(paren
l_int|1
op_lshift
l_int|16
)paren
comma
id|card-&gt;iobase
op_plus
id|ALI_DMACR
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|card-&gt;iobase
op_plus
id|PI_CR
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|card-&gt;iobase
op_plus
id|PI_CR
)paren
op_ne
l_int|0
)paren
suffix:semicolon
singleline_comment|// now clear any latent interrupt bits (like the halt bit)
id|outb
c_func
(paren
id|inb
c_func
(paren
id|card-&gt;iobase
op_plus
id|PI_SR
)paren
op_or
l_int|0x001e
comma
id|card-&gt;iobase
op_plus
id|PI_SR
)paren
suffix:semicolon
id|outl
c_func
(paren
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|ALI_INTERRUPTSR
)paren
op_amp
id|INT_PCMIN
comma
id|card-&gt;iobase
op_plus
id|ALI_INTERRUPTSR
)paren
suffix:semicolon
)brace
DECL|function|stop_adc
r_static
r_void
id|stop_adc
c_func
(paren
r_struct
id|ali_state
op_star
id|state
)paren
(brace
r_struct
id|ali_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|__start_adc
r_static
r_inline
r_void
id|__start_adc
c_func
(paren
r_struct
id|ali_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
id|dmabuf-&gt;dmasize
op_logical_and
id|dmabuf-&gt;ready
op_logical_and
op_logical_neg
id|dmabuf-&gt;enable
op_logical_and
(paren
id|dmabuf-&gt;trigger
op_amp
id|PCM_ENABLE_INPUT
)paren
)paren
(brace
id|dmabuf-&gt;enable
op_or_assign
id|ADC_RUNNING
suffix:semicolon
id|outb
c_func
(paren
(paren
l_int|1
op_lshift
l_int|4
)paren
op_or
(paren
l_int|1
op_lshift
l_int|2
)paren
comma
id|state-&gt;card-&gt;iobase
op_plus
id|PI_CR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;card-&gt;channel
(braket
l_int|0
)braket
dot
id|used
op_eq
l_int|1
)paren
id|outl
c_func
(paren
l_int|1
comma
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_DMACR
)paren
suffix:semicolon
singleline_comment|// DMA CONTROL REGISTRER
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;card-&gt;channel
(braket
l_int|2
)braket
dot
id|used
op_eq
l_int|1
)paren
id|outl
c_func
(paren
(paren
l_int|1
op_lshift
l_int|2
)paren
comma
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_DMACR
)paren
suffix:semicolon
singleline_comment|//DMA CONTROL REGISTER
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
)brace
DECL|function|start_adc
r_static
r_void
id|start_adc
c_func
(paren
r_struct
id|ali_state
op_star
id|state
)paren
(brace
r_struct
id|ali_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__start_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* stop playback (lock held) */
DECL|function|__stop_dac
r_static
r_inline
r_void
id|__stop_dac
c_func
(paren
r_struct
id|ali_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|ali_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
id|dmabuf-&gt;enable
op_and_assign
op_complement
id|DAC_RUNNING
suffix:semicolon
id|outl
c_func
(paren
l_int|0x00020000
comma
id|card-&gt;iobase
op_plus
l_int|0x08
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|card-&gt;iobase
op_plus
id|PO_CR
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|card-&gt;iobase
op_plus
id|PO_CR
)paren
op_ne
l_int|0
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|card-&gt;iobase
op_plus
id|PO_SR
)paren
op_or
l_int|0x001e
comma
id|card-&gt;iobase
op_plus
id|PO_SR
)paren
suffix:semicolon
id|outl
c_func
(paren
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|ALI_INTERRUPTSR
)paren
op_amp
id|INT_PCMOUT
comma
id|card-&gt;iobase
op_plus
id|ALI_INTERRUPTSR
)paren
suffix:semicolon
)brace
DECL|function|stop_dac
r_static
r_void
id|stop_dac
c_func
(paren
r_struct
id|ali_state
op_star
id|state
)paren
(brace
r_struct
id|ali_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|__start_dac
r_static
r_inline
r_void
id|__start_dac
c_func
(paren
r_struct
id|ali_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OG
l_int|0
op_logical_and
id|dmabuf-&gt;ready
op_logical_and
op_logical_neg
id|dmabuf-&gt;enable
op_logical_and
(paren
id|dmabuf-&gt;trigger
op_amp
id|PCM_ENABLE_OUTPUT
)paren
)paren
(brace
id|dmabuf-&gt;enable
op_or_assign
id|DAC_RUNNING
suffix:semicolon
id|outb
c_func
(paren
(paren
l_int|1
op_lshift
l_int|4
)paren
op_or
(paren
l_int|1
op_lshift
l_int|2
)paren
comma
id|state-&gt;card-&gt;iobase
op_plus
id|PO_CR
)paren
suffix:semicolon
id|outl
c_func
(paren
(paren
l_int|1
op_lshift
l_int|1
)paren
comma
id|state-&gt;card-&gt;iobase
op_plus
l_int|0x08
)paren
suffix:semicolon
singleline_comment|//dma control register
)brace
)brace
DECL|function|start_dac
r_static
r_void
id|start_dac
c_func
(paren
r_struct
id|ali_state
op_star
id|state
)paren
(brace
r_struct
id|ali_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* stop codec and controller spdif out  (lock held) */
DECL|function|__stop_spdifout
r_static
r_inline
r_void
id|__stop_spdifout
c_func
(paren
r_struct
id|ali_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|ali_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
id|dmabuf-&gt;enable
op_and_assign
op_complement
id|CODEC_SPDIFOUT_RUNNING
suffix:semicolon
id|outl
c_func
(paren
(paren
l_int|1
op_lshift
l_int|19
)paren
comma
id|card-&gt;iobase
op_plus
l_int|0x08
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|card-&gt;iobase
op_plus
id|CODECSPDIFOUT_CR
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|card-&gt;iobase
op_plus
id|CODECSPDIFOUT_CR
)paren
op_ne
l_int|0
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|card-&gt;iobase
op_plus
id|CODECSPDIFOUT_SR
)paren
op_or
l_int|0x001e
comma
id|card-&gt;iobase
op_plus
id|CODECSPDIFOUT_SR
)paren
suffix:semicolon
id|outl
c_func
(paren
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|ALI_INTERRUPTSR
)paren
op_amp
id|INT_CODECSPDIFOUT
comma
id|card-&gt;iobase
op_plus
id|ALI_INTERRUPTSR
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|controller_independent_spdif_locked
OG
l_int|0
)paren
(brace
id|dmabuf-&gt;enable
op_and_assign
op_complement
id|CONTROLLER_SPDIFOUT_RUNNING
suffix:semicolon
id|outl
c_func
(paren
(paren
l_int|1
op_lshift
l_int|23
)paren
comma
id|card-&gt;iobase
op_plus
l_int|0x08
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|card-&gt;iobase
op_plus
id|CONTROLLERSPDIFOUT_CR
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|card-&gt;iobase
op_plus
id|CONTROLLERSPDIFOUT_CR
)paren
op_ne
l_int|0
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|card-&gt;iobase
op_plus
id|CONTROLLERSPDIFOUT_SR
)paren
op_or
l_int|0x001e
comma
id|card-&gt;iobase
op_plus
id|CONTROLLERSPDIFOUT_SR
)paren
suffix:semicolon
id|outl
c_func
(paren
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|ALI_INTERRUPTSR
)paren
op_amp
id|INT_SPDIFOUT
comma
id|card-&gt;iobase
op_plus
id|ALI_INTERRUPTSR
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|stop_spdifout
r_static
r_void
id|stop_spdifout
c_func
(paren
r_struct
id|ali_state
op_star
id|state
)paren
(brace
r_struct
id|ali_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__stop_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|__start_spdifout
r_static
r_inline
r_void
id|__start_spdifout
c_func
(paren
r_struct
id|ali_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OG
l_int|0
op_logical_and
id|dmabuf-&gt;ready
op_logical_and
op_logical_neg
id|dmabuf-&gt;enable
op_logical_and
(paren
id|dmabuf-&gt;trigger
op_amp
id|SPDIF_ENABLE_OUTPUT
)paren
)paren
(brace
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
id|dmabuf-&gt;enable
op_or_assign
id|CODEC_SPDIFOUT_RUNNING
suffix:semicolon
id|outb
c_func
(paren
(paren
l_int|1
op_lshift
l_int|4
)paren
op_or
(paren
l_int|1
op_lshift
l_int|2
)paren
comma
id|state-&gt;card-&gt;iobase
op_plus
id|CODECSPDIFOUT_CR
)paren
suffix:semicolon
id|outl
c_func
(paren
(paren
l_int|1
op_lshift
l_int|3
)paren
comma
id|state-&gt;card-&gt;iobase
op_plus
l_int|0x08
)paren
suffix:semicolon
singleline_comment|//dma control register
)brace
r_else
(brace
r_if
c_cond
(paren
id|controller_independent_spdif_locked
OG
l_int|0
)paren
(brace
id|dmabuf-&gt;enable
op_or_assign
id|CONTROLLER_SPDIFOUT_RUNNING
suffix:semicolon
id|outb
c_func
(paren
(paren
l_int|1
op_lshift
l_int|4
)paren
op_or
(paren
l_int|1
op_lshift
l_int|2
)paren
comma
id|state-&gt;card-&gt;iobase
op_plus
id|CONTROLLERSPDIFOUT_CR
)paren
suffix:semicolon
id|outl
c_func
(paren
(paren
l_int|1
op_lshift
l_int|7
)paren
comma
id|state-&gt;card-&gt;iobase
op_plus
l_int|0x08
)paren
suffix:semicolon
singleline_comment|//dma control register
)brace
)brace
)brace
)brace
DECL|function|start_spdifout
r_static
r_void
id|start_spdifout
c_func
(paren
r_struct
id|ali_state
op_star
id|state
)paren
(brace
r_struct
id|ali_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__start_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|macro|DMABUF_DEFAULTORDER
mdefine_line|#define DMABUF_DEFAULTORDER (16-PAGE_SHIFT)
DECL|macro|DMABUF_MINORDER
mdefine_line|#define DMABUF_MINORDER 1
multiline_comment|/* allocate DMA buffer, playback , recording,spdif out  buffer should be allocated separately */
DECL|function|alloc_dmabuf
r_static
r_int
id|alloc_dmabuf
c_func
(paren
r_struct
id|ali_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_void
op_star
id|rawbuf
op_assign
l_int|NULL
suffix:semicolon
r_int
id|order
comma
id|size
suffix:semicolon
r_struct
id|page
op_star
id|page
comma
op_star
id|pend
suffix:semicolon
multiline_comment|/* If we don&squot;t have any oss frag params, then use our default ones */
r_if
c_cond
(paren
id|dmabuf-&gt;ossmaxfrags
op_eq
l_int|0
)paren
id|dmabuf-&gt;ossmaxfrags
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;ossfragsize
op_eq
l_int|0
)paren
id|dmabuf-&gt;ossfragsize
op_assign
(paren
id|PAGE_SIZE
op_lshift
id|DMABUF_DEFAULTORDER
)paren
op_div
id|dmabuf-&gt;ossmaxfrags
suffix:semicolon
id|size
op_assign
id|dmabuf-&gt;ossfragsize
op_star
id|dmabuf-&gt;ossmaxfrags
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;rawbuf
op_logical_and
(paren
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
)paren
op_eq
id|size
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* alloc enough to satisfy the oss params */
r_for
c_loop
(paren
id|order
op_assign
id|DMABUF_DEFAULTORDER
suffix:semicolon
id|order
op_ge
id|DMABUF_MINORDER
suffix:semicolon
id|order
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
OG
id|size
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rawbuf
op_assign
id|pci_alloc_consistent
c_func
(paren
id|state-&gt;card-&gt;pci_dev
comma
id|PAGE_SIZE
op_lshift
id|order
comma
op_amp
id|dmabuf-&gt;dma_handle
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rawbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
id|dmabuf-&gt;mapped
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;rawbuf
op_assign
id|rawbuf
suffix:semicolon
id|dmabuf-&gt;buforder
op_assign
id|order
suffix:semicolon
multiline_comment|/* now mark the pages as reserved; otherwise remap_page_range doesn&squot;t do what we want */
id|pend
op_assign
id|virt_to_page
c_func
(paren
id|rawbuf
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
id|rawbuf
)paren
suffix:semicolon
id|page
op_le
id|pend
suffix:semicolon
id|page
op_increment
)paren
id|SetPageReserved
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* free DMA buffer */
DECL|function|dealloc_dmabuf
r_static
r_void
id|dealloc_dmabuf
c_func
(paren
r_struct
id|ali_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|page
op_star
id|page
comma
op_star
id|pend
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;rawbuf
)paren
(brace
multiline_comment|/* undo marking the pages as reserved */
id|pend
op_assign
id|virt_to_page
c_func
(paren
id|dmabuf-&gt;rawbuf
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
id|dmabuf-&gt;rawbuf
)paren
suffix:semicolon
id|page
op_le
id|pend
suffix:semicolon
id|page
op_increment
)paren
id|ClearPageReserved
c_func
(paren
id|page
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|state-&gt;card-&gt;pci_dev
comma
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
comma
id|dmabuf-&gt;rawbuf
comma
id|dmabuf-&gt;dma_handle
)paren
suffix:semicolon
)brace
id|dmabuf-&gt;rawbuf
op_assign
l_int|NULL
suffix:semicolon
id|dmabuf-&gt;mapped
op_assign
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|prog_dmabuf
r_static
r_int
id|prog_dmabuf
c_func
(paren
r_struct
id|ali_state
op_star
id|state
comma
r_int
id|rec
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|ali_channel
op_star
id|c
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sg_item
op_star
id|sg
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|fragint
suffix:semicolon
r_int
id|i
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
id|__stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
id|__stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|CODEC_SPDIFOUT_RUNNING
)paren
id|__stop_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|CONTROLLER_SPDIFOUT_RUNNING
)paren
id|__stop_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;total_bytes
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;error
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* allocate DMA buffer, let alloc_dmabuf determine if we are already&n;&t; * allocated well enough or if we should replace the current buffer&n;&t; * (assuming one is already allocated, if it isn&squot;t, then allocate it).&n;&t; */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|alloc_dmabuf
c_func
(paren
id|state
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* FIXME: figure out all this OSS fragment stuff */
multiline_comment|/* I did, it now does what it should according to the OSS API.  DL */
multiline_comment|/* We may not have realloced our dmabuf, but the fragment size to&n;&t; * fragment number ratio may have changed, so go ahead and reprogram&n;&t; * things&n;&t; */
id|dmabuf-&gt;dmasize
op_assign
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
suffix:semicolon
id|dmabuf-&gt;numfrag
op_assign
id|SG_LEN
suffix:semicolon
id|dmabuf-&gt;fragsize
op_assign
id|dmabuf-&gt;dmasize
op_div
id|dmabuf-&gt;numfrag
suffix:semicolon
id|dmabuf-&gt;fragsamples
op_assign
id|dmabuf-&gt;fragsize
op_rshift
l_int|1
suffix:semicolon
id|dmabuf-&gt;userfragsize
op_assign
id|dmabuf-&gt;ossfragsize
suffix:semicolon
id|dmabuf-&gt;userfrags
op_assign
id|dmabuf-&gt;dmasize
op_div
id|dmabuf-&gt;ossfragsize
suffix:semicolon
id|memset
c_func
(paren
id|dmabuf-&gt;rawbuf
comma
l_int|0
comma
id|dmabuf-&gt;dmasize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;ossmaxfrags
op_eq
l_int|4
)paren
(brace
id|fragint
op_assign
l_int|8
suffix:semicolon
id|dmabuf-&gt;fragshift
op_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dmabuf-&gt;ossmaxfrags
op_eq
l_int|8
)paren
(brace
id|fragint
op_assign
l_int|4
suffix:semicolon
id|dmabuf-&gt;fragshift
op_assign
l_int|3
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dmabuf-&gt;ossmaxfrags
op_eq
l_int|16
)paren
(brace
id|fragint
op_assign
l_int|2
suffix:semicolon
id|dmabuf-&gt;fragshift
op_assign
l_int|4
suffix:semicolon
)brace
r_else
(brace
id|fragint
op_assign
l_int|1
suffix:semicolon
id|dmabuf-&gt;fragshift
op_assign
l_int|5
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      Now set up the ring &n;&t; */
r_if
c_cond
(paren
id|rec
op_eq
l_int|1
)paren
id|c
op_assign
id|dmabuf-&gt;read_channel
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rec
op_eq
l_int|2
)paren
id|c
op_assign
id|dmabuf-&gt;codec_spdifout_channel
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rec
op_eq
l_int|3
)paren
id|c
op_assign
id|dmabuf-&gt;controller_spdifout_channel
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rec
op_eq
l_int|0
)paren
id|c
op_assign
id|dmabuf-&gt;write_channel
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ne
l_int|NULL
)paren
(brace
id|sg
op_assign
op_amp
id|c-&gt;sg
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; *      Load up 32 sg entries and take an interrupt at half&n;&t;&t; *      way (we might want more interrupts later..) &n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dmabuf-&gt;numfrag
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sg-&gt;busaddr
op_assign
id|virt_to_bus
c_func
(paren
id|dmabuf-&gt;rawbuf
op_plus
id|dmabuf-&gt;fragsize
op_star
id|i
)paren
suffix:semicolon
singleline_comment|// the card will always be doing 16bit stereo
id|sg-&gt;control
op_assign
id|dmabuf-&gt;fragsamples
suffix:semicolon
id|sg-&gt;control
op_or_assign
id|CON_BUFPAD
suffix:semicolon
singleline_comment|//I modify
singleline_comment|// set us up to get IOC interrupts as often as needed to
singleline_comment|// satisfy numfrag requirements, no more
r_if
c_cond
(paren
(paren
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|fragint
)paren
op_eq
l_int|0
)paren
(brace
id|sg-&gt;control
op_or_assign
id|CON_IOC
suffix:semicolon
)brace
id|sg
op_increment
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|2
comma
id|state-&gt;card-&gt;iobase
op_plus
id|c-&gt;port
op_plus
id|OFF_CR
)paren
suffix:semicolon
multiline_comment|/* reset DMA machine */
id|outl
c_func
(paren
id|virt_to_bus
c_func
(paren
op_amp
id|c-&gt;sg
(braket
l_int|0
)braket
)paren
comma
id|state-&gt;card-&gt;iobase
op_plus
id|c-&gt;port
op_plus
id|OFF_BDBAR
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|state-&gt;card-&gt;iobase
op_plus
id|c-&gt;port
op_plus
id|OFF_CIV
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|state-&gt;card-&gt;iobase
op_plus
id|c-&gt;port
op_plus
id|OFF_LVI
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* set the ready flag for the dma buffer */
id|dmabuf-&gt;ready
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__ali_update_lvi
r_static
r_void
id|__ali_update_lvi
c_func
(paren
r_struct
id|ali_state
op_star
id|state
comma
r_int
id|rec
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
id|x
comma
id|port
suffix:semicolon
id|port
op_assign
id|state-&gt;card-&gt;iobase
suffix:semicolon
r_if
c_cond
(paren
id|rec
op_eq
l_int|1
)paren
id|port
op_add_assign
id|dmabuf-&gt;read_channel-&gt;port
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rec
op_eq
l_int|2
)paren
id|port
op_add_assign
id|dmabuf-&gt;codec_spdifout_channel-&gt;port
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rec
op_eq
l_int|3
)paren
id|port
op_add_assign
id|dmabuf-&gt;controller_spdifout_channel-&gt;port
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rec
op_eq
l_int|0
)paren
id|port
op_add_assign
id|dmabuf-&gt;write_channel-&gt;port
suffix:semicolon
multiline_comment|/* if we are currently stopped, then our CIV is actually set to our&n;&t; * *last* sg segment and we are ready to wrap to the next.  However,&n;&t; * if we set our LVI to the last sg segment, then it won&squot;t wrap to&n;&t; * the next sg segment, it won&squot;t even get a start.  So, instead, when&n;&t; * we are stopped, we set both the LVI value and also we increment&n;&t; * the CIV value to the next sg segment to be played so that when&n;&t; * we call start_{dac,adc}, things will operate properly&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;enable
op_logical_and
id|dmabuf-&gt;ready
)paren
(brace
r_if
c_cond
(paren
id|rec
op_logical_and
id|dmabuf-&gt;count
OL
id|dmabuf-&gt;dmasize
op_logical_and
(paren
id|dmabuf-&gt;trigger
op_amp
id|PCM_ENABLE_INPUT
)paren
)paren
(brace
id|outb
c_func
(paren
(paren
id|inb
c_func
(paren
id|port
op_plus
id|OFF_CIV
)paren
op_plus
l_int|1
)paren
op_amp
l_int|31
comma
id|port
op_plus
id|OFF_LVI
)paren
suffix:semicolon
id|__start_adc
c_func
(paren
id|state
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|port
op_plus
id|OFF_CR
)paren
op_amp
(paren
(paren
l_int|1
op_lshift
l_int|4
)paren
op_or
(paren
l_int|1
op_lshift
l_int|2
)paren
)paren
)paren
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|rec
op_logical_and
id|dmabuf-&gt;count
op_logical_and
(paren
id|dmabuf-&gt;trigger
op_amp
id|PCM_ENABLE_OUTPUT
)paren
)paren
(brace
id|outb
c_func
(paren
(paren
id|inb
c_func
(paren
id|port
op_plus
id|OFF_CIV
)paren
op_plus
l_int|1
)paren
op_amp
l_int|31
comma
id|port
op_plus
id|OFF_LVI
)paren
suffix:semicolon
id|__start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|port
op_plus
id|OFF_CR
)paren
op_amp
(paren
(paren
l_int|1
op_lshift
l_int|4
)paren
op_or
(paren
l_int|1
op_lshift
l_int|2
)paren
)paren
)paren
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rec
op_logical_and
id|dmabuf-&gt;count
op_logical_and
(paren
id|dmabuf-&gt;trigger
op_amp
id|SPDIF_ENABLE_OUTPUT
)paren
)paren
(brace
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
singleline_comment|// outb((inb(port+OFF_CIV))&amp;31, port+OFF_LVI);
id|outb
c_func
(paren
(paren
id|inb
c_func
(paren
id|port
op_plus
id|OFF_CIV
)paren
op_plus
l_int|1
)paren
op_amp
l_int|31
comma
id|port
op_plus
id|OFF_LVI
)paren
suffix:semicolon
id|__start_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|port
op_plus
id|OFF_CR
)paren
op_amp
(paren
(paren
l_int|1
op_lshift
l_int|4
)paren
op_or
(paren
l_int|1
op_lshift
l_int|2
)paren
)paren
)paren
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|controller_independent_spdif_locked
OG
l_int|0
)paren
(brace
id|outb
c_func
(paren
(paren
id|inb
c_func
(paren
id|port
op_plus
id|OFF_CIV
)paren
op_plus
l_int|1
)paren
op_amp
l_int|31
comma
id|port
op_plus
id|OFF_LVI
)paren
suffix:semicolon
id|__start_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|port
op_plus
id|OFF_CR
)paren
op_amp
(paren
(paren
l_int|1
op_lshift
l_int|4
)paren
op_or
(paren
l_int|1
op_lshift
l_int|2
)paren
)paren
)paren
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* swptr - 1 is the tail of our transfer */
id|x
op_assign
(paren
id|dmabuf-&gt;dmasize
op_plus
id|dmabuf-&gt;swptr
op_minus
l_int|1
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|x
op_div_assign
id|dmabuf-&gt;fragsize
suffix:semicolon
id|outb
c_func
(paren
id|x
comma
id|port
op_plus
id|OFF_LVI
)paren
suffix:semicolon
)brace
DECL|function|ali_update_lvi
r_static
r_void
id|ali_update_lvi
c_func
(paren
r_struct
id|ali_state
op_star
id|state
comma
r_int
id|rec
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__ali_update_lvi
c_func
(paren
id|state
comma
id|rec
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* update buffer manangement pointers, especially, dmabuf-&gt;count and dmabuf-&gt;hwptr */
DECL|function|ali_update_ptr
r_static
r_void
id|ali_update_ptr
c_func
(paren
r_struct
id|ali_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
id|hwptr
suffix:semicolon
r_int
id|diff
suffix:semicolon
multiline_comment|/* error handling and process wake up for DAC */
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_eq
id|ADC_RUNNING
)paren
(brace
multiline_comment|/* update hardware pointer */
id|hwptr
op_assign
id|ali_get_dma_addr
c_func
(paren
id|state
comma
l_int|1
)paren
suffix:semicolon
id|diff
op_assign
(paren
id|dmabuf-&gt;dmasize
op_plus
id|hwptr
op_minus
id|dmabuf-&gt;hwptr
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|dmabuf-&gt;hwptr
op_assign
id|hwptr
suffix:semicolon
id|dmabuf-&gt;total_bytes
op_add_assign
id|diff
suffix:semicolon
id|dmabuf-&gt;count
op_add_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OG
id|dmabuf-&gt;dmasize
)paren
(brace
multiline_comment|/* buffer underrun or buffer overrun */
multiline_comment|/* this is normal for the end of a read */
multiline_comment|/* only give an error if we went past the */
multiline_comment|/* last valid sg entry */
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|PI_CIV
)paren
op_amp
l_int|31
)paren
op_ne
(paren
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|PI_LVI
)paren
op_amp
l_int|31
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ali_audio: DMA overrun on read&bslash;n&quot;
)paren
suffix:semicolon
id|dmabuf-&gt;error
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
OG
id|dmabuf-&gt;userfragsize
)paren
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
)brace
multiline_comment|/* error handling and process wake up for DAC */
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_eq
id|DAC_RUNNING
)paren
(brace
multiline_comment|/* update hardware pointer */
id|hwptr
op_assign
id|ali_get_dma_addr
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
id|diff
op_assign
(paren
id|dmabuf-&gt;dmasize
op_plus
id|hwptr
op_minus
id|dmabuf-&gt;hwptr
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
macro_line|#if defined(DEBUG_INTERRUPTS) || defined(DEBUG_MMAP)
id|printk
c_func
(paren
l_string|&quot;DAC HWP %d,%d,%d&bslash;n&quot;
comma
id|hwptr
comma
id|dmabuf-&gt;hwptr
comma
id|diff
)paren
suffix:semicolon
macro_line|#endif
id|dmabuf-&gt;hwptr
op_assign
id|hwptr
suffix:semicolon
id|dmabuf-&gt;total_bytes
op_add_assign
id|diff
suffix:semicolon
id|dmabuf-&gt;count
op_sub_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
l_int|0
)paren
(brace
multiline_comment|/* buffer underrun or buffer overrun */
multiline_comment|/* this is normal for the end of a write */
multiline_comment|/* only give an error if we went past the */
multiline_comment|/* last valid sg entry */
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|PO_CIV
)paren
op_amp
l_int|31
)paren
op_ne
(paren
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|PO_LVI
)paren
op_amp
l_int|31
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ali_audio: DMA overrun on write&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ali_audio: CIV %d, LVI %d, hwptr %x, count %d&bslash;n&quot;
comma
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|PO_CIV
)paren
op_amp
l_int|31
comma
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|PO_LVI
)paren
op_amp
l_int|31
comma
id|dmabuf-&gt;hwptr
comma
id|dmabuf-&gt;count
)paren
suffix:semicolon
id|dmabuf-&gt;error
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
(paren
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;userfragsize
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
)brace
multiline_comment|/* error handling and process wake up for CODEC SPDIF OUT */
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_eq
id|CODEC_SPDIFOUT_RUNNING
)paren
(brace
multiline_comment|/* update hardware pointer */
id|hwptr
op_assign
id|ali_get_dma_addr
c_func
(paren
id|state
comma
l_int|2
)paren
suffix:semicolon
id|diff
op_assign
(paren
id|dmabuf-&gt;dmasize
op_plus
id|hwptr
op_minus
id|dmabuf-&gt;hwptr
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|dmabuf-&gt;hwptr
op_assign
id|hwptr
suffix:semicolon
id|dmabuf-&gt;total_bytes
op_add_assign
id|diff
suffix:semicolon
id|dmabuf-&gt;count
op_sub_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
l_int|0
)paren
(brace
multiline_comment|/* buffer underrun or buffer overrun */
multiline_comment|/* this is normal for the end of a write */
multiline_comment|/* only give an error if we went past the */
multiline_comment|/* last valid sg entry */
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|CODECSPDIFOUT_CIV
)paren
op_amp
l_int|31
)paren
op_ne
(paren
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|CODECSPDIFOUT_LVI
)paren
op_amp
l_int|31
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ali_audio: DMA overrun on write&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ali_audio: CIV %d, LVI %d, hwptr %x, count %d&bslash;n&quot;
comma
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|CODECSPDIFOUT_CIV
)paren
op_amp
l_int|31
comma
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|CODECSPDIFOUT_LVI
)paren
op_amp
l_int|31
comma
id|dmabuf-&gt;hwptr
comma
id|dmabuf-&gt;count
)paren
suffix:semicolon
id|dmabuf-&gt;error
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
(paren
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;userfragsize
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
)brace
multiline_comment|/* error handling and process wake up for CONTROLLER SPDIF OUT */
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_eq
id|CONTROLLER_SPDIFOUT_RUNNING
)paren
(brace
multiline_comment|/* update hardware pointer */
id|hwptr
op_assign
id|ali_get_dma_addr
c_func
(paren
id|state
comma
l_int|3
)paren
suffix:semicolon
id|diff
op_assign
(paren
id|dmabuf-&gt;dmasize
op_plus
id|hwptr
op_minus
id|dmabuf-&gt;hwptr
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|dmabuf-&gt;hwptr
op_assign
id|hwptr
suffix:semicolon
id|dmabuf-&gt;total_bytes
op_add_assign
id|diff
suffix:semicolon
id|dmabuf-&gt;count
op_sub_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
l_int|0
)paren
(brace
multiline_comment|/* buffer underrun or buffer overrun */
multiline_comment|/* this is normal for the end of a write */
multiline_comment|/* only give an error if we went past the */
multiline_comment|/* last valid sg entry */
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|CONTROLLERSPDIFOUT_CIV
)paren
op_amp
l_int|31
)paren
op_ne
(paren
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|CONTROLLERSPDIFOUT_LVI
)paren
op_amp
l_int|31
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ali_audio: DMA overrun on write&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ali_audio: CIV %d, LVI %d, hwptr %x, &quot;
l_string|&quot;count %d&bslash;n&quot;
comma
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|CONTROLLERSPDIFOUT_CIV
)paren
op_amp
l_int|31
comma
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|CONTROLLERSPDIFOUT_LVI
)paren
op_amp
l_int|31
comma
id|dmabuf-&gt;hwptr
comma
id|dmabuf-&gt;count
)paren
suffix:semicolon
id|dmabuf-&gt;error
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
(paren
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;userfragsize
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
)brace
)brace
DECL|function|ali_get_free_write_space
r_static
r_inline
r_int
id|ali_get_free_write_space
c_func
(paren
r_struct
id|ali_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
id|free
suffix:semicolon
id|ali_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
singleline_comment|// catch underruns during playback
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
l_int|0
)paren
(brace
id|dmabuf-&gt;count
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
)brace
id|free
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;count
suffix:semicolon
id|free
op_sub_assign
(paren
id|dmabuf-&gt;hwptr
op_mod
id|dmabuf-&gt;fragsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|free
OL
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|free
)paren
suffix:semicolon
)brace
DECL|function|ali_get_available_read_data
r_static
r_inline
r_int
id|ali_get_available_read_data
c_func
(paren
r_struct
id|ali_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
id|avail
suffix:semicolon
id|ali_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
singleline_comment|// catch overruns during record
r_if
c_cond
(paren
id|dmabuf-&gt;count
OG
id|dmabuf-&gt;dmasize
)paren
(brace
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;dmasize
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
)brace
id|avail
op_assign
id|dmabuf-&gt;count
suffix:semicolon
id|avail
op_sub_assign
(paren
id|dmabuf-&gt;hwptr
op_mod
id|dmabuf-&gt;fragsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|avail
OL
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|avail
)paren
suffix:semicolon
)brace
DECL|function|drain_dac
r_static
r_int
id|drain_dac
c_func
(paren
r_struct
id|ali_state
op_star
id|state
comma
r_int
id|signals_allowed
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|tmo
suffix:semicolon
r_int
id|count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|add_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ali_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|count
op_assign
id|dmabuf-&gt;count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_le
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* &n;&t;&t; * This will make sure that our LVI is correct, that our&n;&t;&t; * pointer is updated, and that the DAC is running.  We&n;&t;&t; * have to force the setting of dmabuf-&gt;trigger to avoid&n;&t;&t; * any possible deadlocks.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;enable
)paren
(brace
id|dmabuf-&gt;trigger
op_assign
id|PCM_ENABLE_OUTPUT
suffix:semicolon
id|ali_update_lvi
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
op_logical_and
id|signals_allowed
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* It seems that we have to set the current state to&n;&t;&t; * TASK_INTERRUPTIBLE every time to make the process&n;&t;&t; * really go to sleep.  This also has to be *after* the&n;&t;&t; * update_ptr() call because update_ptr is likely to&n;&t;&t; * do a wake_up() which will unset this before we ever&n;&t;&t; * try to sleep, resuling in a tight loop in this code&n;&t;&t; * instead of actually sleeping and waiting for an&n;&t;&t; * interrupt to wake us up!&n;&t;&t; */
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * set the timeout to significantly longer than it *should*&n;&t;&t; * take for the DAC to drain the DMA buffer&n;&t;&t; */
id|tmo
op_assign
(paren
id|count
op_star
id|HZ
)paren
op_div
(paren
id|dmabuf-&gt;rate
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|schedule_timeout
c_func
(paren
id|tmo
op_ge
l_int|2
ques
c_cond
id|tmo
suffix:colon
l_int|2
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ali_audio: drain_dac, dma timeout?&bslash;n&quot;
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|0
op_logical_and
id|signal_pending
c_func
(paren
id|current
)paren
op_logical_and
id|signals_allowed
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|drain_spdifout
r_static
r_int
id|drain_spdifout
c_func
(paren
r_struct
id|ali_state
op_star
id|state
comma
r_int
id|signals_allowed
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|tmo
suffix:semicolon
r_int
id|count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
id|stop_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|add_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ali_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|count
op_assign
id|dmabuf-&gt;count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_le
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* &n;&t;&t; * This will make sure that our LVI is correct, that our&n;&t;&t; * pointer is updated, and that the DAC is running.  We&n;&t;&t; * have to force the setting of dmabuf-&gt;trigger to avoid&n;&t;&t; * any possible deadlocks.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;enable
)paren
(brace
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
id|dmabuf-&gt;trigger
op_assign
id|SPDIF_ENABLE_OUTPUT
suffix:semicolon
id|ali_update_lvi
c_func
(paren
id|state
comma
l_int|2
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|controller_independent_spdif_locked
OG
l_int|0
)paren
(brace
id|dmabuf-&gt;trigger
op_assign
id|SPDIF_ENABLE_OUTPUT
suffix:semicolon
id|ali_update_lvi
c_func
(paren
id|state
comma
l_int|3
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
op_logical_and
id|signals_allowed
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* It seems that we have to set the current state to&n;&t;&t; * TASK_INTERRUPTIBLE every time to make the process&n;&t;&t; * really go to sleep.  This also has to be *after* the&n;&t;&t; * update_ptr() call because update_ptr is likely to&n;&t;&t; * do a wake_up() which will unset this before we ever&n;&t;&t; * try to sleep, resuling in a tight loop in this code&n;&t;&t; * instead of actually sleeping and waiting for an&n;&t;&t; * interrupt to wake us up!&n;&t;&t; */
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * set the timeout to significantly longer than it *should*&n;&t;&t; * take for the DAC to drain the DMA buffer&n;&t;&t; */
id|tmo
op_assign
(paren
id|count
op_star
id|HZ
)paren
op_div
(paren
id|dmabuf-&gt;rate
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|schedule_timeout
c_func
(paren
id|tmo
op_ge
l_int|2
ques
c_cond
id|tmo
suffix:colon
l_int|2
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ali_audio: drain_spdifout, dma timeout?&bslash;n&quot;
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|0
op_logical_and
id|signal_pending
c_func
(paren
id|current
)paren
op_logical_and
id|signals_allowed
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
id|stop_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ali_channel_interrupt
r_static
r_void
id|ali_channel_interrupt
c_func
(paren
r_struct
id|ali_card
op_star
id|card
)paren
(brace
r_int
id|i
comma
id|count
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_HW_CH
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ali_state
op_star
id|state
op_assign
id|card-&gt;states
(braket
id|i
)braket
suffix:semicolon
r_struct
id|ali_channel
op_star
id|c
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
suffix:semicolon
r_int
r_int
id|port
op_assign
id|card-&gt;iobase
suffix:semicolon
id|u16
id|status
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;dmabuf.ready
)paren
r_continue
suffix:semicolon
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|CODEC_SPDIFOUT_RUNNING
)paren
(brace
id|c
op_assign
id|dmabuf-&gt;codec_spdifout_channel
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|controller_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|CONTROLLER_SPDIFOUT_RUNNING
)paren
id|c
op_assign
id|dmabuf-&gt;controller_spdifout_channel
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
(brace
id|c
op_assign
id|dmabuf-&gt;write_channel
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
(brace
id|c
op_assign
id|dmabuf-&gt;read_channel
suffix:semicolon
)brace
r_else
r_continue
suffix:semicolon
)brace
)brace
id|port
op_add_assign
id|c-&gt;port
suffix:semicolon
id|status
op_assign
id|inw
c_func
(paren
id|port
op_plus
id|OFF_SR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|DMA_INT_COMPLETE
)paren
(brace
multiline_comment|/* only wake_up() waiters if this interrupt signals&n;&t;&t;&t; * us being beyond a userfragsize of data open or&n;&t;&t;&t; * available, and ali_update_ptr() does that for&n;&t;&t;&t; * us&n;&t;&t;&t; */
id|ali_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|DMA_INT_LVI
)paren
(brace
id|ali_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
id|count
op_assign
id|dmabuf-&gt;count
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
id|count
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;count
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|CODEC_SPDIFOUT_RUNNING
)paren
id|count
op_assign
id|dmabuf-&gt;count
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|CONTROLLER_SPDIFOUT_RUNNING
)paren
id|count
op_assign
id|dmabuf-&gt;count
suffix:semicolon
r_else
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
id|outl
c_func
(paren
(paren
l_int|1
op_lshift
l_int|1
)paren
comma
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_DMACR
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|CODEC_SPDIFOUT_RUNNING
)paren
id|outl
c_func
(paren
(paren
l_int|1
op_lshift
l_int|3
)paren
comma
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_DMACR
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|CONTROLLER_SPDIFOUT_RUNNING
)paren
id|outl
c_func
(paren
(paren
l_int|1
op_lshift
l_int|7
)paren
comma
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_DMACR
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
id|__stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
id|__stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|CODEC_SPDIFOUT_RUNNING
)paren
id|__stop_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|CONTROLLER_SPDIFOUT_RUNNING
)paren
id|__stop_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;enable
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|DMA_INT_DCH
)paren
)paren
(brace
id|ali_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
id|count
op_assign
id|dmabuf-&gt;count
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
id|count
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;count
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|CODEC_SPDIFOUT_RUNNING
)paren
id|count
op_assign
id|dmabuf-&gt;count
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|CONTROLLER_SPDIFOUT_RUNNING
)paren
id|count
op_assign
id|dmabuf-&gt;count
suffix:semicolon
r_else
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
id|outl
c_func
(paren
(paren
l_int|1
op_lshift
l_int|1
)paren
comma
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_DMACR
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|CODEC_SPDIFOUT_RUNNING
)paren
id|outl
c_func
(paren
(paren
l_int|1
op_lshift
l_int|3
)paren
comma
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_DMACR
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|CONTROLLER_SPDIFOUT_RUNNING
)paren
id|outl
c_func
(paren
(paren
l_int|1
op_lshift
l_int|7
)paren
comma
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_DMACR
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
id|__stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
id|__stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|CODEC_SPDIFOUT_RUNNING
)paren
id|__stop_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|CONTROLLER_SPDIFOUT_RUNNING
)paren
id|__stop_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;enable
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
)brace
)brace
id|outw
c_func
(paren
id|status
op_amp
id|DMA_INT_MASK
comma
id|port
op_plus
id|OFF_SR
)paren
suffix:semicolon
)brace
)brace
DECL|function|ali_interrupt
r_static
id|irqreturn_t
id|ali_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|ali_card
op_star
id|card
op_assign
(paren
r_struct
id|ali_card
op_star
)paren
id|dev_id
suffix:semicolon
id|u32
id|status
suffix:semicolon
id|u16
id|status2
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|status
op_assign
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|ALI_INTERRUPTSR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|INT_MASK
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
r_return
id|IRQ_NONE
suffix:semicolon
multiline_comment|/* not for us */
)brace
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|globel
op_eq
l_int|0
)paren
(brace
id|globel
op_add_assign
l_int|1
suffix:semicolon
id|status2
op_assign
id|inw
c_func
(paren
id|card-&gt;iobase
op_plus
l_int|0x76
)paren
suffix:semicolon
id|outw
c_func
(paren
id|status2
op_or
l_int|0x000c
comma
id|card-&gt;iobase
op_plus
l_int|0x76
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|status
op_amp
(paren
id|INT_PCMOUT
op_or
id|INT_PCMIN
op_or
id|INT_MICIN
op_or
id|INT_SPDIFOUT
op_or
id|INT_CODECSPDIFOUT
)paren
)paren
id|ali_channel_interrupt
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|status
op_amp
(paren
id|INT_PCMOUT
op_or
id|INT_PCMIN
op_or
id|INT_MICIN
op_or
id|INT_SPDIFOUT
op_or
id|INT_CODECSPDIFOUT
)paren
)paren
id|ali_channel_interrupt
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
multiline_comment|/* clear &squot;em */
id|outl
c_func
(paren
id|status
op_amp
id|INT_MASK
comma
id|card-&gt;iobase
op_plus
id|ALI_INTERRUPTSR
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/* in this loop, dmabuf.count signifies the amount of data that is&n;   waiting to be copied to the user&squot;s buffer.  It is filled by the dma&n;   machine and drained by this loop. */
DECL|function|ali_read
r_static
id|ssize_t
id|ali_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|ali_state
op_star
id|state
op_assign
(paren
r_struct
id|ali_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|ali_card
op_star
id|card
op_assign
id|state
ques
c_cond
id|state-&gt;card
suffix:colon
l_int|0
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|swptr
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|waita
comma
id|current
)paren
suffix:semicolon
macro_line|#ifdef DEBUG2
id|printk
c_func
(paren
l_string|&quot;ali_audio: ali_read called, count = %d&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;read_channel
)paren
(brace
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;read_channel
op_assign
id|card
op_member_access_from_pointer
id|alloc_rec_pcm_channel
c_func
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;read_channel
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|waita
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PM_SUSPENDED
c_func
(paren
id|card
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
id|swptr
op_assign
id|dmabuf-&gt;swptr
suffix:semicolon
id|cnt
op_assign
id|ali_get_available_read_data
c_func
(paren
id|state
)paren
suffix:semicolon
singleline_comment|// this is to make the copy_to_user simpler below
r_if
c_cond
(paren
id|cnt
OG
(paren
id|dmabuf-&gt;dmasize
op_minus
id|swptr
)paren
)paren
id|cnt
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|swptr
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|count
)paren
id|cnt
op_assign
id|count
suffix:semicolon
multiline_comment|/* Lop off the last two bits to force the code to always&n;&t;&t; * write in full samples.  This keeps software that sets&n;&t;&t; * O_NONBLOCK but doesn&squot;t check the return value of the&n;&t;&t; * write call from getting things out of state where they&n;&t;&t; * think a full 4 byte sample was written when really only&n;&t;&t; * a portion was, resulting in odd sound and stereo&n;&t;&t; * hysteresis.&n;&t;&t; */
id|cnt
op_and_assign
op_complement
l_int|0x3
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
r_int
r_int
id|tmo
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Don&squot;t let us deadlock.  The ADC won&squot;t start if&n;&t;&t;&t; * dmabuf-&gt;trigger isn&squot;t set.  A call to SETTRIGGER&n;&t;&t;&t; * could have turned it off after we set it to on&n;&t;&t;&t; * previously.&n;&t;&t;&t; */
id|dmabuf-&gt;trigger
op_assign
id|PCM_ENABLE_INPUT
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * This does three things.  Updates LVI to be correct,&n;&t;&t;&t; * makes sure the ADC is running, and updates the&n;&t;&t;&t; * hwptr.&n;&t;&t;&t; */
id|ali_update_lvi
c_func
(paren
id|state
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* Set the timeout to how long it would take to fill&n;&t;&t;&t; * two of our buffers.  If we haven&squot;t been woke up&n;&t;&t;&t; * by then, then we know something is wrong.&n;&t;&t;&t; */
id|tmo
op_assign
(paren
id|dmabuf-&gt;dmasize
op_star
id|HZ
op_star
l_int|2
)paren
op_div
(paren
id|dmabuf-&gt;rate
op_star
l_int|4
)paren
suffix:semicolon
multiline_comment|/* There are two situations when sleep_on_timeout returns, one is when&n;&t;&t;&t;   the interrupt is serviced correctly and the process is waked up by&n;&t;&t;&t;   ISR ON TIME. Another is when timeout is expired, which means that&n;&t;&t;&t;   either interrupt is NOT serviced correctly (pending interrupt) or it&n;&t;&t;&t;   is TOO LATE for the process to be scheduled to run (scheduler latency)&n;&t;&t;&t;   which results in a (potential) buffer overrun. And worse, there is&n;&t;&t;&t;   NOTHING we can do to prevent it. */
r_if
c_cond
(paren
op_logical_neg
id|schedule_timeout
c_func
(paren
id|tmo
op_ge
l_int|2
ques
c_cond
id|tmo
suffix:colon
l_int|2
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ali_audio: recording schedule timeout, &quot;
l_string|&quot;dmasz %u fragsz %u count %i hwptr %u swptr %u&bslash;n&quot;
comma
id|dmabuf-&gt;dmasize
comma
id|dmabuf-&gt;fragsize
comma
id|dmabuf-&gt;count
comma
id|dmabuf-&gt;hwptr
comma
id|dmabuf-&gt;swptr
)paren
suffix:semicolon
multiline_comment|/* a buffer overrun, we delay the recovery until next time the&n;&t;&t;&t;&t;   while loop begin and we REALLY have space to record */
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|ret
op_assign
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|ERESTARTSYS
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
id|dmabuf-&gt;rawbuf
op_plus
id|swptr
comma
id|cnt
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|swptr
op_assign
(paren
id|swptr
op_plus
id|cnt
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PM_SUSPENDED
c_func
(paren
id|card
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|dmabuf-&gt;swptr
op_assign
id|swptr
suffix:semicolon
id|dmabuf-&gt;count
op_sub_assign
id|cnt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_sub_assign
id|cnt
suffix:semicolon
id|buffer
op_add_assign
id|cnt
suffix:semicolon
id|ret
op_add_assign
id|cnt
suffix:semicolon
)brace
id|done
suffix:colon
id|ali_update_lvi
c_func
(paren
id|state
comma
l_int|1
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|waita
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* in this loop, dmabuf.count signifies the amount of data that is waiting to be dma to&n;   the soundcard.  it is drained by the dma machine and filled by this loop. */
DECL|function|ali_write
r_static
id|ssize_t
id|ali_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|ali_state
op_star
id|state
op_assign
(paren
r_struct
id|ali_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|ali_card
op_star
id|card
op_assign
id|state
ques
c_cond
id|state-&gt;card
suffix:colon
l_int|0
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|swptr
op_assign
l_int|0
suffix:semicolon
r_int
id|cnt
comma
id|x
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|waita
comma
id|current
)paren
suffix:semicolon
macro_line|#ifdef DEBUG2
id|printk
c_func
(paren
l_string|&quot;ali_audio: ali_write called, count = %d&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;codec_spdifout_channel
)paren
(brace
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;codec_spdifout_channel
op_assign
id|card
op_member_access_from_pointer
id|alloc_codec_spdifout_channel
c_func
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;codec_spdifout_channel
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|controller_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;controller_spdifout_channel
)paren
(brace
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;controller_spdifout_channel
op_assign
id|card
op_member_access_from_pointer
id|alloc_controller_spdifout_channel
c_func
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;controller_spdifout_channel
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;write_channel
)paren
(brace
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;write_channel
op_assign
id|card
op_member_access_from_pointer
id|alloc_pcm_channel
c_func
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;write_channel
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|2
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|controller_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|3
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|waita
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PM_SUSPENDED
c_func
(paren
id|card
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
id|swptr
op_assign
id|dmabuf-&gt;swptr
suffix:semicolon
id|cnt
op_assign
id|ali_get_free_write_space
c_func
(paren
id|state
)paren
suffix:semicolon
multiline_comment|/* Bound the maximum size to how much we can copy to the&n;&t;&t; * dma buffer before we hit the end.  If we have more to&n;&t;&t; * copy then it will get done in a second pass of this&n;&t;&t; * loop starting from the beginning of the buffer.&n;&t;&t; */
r_if
c_cond
(paren
id|cnt
OG
(paren
id|dmabuf-&gt;dmasize
op_minus
id|swptr
)paren
)paren
id|cnt
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|swptr
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG2
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ali_audio: ali_write: %d bytes available space&bslash;n&quot;
comma
id|cnt
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cnt
OG
id|count
)paren
id|cnt
op_assign
id|count
suffix:semicolon
multiline_comment|/* Lop off the last two bits to force the code to always&n;&t;&t; * write in full samples.  This keeps software that sets&n;&t;&t; * O_NONBLOCK but doesn&squot;t check the return value of the&n;&t;&t; * write call from getting things out of state where they&n;&t;&t; * think a full 4 byte sample was written when really only&n;&t;&t; * a portion was, resulting in odd sound and stereo&n;&t;&t; * hysteresis.&n;&t;&t; */
id|cnt
op_and_assign
op_complement
l_int|0x3
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
r_int
r_int
id|tmo
suffix:semicolon
singleline_comment|// There is data waiting to be played
multiline_comment|/*&n;&t;&t;&t; * Force the trigger setting since we would&n;&t;&t;&t; * deadlock with it set any other way&n;&t;&t;&t; */
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
id|dmabuf-&gt;trigger
op_assign
id|SPDIF_ENABLE_OUTPUT
suffix:semicolon
id|ali_update_lvi
c_func
(paren
id|state
comma
l_int|2
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|controller_independent_spdif_locked
OG
l_int|0
)paren
(brace
id|dmabuf-&gt;trigger
op_assign
id|SPDIF_ENABLE_OUTPUT
suffix:semicolon
id|ali_update_lvi
c_func
(paren
id|state
comma
l_int|3
)paren
suffix:semicolon
)brace
r_else
(brace
id|dmabuf-&gt;trigger
op_assign
id|PCM_ENABLE_OUTPUT
suffix:semicolon
id|ali_update_lvi
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|ret
suffix:semicolon
)brace
multiline_comment|/* Not strictly correct but works */
id|tmo
op_assign
(paren
id|dmabuf-&gt;dmasize
op_star
id|HZ
op_star
l_int|2
)paren
op_div
(paren
id|dmabuf-&gt;rate
op_star
l_int|4
)paren
suffix:semicolon
multiline_comment|/* There are two situations when sleep_on_timeout returns, one is when&n;&t;&t;&t;   the interrupt is serviced correctly and the process is waked up by&n;&t;&t;&t;   ISR ON TIME. Another is when timeout is expired, which means that&n;&t;&t;&t;   either interrupt is NOT serviced correctly (pending interrupt) or it&n;&t;&t;&t;   is TOO LATE for the process to be scheduled to run (scheduler latency)&n;&t;&t;&t;   which results in a (potential) buffer underrun. And worse, there is&n;&t;&t;&t;   NOTHING we can do to prevent it. */
multiline_comment|/* FIXME - do timeout handling here !! */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_goto
id|ret
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|dmabuf-&gt;rawbuf
op_plus
id|swptr
comma
id|buffer
comma
id|cnt
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|ret
suffix:semicolon
)brace
id|swptr
op_assign
(paren
id|swptr
op_plus
id|cnt
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PM_SUSPENDED
c_func
(paren
id|card
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|dmabuf-&gt;swptr
op_assign
id|swptr
suffix:semicolon
id|dmabuf-&gt;count
op_add_assign
id|cnt
suffix:semicolon
id|count
op_sub_assign
id|cnt
suffix:semicolon
id|buffer
op_add_assign
id|cnt
suffix:semicolon
id|ret
op_add_assign
id|cnt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|swptr
op_mod
id|dmabuf-&gt;fragsize
)paren
(brace
id|x
op_assign
id|dmabuf-&gt;fragsize
op_minus
(paren
id|swptr
op_mod
id|dmabuf-&gt;fragsize
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dmabuf-&gt;rawbuf
op_plus
id|swptr
comma
l_char|&squot;&bslash;0&squot;
comma
id|x
)paren
suffix:semicolon
)brace
id|ret
suffix:colon
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
id|ali_update_lvi
c_func
(paren
id|state
comma
l_int|2
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|controller_independent_spdif_locked
OG
l_int|0
)paren
(brace
id|ali_update_lvi
c_func
(paren
id|state
comma
l_int|3
)paren
suffix:semicolon
)brace
r_else
(brace
id|ali_update_lvi
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|waita
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* No kernel lock - we have our own spinlock */
DECL|function|ali_poll
r_static
r_int
r_int
id|ali_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|poll_table_struct
op_star
id|wait
)paren
(brace
r_struct
id|ali_state
op_star
id|state
op_assign
(paren
r_struct
id|ali_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
)paren
r_return
l_int|0
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|dmabuf-&gt;wait
comma
id|wait
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ali_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
op_logical_and
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_ge
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
op_logical_and
(paren
id|dmabuf-&gt;enable
op_amp
(paren
id|DAC_RUNNING
op_or
id|CODEC_SPDIFOUT_RUNNING
op_or
id|CONTROLLER_SPDIFOUT_RUNNING
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|dmabuf-&gt;dmasize
op_ge
id|dmabuf-&gt;count
op_plus
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
DECL|function|ali_mmap
r_static
r_int
id|ali_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|ali_state
op_star
id|state
op_assign
(paren
r_struct
id|ali_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_WRITE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;write_channel
op_logical_and
(paren
id|dmabuf-&gt;write_channel
op_assign
id|state-&gt;card
op_member_access_from_pointer
id|alloc_pcm_channel
c_func
(paren
id|state-&gt;card
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_READ
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;read_channel
op_logical_and
(paren
id|dmabuf-&gt;read_channel
op_assign
id|state-&gt;card
op_member_access_from_pointer
id|alloc_rec_pcm_channel
c_func
(paren
id|state-&gt;card
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_pgoff
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|size
op_assign
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
(paren
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
)paren
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|remap_page_range
c_func
(paren
id|vma
comma
id|vma-&gt;vm_start
comma
id|virt_to_phys
c_func
(paren
id|dmabuf-&gt;rawbuf
)paren
comma
id|size
comma
id|vma-&gt;vm_page_prot
)paren
)paren
r_goto
id|out
suffix:semicolon
id|dmabuf-&gt;mapped
op_assign
l_int|1
suffix:semicolon
id|dmabuf-&gt;trigger
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|ali_ioctl
r_static
r_int
id|ali_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|ali_state
op_star
id|state
op_assign
(paren
r_struct
id|ali_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|ali_channel
op_star
id|c
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|audio_buf_info
id|abinfo
suffix:semicolon
id|count_info
id|cinfo
suffix:semicolon
r_int
r_int
id|i_scr
suffix:semicolon
r_int
id|val
op_assign
l_int|0
comma
id|ret
suffix:semicolon
r_struct
id|ac97_codec
op_star
id|codec
op_assign
id|state-&gt;card-&gt;ac97_codec
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;ali_audio: ali_ioctl, arg=0x%x, cmd=&quot;
comma
id|arg
ques
c_cond
op_star
(paren
r_int
op_star
)paren
id|arg
suffix:colon
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|OSS_GETVERSION
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;OSS_GETVERSION&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|SOUND_VERSION
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_RESET
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_RESET&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_eq
id|DAC_RUNNING
)paren
(brace
id|c
op_assign
id|dmabuf-&gt;write_channel
suffix:semicolon
id|__stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_eq
id|ADC_RUNNING
)paren
(brace
id|c
op_assign
id|dmabuf-&gt;read_channel
suffix:semicolon
id|__stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_eq
id|CODEC_SPDIFOUT_RUNNING
)paren
(brace
id|c
op_assign
id|dmabuf-&gt;codec_spdifout_channel
suffix:semicolon
id|__stop_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_eq
id|CONTROLLER_SPDIFOUT_RUNNING
)paren
(brace
id|c
op_assign
id|dmabuf-&gt;controller_spdifout_channel
suffix:semicolon
id|__stop_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_ne
l_int|NULL
)paren
(brace
id|outb
c_func
(paren
l_int|2
comma
id|state-&gt;card-&gt;iobase
op_plus
id|c-&gt;port
op_plus
id|OFF_CR
)paren
suffix:semicolon
multiline_comment|/* reset DMA machine */
id|outl
c_func
(paren
id|virt_to_bus
c_func
(paren
op_amp
id|c-&gt;sg
(braket
l_int|0
)braket
)paren
comma
id|state-&gt;card-&gt;iobase
op_plus
id|c-&gt;port
op_plus
id|OFF_BDBAR
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|state-&gt;card-&gt;iobase
op_plus
id|c-&gt;port
op_plus
id|OFF_CIV
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|state-&gt;card-&gt;iobase
op_plus
id|c-&gt;port
op_plus
id|OFF_LVI
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
id|state-&gt;card-&gt;pci_dev-&gt;irq
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;total_bytes
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SYNC
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SYNC&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_ne
id|CODEC_SPDIFOUT_RUNNING
op_logical_or
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
op_assign
id|drain_spdifout
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|controller_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_ne
id|CONTROLLER_SPDIFOUT_RUNNING
op_logical_or
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
op_assign
id|drain_spdifout
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_ne
id|DAC_RUNNING
op_logical_or
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
op_assign
id|drain_dac
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
)brace
)brace
id|dmabuf-&gt;total_bytes
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SPEED
suffix:colon
multiline_comment|/* set smaple rate */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SPEED&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
(paren
id|state-&gt;card-&gt;ac97_status
op_amp
id|SPDIF_ON
)paren
)paren
(brace
multiline_comment|/* S/PDIF Enabled */
multiline_comment|/* RELTEK ALC650 only support 48000, need to check that */
r_if
c_cond
(paren
id|ali_valid_spdif_rate
c_func
(paren
id|codec
comma
id|val
)paren
)paren
(brace
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
id|ali_set_spdif_output
c_func
(paren
id|state
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|stop_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* I add test codec independent spdif out */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ali_set_codecspdifout_rate
c_func
(paren
id|state
comma
id|val
)paren
suffix:semicolon
singleline_comment|// I modified
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Set S/PDIF transmitter rate. */
id|i_scr
op_assign
id|inl
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_SCR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i_scr
op_amp
l_int|0x00300000
)paren
op_eq
l_int|0x00100000
)paren
(brace
id|ali_set_spdif_output
c_func
(paren
id|state
comma
id|AC97_EA_SPSA_7_8
comma
id|codec_independent_spdif_locked
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|i_scr
op_amp
l_int|0x00300000
)paren
op_eq
l_int|0x00200000
)paren
(brace
id|ali_set_spdif_output
c_func
(paren
id|state
comma
id|AC97_EA_SPSA_6_9
comma
id|codec_independent_spdif_locked
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|i_scr
op_amp
l_int|0x00300000
)paren
op_eq
l_int|0x00300000
)paren
(brace
id|ali_set_spdif_output
c_func
(paren
id|state
comma
id|AC97_EA_SPSA_10_11
comma
id|codec_independent_spdif_locked
)paren
suffix:semicolon
)brace
r_else
(brace
id|ali_set_spdif_output
c_func
(paren
id|state
comma
id|AC97_EA_SPSA_7_8
comma
id|codec_independent_spdif_locked
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|state-&gt;card-&gt;ac97_status
op_amp
id|SPDIF_ON
)paren
)paren
(brace
id|val
op_assign
id|dmabuf-&gt;rate
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|controller_independent_spdif_locked
OG
l_int|0
)paren
(brace
id|stop_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ali_set_spdifout_rate
c_func
(paren
id|state
comma
id|controller_independent_spdif_locked
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Set DAC rate */
id|ali_set_spdif_output
c_func
(paren
id|state
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ali_set_dac_rate
c_func
(paren
id|state
comma
id|val
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Set S/PDIF transmitter rate. */
id|ali_set_spdif_output
c_func
(paren
id|state
comma
id|AC97_EA_SPSA_3_4
comma
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|state-&gt;card-&gt;ac97_status
op_amp
id|SPDIF_ON
)paren
)paren
(brace
id|val
op_assign
id|dmabuf-&gt;rate
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* Not a valid rate for S/PDIF, ignore it */
id|val
op_assign
id|dmabuf-&gt;rate
suffix:semicolon
)brace
)brace
r_else
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ali_set_dac_rate
c_func
(paren
id|state
comma
id|val
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ali_set_adc_rate
c_func
(paren
id|state
comma
id|val
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;rate
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_STEREO
suffix:colon
multiline_comment|/* set stereo or mono channel */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_STEREO&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|CODEC_SPDIFOUT_RUNNING
)paren
(brace
id|stop_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|CONTROLLER_SPDIFOUT_RUNNING
)paren
(brace
id|stop_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
l_int|1
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETBLKSIZE
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|2
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|controller_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|3
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETBLKSIZE %d&bslash;n&quot;
comma
id|dmabuf-&gt;userfragsize
)paren
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;userfragsize
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETFMTS
suffix:colon
multiline_comment|/* Returns a mask of supported sample format */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETFMTS&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|AFMT_S16_LE
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFMT
suffix:colon
multiline_comment|/* Select sample format */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETFMT&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|AFMT_S16_LE
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_CHANNELS
suffix:colon
singleline_comment|// add support 4,6 channel 
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_CHANNELS&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|CODEC_SPDIFOUT_RUNNING
)paren
(brace
id|stop_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|CONTROLLER_SPDIFOUT_RUNNING
)paren
(brace
id|stop_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_return
id|put_user
c_func
(paren
id|state-&gt;card-&gt;channels
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
id|i_scr
op_assign
id|inl
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_SCR
)paren
suffix:semicolon
multiline_comment|/* Current # of channels enabled */
r_if
c_cond
(paren
id|i_scr
op_amp
l_int|0x00000100
)paren
id|ret
op_assign
l_int|4
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i_scr
op_amp
l_int|0x00000200
)paren
id|ret
op_assign
l_int|6
suffix:semicolon
r_else
id|ret
op_assign
l_int|2
suffix:semicolon
r_switch
c_cond
(paren
id|val
)paren
(brace
r_case
l_int|2
suffix:colon
multiline_comment|/* 2 channels is always supported */
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
id|outl
c_func
(paren
(paren
(paren
id|i_scr
op_amp
l_int|0xfffffcff
)paren
op_or
l_int|0x00100000
)paren
comma
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_SCR
)paren
)paren
suffix:semicolon
)brace
r_else
id|outl
c_func
(paren
(paren
id|i_scr
op_amp
l_int|0xfffffcff
)paren
comma
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_SCR
)paren
)paren
suffix:semicolon
multiline_comment|/* Do we need to change mixer settings????  */
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* Supported on some chipsets, better check first */
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
id|outl
c_func
(paren
(paren
(paren
id|i_scr
op_amp
l_int|0xfffffcff
)paren
op_or
l_int|0x00000100
op_or
l_int|0x00200000
)paren
comma
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_SCR
)paren
)paren
suffix:semicolon
)brace
r_else
id|outl
c_func
(paren
(paren
(paren
id|i_scr
op_amp
l_int|0xfffffcff
)paren
op_or
l_int|0x00000100
)paren
comma
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_SCR
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/* Supported on some chipsets, better check first */
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
id|outl
c_func
(paren
(paren
(paren
id|i_scr
op_amp
l_int|0xfffffcff
)paren
op_or
l_int|0x00000200
op_or
l_int|0x00008000
op_or
l_int|0x00300000
)paren
comma
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_SCR
)paren
)paren
suffix:semicolon
)brace
r_else
id|outl
c_func
(paren
(paren
(paren
id|i_scr
op_amp
l_int|0xfffffcff
)paren
op_or
l_int|0x00000200
op_or
l_int|0x00008000
)paren
comma
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_SCR
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* nothing else is ever supported by the chipset */
id|val
op_assign
id|ret
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_POST
suffix:colon
multiline_comment|/* the user has sent all data and is notifying us */
multiline_comment|/* we update the swptr to the end of the last sg segment then return */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_POST&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_or
(paren
id|dmabuf-&gt;enable
op_ne
id|CODEC_SPDIFOUT_RUNNING
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|controller_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_or
(paren
id|dmabuf-&gt;enable
op_ne
id|CONTROLLER_SPDIFOUT_RUNNING
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_or
(paren
id|dmabuf-&gt;enable
op_ne
id|DAC_RUNNING
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|dmabuf-&gt;swptr
op_mod
id|dmabuf-&gt;fragsize
)paren
op_ne
l_int|0
)paren
(brace
id|val
op_assign
id|dmabuf-&gt;fragsize
op_minus
(paren
id|dmabuf-&gt;swptr
op_mod
id|dmabuf-&gt;fragsize
)paren
suffix:semicolon
id|dmabuf-&gt;swptr
op_add_assign
id|val
suffix:semicolon
id|dmabuf-&gt;count
op_add_assign
id|val
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SUBDIVIDE
suffix:colon
r_if
c_cond
(paren
id|dmabuf-&gt;subdivision
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
l_int|1
op_logical_and
id|val
op_ne
l_int|2
op_logical_and
id|val
op_ne
l_int|4
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SUBDIVIDE %d&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
macro_line|#endif
id|dmabuf-&gt;subdivision
op_assign
id|val
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFRAGMENT
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|dmabuf-&gt;ossfragsize
op_assign
l_int|1
op_lshift
(paren
id|val
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|dmabuf-&gt;ossmaxfrags
op_assign
(paren
id|val
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ossfragsize
op_logical_or
op_logical_neg
id|dmabuf-&gt;ossmaxfrags
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Bound the frag size into our allowed range of 256 - 4096&n;&t;&t; */
r_if
c_cond
(paren
id|dmabuf-&gt;ossfragsize
OL
l_int|256
)paren
id|dmabuf-&gt;ossfragsize
op_assign
l_int|256
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dmabuf-&gt;ossfragsize
OG
l_int|4096
)paren
id|dmabuf-&gt;ossfragsize
op_assign
l_int|4096
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The numfrags could be something reasonable, or it could&n;&t;&t; * be 0xffff meaning &quot;Give me as much as possible&quot;.  So,&n;&t;&t; * we check the numfrags * fragsize doesn&squot;t exceed our&n;&t;&t; * 64k buffer limit, nor is it less than our 8k minimum.&n;&t;&t; * If it fails either one of these checks, then adjust the&n;&t;&t; * number of fragments, not the size of them.  It&squot;s OK if&n;&t;&t; * our number of fragments doesn&squot;t equal 32 or anything&n;&t;&t; * like our hardware based number now since we are using&n;&t;&t; * a different frag count for the hardware.  Before we get&n;&t;&t; * into this though, bound the maxfrags to avoid overflow&n;&t;&t; * issues.  A reasonable bound would be 64k / 256 since our&n;&t;&t; * maximum buffer size is 64k and our minimum frag size is&n;&t;&t; * 256.  On the other end, our minimum buffer size is 8k and&n;&t;&t; * our maximum frag size is 4k, so the lower bound should&n;&t;&t; * be 2.&n;&t;&t; */
r_if
c_cond
(paren
id|dmabuf-&gt;ossmaxfrags
OG
l_int|256
)paren
id|dmabuf-&gt;ossmaxfrags
op_assign
l_int|256
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dmabuf-&gt;ossmaxfrags
OL
l_int|2
)paren
id|dmabuf-&gt;ossmaxfrags
op_assign
l_int|2
suffix:semicolon
id|val
op_assign
id|dmabuf-&gt;ossfragsize
op_star
id|dmabuf-&gt;ossmaxfrags
suffix:semicolon
r_while
c_loop
(paren
id|val
OL
l_int|8192
)paren
(brace
id|val
op_lshift_assign
l_int|1
suffix:semicolon
id|dmabuf-&gt;ossmaxfrags
op_lshift_assign
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|val
OG
l_int|65536
)paren
(brace
id|val
op_rshift_assign
l_int|1
suffix:semicolon
id|dmabuf-&gt;ossmaxfrags
op_rshift_assign
l_int|1
suffix:semicolon
)brace
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETFRAGMENT 0x%x, %d, %d&bslash;n&quot;
comma
id|val
comma
id|dmabuf-&gt;ossfragsize
comma
id|dmabuf-&gt;ossmaxfrags
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOSPACE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|2
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|val
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|controller_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|3
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|val
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|val
suffix:semicolon
)brace
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ali_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|abinfo.fragsize
op_assign
id|dmabuf-&gt;userfragsize
suffix:semicolon
id|abinfo.fragstotal
op_assign
id|dmabuf-&gt;userfrags
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
id|abinfo.bytes
op_assign
id|dmabuf-&gt;dmasize
suffix:semicolon
r_else
id|abinfo.bytes
op_assign
id|ali_get_free_write_space
c_func
(paren
id|state
)paren
suffix:semicolon
id|abinfo.fragments
op_assign
id|abinfo.bytes
op_div
id|dmabuf-&gt;userfragsize
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#if defined(DEBUG) || defined(DEBUG_MMAP)
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETOSPACE %d, %d, %d, %d&bslash;n&quot;
comma
id|abinfo.bytes
comma
id|abinfo.fragsize
comma
id|abinfo.fragments
comma
id|abinfo.fragstotal
)paren
suffix:semicolon
macro_line|#endif
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|abinfo
comma
r_sizeof
(paren
id|abinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOPTR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|2
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|val
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|controller_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|3
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|val
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|val
suffix:semicolon
)brace
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|val
op_assign
id|ali_get_free_write_space
c_func
(paren
id|state
)paren
suffix:semicolon
id|cinfo.bytes
op_assign
id|dmabuf-&gt;total_bytes
suffix:semicolon
id|cinfo.ptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
id|cinfo.blocks
op_assign
id|val
op_div
id|dmabuf-&gt;userfragsize
suffix:semicolon
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
op_logical_and
(paren
id|dmabuf-&gt;trigger
op_amp
id|SPDIF_ENABLE_OUTPUT
)paren
)paren
(brace
id|dmabuf-&gt;count
op_add_assign
id|val
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
(paren
id|dmabuf-&gt;swptr
op_plus
id|val
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|__ali_update_lvi
c_func
(paren
id|state
comma
l_int|2
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|controller_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
op_logical_and
(paren
id|dmabuf-&gt;trigger
op_amp
id|SPDIF_ENABLE_OUTPUT
)paren
)paren
(brace
id|dmabuf-&gt;count
op_add_assign
id|val
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
(paren
id|dmabuf-&gt;swptr
op_plus
id|val
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|__ali_update_lvi
c_func
(paren
id|state
comma
l_int|3
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
op_logical_and
(paren
id|dmabuf-&gt;trigger
op_amp
id|PCM_ENABLE_OUTPUT
)paren
)paren
(brace
id|dmabuf-&gt;count
op_add_assign
id|val
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
(paren
id|dmabuf-&gt;swptr
op_plus
id|val
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|__ali_update_lvi
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#if defined(DEBUG) || defined(DEBUG_MMAP)
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETOPTR %d, %d, %d, %d&bslash;n&quot;
comma
id|cinfo.bytes
comma
id|cinfo.blocks
comma
id|cinfo.ptr
comma
id|dmabuf-&gt;count
)paren
suffix:semicolon
macro_line|#endif
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|cinfo
comma
r_sizeof
(paren
id|cinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETISPACE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|abinfo.bytes
op_assign
id|ali_get_available_read_data
c_func
(paren
id|state
)paren
suffix:semicolon
id|abinfo.fragsize
op_assign
id|dmabuf-&gt;userfragsize
suffix:semicolon
id|abinfo.fragstotal
op_assign
id|dmabuf-&gt;userfrags
suffix:semicolon
id|abinfo.fragments
op_assign
id|abinfo.bytes
op_div
id|dmabuf-&gt;userfragsize
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#if defined(DEBUG) || defined(DEBUG_MMAP)
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETISPACE %d, %d, %d, %d&bslash;n&quot;
comma
id|abinfo.bytes
comma
id|abinfo.fragsize
comma
id|abinfo.fragments
comma
id|abinfo.fragstotal
)paren
suffix:semicolon
macro_line|#endif
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|abinfo
comma
r_sizeof
(paren
id|abinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETIPTR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|val
op_assign
id|ali_get_available_read_data
c_func
(paren
id|state
)paren
suffix:semicolon
id|cinfo.bytes
op_assign
id|dmabuf-&gt;total_bytes
suffix:semicolon
id|cinfo.blocks
op_assign
id|val
op_div
id|dmabuf-&gt;userfragsize
suffix:semicolon
id|cinfo.ptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
op_logical_and
(paren
id|dmabuf-&gt;trigger
op_amp
id|PCM_ENABLE_INPUT
)paren
)paren
(brace
id|dmabuf-&gt;count
op_sub_assign
id|val
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
(paren
id|dmabuf-&gt;swptr
op_plus
id|val
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|__ali_update_lvi
c_func
(paren
id|state
comma
l_int|1
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#if defined(DEBUG) || defined(DEBUG_MMAP)
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETIPTR %d, %d, %d, %d&bslash;n&quot;
comma
id|cinfo.bytes
comma
id|cinfo.blocks
comma
id|cinfo.ptr
comma
id|dmabuf-&gt;count
)paren
suffix:semicolon
macro_line|#endif
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|cinfo
comma
r_sizeof
(paren
id|cinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_NONBLOCK
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_NONBLOCK&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|file-&gt;f_flags
op_or_assign
id|O_NONBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETCAPS
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETCAPS&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|DSP_CAP_REALTIME
op_or
id|DSP_CAP_TRIGGER
op_or
id|DSP_CAP_MMAP
op_or
id|DSP_CAP_BIND
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETTRIGGER
suffix:colon
id|val
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETTRIGGER 0x%x&bslash;n&quot;
comma
id|dmabuf-&gt;trigger
)paren
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;trigger
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETTRIGGER
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
macro_line|#if defined(DEBUG) || defined(DEBUG_MMAP)
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETTRIGGER 0x%x&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|val
op_amp
id|PCM_ENABLE_INPUT
)paren
op_logical_and
id|dmabuf-&gt;enable
op_eq
id|ADC_RUNNING
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|val
op_amp
id|PCM_ENABLE_OUTPUT
)paren
op_logical_and
id|dmabuf-&gt;enable
op_eq
id|DAC_RUNNING
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|val
op_amp
id|SPDIF_ENABLE_OUTPUT
)paren
op_logical_and
id|dmabuf-&gt;enable
op_eq
id|CODEC_SPDIFOUT_RUNNING
)paren
(brace
id|stop_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|val
op_amp
id|SPDIF_ENABLE_OUTPUT
)paren
op_logical_and
id|dmabuf-&gt;enable
op_eq
id|CONTROLLER_SPDIFOUT_RUNNING
)paren
(brace
id|stop_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|dmabuf-&gt;trigger
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|val
op_amp
id|PCM_ENABLE_OUTPUT
op_logical_and
op_logical_neg
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;write_channel
)paren
(brace
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;write_channel
op_assign
id|state-&gt;card
op_member_access_from_pointer
id|alloc_pcm_channel
c_func
(paren
id|state-&gt;card
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;write_channel
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ali_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;count
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|ali_get_free_write_space
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
(paren
id|dmabuf-&gt;swptr
op_plus
id|dmabuf-&gt;count
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|__ali_update_lvi
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
id|start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|val
op_amp
id|SPDIF_ENABLE_OUTPUT
op_logical_and
op_logical_neg
(paren
id|dmabuf-&gt;enable
op_amp
id|CODEC_SPDIFOUT_RUNNING
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;codec_spdifout_channel
)paren
(brace
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;codec_spdifout_channel
op_assign
id|state-&gt;card
op_member_access_from_pointer
id|alloc_codec_spdifout_channel
c_func
(paren
id|state-&gt;card
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;codec_spdifout_channel
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|2
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ali_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;count
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|ali_get_free_write_space
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
(paren
id|dmabuf-&gt;swptr
op_plus
id|dmabuf-&gt;count
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|__ali_update_lvi
c_func
(paren
id|state
comma
l_int|2
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
id|start_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|val
op_amp
id|SPDIF_ENABLE_OUTPUT
op_logical_and
op_logical_neg
(paren
id|dmabuf-&gt;enable
op_amp
id|CONTROLLER_SPDIFOUT_RUNNING
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;controller_spdifout_channel
)paren
(brace
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;controller_spdifout_channel
op_assign
id|state-&gt;card
op_member_access_from_pointer
id|alloc_controller_spdifout_channel
c_func
(paren
id|state-&gt;card
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;controller_spdifout_channel
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|3
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ali_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;count
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|ali_get_free_write_space
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
(paren
id|dmabuf-&gt;swptr
op_plus
id|dmabuf-&gt;count
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|__ali_update_lvi
c_func
(paren
id|state
comma
l_int|3
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
id|start_spdifout
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|val
op_amp
id|PCM_ENABLE_INPUT
op_logical_and
op_logical_neg
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;read_channel
)paren
(brace
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;read_channel
op_assign
id|state-&gt;card
op_member_access_from_pointer
id|alloc_rec_pcm_channel
c_func
(paren
id|state-&gt;card
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;read_channel
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ali_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
id|dmabuf-&gt;count
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|ali_update_lvi
c_func
(paren
id|state
comma
l_int|1
)paren
suffix:semicolon
id|start_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SETDUPLEX
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETDUPLEX&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|SNDCTL_DSP_GETODELAY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ali_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|val
op_assign
id|dmabuf-&gt;count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETODELAY %d&bslash;n&quot;
comma
id|dmabuf-&gt;count
)paren
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_RATE
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SOUND_PCM_READ_RATE %d&bslash;n&quot;
comma
id|dmabuf-&gt;rate
)paren
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;rate
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_CHANNELS
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SOUND_PCM_READ_CHANNELS&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
l_int|2
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_BITS
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SOUND_PCM_READ_BITS&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|AFMT_S16_LE
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETSPDIF
suffix:colon
multiline_comment|/* Set S/PDIF Control register */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETSPDIF&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Check to make sure the codec supports S/PDIF transmitter */
r_if
c_cond
(paren
(paren
id|state-&gt;card-&gt;ac97_features
op_amp
l_int|4
)paren
)paren
(brace
multiline_comment|/* mask out the transmitter speed bits so the user can&squot;t set them */
id|val
op_and_assign
op_complement
l_int|0x3000
suffix:semicolon
multiline_comment|/* Add the current transmitter speed bits to the passed value */
id|ret
op_assign
id|ali_ac97_get
c_func
(paren
id|codec
comma
id|AC97_SPDIF_CONTROL
)paren
suffix:semicolon
id|val
op_or_assign
(paren
id|ret
op_amp
l_int|0x3000
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_SPDIF_CONTROL
comma
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ali_ac97_get
c_func
(paren
id|codec
comma
id|AC97_SPDIF_CONTROL
)paren
op_ne
id|val
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ali_audio: Unable to set S/PDIF configuration to 0x%04x.&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ali_audio: S/PDIF transmitter not avalible.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETSPDIF
suffix:colon
multiline_comment|/* Get S/PDIF Control register */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETSPDIF&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Check to make sure the codec supports S/PDIF transmitter */
r_if
c_cond
(paren
op_logical_neg
(paren
id|state-&gt;card-&gt;ac97_features
op_amp
l_int|4
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ali_audio: S/PDIF transmitter not avalible.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|val
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|val
op_assign
id|ali_ac97_get
c_func
(paren
id|codec
comma
id|AC97_SPDIF_CONTROL
)paren
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
singleline_comment|//end add support spdif out
singleline_comment|//add support 4,6 channel
r_case
id|SNDCTL_DSP_GETCHANNELMASK
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETCHANNELMASK&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Based on AC&squot;97 DAC support, not ICH hardware */
id|val
op_assign
id|DSP_BIND_FRONT
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;card-&gt;ac97_features
op_amp
l_int|0x0004
)paren
id|val
op_or_assign
id|DSP_BIND_SPDIF
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;card-&gt;ac97_features
op_amp
l_int|0x0080
)paren
id|val
op_or_assign
id|DSP_BIND_SURR
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;card-&gt;ac97_features
op_amp
l_int|0x0140
)paren
id|val
op_or_assign
id|DSP_BIND_CENTER_LFE
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_BIND_CHANNEL
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_BIND_CHANNEL&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_eq
id|DSP_BIND_QUERY
)paren
(brace
id|val
op_assign
id|DSP_BIND_FRONT
suffix:semicolon
multiline_comment|/* Always report this as being enabled */
r_if
c_cond
(paren
id|state-&gt;card-&gt;ac97_status
op_amp
id|SPDIF_ON
)paren
id|val
op_or_assign
id|DSP_BIND_SPDIF
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|state-&gt;card-&gt;ac97_status
op_amp
id|SURR_ON
)paren
id|val
op_or_assign
id|DSP_BIND_SURR
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;card
op_member_access_from_pointer
id|ac97_status
op_amp
id|CENTER_LFE_ON
)paren
id|val
op_or_assign
id|DSP_BIND_CENTER_LFE
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Not a query, set it */
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_eq
id|DAC_RUNNING
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|val
op_amp
id|DSP_BIND_SPDIF
)paren
(brace
multiline_comment|/* Turn on SPDIF */
multiline_comment|/*  Ok, this should probably define what slots&n;&t;&t;&t;&t; *  to use. For now, we&squot;ll only set it to the&n;&t;&t;&t;&t; *  defaults:&n;&t;&t;&t;&t; * &n;&t;&t;&t;&t; *   non multichannel codec maps to slots 3&amp;4&n;&t;&t;&t;&t; *   2 channel codec maps to slots 7&amp;8&n;&t;&t;&t;&t; *   4 channel codec maps to slots 6&amp;9&n;&t;&t;&t;&t; *   6 channel codec maps to slots 10&amp;11&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; *  there should be some way for the app to&n;&t;&t;&t;&t; *  select the slot assignment.&n;&t;&t;&t;&t; */
id|i_scr
op_assign
id|inl
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_SCR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|i_scr
op_amp
l_int|0x00300000
)paren
op_eq
l_int|0x00100000
)paren
(brace
id|ali_set_spdif_output
c_func
(paren
id|state
comma
id|AC97_EA_SPSA_7_8
comma
id|codec_independent_spdif_locked
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|i_scr
op_amp
l_int|0x00300000
)paren
op_eq
l_int|0x00200000
)paren
(brace
id|ali_set_spdif_output
c_func
(paren
id|state
comma
id|AC97_EA_SPSA_6_9
comma
id|codec_independent_spdif_locked
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|i_scr
op_amp
l_int|0x00300000
)paren
op_eq
l_int|0x00300000
)paren
(brace
id|ali_set_spdif_output
c_func
(paren
id|state
comma
id|AC97_EA_SPSA_10_11
comma
id|codec_independent_spdif_locked
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* codec spdif out (pcm out share ) */
id|ali_set_spdif_output
c_func
(paren
id|state
comma
id|AC97_EA_SPSA_3_4
comma
id|dmabuf-&gt;rate
)paren
suffix:semicolon
singleline_comment|//I do not modify
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|state-&gt;card-&gt;ac97_status
op_amp
id|SPDIF_ON
)paren
)paren
id|val
op_and_assign
op_complement
id|DSP_BIND_SPDIF
suffix:semicolon
)brace
r_else
(brace
r_int
id|mask
suffix:semicolon
r_int
id|channels
suffix:semicolon
multiline_comment|/* Turn off S/PDIF if it was on */
r_if
c_cond
(paren
id|state-&gt;card-&gt;ac97_status
op_amp
id|SPDIF_ON
)paren
id|ali_set_spdif_output
c_func
(paren
id|state
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|mask
op_assign
id|val
op_amp
(paren
id|DSP_BIND_FRONT
op_or
id|DSP_BIND_SURR
op_or
id|DSP_BIND_CENTER_LFE
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mask
)paren
(brace
r_case
id|DSP_BIND_FRONT
suffix:colon
id|channels
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DSP_BIND_FRONT
op_or
id|DSP_BIND_SURR
suffix:colon
id|channels
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DSP_BIND_FRONT
op_or
id|DSP_BIND_SURR
op_or
id|DSP_BIND_CENTER_LFE
suffix:colon
id|channels
op_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|val
op_assign
id|DSP_BIND_FRONT
suffix:semicolon
id|channels
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ali_set_dac_channels
c_func
(paren
id|state
comma
id|channels
)paren
suffix:semicolon
multiline_comment|/* check that they really got turned on */
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;card-&gt;ac97_status
op_amp
id|SURR_ON
)paren
id|val
op_and_assign
op_complement
id|DSP_BIND_SURR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;card
op_member_access_from_pointer
id|ac97_status
op_amp
id|CENTER_LFE_ON
)paren
id|val
op_and_assign
op_complement
id|DSP_BIND_CENTER_LFE
suffix:semicolon
)brace
)brace
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_MAPINBUF
suffix:colon
r_case
id|SNDCTL_DSP_MAPOUTBUF
suffix:colon
r_case
id|SNDCTL_DSP_SETSYNCRO
suffix:colon
r_case
id|SOUND_PCM_WRITE_FILTER
suffix:colon
r_case
id|SOUND_PCM_READ_FILTER
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|ali_open
r_static
r_int
id|ali_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_struct
id|ali_card
op_star
id|card
op_assign
id|devs
suffix:semicolon
r_struct
id|ali_state
op_star
id|state
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|i_scr
suffix:semicolon
multiline_comment|/* find an available virtual channel (instance of /dev/dsp) */
r_while
c_loop
(paren
id|card
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we are initializing and then fail, card could go&n;&t;&t; * away unuexpectedly while we are in the for() loop.&n;&t;&t; * So, check for card on each iteration before we check&n;&t;&t; * for card-&gt;initializing to avoid a possible oops.&n;&t;&t; * This usually only matters for times when the driver is&n;&t;&t; * autoloaded by kmod.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|50
op_logical_and
id|card
op_logical_and
id|card-&gt;initializing
suffix:semicolon
id|i
op_increment
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_HW_CH
op_logical_and
id|card
op_logical_and
op_logical_neg
id|card-&gt;initializing
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;states
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
id|state
op_assign
id|card-&gt;states
(braket
id|i
)braket
op_assign
(paren
r_struct
id|ali_state
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ali_state
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|state
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ali_state
)paren
)paren
suffix:semicolon
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_goto
id|found_virt
suffix:semicolon
)brace
)brace
id|card
op_assign
id|card-&gt;next
suffix:semicolon
)brace
multiline_comment|/* no more virtual channel avaiable */
r_if
c_cond
(paren
op_logical_neg
id|state
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|found_virt
suffix:colon
multiline_comment|/* initialize the virtual channel */
id|state-&gt;virt
op_assign
id|i
suffix:semicolon
id|state-&gt;card
op_assign
id|card
suffix:semicolon
id|state-&gt;magic
op_assign
id|ALI5455_STATE_MAGIC
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
id|state
suffix:semicolon
id|dmabuf-&gt;trigger
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* allocate hardware channels */
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
(paren
id|dmabuf-&gt;read_channel
op_assign
id|card
op_member_access_from_pointer
id|alloc_rec_pcm_channel
c_func
(paren
id|card
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|card-&gt;states
(braket
id|i
)braket
)paren
suffix:semicolon
id|card-&gt;states
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|dmabuf-&gt;trigger
op_or_assign
id|PCM_ENABLE_INPUT
suffix:semicolon
id|ali_set_adc_rate
c_func
(paren
id|state
comma
l_int|8000
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|dmabuf-&gt;codec_spdifout_channel
op_assign
id|card
op_member_access_from_pointer
id|alloc_codec_spdifout_channel
c_func
(paren
id|card
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|card-&gt;states
(braket
id|i
)braket
)paren
suffix:semicolon
id|card-&gt;states
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|dmabuf-&gt;trigger
op_or_assign
id|SPDIF_ENABLE_OUTPUT
suffix:semicolon
id|ali_set_codecspdifout_rate
c_func
(paren
id|state
comma
id|codec_independent_spdif_locked
)paren
suffix:semicolon
singleline_comment|//It must add
id|i_scr
op_assign
id|inl
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|ALI_SCR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i_scr
op_amp
l_int|0x00300000
)paren
op_eq
l_int|0x00100000
)paren
(brace
id|ali_set_spdif_output
c_func
(paren
id|state
comma
id|AC97_EA_SPSA_7_8
comma
id|codec_independent_spdif_locked
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|i_scr
op_amp
l_int|0x00300000
)paren
op_eq
l_int|0x00200000
)paren
(brace
id|ali_set_spdif_output
c_func
(paren
id|state
comma
id|AC97_EA_SPSA_6_9
comma
id|codec_independent_spdif_locked
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|i_scr
op_amp
l_int|0x00300000
)paren
op_eq
l_int|0x00300000
)paren
(brace
id|ali_set_spdif_output
c_func
(paren
id|state
comma
id|AC97_EA_SPSA_10_11
comma
id|codec_independent_spdif_locked
)paren
suffix:semicolon
)brace
r_else
(brace
id|ali_set_spdif_output
c_func
(paren
id|state
comma
id|AC97_EA_SPSA_7_8
comma
id|codec_independent_spdif_locked
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|controller_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|dmabuf-&gt;controller_spdifout_channel
op_assign
id|card
op_member_access_from_pointer
id|alloc_controller_spdifout_channel
c_func
(paren
id|card
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|card-&gt;states
(braket
id|i
)braket
)paren
suffix:semicolon
id|card-&gt;states
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|dmabuf-&gt;trigger
op_or_assign
id|SPDIF_ENABLE_OUTPUT
suffix:semicolon
id|ali_set_spdifout_rate
c_func
(paren
id|state
comma
id|controller_independent_spdif_locked
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|dmabuf-&gt;write_channel
op_assign
id|card
op_member_access_from_pointer
id|alloc_pcm_channel
c_func
(paren
id|card
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|card-&gt;states
(braket
id|i
)braket
)paren
suffix:semicolon
id|card-&gt;states
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* Initialize to 8kHz?  What if we don&squot;t support 8kHz? */
multiline_comment|/*  Let&squot;s change this to check for S/PDIF stuff */
id|dmabuf-&gt;trigger
op_or_assign
id|PCM_ENABLE_OUTPUT
suffix:semicolon
r_if
c_cond
(paren
id|codec_pcmout_share_spdif_locked
)paren
(brace
id|ali_set_dac_rate
c_func
(paren
id|state
comma
id|codec_pcmout_share_spdif_locked
)paren
suffix:semicolon
id|ali_set_spdif_output
c_func
(paren
id|state
comma
id|AC97_EA_SPSA_3_4
comma
id|codec_pcmout_share_spdif_locked
)paren
suffix:semicolon
)brace
r_else
(brace
id|ali_set_dac_rate
c_func
(paren
id|state
comma
l_int|8000
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* set default sample format. According to OSS Programmer&squot;s Guide  /dev/dsp&n;&t;   should be default to unsigned 8-bits, mono, with sample rate 8kHz and&n;&t;   /dev/dspW will accept 16-bits sample, but we don&squot;t support those so we&n;&t;   set it immediately to stereo and 16bit, which is all we do support */
id|dmabuf-&gt;fmt
op_or_assign
id|ALI5455_FMT_16BIT
op_or
id|ALI5455_FMT_STEREO
suffix:semicolon
id|dmabuf-&gt;ossfragsize
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;ossmaxfrags
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;subdivision
op_assign
l_int|0
suffix:semicolon
id|state-&gt;open_mode
op_or_assign
id|file-&gt;f_mode
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
suffix:semicolon
id|outl
c_func
(paren
l_int|0x00000000
comma
id|card-&gt;iobase
op_plus
id|ALI_INTERRUPTCR
)paren
suffix:semicolon
id|outl
c_func
(paren
l_int|0x00000000
comma
id|card-&gt;iobase
op_plus
id|ALI_INTERRUPTSR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ali_release
r_static
r_int
id|ali_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|ali_state
op_star
id|state
op_assign
(paren
r_struct
id|ali_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|ali_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* stop DMA state machine and free DMA buffers/channels */
r_if
c_cond
(paren
id|dmabuf-&gt;trigger
op_amp
id|PCM_ENABLE_OUTPUT
)paren
id|drain_dac
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;trigger
op_amp
id|SPDIF_ENABLE_OUTPUT
)paren
id|drain_spdifout
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;trigger
op_amp
id|PCM_ENABLE_INPUT
)paren
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|dealloc_dmabuf
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
id|state-&gt;card
op_member_access_from_pointer
id|free_pcm_channel
c_func
(paren
id|state-&gt;card
comma
id|dmabuf-&gt;codec_spdifout_channel-&gt;num
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|controller_independent_spdif_locked
OG
l_int|0
)paren
id|state-&gt;card
op_member_access_from_pointer
id|free_pcm_channel
c_func
(paren
id|state-&gt;card
comma
id|dmabuf-&gt;controller_spdifout_channel-&gt;num
)paren
suffix:semicolon
r_else
id|state-&gt;card
op_member_access_from_pointer
id|free_pcm_channel
c_func
(paren
id|state-&gt;card
comma
id|dmabuf-&gt;write_channel-&gt;num
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
id|state-&gt;card
op_member_access_from_pointer
id|free_pcm_channel
c_func
(paren
id|state-&gt;card
comma
id|dmabuf-&gt;read_channel-&gt;num
)paren
suffix:semicolon
id|state-&gt;card-&gt;states
(braket
id|state-&gt;virt
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|state
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ali_audio_fops
r_static
multiline_comment|/*const */
r_struct
id|file_operations
id|ali_audio_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|llseek
op_assign
id|no_llseek
comma
dot
id|read
op_assign
id|ali_read
comma
dot
id|write
op_assign
id|ali_write
comma
dot
id|poll
op_assign
id|ali_poll
comma
dot
id|ioctl
op_assign
id|ali_ioctl
comma
dot
id|mmap
op_assign
id|ali_mmap
comma
dot
id|open
op_assign
id|ali_open
comma
dot
id|release
op_assign
id|ali_release
comma
)brace
suffix:semicolon
multiline_comment|/* Read AC97 codec registers */
DECL|function|ali_ac97_get
r_static
id|u16
id|ali_ac97_get
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
)paren
(brace
r_struct
id|ali_card
op_star
id|card
op_assign
id|dev-&gt;private_data
suffix:semicolon
r_int
id|count1
op_assign
l_int|100
suffix:semicolon
r_char
id|val
suffix:semicolon
r_int
r_int
r_int
id|data
op_assign
l_int|0
comma
id|count
comma
id|addr1
comma
id|addr2
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|card-&gt;ac97_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count1
op_decrement
op_logical_and
(paren
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|ALI_CAS
)paren
op_amp
l_int|0x80000000
)paren
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|addr1
op_assign
id|reg
suffix:semicolon
id|reg
op_or_assign
l_int|0x0080
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|0x7f
suffix:semicolon
id|count
op_increment
)paren
(brace
id|val
op_assign
id|inb
c_func
(paren
id|card-&gt;iobase
op_plus
id|ALI_CSPSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_amp
l_int|0x08
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_eq
l_int|0x7f
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|card-&gt;ac97_lock
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|outw
c_func
(paren
id|reg
comma
(paren
id|card-&gt;iobase
op_plus
id|ALI_CPR
)paren
op_plus
l_int|2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|0x7f
suffix:semicolon
id|count
op_increment
)paren
(brace
id|val
op_assign
id|inb
c_func
(paren
id|card-&gt;iobase
op_plus
id|ALI_CSPSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_amp
l_int|0x02
)paren
(brace
id|data
op_assign
id|inw
c_func
(paren
id|card-&gt;iobase
op_plus
id|ALI_SPR
)paren
suffix:semicolon
id|addr2
op_assign
id|inw
c_func
(paren
(paren
id|card-&gt;iobase
op_plus
id|ALI_SPR
)paren
op_plus
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|card-&gt;ac97_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0x7f
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|addr2
op_ne
id|addr1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
(paren
(paren
id|u16
)paren
id|data
)paren
suffix:semicolon
)brace
multiline_comment|/* write ac97 codec register   */
DECL|function|ali_ac97_set
r_static
r_void
id|ali_ac97_set
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
comma
id|u16
id|data
)paren
(brace
r_struct
id|ali_card
op_star
id|card
op_assign
id|dev-&gt;private_data
suffix:semicolon
r_int
id|count1
op_assign
l_int|100
suffix:semicolon
r_char
id|val
suffix:semicolon
r_int
r_int
r_int
id|count
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|card-&gt;ac97_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count1
op_decrement
op_logical_and
(paren
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|ALI_CAS
)paren
op_amp
l_int|0x80000000
)paren
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|0x7f
suffix:semicolon
id|count
op_increment
)paren
(brace
id|val
op_assign
id|inb
c_func
(paren
id|card-&gt;iobase
op_plus
id|ALI_CSPSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_amp
l_int|0x08
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_eq
l_int|0x7f
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ali_ac97_set: AC97 codec register access timed out. &bslash;n&quot;
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|card-&gt;ac97_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|outw
c_func
(paren
id|data
comma
(paren
id|card-&gt;iobase
op_plus
id|ALI_CPR
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|reg
comma
(paren
id|card-&gt;iobase
op_plus
id|ALI_CPR
)paren
op_plus
l_int|2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|0x7f
suffix:semicolon
id|count
op_increment
)paren
(brace
id|val
op_assign
id|inb
c_func
(paren
id|card-&gt;iobase
op_plus
id|ALI_CSPSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_amp
l_int|0x01
)paren
r_break
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|card-&gt;ac97_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0x7f
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ali_ac97_set: AC97 codec register access timed out. &bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* OSS /dev/mixer file operation methods */
DECL|function|ali_open_mixdev
r_static
r_int
id|ali_open_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|minor
op_assign
id|iminor
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|ali_card
op_star
id|card
op_assign
id|devs
suffix:semicolon
r_for
c_loop
(paren
id|card
op_assign
id|devs
suffix:semicolon
id|card
op_ne
l_int|NULL
suffix:semicolon
id|card
op_assign
id|card-&gt;next
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we are initializing and then fail, card could go&n;&t;&t; * away unuexpectedly while we are in the for() loop.&n;&t;&t; * So, check for card on each iteration before we check&n;&t;&t; * for card-&gt;initializing to avoid a possible oops.&n;&t;&t; * This usually only matters for times when the driver is&n;&t;&t; * autoloaded by kmod.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|50
op_logical_and
id|card
op_logical_and
id|card-&gt;initializing
suffix:semicolon
id|i
op_increment
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_AC97
op_logical_and
id|card
op_logical_and
op_logical_neg
id|card-&gt;initializing
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_ne
l_int|NULL
op_logical_and
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_member_access_from_pointer
id|dev_mixer
op_eq
id|minor
)paren
(brace
id|file-&gt;private_data
op_assign
id|card-&gt;ac97_codec
(braket
id|i
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|ali_ioctl_mixdev
r_static
r_int
id|ali_ioctl_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|ac97_codec
op_star
id|codec
op_assign
(paren
r_struct
id|ac97_codec
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_return
id|codec
op_member_access_from_pointer
id|mixer_ioctl
c_func
(paren
id|codec
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
DECL|variable|ali_mixer_fops
r_static
multiline_comment|/*const */
r_struct
id|file_operations
id|ali_mixer_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|llseek
op_assign
id|no_llseek
comma
dot
id|ioctl
op_assign
id|ali_ioctl_mixdev
comma
dot
id|open
op_assign
id|ali_open_mixdev
comma
)brace
suffix:semicolon
multiline_comment|/* AC97 codec initialisation.  These small functions exist so we don&squot;t&n;   duplicate code between module init and apm resume */
DECL|function|ali_ac97_exists
r_static
r_inline
r_int
id|ali_ac97_exists
c_func
(paren
r_struct
id|ali_card
op_star
id|card
comma
r_int
id|ac97_number
)paren
(brace
r_int
r_int
id|i
op_assign
l_int|1
suffix:semicolon
id|u32
id|reg
op_assign
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|ALI_RTSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ac97_number
)paren
(brace
r_while
c_loop
(paren
id|i
OL
l_int|100
)paren
(brace
id|reg
op_assign
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|ALI_RTSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_amp
l_int|0x40
)paren
(brace
r_break
suffix:semicolon
)brace
r_else
(brace
id|outl
c_func
(paren
id|reg
op_or
l_int|0x00000040
comma
id|card-&gt;iobase
op_plus
l_int|0x34
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|i
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
r_while
c_loop
(paren
id|i
OL
l_int|100
)paren
(brace
id|reg
op_assign
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|ALI_RTSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_amp
l_int|0x80
)paren
(brace
r_break
suffix:semicolon
)brace
r_else
(brace
id|outl
c_func
(paren
id|reg
op_or
l_int|0x00000080
comma
id|card-&gt;iobase
op_plus
l_int|0x34
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|i
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ac97_number
)paren
r_return
id|reg
op_amp
l_int|0x40
suffix:semicolon
r_else
r_return
id|reg
op_amp
l_int|0x80
suffix:semicolon
)brace
DECL|function|ali_ac97_enable_variable_rate
r_static
r_inline
r_int
id|ali_ac97_enable_variable_rate
c_func
(paren
r_struct
id|ac97_codec
op_star
id|codec
)paren
(brace
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
comma
l_int|9
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
comma
id|ali_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
)paren
op_or
l_int|0xE800
)paren
suffix:semicolon
r_return
(paren
id|ali_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
)paren
op_amp
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|ali_ac97_probe_and_powerup
r_static
r_int
id|ali_ac97_probe_and_powerup
c_func
(paren
r_struct
id|ali_card
op_star
id|card
comma
r_struct
id|ac97_codec
op_star
id|codec
)paren
(brace
multiline_comment|/* Returns 0 on failure */
r_int
id|i
suffix:semicolon
id|u16
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|ac97_probe_codec
c_func
(paren
id|codec
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* ac97_probe_codec is success ,then begin to init codec */
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_RESET
comma
l_int|0xffff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|used
op_eq
l_int|1
)paren
(brace
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_RECORD_SELECT
comma
l_int|0x0000
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_LINEIN_VOL
comma
l_int|0x0808
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_RECORD_GAIN
comma
l_int|0x0F0F
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;channel
(braket
l_int|2
)braket
dot
id|used
op_eq
l_int|1
)paren
singleline_comment|//if MICin then init codec
(brace
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_RECORD_SELECT
comma
l_int|0x0000
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_MIC_VOL
comma
l_int|0x8808
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_RECORD_GAIN
comma
l_int|0x0F0F
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_RECORD_GAIN_MIC
comma
l_int|0x0000
)paren
suffix:semicolon
)brace
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_MASTER_VOL_STEREO
comma
l_int|0x0000
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_HEADPHONE_VOL
comma
l_int|0x0000
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_PCMOUT_VOL
comma
l_int|0x0000
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_CD_VOL
comma
l_int|0x0808
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_VIDEO_VOL
comma
l_int|0x0808
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_AUX_VOL
comma
l_int|0x0808
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_PHONE_VOL
comma
l_int|0x8048
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_PCBEEP_VOL
comma
l_int|0x0000
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_GENERAL_PURPOSE
comma
id|AC97_GP_MIX
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_MASTER_VOL_MONO
comma
l_int|0x0000
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
l_int|0x38
comma
l_int|0x0000
)paren
suffix:semicolon
id|addr
op_assign
id|ali_ac97_get
c_func
(paren
id|codec
comma
l_int|0x2a
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
l_int|0x2a
comma
id|addr
op_or
l_int|0x0001
)paren
suffix:semicolon
id|addr
op_assign
id|ali_ac97_get
c_func
(paren
id|codec
comma
l_int|0x2a
)paren
suffix:semicolon
id|addr
op_assign
id|ali_ac97_get
c_func
(paren
id|codec
comma
l_int|0x28
)paren
suffix:semicolon
id|ali_ac97_set
c_func
(paren
id|codec
comma
l_int|0x2c
comma
l_int|0xbb80
)paren
suffix:semicolon
id|addr
op_assign
id|ali_ac97_get
c_func
(paren
id|codec
comma
l_int|0x2c
)paren
suffix:semicolon
multiline_comment|/* power it all up */
id|ali_ac97_set
c_func
(paren
id|codec
comma
id|AC97_POWER_CONTROL
comma
id|ali_ac97_get
c_func
(paren
id|codec
comma
id|AC97_POWER_CONTROL
)paren
op_amp
op_complement
l_int|0x7f00
)paren
suffix:semicolon
multiline_comment|/* wait for analog ready */
r_for
c_loop
(paren
id|i
op_assign
l_int|10
suffix:semicolon
id|i
op_logical_and
(paren
(paren
id|ali_ac97_get
c_func
(paren
id|codec
comma
id|AC97_POWER_CONTROL
)paren
op_amp
l_int|0xf
)paren
op_ne
l_int|0xf
)paren
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
)brace
multiline_comment|/* FIXME !! */
id|i
op_increment
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* I clone ali5455(2.4.7 )  not clone i810_audio(2.4.18)  */
DECL|function|ali_reset_5455
r_static
r_int
id|ali_reset_5455
c_func
(paren
r_struct
id|ali_card
op_star
id|card
)paren
(brace
id|outl
c_func
(paren
l_int|0x80000003
comma
id|card-&gt;iobase
op_plus
id|ALI_SCR
)paren
suffix:semicolon
id|outl
c_func
(paren
l_int|0x83838383
comma
id|card-&gt;iobase
op_plus
id|ALI_FIFOCR1
)paren
suffix:semicolon
id|outl
c_func
(paren
l_int|0x83838383
comma
id|card-&gt;iobase
op_plus
id|ALI_FIFOCR2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|controller_pcmout_share_spdif_locked
OG
l_int|0
)paren
(brace
id|outl
c_func
(paren
(paren
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|ALI_SPDIFICS
)paren
op_or
l_int|0x00000001
)paren
comma
id|card-&gt;iobase
op_plus
id|ALI_SPDIFICS
)paren
suffix:semicolon
id|outl
c_func
(paren
l_int|0x0408000a
comma
id|card-&gt;iobase
op_plus
id|ALI_INTERFACECR
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
id|outl
c_func
(paren
(paren
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|ALI_SCR
)paren
op_or
l_int|0x00100000
)paren
comma
id|card-&gt;iobase
op_plus
id|ALI_SCR
)paren
suffix:semicolon
singleline_comment|// now I select slot 7 &amp; 8
id|outl
c_func
(paren
l_int|0x00200000
comma
id|card-&gt;iobase
op_plus
id|ALI_INTERFACECR
)paren
suffix:semicolon
singleline_comment|//enable codec independent spdifout 
)brace
r_else
id|outl
c_func
(paren
l_int|0x04080002
comma
id|card-&gt;iobase
op_plus
id|ALI_INTERFACECR
)paren
suffix:semicolon
)brace
id|outl
c_func
(paren
l_int|0x00000000
comma
id|card-&gt;iobase
op_plus
id|ALI_INTERRUPTCR
)paren
suffix:semicolon
id|outl
c_func
(paren
l_int|0x00000000
comma
id|card-&gt;iobase
op_plus
id|ALI_INTERRUPTSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|controller_independent_spdif_locked
OG
l_int|0
)paren
id|outl
c_func
(paren
(paren
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|ALI_SPDIFICS
)paren
op_or
l_int|0x00000001
)paren
comma
id|card-&gt;iobase
op_plus
id|ALI_SPDIFICS
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ali_ac97_random_init_stuff
r_static
r_int
id|ali_ac97_random_init_stuff
c_func
(paren
r_struct
id|ali_card
op_star
id|card
)paren
(brace
id|u32
id|reg
op_assign
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|ALI_SCR
)paren
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|reg
op_assign
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|ALI_SCR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reg
op_amp
l_int|2
)paren
op_eq
l_int|0
)paren
multiline_comment|/* Cold required */
id|reg
op_or_assign
l_int|2
suffix:semicolon
r_else
id|reg
op_or_assign
l_int|1
suffix:semicolon
multiline_comment|/* Warm */
id|reg
op_and_assign
op_complement
l_int|0x80000000
suffix:semicolon
multiline_comment|/* ACLink on */
id|outl
c_func
(paren
id|reg
comma
id|card-&gt;iobase
op_plus
id|ALI_SCR
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
l_int|10
)paren
(brace
r_if
c_cond
(paren
(paren
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
l_int|0x18
)paren
op_amp
(paren
l_int|1
op_lshift
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|10
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ali_audio: AC&squot;97 reset failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|2
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* AC97 codec initialisation. */
DECL|function|ali_ac97_init
r_static
r_int
id|__init
id|ali_ac97_init
c_func
(paren
r_struct
id|ali_card
op_star
id|card
)paren
(brace
r_int
id|num_ac97
op_assign
l_int|0
suffix:semicolon
r_int
id|total_channels
op_assign
l_int|0
suffix:semicolon
r_struct
id|ac97_codec
op_star
id|codec
suffix:semicolon
id|u16
id|eid
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ali_ac97_random_init_stuff
c_func
(paren
id|card
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Number of channels supported */
multiline_comment|/* What about the codec?  Just because the ICH supports */
multiline_comment|/* multiple channels doesn&squot;t mean the codec does.       */
multiline_comment|/* we&squot;ll have to modify this in the codec section below */
multiline_comment|/* to reflect what the codec has.                       */
multiline_comment|/* ICH and ICH0 only support 2 channels so don&squot;t bother */
multiline_comment|/* to check....                                         */
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|ALI_CPR
)paren
suffix:semicolon
id|card-&gt;channels
op_assign
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|num_ac97
op_assign
l_int|0
suffix:semicolon
id|num_ac97
OL
id|NR_AC97
suffix:semicolon
id|num_ac97
op_increment
)paren
(brace
multiline_comment|/* Assume codec isn&squot;t available until we go through the&n;&t;&t; * gauntlet below */
id|card-&gt;ac97_codec
(braket
id|num_ac97
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* The ICH programmer&squot;s reference says you should   */
multiline_comment|/* check the ready status before probing. So we chk */
multiline_comment|/*   What do we do if it&squot;s not ready?  Wait and try */
multiline_comment|/*   again, or abort?                               */
r_if
c_cond
(paren
op_logical_neg
id|ali_ac97_exists
c_func
(paren
id|card
comma
id|num_ac97
)paren
)paren
(brace
r_if
c_cond
(paren
id|num_ac97
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ali_audio: Primary codec not ready.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|codec
op_assign
id|ac97_alloc_codec
c_func
(paren
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* initialize some basic codec information, other fields will be filled&n;&t;&t;   in ac97_probe_codec */
id|codec-&gt;private_data
op_assign
id|card
suffix:semicolon
id|codec-&gt;id
op_assign
id|num_ac97
suffix:semicolon
id|codec-&gt;codec_read
op_assign
id|ali_ac97_get
suffix:semicolon
id|codec-&gt;codec_write
op_assign
id|ali_ac97_set
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ali_ac97_probe_and_powerup
c_func
(paren
id|card
comma
id|codec
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ali_audio: timed out waiting for codec %d analog ready&quot;
comma
id|num_ac97
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|codec
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* it didn&squot;t work */
)brace
multiline_comment|/* Store state information about S/PDIF transmitter */
id|card-&gt;ac97_status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Don&squot;t attempt to get eid until powerup is complete */
id|eid
op_assign
id|ali_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_ID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eid
op_eq
l_int|0xFFFF
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ali_audio: no codec attached ?&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|codec
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|card-&gt;ac97_features
op_assign
id|eid
suffix:semicolon
multiline_comment|/* Now check the codec for useful features to make up for&n;&t;&t;   the dumbness of the ali5455 hardware engine */
r_if
c_cond
(paren
op_logical_neg
(paren
id|eid
op_amp
l_int|0x0001
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ali_audio: only 48Khz playback available.&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|ali_ac97_enable_variable_rate
c_func
(paren
id|codec
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ali_audio: Codec refused to allow VRA, using 48Khz only.&bslash;n&quot;
)paren
suffix:semicolon
id|card-&gt;ac97_features
op_and_assign
op_complement
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Determine how many channels the codec(s) support   */
multiline_comment|/*   - The primary codec always supports 2            */
multiline_comment|/*   - If the codec supports AMAP, surround DACs will */
multiline_comment|/*     automaticlly get assigned to slots.            */
multiline_comment|/*     * Check for surround DACs and increment if     */
multiline_comment|/*       found.                                       */
multiline_comment|/*   - Else check if the codec is revision 2.2        */
multiline_comment|/*     * If surround DACs exist, assign them to slots */
multiline_comment|/*       and increment channel count.                 */
multiline_comment|/* All of this only applies to ICH2 and above. ICH    */
multiline_comment|/* and ICH0 only support 2 channels.  ICH2 will only  */
multiline_comment|/* support multiple codecs in a &quot;split audio&quot; config. */
multiline_comment|/* as described above.                                */
multiline_comment|/* TODO: Remove all the debugging messages!           */
r_if
c_cond
(paren
(paren
id|eid
op_amp
l_int|0xc000
)paren
op_eq
l_int|0
)paren
multiline_comment|/* primary codec */
id|total_channels
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
(paren
id|codec-&gt;dev_mixer
op_assign
id|register_sound_mixer
c_func
(paren
op_amp
id|ali_mixer_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ali_audio: couldn&squot;t register mixer!&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|codec
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|card-&gt;ac97_codec
(braket
id|num_ac97
)braket
op_assign
id|codec
suffix:semicolon
)brace
multiline_comment|/* pick the minimum of channels supported by ICHx or codec(s) */
id|card-&gt;channels
op_assign
(paren
id|card-&gt;channels
OG
id|total_channels
)paren
ques
c_cond
id|total_channels
suffix:colon
id|card-&gt;channels
suffix:semicolon
r_return
id|num_ac97
suffix:semicolon
)brace
DECL|function|ali_configure_clocking
r_static
r_void
id|__init
id|ali_configure_clocking
c_func
(paren
r_void
)paren
(brace
r_struct
id|ali_card
op_star
id|card
suffix:semicolon
r_struct
id|ali_state
op_star
id|state
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
suffix:semicolon
r_int
r_int
id|i
comma
id|offset
comma
id|new_offset
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|card
op_assign
id|devs
suffix:semicolon
multiline_comment|/* We could try to set the clocking for multiple cards, but can you even have&n;&t; * more than one ali in a machine?  Besides, clocking is global, so unless&n;&t; * someone actually thinks more than one ali in a machine is possible and&n;&t; * decides to rewrite that little bit, setting the rate for more than one card&n;&t; * is a waste of time.&n;&t; */
r_if
c_cond
(paren
id|card
op_ne
l_int|NULL
)paren
(brace
id|state
op_assign
id|card-&gt;states
(braket
l_int|0
)braket
op_assign
(paren
r_struct
id|ali_state
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ali_state
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|memset
c_func
(paren
id|state
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ali_state
)paren
)paren
suffix:semicolon
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|dmabuf-&gt;write_channel
op_assign
id|card
op_member_access_from_pointer
id|alloc_pcm_channel
c_func
(paren
id|card
)paren
suffix:semicolon
id|state-&gt;virt
op_assign
l_int|0
suffix:semicolon
id|state-&gt;card
op_assign
id|card
suffix:semicolon
id|state-&gt;magic
op_assign
id|ALI5455_STATE_MAGIC
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
id|dmabuf-&gt;fmt
op_assign
id|ALI5455_FMT_STEREO
op_or
id|ALI5455_FMT_16BIT
suffix:semicolon
id|dmabuf-&gt;trigger
op_assign
id|PCM_ENABLE_OUTPUT
suffix:semicolon
id|ali_set_dac_rate
c_func
(paren
id|state
comma
l_int|48000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
op_ne
l_int|0
)paren
r_goto
id|config_out_nodmabuf
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;dmasize
OL
l_int|16384
)paren
r_goto
id|config_out
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;dmasize
suffix:semicolon
id|outb
c_func
(paren
l_int|31
comma
id|card-&gt;iobase
op_plus
id|dmabuf-&gt;write_channel-&gt;port
op_plus
id|OFF_LVI
)paren
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|offset
op_assign
id|ali_get_dma_addr
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|new_offset
op_assign
id|ali_get_dma_addr
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|2
comma
id|card-&gt;iobase
op_plus
id|dmabuf-&gt;write_channel-&gt;port
op_plus
id|OFF_CR
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
id|i
op_assign
id|new_offset
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
r_goto
id|config_out
suffix:semicolon
id|i
op_assign
id|i
op_div
l_int|4
op_star
l_int|20
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|48500
op_logical_or
id|i
OL
l_int|47500
)paren
(brace
id|clocking
op_assign
id|clocking
op_star
id|clocking
op_div
id|i
suffix:semicolon
)brace
id|config_out
suffix:colon
id|dealloc_dmabuf
c_func
(paren
id|state
)paren
suffix:semicolon
id|config_out_nodmabuf
suffix:colon
id|state-&gt;card
op_member_access_from_pointer
id|free_pcm_channel
c_func
(paren
id|state-&gt;card
comma
id|state-&gt;dmabuf
dot
id|write_channel-&gt;num
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|state
)paren
suffix:semicolon
id|card-&gt;states
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* install the driver, we do not allocate hardware channel nor DMA buffer now, they are defered &n;   until &quot;ACCESS&quot; time (in prog_dmabuf called by open/read/write/ioctl/mmap) */
DECL|function|ali_probe
r_static
r_int
id|__init
id|ali_probe
c_func
(paren
r_struct
id|pci_dev
op_star
id|pci_dev
comma
r_const
r_struct
id|pci_device_id
op_star
id|pci_id
)paren
(brace
r_struct
id|ali_card
op_star
id|card
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pci_dev
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|pci_set_dma_mask
c_func
(paren
id|pci_dev
comma
id|ALI5455_DMA_MASK
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ali5455: architecture does not support&quot;
l_string|&quot; 32bit PCI busmaster DMA&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|card
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ali_card
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ali_audio: out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|card
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|card
)paren
)paren
suffix:semicolon
id|card-&gt;initializing
op_assign
l_int|1
suffix:semicolon
id|card-&gt;iobase
op_assign
id|pci_resource_start
c_func
(paren
id|pci_dev
comma
l_int|0
)paren
suffix:semicolon
id|card-&gt;pci_dev
op_assign
id|pci_dev
suffix:semicolon
id|card-&gt;pci_id
op_assign
id|pci_id-&gt;device
suffix:semicolon
id|card-&gt;irq
op_assign
id|pci_dev-&gt;irq
suffix:semicolon
id|card-&gt;next
op_assign
id|devs
suffix:semicolon
id|card-&gt;magic
op_assign
id|ALI5455_CARD_MAGIC
suffix:semicolon
macro_line|#ifdef CONFIG_PM
id|card-&gt;pm_suspended
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|spin_lock_init
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|card-&gt;ac97_lock
)paren
suffix:semicolon
id|devs
op_assign
id|card
suffix:semicolon
id|pci_set_master
c_func
(paren
id|pci_dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ali: %s found at IO 0x%04lx, IRQ %d&bslash;n&quot;
comma
id|card_names
(braket
id|pci_id-&gt;driver_data
)braket
comma
id|card-&gt;iobase
comma
id|card-&gt;irq
)paren
suffix:semicolon
id|card-&gt;alloc_pcm_channel
op_assign
id|ali_alloc_pcm_channel
suffix:semicolon
id|card-&gt;alloc_rec_pcm_channel
op_assign
id|ali_alloc_rec_pcm_channel
suffix:semicolon
id|card-&gt;alloc_rec_mic_channel
op_assign
id|ali_alloc_rec_mic_channel
suffix:semicolon
id|card-&gt;alloc_codec_spdifout_channel
op_assign
id|ali_alloc_codec_spdifout_channel
suffix:semicolon
id|card-&gt;alloc_controller_spdifout_channel
op_assign
id|ali_alloc_controller_spdifout_channel
suffix:semicolon
id|card-&gt;free_pcm_channel
op_assign
id|ali_free_pcm_channel
suffix:semicolon
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|offset
op_assign
l_int|0
suffix:semicolon
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|port
op_assign
l_int|0x40
suffix:semicolon
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|num
op_assign
l_int|0
suffix:semicolon
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|offset
op_assign
l_int|0
suffix:semicolon
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|port
op_assign
l_int|0x50
suffix:semicolon
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|num
op_assign
l_int|1
suffix:semicolon
id|card-&gt;channel
(braket
l_int|2
)braket
dot
id|offset
op_assign
l_int|0
suffix:semicolon
id|card-&gt;channel
(braket
l_int|2
)braket
dot
id|port
op_assign
l_int|0x60
suffix:semicolon
id|card-&gt;channel
(braket
l_int|2
)braket
dot
id|num
op_assign
l_int|2
suffix:semicolon
id|card-&gt;channel
(braket
l_int|3
)braket
dot
id|offset
op_assign
l_int|0
suffix:semicolon
id|card-&gt;channel
(braket
l_int|3
)braket
dot
id|port
op_assign
l_int|0x70
suffix:semicolon
id|card-&gt;channel
(braket
l_int|3
)braket
dot
id|num
op_assign
l_int|3
suffix:semicolon
id|card-&gt;channel
(braket
l_int|4
)braket
dot
id|offset
op_assign
l_int|0
suffix:semicolon
id|card-&gt;channel
(braket
l_int|4
)braket
dot
id|port
op_assign
l_int|0xb0
suffix:semicolon
id|card-&gt;channel
(braket
l_int|4
)braket
dot
id|num
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* claim our iospace and irq */
id|request_region
c_func
(paren
id|card-&gt;iobase
comma
l_int|256
comma
id|card_names
(braket
id|pci_id-&gt;driver_data
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|card-&gt;irq
comma
op_amp
id|ali_interrupt
comma
id|SA_SHIRQ
comma
id|card_names
(braket
id|pci_id-&gt;driver_data
)braket
comma
id|card
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ali_audio: unable to allocate irq %d&bslash;n&quot;
comma
id|card-&gt;irq
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|card-&gt;iobase
comma
l_int|256
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ali_reset_5455
c_func
(paren
id|card
)paren
op_le
l_int|0
)paren
(brace
id|unregister_sound_dsp
c_func
(paren
id|card-&gt;dev_audio
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|card-&gt;iobase
comma
l_int|256
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|card-&gt;irq
comma
id|card
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* initialize AC97 codec and register /dev/mixer */
r_if
c_cond
(paren
id|ali_ac97_init
c_func
(paren
id|card
)paren
OL
l_int|0
)paren
(brace
id|release_region
c_func
(paren
id|card-&gt;iobase
comma
l_int|256
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|card-&gt;irq
comma
id|card
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|pci_set_drvdata
c_func
(paren
id|pci_dev
comma
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clocking
op_eq
l_int|0
)paren
(brace
id|clocking
op_assign
l_int|48000
suffix:semicolon
id|ali_configure_clocking
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* register /dev/dsp */
r_if
c_cond
(paren
(paren
id|card-&gt;dev_audio
op_assign
id|register_sound_dsp
c_func
(paren
op_amp
id|ali_audio_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ali_audio: couldn&squot;t register DSP device!&bslash;n&quot;
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|card-&gt;iobase
comma
l_int|256
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|card-&gt;irq
comma
id|card
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_AC97
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|unregister_sound_mixer
c_func
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_member_access_from_pointer
id|dev_mixer
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|card-&gt;initializing
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ali_remove
r_static
r_void
id|__devexit
id|ali_remove
c_func
(paren
r_struct
id|pci_dev
op_star
id|pci_dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|ali_card
op_star
id|card
op_assign
id|pci_get_drvdata
c_func
(paren
id|pci_dev
)paren
suffix:semicolon
multiline_comment|/* free hardware resources */
id|free_irq
c_func
(paren
id|card-&gt;irq
comma
id|devs
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|card-&gt;iobase
comma
l_int|256
)paren
suffix:semicolon
multiline_comment|/* unregister audio devices */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_AC97
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|unregister_sound_mixer
c_func
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_member_access_from_pointer
id|dev_mixer
)paren
suffix:semicolon
id|ac97_release_codec
c_func
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
)paren
suffix:semicolon
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|unregister_sound_dsp
c_func
(paren
id|card-&gt;dev_audio
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PM
DECL|function|ali_pm_suspend
r_static
r_int
id|ali_pm_suspend
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
id|u32
id|pm_state
)paren
(brace
r_struct
id|ali_card
op_star
id|card
op_assign
id|pci_get_drvdata
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|ali_state
op_star
id|state
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
suffix:semicolon
r_int
id|i
comma
id|num_ac97
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|card
)paren
r_return
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|card-&gt;pm_suspended
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_HW_CH
suffix:semicolon
id|i
op_increment
)paren
(brace
id|state
op_assign
id|card-&gt;states
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state
)paren
r_continue
suffix:semicolon
multiline_comment|/* this happens only if there are open files */
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
op_logical_or
(paren
id|dmabuf-&gt;count
op_logical_and
(paren
id|dmabuf-&gt;trigger
op_amp
id|PCM_ENABLE_OUTPUT
)paren
)paren
)paren
(brace
id|state-&gt;pm_saved_dac_rate
op_assign
id|dmabuf-&gt;rate
suffix:semicolon
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_else
(brace
id|state-&gt;pm_saved_dac_rate
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
(brace
id|state-&gt;pm_saved_adc_rate
op_assign
id|dmabuf-&gt;rate
suffix:semicolon
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_else
(brace
id|state-&gt;pm_saved_adc_rate
op_assign
l_int|0
suffix:semicolon
)brace
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;total_bytes
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* save mixer settings */
r_for
c_loop
(paren
id|num_ac97
op_assign
l_int|0
suffix:semicolon
id|num_ac97
OL
id|NR_AC97
suffix:semicolon
id|num_ac97
op_increment
)paren
(brace
r_struct
id|ac97_codec
op_star
id|codec
op_assign
id|card-&gt;ac97_codec
(braket
id|num_ac97
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|codec
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SOUND_MIXER_NRDEVICES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|supported_mixer
c_func
(paren
id|codec
comma
id|i
)paren
)paren
op_logical_and
(paren
id|codec-&gt;read_mixer
)paren
)paren
(brace
id|card-&gt;pm_saved_mixer_settings
(braket
id|i
)braket
(braket
id|num_ac97
)braket
op_assign
id|codec
op_member_access_from_pointer
id|read_mixer
c_func
(paren
id|codec
comma
id|i
)paren
suffix:semicolon
)brace
)brace
)brace
id|pci_save_state
c_func
(paren
id|dev
comma
id|card-&gt;pm_save_state
)paren
suffix:semicolon
multiline_comment|/* XXX do we need this? */
id|pci_disable_device
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* disable busmastering */
id|pci_set_power_state
c_func
(paren
id|dev
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Zzz. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ali_pm_resume
r_static
r_int
id|ali_pm_resume
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_int
id|num_ac97
comma
id|i
op_assign
l_int|0
suffix:semicolon
r_struct
id|ali_card
op_star
id|card
op_assign
id|pci_get_drvdata
c_func
(paren
id|dev
)paren
suffix:semicolon
id|pci_enable_device
c_func
(paren
id|dev
)paren
suffix:semicolon
id|pci_restore_state
c_func
(paren
id|dev
comma
id|card-&gt;pm_save_state
)paren
suffix:semicolon
multiline_comment|/* observation of a toshiba portege 3440ct suggests that the &n;&t;   hardware has to be more or less completely reinitialized from&n;&t;   scratch after an apm suspend.  Works For Me.   -dan */
id|ali_ac97_random_init_stuff
c_func
(paren
id|card
)paren
suffix:semicolon
r_for
c_loop
(paren
id|num_ac97
op_assign
l_int|0
suffix:semicolon
id|num_ac97
OL
id|NR_AC97
suffix:semicolon
id|num_ac97
op_increment
)paren
(brace
r_struct
id|ac97_codec
op_star
id|codec
op_assign
id|card-&gt;ac97_codec
(braket
id|num_ac97
)braket
suffix:semicolon
multiline_comment|/* check they haven&squot;t stolen the hardware while we were&n;&t;&t;   away */
r_if
c_cond
(paren
op_logical_neg
id|codec
op_logical_or
op_logical_neg
id|ali_ac97_exists
c_func
(paren
id|card
comma
id|num_ac97
)paren
)paren
(brace
r_if
c_cond
(paren
id|num_ac97
)paren
r_continue
suffix:semicolon
r_else
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ali_ac97_probe_and_powerup
c_func
(paren
id|card
comma
id|codec
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|card-&gt;ac97_features
op_amp
l_int|0x0001
)paren
)paren
(brace
multiline_comment|/* at probe time we found we could do variable&n;&t;&t;&t;   rates, but APM suspend has made it forget&n;&t;&t;&t;   its magical powers */
r_if
c_cond
(paren
op_logical_neg
id|ali_ac97_enable_variable_rate
c_func
(paren
id|codec
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* we lost our mixer settings, so restore them */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SOUND_MIXER_NRDEVICES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|supported_mixer
c_func
(paren
id|codec
comma
id|i
)paren
)paren
(brace
r_int
id|val
op_assign
id|card-&gt;pm_saved_mixer_settings
(braket
id|i
)braket
(braket
id|num_ac97
)braket
suffix:semicolon
id|codec-&gt;mixer_state
(braket
id|i
)braket
op_assign
id|val
suffix:semicolon
id|codec
op_member_access_from_pointer
id|write_mixer
c_func
(paren
id|codec
comma
id|i
comma
(paren
id|val
op_amp
l_int|0xff
)paren
comma
(paren
(paren
id|val
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* we need to restore the sample rate from whatever it was */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_HW_CH
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ali_state
op_star
id|state
op_assign
id|card-&gt;states
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
r_if
c_cond
(paren
id|state-&gt;pm_saved_adc_rate
)paren
id|ali_set_adc_rate
c_func
(paren
id|state
comma
id|state-&gt;pm_saved_adc_rate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;pm_saved_dac_rate
)paren
id|ali_set_dac_rate
c_func
(paren
id|state
comma
id|state-&gt;pm_saved_dac_rate
)paren
suffix:semicolon
)brace
)brace
id|card-&gt;pm_suspended
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* any processes that were reading/writing during the suspend&n;&t;   probably ended up here */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_HW_CH
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ali_state
op_star
id|state
op_assign
id|card-&gt;states
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
id|wake_up
c_func
(paren
op_amp
id|state-&gt;dmabuf.wait
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* CONFIG_PM */
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;ALI 5455 audio support&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|clocking
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|strict_clocking
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|codec_pcmout_share_spdif_locked
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|codec_independent_spdif_locked
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|controller_pcmout_share_spdif_locked
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|controller_independent_spdif_locked
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|macro|ALI5455_MODULE_NAME
mdefine_line|#define ALI5455_MODULE_NAME &quot;ali5455&quot;
DECL|variable|ali_pci_driver
r_static
r_struct
id|pci_driver
id|ali_pci_driver
op_assign
(brace
dot
id|name
op_assign
id|ALI5455_MODULE_NAME
comma
dot
id|id_table
op_assign
id|ali_pci_tbl
comma
dot
id|probe
op_assign
id|ali_probe
comma
dot
id|remove
op_assign
id|__devexit_p
c_func
(paren
id|ali_remove
)paren
comma
macro_line|#ifdef CONFIG_PM
dot
id|suspend
op_assign
id|ali_pm_suspend
comma
dot
id|resume
op_assign
id|ali_pm_resume
comma
macro_line|#endif&t;&t;&t;&t;/* CONFIG_PM */
)brace
suffix:semicolon
DECL|function|ali_init_module
r_static
r_int
id|__init
id|ali_init_module
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ALI 5455 + AC97 Audio, version &quot;
id|DRIVER_VERSION
l_string|&quot;, &quot;
id|__TIME__
l_string|&quot; &quot;
id|__DATE__
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|codec_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|codec_independent_spdif_locked
op_eq
l_int|32000
op_logical_or
id|codec_independent_spdif_locked
op_eq
l_int|44100
op_logical_or
id|codec_independent_spdif_locked
op_eq
l_int|48000
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ali_audio: Enabling S/PDIF at sample rate %dHz.&bslash;n&quot;
comma
id|codec_independent_spdif_locked
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ali_audio: S/PDIF can only be locked to 32000, 44100, or 48000Hz.&bslash;n&quot;
)paren
suffix:semicolon
id|codec_independent_spdif_locked
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|controller_independent_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|controller_independent_spdif_locked
op_eq
l_int|32000
op_logical_or
id|controller_independent_spdif_locked
op_eq
l_int|44100
op_logical_or
id|controller_independent_spdif_locked
op_eq
l_int|48000
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ali_audio: Enabling S/PDIF at sample rate %dHz.&bslash;n&quot;
comma
id|controller_independent_spdif_locked
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ali_audio: S/PDIF can only be locked to 32000, 44100, or 48000Hz.&bslash;n&quot;
)paren
suffix:semicolon
id|controller_independent_spdif_locked
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|codec_pcmout_share_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|codec_pcmout_share_spdif_locked
op_eq
l_int|32000
op_logical_or
id|codec_pcmout_share_spdif_locked
op_eq
l_int|44100
op_logical_or
id|codec_pcmout_share_spdif_locked
op_eq
l_int|48000
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ali_audio: Enabling S/PDIF at sample rate %dHz.&bslash;n&quot;
comma
id|codec_pcmout_share_spdif_locked
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ali_audio: S/PDIF can only be locked to 32000, 44100, or 48000Hz.&bslash;n&quot;
)paren
suffix:semicolon
id|codec_pcmout_share_spdif_locked
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|controller_pcmout_share_spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|controller_pcmout_share_spdif_locked
op_eq
l_int|32000
op_logical_or
id|controller_pcmout_share_spdif_locked
op_eq
l_int|44100
op_logical_or
id|controller_pcmout_share_spdif_locked
op_eq
l_int|48000
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ali_audio: Enabling controller S/PDIF at sample rate %dHz.&bslash;n&quot;
comma
id|controller_pcmout_share_spdif_locked
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ali_audio: S/PDIF can only be locked to 32000, 44100, or 48000Hz.&bslash;n&quot;
)paren
suffix:semicolon
id|controller_pcmout_share_spdif_locked
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|pci_register_driver
c_func
(paren
op_amp
id|ali_pci_driver
)paren
)paren
(brace
id|pci_unregister_driver
c_func
(paren
op_amp
id|ali_pci_driver
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ali_cleanup_module
r_static
r_void
id|__exit
id|ali_cleanup_module
c_func
(paren
r_void
)paren
(brace
id|pci_unregister_driver
c_func
(paren
op_amp
id|ali_pci_driver
)paren
suffix:semicolon
)brace
DECL|variable|ali_init_module
id|module_init
c_func
(paren
id|ali_init_module
)paren
suffix:semicolon
DECL|variable|ali_cleanup_module
id|module_exit
c_func
(paren
id|ali_cleanup_module
)paren
suffix:semicolon
multiline_comment|/*&n;Local Variables:&n;c-basic-offset: 8&n;End:&n;*/
eof
