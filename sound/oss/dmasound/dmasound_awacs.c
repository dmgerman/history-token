multiline_comment|/*&n; *  linux/drivers/sound/dmasound/dmasound_awacs.c&n; *&n; *  PowerMac `AWACS&squot; and `Burgundy&squot; DMA Sound Driver&n; *  with some limited support for DACA &amp; Tumbler&n; *&n; *  See linux/drivers/sound/dmasound/dmasound_core.c for copyright and&n; *  history prior to 2001/01/26.&n; *&n; *&t;26/01/2001 ed 0.1 Iain Sandoe&n; *&t;&t;- added version info.&n; *&t;&t;- moved dbdma command buffer allocation to PMacXXXSqSetup()&n; *&t;&t;- fixed up beep dbdma cmd buffers&n; *&n; *&t;08/02/2001 [0.2]&n; *&t;&t;- make SNDCTL_DSP_GETFMTS return the correct info for the h/w&n; *&t;&t;- move soft format translations to a separate file&n; *&t;&t;- [0.3] make SNDCTL_DSP_GETCAPS return correct info.&n; *&t;&t;- [0.4] more informative machine name strings.&n; *&t;&t;- [0.5]&n; *&t;&t;- record changes.&n; *&t;&t;- made the default_hard/soft entries.&n; *&t;04/04/2001 [0.6]&n; *&t;&t;- minor correction to bit assignments in awacs_defs.h&n; *&t;&t;- incorporate mixer changes from 2.2.x back-port.&n; *&t;&t;- take out passthru as a rec input (it isn&squot;t).&n; *              - make Input Gain slider work the &squot;right way up&squot;.&n; *              - try to make the mixer sliders more logical - so now the&n; *                input selectors are just two-state (&gt;50% == ON) and the&n; *                Input Gain slider handles the rest of the gain issues.&n; *              - try to pick slider representations that most closely match&n; *                the actual use - e.g. IGain for input gain... &n; *              - first stab at over/under-run detection.&n; *&t;&t;- minor cosmetic changes to IRQ identification.&n; *&t;&t;- fix bug where rates &gt; max would be reported as supported.&n; *              - first stab at over/under-run detection.&n; *              - make use of i2c for mixer settings conditional on perch&n; *                rather than cuda (some machines without perch have cuda).&n; *              - fix bug where TX stops when dbdma status comes up &quot;DEAD&quot;&n; *&t;&t;  so far only reported on PowerComputing clones ... but.&n; *&t;&t;- put in AWACS/Screamer register write timeouts.&n; *&t;&t;- part way to partitioning the init() stuff&n; *&t;&t;- first pass at &squot;tumbler&squot; stuff (not support - just an attempt&n; *&t;&t;  to allow the driver to load on new G4s).&n; *      01/02/2002 [0.7] - BenH&n; *&t;        - all sort of minor bits went in since the latest update, I&n; *&t;          bumped the version number for that reason&n;*/
multiline_comment|/* GENERAL FIXME/TODO: check that the assumptions about what is written to&n;   mac-io is valid for DACA &amp; Tumbler.&n;&n;   This driver is in bad need of a rewrite. The dbdma code has to be split,&n;   some proper device-tree parsing code has to be written, etc...&n;*/
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/soundcard.h&gt;
macro_line|#include &lt;linux/adb.h&gt;
macro_line|#include &lt;linux/nvram.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/vt_kern.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#ifdef CONFIG_ADB_CUDA
macro_line|#include &lt;linux/cuda.h&gt;
macro_line|#endif
macro_line|#ifdef CONFIG_ADB_PMU
macro_line|#include &lt;linux/pmu.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/i2c-dev.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dbdma.h&gt;
macro_line|#include &lt;asm/pmac_feature.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/nvram.h&gt;
macro_line|#include &quot;awacs_defs.h&quot;
macro_line|#include &quot;dmasound.h&quot;
DECL|macro|DMASOUND_AWACS_REVISION
mdefine_line|#define DMASOUND_AWACS_REVISION&t;0
DECL|macro|DMASOUND_AWACS_EDITION
mdefine_line|#define DMASOUND_AWACS_EDITION&t;7
DECL|macro|AWACS_BURGUNDY
mdefine_line|#define AWACS_BURGUNDY&t;100&t;/* fake revision # for burgundy */
DECL|macro|AWACS_TUMBLER
mdefine_line|#define AWACS_TUMBLER    90&t;/* fake revision # for tumbler */
DECL|macro|AWACS_DACA
mdefine_line|#define AWACS_DACA&t; 80&t;/* fake revision # for daca (ibook) */
DECL|macro|AWACS_AWACS
mdefine_line|#define AWACS_AWACS       2     /* holding revision for AWACS */
DECL|macro|AWACS_SCREAMER
mdefine_line|#define AWACS_SCREAMER    3     /* holding revision for Screamer */
multiline_comment|/*&n; * Interrupt numbers and addresses, &amp; info obtained from the device tree.&n; */
DECL|variable|awacs_irq
DECL|variable|awacs_tx_irq
DECL|variable|awacs_rx_irq
r_static
r_int
id|awacs_irq
comma
id|awacs_tx_irq
comma
id|awacs_rx_irq
suffix:semicolon
DECL|variable|awacs
r_static
r_volatile
r_struct
id|awacs_regs
op_star
id|awacs
suffix:semicolon
DECL|variable|awacs_txdma
DECL|variable|awacs_rxdma
r_static
r_volatile
r_struct
id|dbdma_regs
op_star
id|awacs_txdma
comma
op_star
id|awacs_rxdma
suffix:semicolon
DECL|variable|awacs_rate_index
r_static
r_int
id|awacs_rate_index
suffix:semicolon
DECL|variable|awacs_subframe
r_static
r_int
id|awacs_subframe
suffix:semicolon
DECL|variable|awacs_spkr_vol
r_static
r_int
id|awacs_spkr_vol
suffix:semicolon
DECL|variable|awacs_node
r_static
r_struct
id|device_node
op_star
id|awacs_node
suffix:semicolon
DECL|variable|awacs_name
r_static
r_char
id|awacs_name
(braket
l_int|64
)braket
suffix:semicolon
DECL|variable|awacs_revision
r_static
r_int
id|awacs_revision
suffix:semicolon
DECL|variable|awacs_sleeping
r_static
r_int
id|awacs_sleeping
suffix:semicolon
r_static
id|DECLARE_MUTEX
c_func
(paren
id|dmasound_sem
)paren
suffix:semicolon
DECL|variable|sound_device_id
r_static
r_int
id|sound_device_id
suffix:semicolon
multiline_comment|/* exists after iMac revA */
DECL|variable|hw_can_byteswap
r_static
r_int
id|hw_can_byteswap
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* most pmac sound h/w can */
multiline_comment|/* model info */
multiline_comment|/* To be replaced with better interaction with pmac_feature.c */
DECL|variable|is_pbook_3X00
r_static
r_int
id|is_pbook_3X00
suffix:semicolon
DECL|variable|is_pbook_g3
r_static
r_int
id|is_pbook_g3
suffix:semicolon
multiline_comment|/* expansion info */
DECL|variable|has_perch
r_static
r_int
id|has_perch
suffix:semicolon
DECL|variable|has_ziva
r_static
r_int
id|has_ziva
suffix:semicolon
multiline_comment|/* for earlier powerbooks which need fiddling with mac-io to enable&n; * cd etc.&n;*/
DECL|variable|latch_base
r_static
r_int
r_char
op_star
id|latch_base
suffix:semicolon
DECL|variable|macio_base
r_static
r_int
r_char
op_star
id|macio_base
suffix:semicolon
multiline_comment|/*&n; * Space for the DBDMA command blocks.&n; */
DECL|variable|awacs_tx_cmd_space
r_static
r_void
op_star
id|awacs_tx_cmd_space
suffix:semicolon
DECL|variable|awacs_tx_cmds
r_static
r_volatile
r_struct
id|dbdma_cmd
op_star
id|awacs_tx_cmds
suffix:semicolon
DECL|variable|number_of_tx_cmd_buffers
r_static
r_int
id|number_of_tx_cmd_buffers
op_assign
l_int|0
suffix:semicolon
DECL|variable|awacs_rx_cmd_space
r_static
r_void
op_star
id|awacs_rx_cmd_space
suffix:semicolon
DECL|variable|awacs_rx_cmds
r_static
r_volatile
r_struct
id|dbdma_cmd
op_star
id|awacs_rx_cmds
suffix:semicolon
DECL|variable|number_of_rx_cmd_buffers
r_static
r_int
id|number_of_rx_cmd_buffers
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Cached values of AWACS registers (we can&squot;t read them).&n; * Except on the burgundy (and screamer). XXX&n; */
DECL|variable|awacs_reg
r_int
id|awacs_reg
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|awacs_reg1_save
r_int
id|awacs_reg1_save
suffix:semicolon
multiline_comment|/* tracking values for the mixer contents&n;*/
DECL|variable|spk_vol
r_static
r_int
id|spk_vol
op_assign
l_int|0
suffix:semicolon
DECL|variable|line_vol
r_static
r_int
id|line_vol
op_assign
l_int|0
suffix:semicolon
DECL|variable|passthru_vol
r_static
r_int
id|passthru_vol
op_assign
l_int|0
suffix:semicolon
DECL|variable|ip_gain
r_static
r_int
id|ip_gain
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* mic preamp settings */
DECL|variable|rec_lev
r_static
r_int
id|rec_lev
op_assign
l_int|0x4545
suffix:semicolon
multiline_comment|/* default CD gain 69 % */
DECL|variable|mic_lev
r_static
r_int
id|mic_lev
op_assign
l_int|0
suffix:semicolon
DECL|variable|cd_lev
r_static
r_int
id|cd_lev
op_assign
l_int|0x6363
suffix:semicolon
multiline_comment|/* 99 % */
DECL|variable|line_lev
r_static
r_int
id|line_lev
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Stuff for outputting a beep.  The values range from -327 to +327&n; * so we can multiply by an amplitude in the range 0..100 to get a&n; * signed short value to put in the output buffer.&n; */
DECL|variable|beep_wform
r_static
r_int
id|beep_wform
(braket
l_int|256
)braket
op_assign
(brace
l_int|0
comma
l_int|40
comma
l_int|79
comma
l_int|117
comma
l_int|153
comma
l_int|187
comma
l_int|218
comma
l_int|245
comma
l_int|269
comma
l_int|288
comma
l_int|304
comma
l_int|316
comma
l_int|323
comma
l_int|327
comma
l_int|327
comma
l_int|324
comma
l_int|318
comma
l_int|310
comma
l_int|299
comma
l_int|288
comma
l_int|275
comma
l_int|262
comma
l_int|249
comma
l_int|236
comma
l_int|224
comma
l_int|213
comma
l_int|204
comma
l_int|196
comma
l_int|190
comma
l_int|186
comma
l_int|183
comma
l_int|182
comma
l_int|182
comma
l_int|183
comma
l_int|186
comma
l_int|189
comma
l_int|192
comma
l_int|196
comma
l_int|200
comma
l_int|203
comma
l_int|206
comma
l_int|208
comma
l_int|209
comma
l_int|209
comma
l_int|209
comma
l_int|207
comma
l_int|204
comma
l_int|201
comma
l_int|197
comma
l_int|193
comma
l_int|188
comma
l_int|183
comma
l_int|179
comma
l_int|174
comma
l_int|170
comma
l_int|166
comma
l_int|163
comma
l_int|161
comma
l_int|160
comma
l_int|159
comma
l_int|159
comma
l_int|160
comma
l_int|161
comma
l_int|162
comma
l_int|164
comma
l_int|166
comma
l_int|168
comma
l_int|169
comma
l_int|171
comma
l_int|171
comma
l_int|171
comma
l_int|170
comma
l_int|169
comma
l_int|167
comma
l_int|163
comma
l_int|159
comma
l_int|155
comma
l_int|150
comma
l_int|144
comma
l_int|139
comma
l_int|133
comma
l_int|128
comma
l_int|122
comma
l_int|117
comma
l_int|113
comma
l_int|110
comma
l_int|107
comma
l_int|105
comma
l_int|103
comma
l_int|103
comma
l_int|103
comma
l_int|103
comma
l_int|104
comma
l_int|104
comma
l_int|105
comma
l_int|105
comma
l_int|105
comma
l_int|103
comma
l_int|101
comma
l_int|97
comma
l_int|92
comma
l_int|86
comma
l_int|78
comma
l_int|68
comma
l_int|58
comma
l_int|45
comma
l_int|32
comma
l_int|18
comma
l_int|3
comma
op_minus
l_int|11
comma
op_minus
l_int|26
comma
op_minus
l_int|41
comma
op_minus
l_int|55
comma
op_minus
l_int|68
comma
op_minus
l_int|79
comma
op_minus
l_int|88
comma
op_minus
l_int|95
comma
op_minus
l_int|100
comma
op_minus
l_int|102
comma
op_minus
l_int|102
comma
op_minus
l_int|99
comma
op_minus
l_int|93
comma
op_minus
l_int|85
comma
op_minus
l_int|75
comma
op_minus
l_int|62
comma
op_minus
l_int|48
comma
op_minus
l_int|33
comma
op_minus
l_int|16
comma
l_int|0
comma
l_int|16
comma
l_int|33
comma
l_int|48
comma
l_int|62
comma
l_int|75
comma
l_int|85
comma
l_int|93
comma
l_int|99
comma
l_int|102
comma
l_int|102
comma
l_int|100
comma
l_int|95
comma
l_int|88
comma
l_int|79
comma
l_int|68
comma
l_int|55
comma
l_int|41
comma
l_int|26
comma
l_int|11
comma
op_minus
l_int|3
comma
op_minus
l_int|18
comma
op_minus
l_int|32
comma
op_minus
l_int|45
comma
op_minus
l_int|58
comma
op_minus
l_int|68
comma
op_minus
l_int|78
comma
op_minus
l_int|86
comma
op_minus
l_int|92
comma
op_minus
l_int|97
comma
op_minus
l_int|101
comma
op_minus
l_int|103
comma
op_minus
l_int|105
comma
op_minus
l_int|105
comma
op_minus
l_int|105
comma
op_minus
l_int|104
comma
op_minus
l_int|104
comma
op_minus
l_int|103
comma
op_minus
l_int|103
comma
op_minus
l_int|103
comma
op_minus
l_int|103
comma
op_minus
l_int|105
comma
op_minus
l_int|107
comma
op_minus
l_int|110
comma
op_minus
l_int|113
comma
op_minus
l_int|117
comma
op_minus
l_int|122
comma
op_minus
l_int|128
comma
op_minus
l_int|133
comma
op_minus
l_int|139
comma
op_minus
l_int|144
comma
op_minus
l_int|150
comma
op_minus
l_int|155
comma
op_minus
l_int|159
comma
op_minus
l_int|163
comma
op_minus
l_int|167
comma
op_minus
l_int|169
comma
op_minus
l_int|170
comma
op_minus
l_int|171
comma
op_minus
l_int|171
comma
op_minus
l_int|171
comma
op_minus
l_int|169
comma
op_minus
l_int|168
comma
op_minus
l_int|166
comma
op_minus
l_int|164
comma
op_minus
l_int|162
comma
op_minus
l_int|161
comma
op_minus
l_int|160
comma
op_minus
l_int|159
comma
op_minus
l_int|159
comma
op_minus
l_int|160
comma
op_minus
l_int|161
comma
op_minus
l_int|163
comma
op_minus
l_int|166
comma
op_minus
l_int|170
comma
op_minus
l_int|174
comma
op_minus
l_int|179
comma
op_minus
l_int|183
comma
op_minus
l_int|188
comma
op_minus
l_int|193
comma
op_minus
l_int|197
comma
op_minus
l_int|201
comma
op_minus
l_int|204
comma
op_minus
l_int|207
comma
op_minus
l_int|209
comma
op_minus
l_int|209
comma
op_minus
l_int|209
comma
op_minus
l_int|208
comma
op_minus
l_int|206
comma
op_minus
l_int|203
comma
op_minus
l_int|200
comma
op_minus
l_int|196
comma
op_minus
l_int|192
comma
op_minus
l_int|189
comma
op_minus
l_int|186
comma
op_minus
l_int|183
comma
op_minus
l_int|182
comma
op_minus
l_int|182
comma
op_minus
l_int|183
comma
op_minus
l_int|186
comma
op_minus
l_int|190
comma
op_minus
l_int|196
comma
op_minus
l_int|204
comma
op_minus
l_int|213
comma
op_minus
l_int|224
comma
op_minus
l_int|236
comma
op_minus
l_int|249
comma
op_minus
l_int|262
comma
op_minus
l_int|275
comma
op_minus
l_int|288
comma
op_minus
l_int|299
comma
op_minus
l_int|310
comma
op_minus
l_int|318
comma
op_minus
l_int|324
comma
op_minus
l_int|327
comma
op_minus
l_int|327
comma
op_minus
l_int|323
comma
op_minus
l_int|316
comma
op_minus
l_int|304
comma
op_minus
l_int|288
comma
op_minus
l_int|269
comma
op_minus
l_int|245
comma
op_minus
l_int|218
comma
op_minus
l_int|187
comma
op_minus
l_int|153
comma
op_minus
l_int|117
comma
op_minus
l_int|79
comma
op_minus
l_int|40
comma
)brace
suffix:semicolon
multiline_comment|/* beep support */
DECL|macro|BEEP_SRATE
mdefine_line|#define BEEP_SRATE&t;22050&t;/* 22050 Hz sample rate */
DECL|macro|BEEP_BUFLEN
mdefine_line|#define BEEP_BUFLEN&t;512
DECL|macro|BEEP_VOLUME
mdefine_line|#define BEEP_VOLUME&t;15&t;/* 0 - 100 */
DECL|variable|beep_vol
r_static
r_int
id|beep_vol
op_assign
id|BEEP_VOLUME
suffix:semicolon
DECL|variable|beep_playing
r_static
r_int
id|beep_playing
op_assign
l_int|0
suffix:semicolon
DECL|variable|awacs_beep_state
r_static
r_int
id|awacs_beep_state
op_assign
l_int|0
suffix:semicolon
DECL|variable|beep_buf
r_static
r_int
op_star
id|beep_buf
suffix:semicolon
DECL|variable|beep_dbdma_cmd_space
r_static
r_void
op_star
id|beep_dbdma_cmd_space
suffix:semicolon
DECL|variable|beep_dbdma_cmd
r_static
r_volatile
r_struct
id|dbdma_cmd
op_star
id|beep_dbdma_cmd
suffix:semicolon
DECL|variable|orig_mksound
r_static
r_void
(paren
op_star
id|orig_mksound
)paren
(paren
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* Burgundy functions */
r_static
r_void
id|awacs_burgundy_wcw
c_func
(paren
r_int
id|addr
comma
r_int
id|newval
)paren
suffix:semicolon
r_static
r_int
id|awacs_burgundy_rcw
c_func
(paren
r_int
id|addr
)paren
suffix:semicolon
r_static
r_void
id|awacs_burgundy_write_volume
c_func
(paren
r_int
id|address
comma
r_int
id|volume
)paren
suffix:semicolon
r_static
r_int
id|awacs_burgundy_read_volume
c_func
(paren
r_int
id|address
)paren
suffix:semicolon
r_static
r_void
id|awacs_burgundy_write_mvolume
c_func
(paren
r_int
id|address
comma
r_int
id|volume
)paren
suffix:semicolon
r_static
r_int
id|awacs_burgundy_read_mvolume
c_func
(paren
r_int
id|address
)paren
suffix:semicolon
multiline_comment|/* we will allocate a single &squot;emergency&squot; dbdma cmd block to use if the&n;   tx status comes up &quot;DEAD&quot;.  This happens on some PowerComputing Pmac&n;   clones, either owing to a bug in dbdma or some interaction between&n;   IDE and sound.  However, this measure would deal with DEAD status if&n;   if appeared elsewhere.&n;&n;   for the sake of memory efficiency we&squot;ll allocate this cmd as part of&n;   the beep cmd stuff.&n;*/
DECL|variable|emergency_dbdma_cmd
r_static
r_volatile
r_struct
id|dbdma_cmd
op_star
id|emergency_dbdma_cmd
suffix:semicolon
macro_line|#ifdef CONFIG_PMAC_PBOOK
multiline_comment|/*&n; * Stuff for restoring after a sleep.&n; */
r_static
r_int
id|awacs_sleep_notify
c_func
(paren
r_struct
id|pmu_sleep_notifier
op_star
id|self
comma
r_int
id|when
)paren
suffix:semicolon
DECL|variable|awacs_sleep_notifier
r_struct
id|pmu_sleep_notifier
id|awacs_sleep_notifier
op_assign
(brace
id|awacs_sleep_notify
comma
id|SLEEP_LEVEL_SOUND
comma
)brace
suffix:semicolon
macro_line|#endif /* CONFIG_PMAC_PBOOK */
multiline_comment|/* for (soft) sample rate translations */
DECL|variable|expand_bal
r_int
id|expand_bal
suffix:semicolon
multiline_comment|/* Balance factor for expanding (not volume!) */
multiline_comment|/*** Low level stuff *********************************************************/
r_static
r_void
id|PMacOpen
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|PMacRelease
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
op_star
id|PMacAlloc
c_func
(paren
r_int
r_int
id|size
comma
r_int
id|flags
)paren
suffix:semicolon
r_static
r_void
id|PMacFree
c_func
(paren
r_void
op_star
id|ptr
comma
r_int
r_int
id|size
)paren
suffix:semicolon
r_static
r_int
id|PMacIrqInit
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef MODULE
r_static
r_void
id|PMacIrqCleanup
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|PMacSilence
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|PMacInit
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|PMacSetFormat
c_func
(paren
r_int
id|format
)paren
suffix:semicolon
r_static
r_int
id|PMacSetVolume
c_func
(paren
r_int
id|volume
)paren
suffix:semicolon
r_static
r_void
id|PMacPlay
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|PMacRecord
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|pmac_awacs_tx_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|devid
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|pmac_awacs_rx_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|devid
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|pmac_awacs_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|devid
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|awacs_write
c_func
(paren
r_int
id|val
)paren
suffix:semicolon
r_static
r_int
id|awacs_get_volume
c_func
(paren
r_int
id|reg
comma
r_int
id|lshift
)paren
suffix:semicolon
r_static
r_int
id|awacs_volume_setter
c_func
(paren
r_int
id|volume
comma
r_int
id|n
comma
r_int
id|mute
comma
r_int
id|lshift
)paren
suffix:semicolon
r_static
r_void
id|awacs_mksound
c_func
(paren
r_int
r_int
id|hz
comma
r_int
r_int
id|ticks
)paren
suffix:semicolon
r_static
r_void
id|awacs_nosound
c_func
(paren
r_int
r_int
id|xx
)paren
suffix:semicolon
multiline_comment|/*** Mid level stuff **********************************************************/
r_static
r_int
id|PMacMixerIoctl
c_func
(paren
id|u_int
id|cmd
comma
id|u_long
id|arg
)paren
suffix:semicolon
r_static
r_int
id|PMacWriteSqSetup
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|PMacReadSqSetup
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|PMacAbortRead
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|TRANS
id|transAwacsNormal
suffix:semicolon
r_extern
id|TRANS
id|transAwacsExpand
suffix:semicolon
r_extern
id|TRANS
id|transAwacsNormalRead
suffix:semicolon
r_extern
r_int
id|daca_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|daca_cleanup
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|daca_set_volume
c_func
(paren
id|uint
id|left_vol
comma
id|uint
id|right_vol
)paren
suffix:semicolon
r_extern
r_void
id|daca_get_volume
c_func
(paren
id|uint
op_star
id|left_vol
comma
id|uint
op_star
id|right_vol
)paren
suffix:semicolon
r_extern
r_int
id|daca_enter_sleep
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|daca_leave_sleep
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|tas_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|tas_cleanup
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|tumbler_set_volume
c_func
(paren
id|uint
id|left_vol
comma
id|uint
id|right_vol
)paren
suffix:semicolon
r_extern
r_void
id|tumbler_get_volume
c_func
(paren
id|uint
op_star
id|left_vol
comma
id|uint
op_star
id|right_vol
)paren
suffix:semicolon
r_extern
r_void
id|tumbler_set_treble
c_func
(paren
r_int
id|treble
)paren
suffix:semicolon
r_extern
r_void
id|tumbler_get_treble
c_func
(paren
r_int
op_star
id|treble
)paren
suffix:semicolon
r_extern
r_void
id|tumbler_set_bass
c_func
(paren
r_int
id|bass
)paren
suffix:semicolon
r_extern
r_void
id|tumbler_get_bass
c_func
(paren
r_int
op_star
id|bass
)paren
suffix:semicolon
r_extern
r_void
id|tumbler_set_pcm_lvl
c_func
(paren
r_int
id|pcm_lvl
)paren
suffix:semicolon
r_extern
r_void
id|tumbler_get_pcm_lvl
c_func
(paren
r_int
op_star
id|pcm_lvl
)paren
suffix:semicolon
r_extern
r_int
id|tumbler_enter_sleep
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|tumbler_leave_sleep
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|TRY_LOCK
mdefine_line|#define TRY_LOCK()&t;&bslash;&n;&t;if ((rc = down_interruptible(&amp;dmasound_sem)) != 0)&t;&bslash;&n;&t;&t;return rc;
DECL|macro|LOCK
mdefine_line|#define LOCK()&t;&t;down(&amp;dmasound_sem);
DECL|macro|UNLOCK
mdefine_line|#define UNLOCK()&t;up(&amp;dmasound_sem);
multiline_comment|/* We use different versions that the ones provided in dmasound.h&n; * &n; * FIXME: Use different names ;)&n; */
DECL|macro|IOCTL_IN
macro_line|#undef IOCTL_IN
DECL|macro|IOCTL_OUT
macro_line|#undef IOCTL_OUT
DECL|macro|IOCTL_IN
mdefine_line|#define IOCTL_IN(arg, ret)&t;&bslash;&n;&t;rc = get_user(ret, (int *)(arg)); &bslash;&n;&t;if (rc) break;
DECL|macro|IOCTL_OUT
mdefine_line|#define IOCTL_OUT(arg, ret)&t;&bslash;&n;&t;ioctl_return2((int *)(arg), ret)
DECL|function|ioctl_return2
r_static
r_inline
r_int
id|ioctl_return2
c_func
(paren
r_int
op_star
id|addr
comma
r_int
id|value
)paren
(brace
r_return
id|value
OL
l_int|0
ques
c_cond
id|value
suffix:colon
id|put_user
c_func
(paren
id|value
comma
id|addr
)paren
suffix:semicolon
)brace
multiline_comment|/*** AE - TUMBLER START *********************************************************/
DECL|variable|gpio_audio_reset
DECL|variable|gpio_audio_reset_pol
r_int
id|gpio_audio_reset
comma
id|gpio_audio_reset_pol
suffix:semicolon
DECL|variable|gpio_amp_mute
DECL|variable|gpio_amp_mute_pol
r_int
id|gpio_amp_mute
comma
id|gpio_amp_mute_pol
suffix:semicolon
DECL|variable|gpio_headphone_mute
DECL|variable|gpio_headphone_mute_pol
r_int
id|gpio_headphone_mute
comma
id|gpio_headphone_mute_pol
suffix:semicolon
DECL|variable|gpio_headphone_detect
DECL|variable|gpio_headphone_detect_pol
r_int
id|gpio_headphone_detect
comma
id|gpio_headphone_detect_pol
suffix:semicolon
DECL|variable|gpio_headphone_irq
r_int
id|gpio_headphone_irq
suffix:semicolon
r_int
DECL|function|setup_audio_gpio
id|setup_audio_gpio
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_char
op_star
id|compatible
comma
r_int
op_star
id|gpio_addr
comma
r_int
op_star
id|gpio_pol
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
id|u32
op_star
id|pp
suffix:semicolon
id|np
op_assign
id|find_devices
c_func
(paren
l_string|&quot;gpio&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|np
op_assign
id|np-&gt;child
suffix:semicolon
r_while
c_loop
(paren
id|np
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|name
)paren
(brace
r_char
op_star
id|property
op_assign
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;audio-gpio&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|property
op_ne
l_int|0
op_logical_and
id|strcmp
c_func
(paren
id|property
comma
id|name
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|compatible
op_logical_and
id|device_is_compatible
c_func
(paren
id|np
comma
id|compatible
)paren
)paren
r_break
suffix:semicolon
id|np
op_assign
id|np-&gt;sibling
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|np
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|pp
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;AAPL,address&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pp
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
op_star
id|gpio_addr
op_assign
(paren
op_star
id|pp
)paren
op_amp
l_int|0x0000ffff
suffix:semicolon
id|pp
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;audio-gpio-active-state&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp
)paren
op_star
id|gpio_pol
op_assign
op_star
id|pp
suffix:semicolon
r_else
op_star
id|gpio_pol
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;n_intrs
OG
l_int|0
)paren
r_return
id|np-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|write_audio_gpio
id|write_audio_gpio
c_func
(paren
r_int
id|gpio_addr
comma
r_int
id|data
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|gpio_addr
)paren
r_return
suffix:semicolon
id|pmac_call_feature
c_func
(paren
id|PMAC_FTR_WRITE_GPIO
comma
l_int|NULL
comma
id|gpio_addr
comma
id|data
ques
c_cond
l_int|0x05
suffix:colon
l_int|0x04
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|read_audio_gpio
id|read_audio_gpio
c_func
(paren
r_int
id|gpio_addr
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|gpio_addr
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
(paren
id|pmac_call_feature
c_func
(paren
id|PMAC_FTR_READ_GPIO
comma
l_int|NULL
comma
id|gpio_addr
comma
l_int|0
)paren
op_amp
l_int|0x02
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|headphone_intr
id|headphone_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|devid
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|read_audio_gpio
c_func
(paren
id|gpio_headphone_detect
)paren
op_eq
id|gpio_headphone_detect_pol
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Audio jack plugged, muting speakers.&bslash;n&quot;
)paren
suffix:semicolon
id|write_audio_gpio
c_func
(paren
id|gpio_amp_mute
comma
id|gpio_amp_mute_pol
)paren
suffix:semicolon
id|write_audio_gpio
c_func
(paren
id|gpio_headphone_mute
comma
op_logical_neg
id|gpio_headphone_mute_pol
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Audio jack unplugged, enabling speakers.&bslash;n&quot;
)paren
suffix:semicolon
id|write_audio_gpio
c_func
(paren
id|gpio_amp_mute
comma
op_logical_neg
id|gpio_amp_mute_pol
)paren
suffix:semicolon
id|write_audio_gpio
c_func
(paren
id|gpio_headphone_mute
comma
id|gpio_headphone_mute_pol
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Initialize tumbler */
r_static
r_int
DECL|function|awacs_tumbler_init
id|awacs_tumbler_init
c_func
(paren
r_void
)paren
(brace
id|setup_audio_gpio
c_func
(paren
l_string|&quot;audio-hw-reset&quot;
comma
l_int|NULL
comma
op_amp
id|gpio_audio_reset
comma
op_amp
id|gpio_audio_reset_pol
)paren
suffix:semicolon
id|setup_audio_gpio
c_func
(paren
l_string|&quot;amp-mute&quot;
comma
l_int|NULL
comma
op_amp
id|gpio_amp_mute
comma
op_amp
id|gpio_amp_mute_pol
)paren
suffix:semicolon
id|setup_audio_gpio
c_func
(paren
l_string|&quot;headphone-mute&quot;
comma
l_int|NULL
comma
op_amp
id|gpio_headphone_mute
comma
op_amp
id|gpio_headphone_mute_pol
)paren
suffix:semicolon
id|gpio_headphone_irq
op_assign
id|setup_audio_gpio
c_func
(paren
l_string|&quot;headphone-detect&quot;
comma
l_int|NULL
comma
op_amp
id|gpio_headphone_detect
comma
op_amp
id|gpio_headphone_detect_pol
)paren
suffix:semicolon
multiline_comment|/* Fix some broken OF entries in desktop machines */
r_if
c_cond
(paren
op_logical_neg
id|gpio_headphone_irq
)paren
id|gpio_headphone_irq
op_assign
id|setup_audio_gpio
c_func
(paren
l_int|NULL
comma
l_string|&quot;keywest-gpio15&quot;
comma
op_amp
id|gpio_headphone_detect
comma
op_amp
id|gpio_headphone_detect_pol
)paren
suffix:semicolon
id|write_audio_gpio
c_func
(paren
id|gpio_audio_reset
comma
id|gpio_audio_reset_pol
)paren
suffix:semicolon
id|wait_ms
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|write_audio_gpio
c_func
(paren
id|gpio_audio_reset
comma
op_logical_neg
id|gpio_audio_reset_pol
)paren
suffix:semicolon
id|wait_ms
c_func
(paren
l_int|100
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gpio_headphone_irq
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|gpio_headphone_irq
comma
id|headphone_intr
comma
l_int|0
comma
l_string|&quot;Headphone detect&quot;
comma
l_int|0
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;tumbler: Can&squot;t request headphone interrupt&bslash;n&quot;
)paren
suffix:semicolon
id|gpio_headphone_irq
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|u8
id|val
suffix:semicolon
multiline_comment|/* Activate headphone status interrupts */
id|val
op_assign
id|pmac_call_feature
c_func
(paren
id|PMAC_FTR_READ_GPIO
comma
l_int|NULL
comma
id|gpio_headphone_detect
comma
l_int|0
)paren
suffix:semicolon
id|pmac_call_feature
c_func
(paren
id|PMAC_FTR_WRITE_GPIO
comma
l_int|NULL
comma
id|gpio_headphone_detect
comma
id|val
op_or
l_int|0x80
)paren
suffix:semicolon
multiline_comment|/* Trigger it */
id|headphone_intr
c_func
(paren
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|gpio_headphone_irq
)paren
(brace
multiline_comment|/* Some machine enter this case ? */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;tumbler: Headphone detect IRQ not found, enabling all outputs !&bslash;n&quot;
)paren
suffix:semicolon
id|write_audio_gpio
c_func
(paren
id|gpio_amp_mute
comma
op_logical_neg
id|gpio_amp_mute_pol
)paren
suffix:semicolon
id|write_audio_gpio
c_func
(paren
id|gpio_headphone_mute
comma
op_logical_neg
id|gpio_headphone_mute_pol
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|awacs_tumbler_cleanup
id|awacs_tumbler_cleanup
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|gpio_headphone_irq
)paren
id|free_irq
c_func
(paren
id|gpio_headphone_irq
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*** AE - TUMBLER END *********************************************************/
multiline_comment|/*** Low level stuff *********************************************************/
multiline_comment|/*&n; * PCI PowerMac, with AWACS, Screamer, Burgundy, DACA or Tumbler and DBDMA.&n; */
DECL|function|PMacOpen
r_static
r_void
id|PMacOpen
c_func
(paren
r_void
)paren
(brace
id|MOD_INC_USE_COUNT
suffix:semicolon
)brace
DECL|function|PMacRelease
r_static
r_void
id|PMacRelease
c_func
(paren
r_void
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
DECL|function|PMacAlloc
r_static
r_void
op_star
id|PMacAlloc
c_func
(paren
r_int
r_int
id|size
comma
r_int
id|flags
)paren
(brace
r_return
id|kmalloc
c_func
(paren
id|size
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|PMacFree
r_static
r_void
id|PMacFree
c_func
(paren
r_void
op_star
id|ptr
comma
r_int
r_int
id|size
)paren
(brace
id|kfree
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
DECL|function|PMacIrqInit
r_static
r_int
id|__init
id|PMacIrqInit
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|awacs_irq
comma
id|pmac_awacs_intr
comma
l_int|0
comma
l_string|&quot;Built-in Sound misc&quot;
comma
l_int|0
)paren
op_logical_or
id|request_irq
c_func
(paren
id|awacs_tx_irq
comma
id|pmac_awacs_tx_intr
comma
l_int|0
comma
l_string|&quot;Built-in Sound out&quot;
comma
l_int|0
)paren
op_logical_or
id|request_irq
c_func
(paren
id|awacs_rx_irq
comma
id|pmac_awacs_rx_intr
comma
l_int|0
comma
l_string|&quot;Built-in Sound in&quot;
comma
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|PMacIrqCleanup
r_static
r_void
id|PMacIrqCleanup
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* turn off input &amp; output dma */
id|DBDMA_DO_STOP
c_func
(paren
id|awacs_txdma
)paren
suffix:semicolon
id|DBDMA_DO_STOP
c_func
(paren
id|awacs_rxdma
)paren
suffix:semicolon
multiline_comment|/* disable interrupts from awacs interface */
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;control
comma
id|in_le32
c_func
(paren
op_amp
id|awacs-&gt;control
)paren
op_amp
l_int|0xfff
)paren
suffix:semicolon
multiline_comment|/* Switch off the sound clock */
id|pmac_call_feature
c_func
(paren
id|PMAC_FTR_SOUND_CHIP_ENABLE
comma
id|awacs_node
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Make sure proper bits are set on pismo &amp; tipb */
r_if
c_cond
(paren
id|machine_is_compatible
c_func
(paren
l_string|&quot;PowerBook3,1&quot;
)paren
op_logical_or
id|machine_is_compatible
c_func
(paren
l_string|&quot;PowerBook3,2&quot;
)paren
)paren
(brace
id|awacs_reg
(braket
l_int|1
)braket
op_or_assign
id|MASK_PAROUT0
op_or
id|MASK_PAROUT1
suffix:semicolon
id|awacs_write
c_func
(paren
id|MASK_ADDR1
op_or
id|awacs_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|wait_ms
c_func
(paren
l_int|200
)paren
suffix:semicolon
)brace
id|free_irq
c_func
(paren
id|awacs_irq
comma
l_int|0
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|awacs_tx_irq
comma
l_int|0
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|awacs_rx_irq
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* all OF versions I&squot;ve seen use this value */
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|awacs
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|awacs_txdma
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|awacs_rxdma
)paren
suffix:semicolon
id|release_OF_resource
c_func
(paren
id|awacs_node
comma
l_int|0
)paren
suffix:semicolon
id|release_OF_resource
c_func
(paren
id|awacs_node
comma
l_int|1
)paren
suffix:semicolon
id|release_OF_resource
c_func
(paren
id|awacs_node
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|awacs_tx_cmd_space
)paren
id|kfree
c_func
(paren
id|awacs_tx_cmd_space
)paren
suffix:semicolon
r_if
c_cond
(paren
id|awacs_rx_cmd_space
)paren
id|kfree
c_func
(paren
id|awacs_rx_cmd_space
)paren
suffix:semicolon
r_if
c_cond
(paren
id|beep_dbdma_cmd_space
)paren
id|kfree
c_func
(paren
id|beep_dbdma_cmd_space
)paren
suffix:semicolon
r_if
c_cond
(paren
id|beep_buf
)paren
(brace
id|kfree
c_func
(paren
id|beep_buf
)paren
suffix:semicolon
id|kd_mksound
op_assign
id|orig_mksound
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PMAC_PBOOK
id|pmu_unregister_sleep_notifier
c_func
(paren
op_amp
id|awacs_sleep_notifier
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif /* MODULE */
DECL|function|PMacSilence
r_static
r_void
id|PMacSilence
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* turn off output dma */
id|DBDMA_DO_STOP
c_func
(paren
id|awacs_txdma
)paren
suffix:semicolon
)brace
DECL|variable|tumbler_freqs
r_static
r_int
id|tumbler_freqs
(braket
l_int|2
)braket
op_assign
(brace
l_int|48000
comma
l_int|44100
)brace
suffix:semicolon
DECL|variable|tumbler_freqs_ok
r_static
r_int
id|tumbler_freqs_ok
(braket
l_int|2
)braket
op_assign
(brace
l_int|1
comma
l_int|1
)brace
suffix:semicolon
multiline_comment|/* don&squot;t know what to do really - just have to leave it where&n; * OF left things&n;*/
DECL|function|tumbler_set_frame_rate
r_static
r_int
id|tumbler_set_frame_rate
c_func
(paren
r_void
)paren
(brace
id|dmasound.hard.speed
op_assign
l_int|44100
suffix:semicolon
id|awacs_rate_index
op_assign
l_int|0
suffix:semicolon
r_return
l_int|44100
suffix:semicolon
)brace
multiline_comment|/* don&squot;t know what to do really - just have to leave it where&n; * OF left things&n;*/
DECL|function|daca_set_frame_rate
r_static
r_int
id|daca_set_frame_rate
c_func
(paren
r_void
)paren
(brace
id|dmasound.hard.speed
op_assign
l_int|44100
suffix:semicolon
id|awacs_rate_index
op_assign
l_int|0
suffix:semicolon
r_return
l_int|44100
suffix:semicolon
)brace
DECL|variable|awacs_freqs
r_static
r_int
id|awacs_freqs
(braket
l_int|8
)braket
op_assign
(brace
l_int|44100
comma
l_int|29400
comma
l_int|22050
comma
l_int|17640
comma
l_int|14700
comma
l_int|11025
comma
l_int|8820
comma
l_int|7350
)brace
suffix:semicolon
DECL|variable|awacs_freqs_ok
r_static
r_int
id|awacs_freqs_ok
(braket
l_int|8
)braket
op_assign
(brace
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)brace
suffix:semicolon
DECL|function|awacs_set_frame_rate
r_static
r_int
id|awacs_set_frame_rate
c_func
(paren
r_int
id|desired
comma
r_int
id|catch_r
)paren
(brace
r_int
id|tolerance
comma
id|i
op_assign
l_int|8
suffix:semicolon
multiline_comment|/*&n;&t; * If we have a sample rate which is within catchRadius percent&n;&t; * of the requested value, we don&squot;t have to expand the samples.&n;&t; * Otherwise choose the next higher rate.&n;&t; * N.B.: burgundy awacs only works at 44100 Hz.&n;&t; */
r_do
(brace
id|tolerance
op_assign
id|catch_r
op_star
id|awacs_freqs
(braket
op_decrement
id|i
)braket
op_div
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|awacs_freqs_ok
(braket
id|i
)braket
op_logical_and
id|dmasound.soft.speed
op_le
id|awacs_freqs
(braket
id|i
)braket
op_plus
id|tolerance
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OG
l_int|0
)paren
suffix:semicolon
id|dmasound.hard.speed
op_assign
id|awacs_freqs
(braket
id|i
)braket
suffix:semicolon
id|awacs_rate_index
op_assign
id|i
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;control
comma
id|MASK_IEPC
op_or
(paren
id|i
op_lshift
l_int|8
)paren
op_or
l_int|0x11
)paren
suffix:semicolon
id|awacs_reg
(braket
l_int|1
)braket
op_assign
(paren
id|awacs_reg
(braket
l_int|1
)braket
op_amp
op_complement
id|MASK_SAMPLERATE
)paren
op_or
(paren
id|i
op_lshift
l_int|3
)paren
suffix:semicolon
id|awacs_write
c_func
(paren
id|awacs_reg
(braket
l_int|1
)braket
op_or
id|MASK_ADDR1
)paren
suffix:semicolon
r_return
id|dmasound.hard.speed
suffix:semicolon
)brace
DECL|variable|burgundy_frame_rates
r_static
r_int
id|burgundy_frame_rates
op_assign
l_int|1
suffix:semicolon
DECL|function|burgundy_set_frame_rate
r_static
r_int
id|burgundy_set_frame_rate
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUG_DMASOUND
r_if
c_cond
(paren
id|burgundy_frame_rates
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;dmasound_pmac: warning Burgundy had more than one frame rate&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|awacs_rate_index
op_assign
l_int|0
suffix:semicolon
id|awacs_reg
(braket
l_int|1
)braket
op_assign
(paren
id|awacs_reg
(braket
l_int|1
)braket
op_amp
op_complement
id|MASK_SAMPLERATE
)paren
suffix:semicolon
multiline_comment|/* XXX disable error interrupt on burgundy for now */
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;control
comma
id|MASK_IEPC
op_or
l_int|0
op_or
l_int|0x11
op_or
id|MASK_IEE
)paren
suffix:semicolon
r_return
l_int|44100
suffix:semicolon
)brace
DECL|function|set_frame_rate
r_static
r_int
id|set_frame_rate
c_func
(paren
r_int
id|desired
comma
r_int
id|catch_r
)paren
(brace
r_switch
c_cond
(paren
id|awacs_revision
)paren
(brace
r_case
id|AWACS_BURGUNDY
suffix:colon
id|dmasound.hard.speed
op_assign
id|burgundy_set_frame_rate
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AWACS_TUMBLER
suffix:colon
id|dmasound.hard.speed
op_assign
id|tumbler_set_frame_rate
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AWACS_DACA
suffix:colon
id|dmasound.hard.speed
op_assign
id|daca_set_frame_rate
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dmasound.hard.speed
op_assign
id|awacs_set_frame_rate
c_func
(paren
id|desired
comma
id|catch_r
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|dmasound.hard.speed
suffix:semicolon
)brace
r_static
r_void
DECL|function|awacs_recalibrate
id|awacs_recalibrate
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Sorry for the horrible delays... I hope to get that improved&n;&t; * by making the whole PM process asynchronous in a future version&n;&t; */
id|wait_ms
c_func
(paren
l_int|750
)paren
suffix:semicolon
id|awacs_reg
(braket
l_int|1
)braket
op_or_assign
id|MASK_CMUTE
op_or
id|MASK_AMUTE
suffix:semicolon
id|awacs_write
c_func
(paren
id|awacs_reg
(braket
l_int|1
)braket
op_or
id|MASK_RECALIBRATE
op_or
id|MASK_ADDR1
)paren
suffix:semicolon
id|wait_ms
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|awacs_write
c_func
(paren
id|awacs_reg
(braket
l_int|1
)braket
op_or
id|MASK_ADDR1
)paren
suffix:semicolon
)brace
DECL|function|PMacInit
r_static
r_void
id|PMacInit
c_func
(paren
r_void
)paren
(brace
r_int
id|tolerance
suffix:semicolon
r_switch
c_cond
(paren
id|dmasound.soft.format
)paren
(brace
r_case
id|AFMT_S16_LE
suffix:colon
r_case
id|AFMT_U16_LE
suffix:colon
r_if
c_cond
(paren
id|hw_can_byteswap
)paren
id|dmasound.hard.format
op_assign
id|AFMT_S16_LE
suffix:semicolon
r_else
id|dmasound.hard.format
op_assign
id|AFMT_S16_BE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dmasound.hard.format
op_assign
id|AFMT_S16_BE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dmasound.hard.stereo
op_assign
l_int|1
suffix:semicolon
id|dmasound.hard.size
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* set dmasound.hard.speed - on the basis of what we want (soft)&n;&t; * and the tolerance we&squot;ll allow.&n;&t;*/
id|set_frame_rate
c_func
(paren
id|dmasound.soft.speed
comma
id|catchRadius
)paren
suffix:semicolon
id|tolerance
op_assign
(paren
id|catchRadius
op_star
id|dmasound.hard.speed
)paren
op_div
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|dmasound.soft.speed
op_ge
id|dmasound.hard.speed
op_minus
id|tolerance
)paren
id|dmasound.trans_write
op_assign
op_amp
id|transAwacsNormal
suffix:semicolon
r_else
id|dmasound.trans_write
op_assign
op_amp
id|transAwacsExpand
suffix:semicolon
id|dmasound.trans_read
op_assign
op_amp
id|transAwacsNormalRead
suffix:semicolon
r_if
c_cond
(paren
id|hw_can_byteswap
op_logical_and
(paren
id|dmasound.hard.format
op_eq
id|AFMT_S16_LE
)paren
)paren
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;byteswap
comma
id|BS_VAL
)paren
suffix:semicolon
r_else
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;byteswap
comma
l_int|0
)paren
suffix:semicolon
id|expand_bal
op_assign
op_minus
id|dmasound.soft.speed
suffix:semicolon
)brace
DECL|function|PMacSetFormat
r_static
r_int
id|PMacSetFormat
c_func
(paren
r_int
id|format
)paren
(brace
r_int
id|size
suffix:semicolon
r_int
id|req_format
op_assign
id|format
suffix:semicolon
r_switch
c_cond
(paren
id|format
)paren
(brace
r_case
id|AFMT_QUERY
suffix:colon
r_return
id|dmasound.soft.format
suffix:semicolon
r_case
id|AFMT_MU_LAW
suffix:colon
r_case
id|AFMT_A_LAW
suffix:colon
r_case
id|AFMT_U8
suffix:colon
r_case
id|AFMT_S8
suffix:colon
id|size
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_S16_LE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|hw_can_byteswap
)paren
(brace
id|format
op_assign
id|AFMT_S16_BE
suffix:semicolon
)brace
r_case
id|AFMT_S16_BE
suffix:colon
id|size
op_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_U16_LE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|hw_can_byteswap
)paren
(brace
id|format
op_assign
id|AFMT_U16_BE
suffix:semicolon
)brace
r_case
id|AFMT_U16_BE
suffix:colon
id|size
op_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* :-) */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;dmasound: unknown format 0x%x, using AFMT_U8&bslash;n&quot;
comma
id|format
)paren
suffix:semicolon
id|size
op_assign
l_int|8
suffix:semicolon
id|format
op_assign
id|AFMT_U8
suffix:semicolon
)brace
r_if
c_cond
(paren
id|req_format
op_eq
id|format
)paren
(brace
id|dmasound.soft.format
op_assign
id|format
suffix:semicolon
id|dmasound.soft.size
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|dmasound.minDev
op_eq
id|SND_DEV_DSP
)paren
(brace
id|dmasound.dsp.format
op_assign
id|format
suffix:semicolon
id|dmasound.dsp.size
op_assign
id|size
suffix:semicolon
)brace
)brace
r_return
id|format
suffix:semicolon
)brace
DECL|macro|AWACS_VOLUME_TO_MASK
mdefine_line|#define AWACS_VOLUME_TO_MASK(x)&t;(15 - ((((x) - 1) * 15) / 99))
DECL|macro|AWACS_MASK_TO_VOLUME
mdefine_line|#define AWACS_MASK_TO_VOLUME(y)&t;(100 - ((y) * 99 / 15))
DECL|function|awacs_get_volume
r_static
r_int
id|awacs_get_volume
c_func
(paren
r_int
id|reg
comma
r_int
id|lshift
)paren
(brace
r_int
id|volume
suffix:semicolon
id|volume
op_assign
id|AWACS_MASK_TO_VOLUME
c_func
(paren
(paren
id|reg
op_rshift
id|lshift
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
id|volume
op_or_assign
id|AWACS_MASK_TO_VOLUME
c_func
(paren
id|reg
op_amp
l_int|0xf
)paren
op_lshift
l_int|8
suffix:semicolon
r_return
id|volume
suffix:semicolon
)brace
DECL|function|awacs_volume_setter
r_static
r_int
id|awacs_volume_setter
c_func
(paren
r_int
id|volume
comma
r_int
id|n
comma
r_int
id|mute
comma
r_int
id|lshift
)paren
(brace
r_int
id|r1
comma
id|rn
suffix:semicolon
r_if
c_cond
(paren
id|mute
op_logical_and
id|volume
op_eq
l_int|0
)paren
(brace
id|r1
op_assign
id|awacs_reg
(braket
l_int|1
)braket
op_or
id|mute
suffix:semicolon
)brace
r_else
(brace
id|r1
op_assign
id|awacs_reg
(braket
l_int|1
)braket
op_amp
op_complement
id|mute
suffix:semicolon
id|rn
op_assign
id|awacs_reg
(braket
id|n
)braket
op_amp
op_complement
(paren
l_int|0xf
op_or
(paren
l_int|0xf
op_lshift
id|lshift
)paren
)paren
suffix:semicolon
id|rn
op_or_assign
(paren
(paren
id|AWACS_VOLUME_TO_MASK
c_func
(paren
id|volume
op_amp
l_int|0xff
)paren
op_amp
l_int|0xf
)paren
op_lshift
id|lshift
)paren
suffix:semicolon
id|rn
op_or_assign
id|AWACS_VOLUME_TO_MASK
c_func
(paren
(paren
id|volume
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
op_amp
l_int|0xf
suffix:semicolon
id|awacs_reg
(braket
id|n
)braket
op_assign
id|rn
suffix:semicolon
id|awacs_write
c_func
(paren
(paren
id|n
op_lshift
l_int|12
)paren
op_or
id|rn
)paren
suffix:semicolon
id|volume
op_assign
id|awacs_get_volume
c_func
(paren
id|rn
comma
id|lshift
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r1
op_ne
id|awacs_reg
(braket
l_int|1
)braket
)paren
(brace
id|awacs_reg
(braket
l_int|1
)braket
op_assign
id|r1
suffix:semicolon
id|awacs_write
c_func
(paren
id|r1
op_or
id|MASK_ADDR1
)paren
suffix:semicolon
)brace
r_return
id|volume
suffix:semicolon
)brace
DECL|function|PMacSetVolume
r_static
r_int
id|PMacSetVolume
c_func
(paren
r_int
id|volume
)paren
(brace
r_return
id|awacs_volume_setter
c_func
(paren
id|volume
comma
l_int|2
comma
id|MASK_AMUTE
comma
l_int|6
)paren
suffix:semicolon
)brace
DECL|function|__PMacPlay
r_static
r_void
id|__PMacPlay
c_func
(paren
r_void
)paren
(brace
r_volatile
r_struct
id|dbdma_cmd
op_star
id|cp
suffix:semicolon
r_int
id|next_frg
comma
id|count
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* CHECK: how much of this *really* needs IRQs masked? */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|count
op_assign
l_int|300
suffix:semicolon
multiline_comment|/* &gt; two cycles at the lowest sample rate */
multiline_comment|/* what we want to send next */
id|next_frg
op_assign
(paren
id|write_sq.front
op_plus
id|write_sq.active
)paren
op_mod
id|write_sq.max_count
suffix:semicolon
r_if
c_cond
(paren
id|awacs_beep_state
)paren
(brace
multiline_comment|/* sound takes precedence over beeps */
multiline_comment|/* stop the dma channel */
id|out_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;control
comma
(paren
id|RUN
op_or
id|PAUSE
op_or
id|FLUSH
op_or
id|WAKE
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|in_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;status
)paren
op_amp
id|RUN
)paren
op_logical_and
id|count
op_decrement
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* FIXME: check that this is OK for other chip sets */
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;control
comma
(paren
id|in_le32
c_func
(paren
op_amp
id|awacs-&gt;control
)paren
op_amp
op_complement
l_int|0x1f00
)paren
op_or
(paren
id|awacs_rate_index
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw_can_byteswap
op_logical_and
(paren
id|dmasound.hard.format
op_eq
id|AFMT_S16_LE
)paren
)paren
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;byteswap
comma
id|BS_VAL
)paren
suffix:semicolon
r_else
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;byteswap
comma
l_int|0
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;cmdptr
comma
id|virt_to_bus
c_func
(paren
op_amp
(paren
id|awacs_tx_cmds
(braket
id|next_frg
)braket
)paren
)paren
)paren
suffix:semicolon
id|beep_playing
op_assign
l_int|0
suffix:semicolon
id|awacs_beep_state
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* this won&squot;t allow more than two frags to be in the output queue at&n;&t;   once. (or one, if the max frags is 2 - because count can&squot;t exceed&n;&t;   2 in that case)&n;&t;*/
r_while
c_loop
(paren
id|write_sq.active
OL
l_int|2
op_logical_and
id|write_sq.active
OL
id|write_sq.count
)paren
(brace
id|count
op_assign
(paren
id|write_sq.count
op_eq
id|write_sq.active
op_plus
l_int|1
)paren
ques
c_cond
id|write_sq.rear_size
suffix:colon
id|write_sq.block_size
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
id|write_sq.block_size
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|write_sq.syncing
)paren
multiline_comment|/* last block not yet filled,*/
r_break
suffix:semicolon
multiline_comment|/* and we&squot;re not syncing or POST-ed */
r_else
(brace
multiline_comment|/* pretend the block is full to force a new&n;&t;&t;&t;&t;   block to be started on the next write */
id|write_sq.rear_size
op_assign
id|write_sq.block_size
suffix:semicolon
id|write_sq.syncing
op_and_assign
op_complement
l_int|2
suffix:semicolon
multiline_comment|/* clear POST */
)brace
)brace
id|cp
op_assign
op_amp
id|awacs_tx_cmds
(braket
id|next_frg
)braket
suffix:semicolon
id|st_le16
c_func
(paren
op_amp
id|cp-&gt;req_count
comma
id|count
)paren
suffix:semicolon
id|st_le16
c_func
(paren
op_amp
id|cp-&gt;xfer_status
comma
l_int|0
)paren
suffix:semicolon
id|st_le16
c_func
(paren
op_amp
id|cp-&gt;command
comma
id|OUTPUT_MORE
op_plus
id|INTR_ALWAYS
)paren
suffix:semicolon
multiline_comment|/* put a STOP at the end of the queue - but only if we have&n;&t;&t;   space for it.  This means that, if we under-run and we only&n;&t;&t;   have two fragments, we might re-play sound from an existing&n;&t;&t;   queued frag.  I guess the solution to that is not to set two&n;&t;&t;   frags if you are likely to under-run...&n;&t;&t;*/
r_if
c_cond
(paren
id|write_sq.count
OL
id|write_sq.max_count
)paren
(brace
r_if
c_cond
(paren
op_increment
id|next_frg
op_ge
id|write_sq.max_count
)paren
id|next_frg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* wrap */
multiline_comment|/* if we get here then we&squot;ve underrun so we will stop*/
id|st_le16
c_func
(paren
op_amp
id|awacs_tx_cmds
(braket
id|next_frg
)braket
dot
id|command
comma
id|DBDMA_STOP
)paren
suffix:semicolon
)brace
multiline_comment|/* set the dbdma controller going, if it is not already */
r_if
c_cond
(paren
id|write_sq.active
op_eq
l_int|0
)paren
id|out_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;cmdptr
comma
id|virt_to_bus
c_func
(paren
id|cp
)paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|in_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;status
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;control
comma
(paren
(paren
id|RUN
op_or
id|WAKE
)paren
op_lshift
l_int|16
)paren
op_plus
(paren
id|RUN
op_or
id|WAKE
)paren
)paren
suffix:semicolon
op_increment
id|write_sq.active
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|PMacPlay
r_static
r_void
id|PMacPlay
c_func
(paren
r_void
)paren
(brace
id|LOCK
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|awacs_sleeping
)paren
id|__PMacPlay
c_func
(paren
)paren
suffix:semicolon
id|UNLOCK
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|PMacRecord
r_static
r_void
id|PMacRecord
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|read_sq.active
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* This is all we have to do......Just start it up.&n;&t;*/
id|out_le32
c_func
(paren
op_amp
id|awacs_rxdma-&gt;control
comma
(paren
(paren
id|RUN
op_or
id|WAKE
)paren
op_lshift
l_int|16
)paren
op_plus
(paren
id|RUN
op_or
id|WAKE
)paren
)paren
suffix:semicolon
id|read_sq.active
op_assign
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* if the TX status comes up &quot;DEAD&quot; - reported on some Power Computing machines&n;   we need to re-start the dbdma - but from a different physical start address&n;   and with a different transfer length.  It would get very messy to do this&n;   with the normal dbdma_cmd blocks - we would have to re-write the buffer start&n;   addresses each time.  So, we will keep a single dbdma_cmd block which can be&n;   fiddled with.&n;   When DEAD status is first reported the content of the faulted dbdma block is&n;   copied into the emergency buffer and we note that the buffer is in use.&n;   we then bump the start physical address by the amount that was successfully&n;   output before it died.&n;   On any subsequent DEAD result we just do the bump-ups (we know that we are&n;   already using the emergency dbdma_cmd).&n;   CHECK: this just tries to &quot;do it&quot;.  It is possible that we should abandon&n;   xfers when the number of residual bytes gets below a certain value - I can&n;   see that this might cause a loop-forever if too small a transfer causes&n;   DEAD status.  However this is a TODO for now - we&squot;ll see what gets reported.&n;   When we get a successful transfer result with the emergency buffer we just&n;   pretend that it completed using the original dmdma_cmd and carry on.  The&n;   &squot;next_cmd&squot; field will already point back to the original loop of blocks.&n;*/
r_static
r_void
DECL|function|pmac_awacs_tx_intr
id|pmac_awacs_tx_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|devid
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
op_assign
id|write_sq.front
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_volatile
r_struct
id|dbdma_cmd
op_star
id|cp
suffix:semicolon
multiline_comment|/* != 0 when we are dealing with a DEAD xfer */
r_static
r_int
id|emergency_in_use
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|write_sq.active
OG
l_int|0
)paren
(brace
multiline_comment|/* we expect to have done something*/
r_if
c_cond
(paren
id|emergency_in_use
)paren
multiline_comment|/* we are dealing with DEAD xfer */
id|cp
op_assign
id|emergency_dbdma_cmd
suffix:semicolon
r_else
id|cp
op_assign
op_amp
id|awacs_tx_cmds
(braket
id|i
)braket
suffix:semicolon
id|stat
op_assign
id|ld_le16
c_func
(paren
op_amp
id|cp-&gt;xfer_status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|DEAD
)paren
(brace
r_int
r_int
id|req
comma
id|res
suffix:semicolon
r_int
r_int
id|phy
suffix:semicolon
macro_line|#ifdef DEBUG_DMASOUND
id|printk
c_func
(paren
l_string|&quot;dmasound_pmac: tx-irq: xfer died - patching it up...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* to clear DEAD status we must first clear RUN&n;&t;&t;&t;   set it to quiescent to be on the safe side */
(paren
r_void
)paren
id|in_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;status
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;control
comma
(paren
id|RUN
op_or
id|PAUSE
op_or
id|FLUSH
op_or
id|WAKE
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|write_sq.died
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|emergency_in_use
)paren
(brace
multiline_comment|/* new problem */
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|emergency_dbdma_cmd
comma
(paren
r_void
op_star
)paren
id|cp
comma
r_sizeof
(paren
r_struct
id|dbdma_cmd
)paren
)paren
suffix:semicolon
id|emergency_in_use
op_assign
l_int|1
suffix:semicolon
id|cp
op_assign
id|emergency_dbdma_cmd
suffix:semicolon
)brace
multiline_comment|/* now bump the values to reflect the amount&n;&t;&t;&t;   we haven&squot;t yet shifted */
id|req
op_assign
id|ld_le16
c_func
(paren
op_amp
id|cp-&gt;req_count
)paren
suffix:semicolon
id|res
op_assign
id|ld_le16
c_func
(paren
op_amp
id|cp-&gt;res_count
)paren
suffix:semicolon
id|phy
op_assign
id|ld_le32
c_func
(paren
op_amp
id|cp-&gt;phy_addr
)paren
suffix:semicolon
id|phy
op_add_assign
(paren
id|req
op_minus
id|res
)paren
suffix:semicolon
id|st_le16
c_func
(paren
op_amp
id|cp-&gt;req_count
comma
id|res
)paren
suffix:semicolon
id|st_le16
c_func
(paren
op_amp
id|cp-&gt;res_count
comma
l_int|0
)paren
suffix:semicolon
id|st_le16
c_func
(paren
op_amp
id|cp-&gt;xfer_status
comma
l_int|0
)paren
suffix:semicolon
id|st_le32
c_func
(paren
op_amp
id|cp-&gt;phy_addr
comma
id|phy
)paren
suffix:semicolon
id|st_le32
c_func
(paren
op_amp
id|cp-&gt;cmd_dep
comma
id|virt_to_bus
c_func
(paren
op_amp
id|awacs_tx_cmds
(braket
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|write_sq.max_count
)braket
)paren
)paren
suffix:semicolon
id|st_le16
c_func
(paren
op_amp
id|cp-&gt;command
comma
id|OUTPUT_MORE
op_or
id|BR_ALWAYS
op_or
id|INTR_ALWAYS
)paren
suffix:semicolon
multiline_comment|/* point at our patched up command block */
id|out_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;cmdptr
comma
id|virt_to_bus
c_func
(paren
id|cp
)paren
)paren
suffix:semicolon
multiline_comment|/* we must re-start the controller */
(paren
r_void
)paren
id|in_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;status
)paren
suffix:semicolon
multiline_comment|/* should complete clearing the DEAD status */
id|out_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;control
comma
(paren
(paren
id|RUN
op_or
id|WAKE
)paren
op_lshift
l_int|16
)paren
op_plus
(paren
id|RUN
op_or
id|WAKE
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* this block is still going */
)brace
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|ACTIVE
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* this frame is still going */
r_if
c_cond
(paren
id|emergency_in_use
)paren
id|emergency_in_use
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* done that */
op_decrement
id|write_sq.count
suffix:semicolon
op_decrement
id|write_sq.active
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|i
op_ge
id|write_sq.max_count
)paren
id|i
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if we stopped and we were not sync-ing - then we under-ran */
r_if
c_cond
(paren
id|write_sq.syncing
op_eq
l_int|0
)paren
(brace
id|stat
op_assign
id|in_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;status
)paren
suffix:semicolon
multiline_comment|/* we hit the dbdma_stop */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|ACTIVE
)paren
op_eq
l_int|0
)paren
(brace
id|write_sq.xruns
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* if we used some data up then wake the writer to supply some more*/
r_if
c_cond
(paren
id|i
op_ne
id|write_sq.front
)paren
id|WAKE_UP
c_func
(paren
id|write_sq.action_queue
)paren
suffix:semicolon
id|write_sq.front
op_assign
id|i
suffix:semicolon
multiline_comment|/* but make sure we funnel what we&squot;ve already got */
"&bslash;"
r_if
c_cond
(paren
op_logical_neg
id|awacs_sleeping
)paren
id|__PMacPlay
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* make the wake-on-empty conditional on syncing */
r_if
c_cond
(paren
op_logical_neg
id|write_sq.active
op_logical_and
(paren
id|write_sq.syncing
op_amp
l_int|1
)paren
)paren
id|WAKE_UP
c_func
(paren
id|write_sq.sync_queue
)paren
suffix:semicolon
multiline_comment|/* any time we&squot;re empty */
)brace
r_static
r_void
DECL|function|pmac_awacs_rx_intr
id|pmac_awacs_rx_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|devid
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|stat
suffix:semicolon
multiline_comment|/* For some reason on my PowerBook G3, I get one interrupt&n;&t; * when the interrupt vector is installed (like something is&n;&t; * pending).  This happens before the dbdma is initialized by&n;&t; * us, so I just check the command pointer and if it is zero,&n;&t; * just blow it off.&n;&t; */
r_if
c_cond
(paren
id|in_le32
c_func
(paren
op_amp
id|awacs_rxdma-&gt;cmdptr
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* We also want to blow &squot;em off when shutting down.&n;&t;*/
r_if
c_cond
(paren
id|read_sq.active
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* Check multiple buffers in case we were held off from&n;&t; * interrupt processing for a long time.  Geeze, I really hope&n;&t; * this doesn&squot;t happen.&n;&t; */
r_while
c_loop
(paren
(paren
id|stat
op_assign
id|awacs_rx_cmds
(braket
id|read_sq.rear
)braket
dot
id|xfer_status
)paren
)paren
(brace
multiline_comment|/* if we got a &quot;DEAD&quot; status then just log it for now.&n;&t;&t;   and try to restart dma.&n;&t;&t;   TODO: figure out how best to fix it up&n;&t;&t;*/
r_if
c_cond
(paren
id|stat
op_amp
id|DEAD
)paren
(brace
macro_line|#ifdef DEBUG_DMASOUND
id|printk
c_func
(paren
l_string|&quot;dmasound_pmac: rx-irq: DIED - attempting resurection&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* to clear DEAD status we must first clear RUN&n;&t;&t;&t;   set it to quiescent to be on the safe side */
(paren
r_void
)paren
id|in_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;status
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;control
comma
(paren
id|RUN
op_or
id|PAUSE
op_or
id|FLUSH
op_or
id|WAKE
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|awacs_rx_cmds
(braket
id|read_sq.rear
)braket
dot
id|xfer_status
op_assign
l_int|0
suffix:semicolon
id|awacs_rx_cmds
(braket
id|read_sq.rear
)braket
dot
id|res_count
op_assign
l_int|0
suffix:semicolon
id|read_sq.died
op_increment
suffix:semicolon
(paren
r_void
)paren
id|in_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;status
)paren
suffix:semicolon
multiline_comment|/* re-start the same block */
id|out_le32
c_func
(paren
op_amp
id|awacs_rxdma-&gt;cmdptr
comma
id|virt_to_bus
c_func
(paren
op_amp
id|awacs_rx_cmds
(braket
id|read_sq.rear
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/* we must re-start the controller */
(paren
r_void
)paren
id|in_le32
c_func
(paren
op_amp
id|awacs_rxdma-&gt;status
)paren
suffix:semicolon
multiline_comment|/* should complete clearing the DEAD status */
id|out_le32
c_func
(paren
op_amp
id|awacs_rxdma-&gt;control
comma
(paren
(paren
id|RUN
op_or
id|WAKE
)paren
op_lshift
l_int|16
)paren
op_plus
(paren
id|RUN
op_or
id|WAKE
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* try this block again */
)brace
multiline_comment|/* Clear status and move on to next buffer.&n;&t;&t;*/
id|awacs_rx_cmds
(braket
id|read_sq.rear
)braket
dot
id|xfer_status
op_assign
l_int|0
suffix:semicolon
id|read_sq.rear
op_increment
suffix:semicolon
multiline_comment|/* Wrap the buffer ring.&n;&t;&t;*/
r_if
c_cond
(paren
id|read_sq.rear
op_ge
id|read_sq.max_active
)paren
id|read_sq.rear
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If we have caught up to the front buffer, bump it.&n;&t;&t; * This will cause weird (but not fatal) results if the&n;&t;&t; * read loop is currently using this buffer.  The user is&n;&t;&t; * behind in this case anyway, so weird things are going&n;&t;&t; * to happen.&n;&t;&t; */
r_if
c_cond
(paren
id|read_sq.rear
op_eq
id|read_sq.front
)paren
(brace
id|read_sq.front
op_increment
suffix:semicolon
id|read_sq.xruns
op_increment
suffix:semicolon
multiline_comment|/* we overan */
r_if
c_cond
(paren
id|read_sq.front
op_ge
id|read_sq.max_active
)paren
id|read_sq.front
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|WAKE_UP
c_func
(paren
id|read_sq.action_queue
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|pmac_awacs_intr
id|pmac_awacs_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|devid
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|ctrl
op_assign
id|in_le32
c_func
(paren
op_amp
id|awacs-&gt;control
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctrl
op_amp
id|MASK_PORTCHG
)paren
(brace
multiline_comment|/* do something when headphone is plugged/unplugged? */
)brace
r_if
c_cond
(paren
id|ctrl
op_amp
id|MASK_CNTLERR
)paren
(brace
r_int
id|err
op_assign
(paren
id|in_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_stat
)paren
op_amp
id|MASK_ERRCODE
)paren
op_rshift
l_int|16
suffix:semicolon
multiline_comment|/* CHECK: we just swallow burgundy errors at the moment..*/
r_if
c_cond
(paren
id|err
op_ne
l_int|0
op_logical_and
id|awacs_revision
op_ne
id|AWACS_BURGUNDY
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;dmasound_pmac: error %x&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/* Writing 1s to the CNTLERR and PORTCHG bits clears them... */
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;control
comma
id|ctrl
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|awacs_write
id|awacs_write
c_func
(paren
r_int
id|val
)paren
(brace
r_int
id|count
op_assign
l_int|300
suffix:semicolon
r_if
c_cond
(paren
id|awacs_revision
op_ge
id|AWACS_DACA
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
(paren
id|in_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_ctrl
)paren
op_amp
id|MASK_NEWECMD
)paren
op_logical_and
id|count
op_decrement
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* timeout is &gt; 2 samples at lowest rate */
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_ctrl
comma
id|val
op_or
(paren
id|awacs_subframe
op_lshift
l_int|22
)paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|in_le32
c_func
(paren
op_amp
id|awacs-&gt;byteswap
)paren
suffix:semicolon
)brace
multiline_comment|/* this is called when the beep timer expires... it will be called even&n;   if the beep has been overidden by other sound output.&n;*/
DECL|function|awacs_nosound
r_static
r_void
id|awacs_nosound
c_func
(paren
r_int
r_int
id|xx
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|count
op_assign
l_int|600
suffix:semicolon
multiline_comment|/* &gt; four samples at lowest rate */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|beep_playing
)paren
(brace
id|st_le16
c_func
(paren
op_amp
id|beep_dbdma_cmd-&gt;command
comma
id|DBDMA_STOP
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;control
comma
(paren
id|RUN
op_or
id|PAUSE
op_or
id|FLUSH
op_or
id|WAKE
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|in_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;status
)paren
op_amp
id|RUN
)paren
op_logical_and
id|count
op_decrement
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* FIXME: check this is OK for DACA, Tumbler */
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;control
comma
(paren
id|in_le32
c_func
(paren
op_amp
id|awacs-&gt;control
)paren
op_amp
op_complement
l_int|0x1f00
)paren
op_or
(paren
id|awacs_rate_index
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw_can_byteswap
op_logical_and
(paren
id|dmasound.hard.format
op_eq
id|AFMT_S16_LE
)paren
)paren
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;byteswap
comma
id|BS_VAL
)paren
suffix:semicolon
r_else
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;byteswap
comma
l_int|0
)paren
suffix:semicolon
id|beep_playing
op_assign
l_int|0
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|beep_timer
r_static
r_struct
id|timer_list
id|beep_timer
op_assign
(brace
id|function
suffix:colon
id|awacs_nosound
)brace
suffix:semicolon
multiline_comment|/* we generate the beep with a single dbdma command that loops a buffer&n;   forever - without generating interrupts.&n;   So, to stop it you have to stop dma output as per awacs_nosound.&n;*/
DECL|function|awacs_mksound
r_static
r_void
id|awacs_mksound
c_func
(paren
r_int
r_int
id|hz
comma
r_int
r_int
id|ticks
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|beep_speed
op_assign
l_int|0
suffix:semicolon
r_int
id|srate
suffix:semicolon
r_int
id|period
comma
id|ncycles
comma
id|nsamples
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|f
suffix:semicolon
r_int
op_star
id|p
suffix:semicolon
r_static
r_int
id|beep_hz_cache
suffix:semicolon
r_static
r_int
id|beep_nsamples_cache
suffix:semicolon
r_static
r_int
id|beep_volume_cache
suffix:semicolon
r_if
c_cond
(paren
id|beep_buf
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* quick-hack fix for DACA, Burgundy &amp; Tumbler */
r_if
c_cond
(paren
id|awacs_revision
op_ge
id|AWACS_DACA
)paren
(brace
id|srate
op_assign
l_int|44100
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
op_logical_and
id|awacs_freqs
(braket
id|i
)braket
op_ge
id|BEEP_SRATE
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|awacs_freqs_ok
(braket
id|i
)braket
)paren
id|beep_speed
op_assign
id|i
suffix:semicolon
id|srate
op_assign
id|awacs_freqs
(braket
id|beep_speed
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hz
op_le
id|srate
op_div
id|BEEP_BUFLEN
op_logical_or
id|hz
OG
id|srate
op_div
l_int|2
)paren
(brace
macro_line|#if 1
multiline_comment|/* this is a hack for broken X server code */
id|hz
op_assign
l_int|750
suffix:semicolon
id|ticks
op_assign
l_int|12
suffix:semicolon
macro_line|#else
multiline_comment|/* cancel beep currently playing */
id|awacs_nosound
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#endif
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|beep_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ticks
)paren
(brace
id|beep_timer.expires
op_assign
id|jiffies
op_plus
id|ticks
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|beep_timer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|beep_playing
op_logical_or
id|write_sq.active
op_logical_or
id|beep_buf
op_eq
l_int|NULL
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* too hard, sorry :-( */
)brace
id|beep_playing
op_assign
l_int|1
suffix:semicolon
id|st_le16
c_func
(paren
op_amp
id|beep_dbdma_cmd-&gt;command
comma
id|OUTPUT_MORE
op_plus
id|BR_ALWAYS
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hz
op_eq
id|beep_hz_cache
op_logical_and
id|beep_vol
op_eq
id|beep_volume_cache
)paren
(brace
id|nsamples
op_assign
id|beep_nsamples_cache
suffix:semicolon
)brace
r_else
(brace
id|period
op_assign
id|srate
op_star
l_int|256
op_div
id|hz
suffix:semicolon
multiline_comment|/* fixed point */
id|ncycles
op_assign
id|BEEP_BUFLEN
op_star
l_int|256
op_div
id|period
suffix:semicolon
id|nsamples
op_assign
(paren
id|period
op_star
id|ncycles
)paren
op_rshift
l_int|8
suffix:semicolon
id|f
op_assign
id|ncycles
op_star
l_int|65536
op_div
id|nsamples
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
id|beep_buf
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nsamples
suffix:semicolon
op_increment
id|i
comma
id|p
op_add_assign
l_int|2
)paren
(brace
id|p
(braket
l_int|0
)braket
op_assign
id|p
(braket
l_int|1
)braket
op_assign
id|beep_wform
(braket
id|j
op_rshift
l_int|8
)braket
op_star
id|beep_vol
suffix:semicolon
id|j
op_assign
(paren
id|j
op_plus
id|f
)paren
op_amp
l_int|0xffff
suffix:semicolon
)brace
id|beep_hz_cache
op_assign
id|hz
suffix:semicolon
id|beep_volume_cache
op_assign
id|beep_vol
suffix:semicolon
id|beep_nsamples_cache
op_assign
id|nsamples
suffix:semicolon
)brace
id|st_le16
c_func
(paren
op_amp
id|beep_dbdma_cmd-&gt;req_count
comma
id|nsamples
op_star
l_int|4
)paren
suffix:semicolon
id|st_le16
c_func
(paren
op_amp
id|beep_dbdma_cmd-&gt;xfer_status
comma
l_int|0
)paren
suffix:semicolon
id|st_le32
c_func
(paren
op_amp
id|beep_dbdma_cmd-&gt;cmd_dep
comma
id|virt_to_bus
c_func
(paren
id|beep_dbdma_cmd
)paren
)paren
suffix:semicolon
id|st_le32
c_func
(paren
op_amp
id|beep_dbdma_cmd-&gt;phy_addr
comma
id|virt_to_bus
c_func
(paren
id|beep_buf
)paren
)paren
suffix:semicolon
id|awacs_beep_state
op_assign
l_int|1
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|beep_playing
)paren
(brace
multiline_comment|/* i.e. haven&squot;t been terminated already */
r_int
id|count
op_assign
l_int|300
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;control
comma
(paren
id|RUN
op_or
id|WAKE
op_or
id|FLUSH
op_or
id|PAUSE
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|in_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;status
)paren
op_amp
id|RUN
)paren
op_logical_and
id|count
op_decrement
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* timeout &gt; 2 samples at lowest rate*/
multiline_comment|/* FIXME: check this is OK on DACA, Tumbler */
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;control
comma
(paren
id|in_le32
c_func
(paren
op_amp
id|awacs-&gt;control
)paren
op_amp
op_complement
l_int|0x1f00
)paren
op_or
(paren
id|beep_speed
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;byteswap
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* force BE */
id|out_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;cmdptr
comma
id|virt_to_bus
c_func
(paren
id|beep_dbdma_cmd
)paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|in_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;status
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;control
comma
id|RUN
op_or
(paren
id|RUN
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* used in init and for wake-up */
r_static
r_void
DECL|function|load_awacs
id|load_awacs
c_func
(paren
r_void
)paren
(brace
id|awacs_write
c_func
(paren
id|awacs_reg
(braket
l_int|0
)braket
op_plus
id|MASK_ADDR0
)paren
suffix:semicolon
id|awacs_write
c_func
(paren
id|awacs_reg
(braket
l_int|1
)braket
op_plus
id|MASK_ADDR1
)paren
suffix:semicolon
id|awacs_write
c_func
(paren
id|awacs_reg
(braket
l_int|2
)braket
op_plus
id|MASK_ADDR2
)paren
suffix:semicolon
id|awacs_write
c_func
(paren
id|awacs_reg
(braket
l_int|4
)braket
op_plus
id|MASK_ADDR4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|awacs_revision
op_eq
id|AWACS_SCREAMER
)paren
(brace
id|awacs_write
c_func
(paren
id|awacs_reg
(braket
l_int|5
)braket
op_plus
id|MASK_ADDR5
)paren
suffix:semicolon
id|wait_ms
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|awacs_write
c_func
(paren
id|awacs_reg
(braket
l_int|6
)braket
op_plus
id|MASK_ADDR6
)paren
suffix:semicolon
id|wait_ms
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|awacs_write
c_func
(paren
id|awacs_reg
(braket
l_int|1
)braket
op_plus
id|MASK_ADDR1
)paren
suffix:semicolon
id|awacs_write
c_func
(paren
id|awacs_reg
(braket
l_int|7
)braket
op_plus
id|MASK_ADDR7
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hw_can_byteswap
op_logical_and
(paren
id|dmasound.hard.format
op_eq
id|AFMT_S16_LE
)paren
)paren
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;byteswap
comma
id|BS_VAL
)paren
suffix:semicolon
r_else
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;byteswap
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PMAC_PBOOK
multiline_comment|/*&n; * Save state when going to sleep, restore it afterwards.&n; */
multiline_comment|/* FIXME: sort out disabling/re-enabling of read stuff as well */
DECL|function|awacs_sleep_notify
r_static
r_int
id|awacs_sleep_notify
c_func
(paren
r_struct
id|pmu_sleep_notifier
op_star
id|self
comma
r_int
id|when
)paren
(brace
r_switch
c_cond
(paren
id|when
)paren
(brace
r_case
id|PBOOK_SLEEP_NOW
suffix:colon
id|LOCK
c_func
(paren
)paren
suffix:semicolon
id|awacs_sleeping
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Tell the rest of the driver we are now going to sleep */
id|mb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|awacs_revision
op_eq
id|AWACS_SCREAMER
op_logical_or
id|awacs_revision
op_eq
id|AWACS_AWACS
)paren
(brace
id|awacs_reg1_save
op_assign
id|awacs_reg
(braket
l_int|1
)braket
suffix:semicolon
id|awacs_reg
(braket
l_int|1
)braket
op_or_assign
id|MASK_AMUTE
op_or
id|MASK_CMUTE
suffix:semicolon
id|awacs_write
c_func
(paren
id|MASK_ADDR1
op_or
id|awacs_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|PMacSilence
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* stop rx - if going - a bit of a daft user... but */
id|out_le32
c_func
(paren
op_amp
id|awacs_rxdma-&gt;control
comma
(paren
id|RUN
op_or
id|WAKE
op_or
id|FLUSH
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
multiline_comment|/* deny interrupts */
r_switch
c_cond
(paren
id|awacs_revision
)paren
(brace
r_case
id|AWACS_TUMBLER
suffix:colon
id|tumbler_enter_sleep
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Stub for now */
r_break
suffix:semicolon
r_case
id|AWACS_DACA
suffix:colon
id|daca_enter_sleep
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AWACS_BURGUNDY
suffix:colon
r_break
suffix:semicolon
r_case
id|AWACS_SCREAMER
suffix:colon
r_case
id|AWACS_AWACS
suffix:colon
r_default
suffix:colon
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;control
comma
l_int|0x11
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|disable_irq
c_func
(paren
id|awacs_irq
)paren
suffix:semicolon
id|disable_irq
c_func
(paren
id|awacs_tx_irq
)paren
suffix:semicolon
id|disable_irq
c_func
(paren
id|awacs_rx_irq
)paren
suffix:semicolon
multiline_comment|/* Disable sound clock */
id|pmac_call_feature
c_func
(paren
id|PMAC_FTR_SOUND_CHIP_ENABLE
comma
id|awacs_node
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* According to Darwin, we do that after turning off the sound&n;&t;&t; * chip clock. All this will have to be cleaned up once we properly&n;&t;&t; * parse the OF sound-objects&n;&t;&t; */
r_if
c_cond
(paren
id|machine_is_compatible
c_func
(paren
l_string|&quot;PowerBook3,1&quot;
)paren
op_logical_or
id|machine_is_compatible
c_func
(paren
l_string|&quot;PowerBook3,2&quot;
)paren
)paren
(brace
id|awacs_reg
(braket
l_int|1
)braket
op_or_assign
id|MASK_PAROUT0
op_or
id|MASK_PAROUT1
suffix:semicolon
id|awacs_write
c_func
(paren
id|MASK_ADDR1
op_or
id|awacs_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|wait_ms
c_func
(paren
l_int|200
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PBOOK_WAKE
suffix:colon
multiline_comment|/* Enable sound clock */
id|pmac_call_feature
c_func
(paren
id|PMAC_FTR_SOUND_CHIP_ENABLE
comma
id|awacs_node
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|machine_is_compatible
c_func
(paren
l_string|&quot;PowerBook3,1&quot;
)paren
op_logical_or
id|machine_is_compatible
c_func
(paren
l_string|&quot;PowerBook3,2&quot;
)paren
)paren
(brace
id|wait_ms
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|awacs_reg
(braket
l_int|1
)braket
op_and_assign
op_complement
(paren
id|MASK_PAROUT0
op_or
id|MASK_PAROUT1
)paren
suffix:semicolon
id|awacs_write
c_func
(paren
id|MASK_ADDR1
op_or
id|awacs_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|wait_ms
c_func
(paren
l_int|300
)paren
suffix:semicolon
)brace
r_else
id|wait_ms
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* restore settings */
r_switch
c_cond
(paren
id|awacs_revision
)paren
(brace
r_case
id|AWACS_TUMBLER
suffix:colon
id|headphone_intr
c_func
(paren
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|tumbler_leave_sleep
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Stub for now */
r_break
suffix:semicolon
r_case
id|AWACS_DACA
suffix:colon
id|wait_ms
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Check this !!! */
id|daca_leave_sleep
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* dont know how yet */
r_case
id|AWACS_BURGUNDY
suffix:colon
r_break
suffix:semicolon
r_case
id|AWACS_SCREAMER
suffix:colon
r_case
id|AWACS_AWACS
suffix:colon
r_default
suffix:colon
id|load_awacs
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Recalibrate chip */
r_if
c_cond
(paren
id|awacs_revision
op_eq
id|AWACS_SCREAMER
)paren
id|awacs_recalibrate
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Make sure dma is stopped */
id|PMacSilence
c_func
(paren
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|awacs_irq
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|awacs_tx_irq
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|awacs_rx_irq
)paren
suffix:semicolon
multiline_comment|/* OK, allow ints back again */
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;control
comma
id|MASK_IEPC
op_or
(paren
id|awacs_rate_index
op_lshift
l_int|8
)paren
op_or
l_int|0x11
op_or
(paren
id|awacs_revision
OL
id|AWACS_DACA
ques
c_cond
id|MASK_IEE
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|macio_base
op_logical_and
id|is_pbook_g3
)paren
(brace
multiline_comment|/* FIXME: should restore the setup we had...*/
id|out_8
c_func
(paren
id|macio_base
op_plus
l_int|0x37
comma
l_int|3
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|is_pbook_3X00
)paren
(brace
id|in_8
c_func
(paren
id|latch_base
op_plus
l_int|0x190
)paren
suffix:semicolon
)brace
multiline_comment|/* Remove mute */
r_if
c_cond
(paren
id|awacs_revision
op_eq
id|AWACS_SCREAMER
op_logical_or
id|awacs_revision
op_eq
id|AWACS_AWACS
)paren
(brace
id|awacs_reg
(braket
l_int|1
)braket
op_assign
id|awacs_reg1_save
suffix:semicolon
id|awacs_write
c_func
(paren
id|MASK_ADDR1
op_or
id|awacs_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|awacs_sleeping
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Resume pending sounds. */
multiline_comment|/* we don&squot;t try to restart input... */
id|__PMacPlay
c_func
(paren
)paren
suffix:semicolon
id|UNLOCK
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|PBOOK_SLEEP_OK
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PMAC_PBOOK */
multiline_comment|/* All the burgundy functions: */
multiline_comment|/* Waits for busy flag to clear */
r_inline
r_static
r_void
DECL|function|awacs_burgundy_busy_wait
id|awacs_burgundy_busy_wait
c_func
(paren
r_void
)paren
(brace
r_int
id|count
op_assign
l_int|50
suffix:semicolon
multiline_comment|/* &gt; 2 samples at 44k1 */
r_while
c_loop
(paren
(paren
id|in_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_ctrl
)paren
op_amp
id|MASK_NEWECMD
)paren
op_logical_and
id|count
op_decrement
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_inline
r_static
r_void
DECL|function|awacs_burgundy_extend_wait
id|awacs_burgundy_extend_wait
c_func
(paren
r_void
)paren
(brace
r_int
id|count
op_assign
l_int|50
suffix:semicolon
multiline_comment|/* &gt; 2 samples at 44k1 */
r_while
c_loop
(paren
(paren
op_logical_neg
(paren
id|in_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_stat
)paren
op_amp
id|MASK_EXTEND
)paren
)paren
op_logical_and
id|count
op_decrement
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|count
op_assign
l_int|50
suffix:semicolon
r_while
c_loop
(paren
(paren
id|in_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_stat
)paren
op_amp
id|MASK_EXTEND
)paren
op_logical_and
id|count
op_decrement
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|awacs_burgundy_wcw
id|awacs_burgundy_wcw
c_func
(paren
r_int
id|addr
comma
r_int
id|val
)paren
(brace
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_ctrl
comma
id|addr
op_plus
l_int|0x200c00
op_plus
(paren
id|val
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|awacs_burgundy_busy_wait
c_func
(paren
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_ctrl
comma
id|addr
op_plus
l_int|0x200d00
op_plus
(paren
(paren
id|val
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|awacs_burgundy_busy_wait
c_func
(paren
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_ctrl
comma
id|addr
op_plus
l_int|0x200e00
op_plus
(paren
(paren
id|val
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|awacs_burgundy_busy_wait
c_func
(paren
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_ctrl
comma
id|addr
op_plus
l_int|0x200f00
op_plus
(paren
(paren
id|val
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|awacs_burgundy_busy_wait
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|awacs_burgundy_rcw
id|awacs_burgundy_rcw
c_func
(paren
r_int
id|addr
)paren
(brace
r_int
id|val
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* should have timeouts here */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_ctrl
comma
id|addr
op_plus
l_int|0x100000
)paren
suffix:semicolon
id|awacs_burgundy_busy_wait
c_func
(paren
)paren
suffix:semicolon
id|awacs_burgundy_extend_wait
c_func
(paren
)paren
suffix:semicolon
id|val
op_add_assign
(paren
id|in_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_stat
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0xff
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_ctrl
comma
id|addr
op_plus
l_int|0x100100
)paren
suffix:semicolon
id|awacs_burgundy_busy_wait
c_func
(paren
)paren
suffix:semicolon
id|awacs_burgundy_extend_wait
c_func
(paren
)paren
suffix:semicolon
id|val
op_add_assign
(paren
(paren
id|in_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_stat
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_ctrl
comma
id|addr
op_plus
l_int|0x100200
)paren
suffix:semicolon
id|awacs_burgundy_busy_wait
c_func
(paren
)paren
suffix:semicolon
id|awacs_burgundy_extend_wait
c_func
(paren
)paren
suffix:semicolon
id|val
op_add_assign
(paren
(paren
id|in_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_stat
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0xff
)paren
op_lshift
l_int|16
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_ctrl
comma
id|addr
op_plus
l_int|0x100300
)paren
suffix:semicolon
id|awacs_burgundy_busy_wait
c_func
(paren
)paren
suffix:semicolon
id|awacs_burgundy_extend_wait
c_func
(paren
)paren
suffix:semicolon
id|val
op_add_assign
(paren
(paren
id|in_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_stat
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0xff
)paren
op_lshift
l_int|24
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
r_static
r_void
DECL|function|awacs_burgundy_wcb
id|awacs_burgundy_wcb
c_func
(paren
r_int
id|addr
comma
r_int
id|val
)paren
(brace
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_ctrl
comma
id|addr
op_plus
l_int|0x300000
op_plus
(paren
id|val
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|awacs_burgundy_busy_wait
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|awacs_burgundy_rcb
id|awacs_burgundy_rcb
c_func
(paren
r_int
id|addr
)paren
(brace
r_int
id|val
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* should have timeouts here */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_ctrl
comma
id|addr
op_plus
l_int|0x100000
)paren
suffix:semicolon
id|awacs_burgundy_busy_wait
c_func
(paren
)paren
suffix:semicolon
id|awacs_burgundy_extend_wait
c_func
(paren
)paren
suffix:semicolon
id|val
op_add_assign
(paren
id|in_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_stat
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0xff
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
r_static
r_int
DECL|function|awacs_burgundy_check
id|awacs_burgundy_check
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Checks to see the chip is alive and kicking */
r_int
id|error
op_assign
id|in_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_ctrl
)paren
op_amp
id|MASK_ERRCODE
suffix:semicolon
r_return
id|error
op_eq
l_int|0xf0000
suffix:semicolon
)brace
r_static
r_int
DECL|function|awacs_burgundy_init
id|awacs_burgundy_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|awacs_burgundy_check
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;dmasound_pmac: burgundy not working :-(&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|awacs_burgundy_wcb
c_func
(paren
id|MASK_ADDR_BURGUNDY_OUTPUTENABLES
comma
id|DEF_BURGUNDY_OUTPUTENABLES
)paren
suffix:semicolon
id|awacs_burgundy_wcb
c_func
(paren
id|MASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES
comma
id|DEF_BURGUNDY_MORE_OUTPUTENABLES
)paren
suffix:semicolon
id|awacs_burgundy_wcw
c_func
(paren
id|MASK_ADDR_BURGUNDY_OUTPUTSELECTS
comma
id|DEF_BURGUNDY_OUTPUTSELECTS
)paren
suffix:semicolon
id|awacs_burgundy_wcb
c_func
(paren
id|MASK_ADDR_BURGUNDY_INPSEL21
comma
id|DEF_BURGUNDY_INPSEL21
)paren
suffix:semicolon
id|awacs_burgundy_wcb
c_func
(paren
id|MASK_ADDR_BURGUNDY_INPSEL3
comma
id|DEF_BURGUNDY_INPSEL3
)paren
suffix:semicolon
id|awacs_burgundy_wcb
c_func
(paren
id|MASK_ADDR_BURGUNDY_GAINCD
comma
id|DEF_BURGUNDY_GAINCD
)paren
suffix:semicolon
id|awacs_burgundy_wcb
c_func
(paren
id|MASK_ADDR_BURGUNDY_GAINLINE
comma
id|DEF_BURGUNDY_GAINLINE
)paren
suffix:semicolon
id|awacs_burgundy_wcb
c_func
(paren
id|MASK_ADDR_BURGUNDY_GAINMIC
comma
id|DEF_BURGUNDY_GAINMIC
)paren
suffix:semicolon
id|awacs_burgundy_wcb
c_func
(paren
id|MASK_ADDR_BURGUNDY_GAINMODEM
comma
id|DEF_BURGUNDY_GAINMODEM
)paren
suffix:semicolon
id|awacs_burgundy_wcb
c_func
(paren
id|MASK_ADDR_BURGUNDY_ATTENSPEAKER
comma
id|DEF_BURGUNDY_ATTENSPEAKER
)paren
suffix:semicolon
id|awacs_burgundy_wcb
c_func
(paren
id|MASK_ADDR_BURGUNDY_ATTENLINEOUT
comma
id|DEF_BURGUNDY_ATTENLINEOUT
)paren
suffix:semicolon
id|awacs_burgundy_wcb
c_func
(paren
id|MASK_ADDR_BURGUNDY_ATTENHP
comma
id|DEF_BURGUNDY_ATTENHP
)paren
suffix:semicolon
id|awacs_burgundy_wcw
c_func
(paren
id|MASK_ADDR_BURGUNDY_MASTER_VOLUME
comma
id|DEF_BURGUNDY_MASTER_VOLUME
)paren
suffix:semicolon
id|awacs_burgundy_wcw
c_func
(paren
id|MASK_ADDR_BURGUNDY_VOLCD
comma
id|DEF_BURGUNDY_VOLCD
)paren
suffix:semicolon
id|awacs_burgundy_wcw
c_func
(paren
id|MASK_ADDR_BURGUNDY_VOLLINE
comma
id|DEF_BURGUNDY_VOLLINE
)paren
suffix:semicolon
id|awacs_burgundy_wcw
c_func
(paren
id|MASK_ADDR_BURGUNDY_VOLMIC
comma
id|DEF_BURGUNDY_VOLMIC
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|awacs_burgundy_write_volume
id|awacs_burgundy_write_volume
c_func
(paren
r_int
id|address
comma
r_int
id|volume
)paren
(brace
r_int
id|hardvolume
comma
id|lvolume
comma
id|rvolume
suffix:semicolon
id|lvolume
op_assign
(paren
id|volume
op_amp
l_int|0xff
)paren
ques
c_cond
(paren
id|volume
op_amp
l_int|0xff
)paren
op_plus
l_int|155
suffix:colon
l_int|0
suffix:semicolon
id|rvolume
op_assign
(paren
(paren
id|volume
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
ques
c_cond
(paren
(paren
id|volume
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
op_plus
l_int|155
suffix:colon
l_int|0
suffix:semicolon
id|hardvolume
op_assign
id|lvolume
op_plus
(paren
id|rvolume
op_lshift
l_int|16
)paren
suffix:semicolon
id|awacs_burgundy_wcw
c_func
(paren
id|address
comma
id|hardvolume
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|awacs_burgundy_read_volume
id|awacs_burgundy_read_volume
c_func
(paren
r_int
id|address
)paren
(brace
r_int
id|softvolume
comma
id|wvolume
suffix:semicolon
id|wvolume
op_assign
id|awacs_burgundy_rcw
c_func
(paren
id|address
)paren
suffix:semicolon
id|softvolume
op_assign
(paren
id|wvolume
op_amp
l_int|0xff
)paren
op_minus
l_int|155
suffix:semicolon
id|softvolume
op_add_assign
(paren
(paren
(paren
id|wvolume
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
op_minus
l_int|155
)paren
op_lshift
l_int|8
suffix:semicolon
r_return
id|softvolume
OG
l_int|0
ques
c_cond
id|softvolume
suffix:colon
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|awacs_burgundy_read_mvolume
id|awacs_burgundy_read_mvolume
c_func
(paren
r_int
id|address
)paren
(brace
r_int
id|lvolume
comma
id|rvolume
comma
id|wvolume
suffix:semicolon
id|wvolume
op_assign
id|awacs_burgundy_rcw
c_func
(paren
id|address
)paren
suffix:semicolon
id|wvolume
op_and_assign
l_int|0xffff
suffix:semicolon
id|rvolume
op_assign
(paren
id|wvolume
op_amp
l_int|0xff
)paren
op_minus
l_int|155
suffix:semicolon
id|lvolume
op_assign
(paren
(paren
id|wvolume
op_amp
l_int|0xff00
)paren
op_rshift
l_int|8
)paren
op_minus
l_int|155
suffix:semicolon
r_return
id|lvolume
op_plus
(paren
id|rvolume
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|awacs_burgundy_write_mvolume
id|awacs_burgundy_write_mvolume
c_func
(paren
r_int
id|address
comma
r_int
id|volume
)paren
(brace
r_int
id|lvolume
comma
id|rvolume
comma
id|hardvolume
suffix:semicolon
id|lvolume
op_assign
(paren
id|volume
op_amp
l_int|0xff
)paren
ques
c_cond
(paren
id|volume
op_amp
l_int|0xff
)paren
op_plus
l_int|155
suffix:colon
l_int|0
suffix:semicolon
id|rvolume
op_assign
(paren
(paren
id|volume
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
ques
c_cond
(paren
id|volume
op_rshift
l_int|8
)paren
op_plus
l_int|155
suffix:colon
l_int|0
suffix:semicolon
id|hardvolume
op_assign
id|lvolume
op_plus
(paren
id|rvolume
op_lshift
l_int|8
)paren
suffix:semicolon
id|hardvolume
op_add_assign
(paren
id|hardvolume
op_lshift
l_int|16
)paren
suffix:semicolon
id|awacs_burgundy_wcw
c_func
(paren
id|address
comma
id|hardvolume
)paren
suffix:semicolon
)brace
multiline_comment|/* End burgundy functions */
multiline_comment|/* Set up output volumes on machines with the &squot;perch/whisper&squot; extension card.&n; * this has an SGS i2c chip (7433) which is accessed using the cuda.&n; *&n; * TODO: split this out and make use of the other parts of the SGS chip to&n; * do Bass, Treble etc.&n; */
r_static
r_void
DECL|function|awacs_enable_amp
id|awacs_enable_amp
c_func
(paren
r_int
id|spkr_vol
)paren
(brace
macro_line|#ifdef CONFIG_ADB_CUDA
r_struct
id|adb_request
id|req
suffix:semicolon
id|awacs_spkr_vol
op_assign
id|spkr_vol
suffix:semicolon
r_if
c_cond
(paren
id|sys_ctrler
op_ne
id|SYS_CTRLER_CUDA
)paren
r_return
suffix:semicolon
multiline_comment|/* turn on headphones */
id|cuda_request
c_func
(paren
op_amp
id|req
comma
l_int|NULL
comma
l_int|5
comma
id|CUDA_PACKET
comma
id|CUDA_GET_SET_IIC
comma
l_int|0x8a
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|req.complete
)paren
id|cuda_poll
c_func
(paren
)paren
suffix:semicolon
id|cuda_request
c_func
(paren
op_amp
id|req
comma
l_int|NULL
comma
l_int|5
comma
id|CUDA_PACKET
comma
id|CUDA_GET_SET_IIC
comma
l_int|0x8a
comma
l_int|6
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|req.complete
)paren
id|cuda_poll
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* turn on speaker */
id|cuda_request
c_func
(paren
op_amp
id|req
comma
l_int|NULL
comma
l_int|5
comma
id|CUDA_PACKET
comma
id|CUDA_GET_SET_IIC
comma
l_int|0x8a
comma
l_int|3
comma
(paren
l_int|100
op_minus
(paren
id|spkr_vol
op_amp
l_int|0xff
)paren
)paren
op_star
l_int|32
op_div
l_int|100
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|req.complete
)paren
id|cuda_poll
c_func
(paren
)paren
suffix:semicolon
id|cuda_request
c_func
(paren
op_amp
id|req
comma
l_int|NULL
comma
l_int|5
comma
id|CUDA_PACKET
comma
id|CUDA_GET_SET_IIC
comma
l_int|0x8a
comma
l_int|5
comma
(paren
l_int|100
op_minus
(paren
(paren
id|spkr_vol
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
)paren
op_star
l_int|32
op_div
l_int|100
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|req.complete
)paren
id|cuda_poll
c_func
(paren
)paren
suffix:semicolon
id|cuda_request
c_func
(paren
op_amp
id|req
comma
l_int|NULL
comma
l_int|5
comma
id|CUDA_PACKET
comma
id|CUDA_GET_SET_IIC
comma
l_int|0x8a
comma
l_int|1
comma
l_int|0x29
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|req.complete
)paren
id|cuda_poll
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_ADB_CUDA */
)brace
multiline_comment|/*** Mid level stuff *********************************************************/
multiline_comment|/*&n; * /dev/mixer abstraction&n; */
DECL|function|do_line_lev
r_static
r_void
id|do_line_lev
c_func
(paren
r_int
id|data
)paren
(brace
id|line_lev
op_assign
id|data
suffix:semicolon
id|awacs_reg
(braket
l_int|0
)braket
op_and_assign
op_complement
id|MASK_MUX_AUDIN
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data
op_amp
l_int|0xff
)paren
op_ge
l_int|50
)paren
id|awacs_reg
(braket
l_int|0
)braket
op_or_assign
id|MASK_MUX_AUDIN
suffix:semicolon
id|awacs_write
c_func
(paren
id|MASK_ADDR0
op_or
id|awacs_reg
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
DECL|function|do_ip_gain
r_static
r_void
id|do_ip_gain
c_func
(paren
r_int
id|data
)paren
(brace
id|ip_gain
op_assign
id|data
suffix:semicolon
id|data
op_and_assign
l_int|0xff
suffix:semicolon
id|awacs_reg
(braket
l_int|0
)braket
op_and_assign
op_complement
id|MASK_GAINLINE
suffix:semicolon
r_if
c_cond
(paren
id|awacs_revision
op_eq
id|AWACS_SCREAMER
)paren
(brace
id|awacs_reg
(braket
l_int|6
)braket
op_and_assign
op_complement
id|MASK_MIC_BOOST
suffix:semicolon
r_if
c_cond
(paren
id|data
op_ge
l_int|33
)paren
(brace
id|awacs_reg
(braket
l_int|0
)braket
op_or_assign
id|MASK_GAINLINE
suffix:semicolon
r_if
c_cond
(paren
id|data
op_ge
l_int|66
)paren
(brace
id|awacs_reg
(braket
l_int|6
)braket
op_or_assign
id|MASK_MIC_BOOST
suffix:semicolon
)brace
)brace
id|awacs_write
c_func
(paren
id|MASK_ADDR6
op_or
id|awacs_reg
(braket
l_int|6
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|data
op_ge
l_int|50
)paren
id|awacs_reg
(braket
l_int|0
)braket
op_or_assign
id|MASK_GAINLINE
suffix:semicolon
)brace
id|awacs_write
c_func
(paren
id|MASK_ADDR0
op_or
id|awacs_reg
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
DECL|function|do_mic_lev
r_static
r_void
id|do_mic_lev
c_func
(paren
r_int
id|data
)paren
(brace
id|mic_lev
op_assign
id|data
suffix:semicolon
id|data
op_and_assign
l_int|0xff
suffix:semicolon
id|awacs_reg
(braket
l_int|0
)braket
op_and_assign
op_complement
id|MASK_MUX_MIC
suffix:semicolon
r_if
c_cond
(paren
id|data
op_ge
l_int|50
)paren
id|awacs_reg
(braket
l_int|0
)braket
op_or_assign
id|MASK_MUX_MIC
suffix:semicolon
id|awacs_write
c_func
(paren
id|MASK_ADDR0
op_or
id|awacs_reg
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
DECL|function|do_cd_lev
r_static
r_void
id|do_cd_lev
c_func
(paren
r_int
id|data
)paren
(brace
id|cd_lev
op_assign
id|data
suffix:semicolon
id|awacs_reg
(braket
l_int|0
)braket
op_and_assign
op_complement
id|MASK_MUX_CD
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data
op_amp
l_int|0xff
)paren
op_ge
l_int|50
)paren
id|awacs_reg
(braket
l_int|0
)braket
op_or_assign
id|MASK_MUX_CD
suffix:semicolon
id|awacs_write
c_func
(paren
id|MASK_ADDR0
op_or
id|awacs_reg
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
DECL|function|do_rec_lev
r_static
r_void
id|do_rec_lev
c_func
(paren
r_int
id|data
)paren
(brace
r_int
id|left
comma
id|right
suffix:semicolon
id|rec_lev
op_assign
id|data
suffix:semicolon
multiline_comment|/* need to fudge this to use the volume setter routine */
id|left
op_assign
l_int|100
op_minus
(paren
id|data
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|left
OL
l_int|0
)paren
(brace
id|left
op_assign
l_int|0
suffix:semicolon
)brace
id|right
op_assign
l_int|100
op_minus
(paren
(paren
id|data
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|right
OL
l_int|0
)paren
(brace
id|right
op_assign
l_int|0
suffix:semicolon
)brace
id|left
op_or_assign
(paren
id|right
op_lshift
l_int|8
)paren
suffix:semicolon
id|left
op_assign
id|awacs_volume_setter
c_func
(paren
id|left
comma
l_int|0
comma
l_int|0
comma
l_int|4
)paren
suffix:semicolon
)brace
DECL|function|do_passthru_vol
r_static
r_void
id|do_passthru_vol
c_func
(paren
r_int
id|data
)paren
(brace
id|passthru_vol
op_assign
id|data
suffix:semicolon
id|awacs_reg
(braket
l_int|1
)braket
op_and_assign
op_complement
id|MASK_LOOPTHRU
suffix:semicolon
r_if
c_cond
(paren
id|awacs_revision
op_eq
id|AWACS_SCREAMER
)paren
(brace
r_if
c_cond
(paren
id|data
)paren
(brace
multiline_comment|/* switch it on for non-zero */
id|awacs_reg
(braket
l_int|1
)braket
op_or_assign
id|MASK_LOOPTHRU
suffix:semicolon
id|awacs_write
c_func
(paren
id|MASK_ADDR1
op_or
id|awacs_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|data
op_assign
id|awacs_volume_setter
c_func
(paren
id|data
comma
l_int|5
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|data
op_amp
l_int|0xff
)paren
op_ge
l_int|50
)paren
id|awacs_reg
(braket
l_int|1
)braket
op_or_assign
id|MASK_LOOPTHRU
suffix:semicolon
id|awacs_write
c_func
(paren
id|MASK_ADDR1
op_or
id|awacs_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|data
op_assign
(paren
id|awacs_reg
(braket
l_int|1
)braket
op_amp
id|MASK_LOOPTHRU
)paren
ques
c_cond
l_int|100
suffix:colon
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|awacs_mixer_ioctl
r_static
r_int
id|awacs_mixer_ioctl
c_func
(paren
id|u_int
id|cmd
comma
id|u_long
id|arg
)paren
(brace
r_int
id|data
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SOUND_MIXER_READ_CAPS
suffix:colon
multiline_comment|/* say we will allow multiple inputs?  prob. wrong&n;&t;&t;&t;so I&squot;m switching it to single */
r_return
id|IOCTL_OUT
c_func
(paren
id|arg
comma
l_int|1
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_READ_DEVMASK
suffix:colon
id|data
op_assign
id|SOUND_MASK_VOLUME
op_or
id|SOUND_MASK_SPEAKER
op_or
id|SOUND_MASK_LINE
op_or
id|SOUND_MASK_MIC
op_or
id|SOUND_MASK_CD
op_or
id|SOUND_MASK_IGAIN
op_or
id|SOUND_MASK_RECLEV
op_or
id|SOUND_MASK_ALTPCM
op_or
id|SOUND_MASK_MONITOR
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_READ_RECMASK
suffix:colon
id|data
op_assign
id|SOUND_MASK_LINE
op_or
id|SOUND_MASK_MIC
op_or
id|SOUND_MASK_CD
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_READ_RECSRC
suffix:colon
id|data
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|awacs_reg
(braket
l_int|0
)braket
op_amp
id|MASK_MUX_AUDIN
)paren
id|data
op_or_assign
id|SOUND_MASK_LINE
suffix:semicolon
r_if
c_cond
(paren
id|awacs_reg
(braket
l_int|0
)braket
op_amp
id|MASK_MUX_MIC
)paren
id|data
op_or_assign
id|SOUND_MASK_MIC
suffix:semicolon
r_if
c_cond
(paren
id|awacs_reg
(braket
l_int|0
)braket
op_amp
id|MASK_MUX_CD
)paren
id|data
op_or_assign
id|SOUND_MASK_CD
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_RECSRC
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|data
op_and_assign
(paren
id|SOUND_MASK_LINE
op_or
id|SOUND_MASK_MIC
op_or
id|SOUND_MASK_CD
)paren
suffix:semicolon
id|awacs_reg
(braket
l_int|0
)braket
op_and_assign
op_complement
(paren
id|MASK_MUX_CD
op_or
id|MASK_MUX_MIC
op_or
id|MASK_MUX_AUDIN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_amp
id|SOUND_MASK_LINE
)paren
id|awacs_reg
(braket
l_int|0
)braket
op_or_assign
id|MASK_MUX_AUDIN
suffix:semicolon
r_if
c_cond
(paren
id|data
op_amp
id|SOUND_MASK_MIC
)paren
id|awacs_reg
(braket
l_int|0
)braket
op_or_assign
id|MASK_MUX_MIC
suffix:semicolon
r_if
c_cond
(paren
id|data
op_amp
id|SOUND_MASK_CD
)paren
id|awacs_reg
(braket
l_int|0
)braket
op_or_assign
id|MASK_MUX_CD
suffix:semicolon
id|awacs_write
c_func
(paren
id|awacs_reg
(braket
l_int|0
)braket
op_or
id|MASK_ADDR0
)paren
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_READ_STEREODEVS
suffix:colon
id|data
op_assign
id|SOUND_MASK_VOLUME
op_or
id|SOUND_MASK_SPEAKER
op_or
id|SOUND_MASK_RECLEV
suffix:semicolon
r_if
c_cond
(paren
id|awacs_revision
op_eq
id|AWACS_SCREAMER
)paren
id|data
op_or_assign
id|SOUND_MASK_MONITOR
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_VOLUME
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|line_vol
op_assign
id|data
suffix:semicolon
id|awacs_volume_setter
c_func
(paren
id|data
comma
l_int|2
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SOUND_MIXER_READ_VOLUME
suffix:colon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|line_vol
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_SPEAKER
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|spk_vol
op_assign
id|data
suffix:semicolon
r_if
c_cond
(paren
id|has_perch
)paren
id|awacs_enable_amp
c_func
(paren
id|data
)paren
suffix:semicolon
r_else
(paren
r_void
)paren
id|awacs_volume_setter
c_func
(paren
id|data
comma
l_int|4
comma
id|MASK_CMUTE
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* fall though */
r_case
id|SOUND_MIXER_READ_SPEAKER
suffix:colon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|spk_vol
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_ALTPCM
suffix:colon
multiline_comment|/* really bell volume */
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|beep_vol
op_assign
id|data
op_amp
l_int|0xff
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SOUND_MIXER_READ_ALTPCM
suffix:colon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|beep_vol
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_LINE
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|do_line_lev
c_func
(paren
id|data
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SOUND_MIXER_READ_LINE
suffix:colon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|line_lev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_IGAIN
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|do_ip_gain
c_func
(paren
id|data
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SOUND_MIXER_READ_IGAIN
suffix:colon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|ip_gain
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_MIC
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|do_mic_lev
c_func
(paren
id|data
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SOUND_MIXER_READ_MIC
suffix:colon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|mic_lev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_CD
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|do_cd_lev
c_func
(paren
id|data
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SOUND_MIXER_READ_CD
suffix:colon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|cd_lev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_RECLEV
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|do_rec_lev
c_func
(paren
id|data
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SOUND_MIXER_READ_RECLEV
suffix:colon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|rec_lev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MIXER_WRITE
c_func
(paren
id|SOUND_MIXER_MONITOR
)paren
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|do_passthru_vol
c_func
(paren
id|data
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|MIXER_READ
c_func
(paren
id|SOUND_MIXER_MONITOR
)paren
suffix:colon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|passthru_vol
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|awacs_mixer_init
r_static
r_void
id|awacs_mixer_init
c_func
(paren
r_void
)paren
(brace
id|awacs_volume_setter
c_func
(paren
id|line_vol
comma
l_int|2
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|has_perch
)paren
id|awacs_enable_amp
c_func
(paren
id|spk_vol
)paren
suffix:semicolon
r_else
(paren
r_void
)paren
id|awacs_volume_setter
c_func
(paren
id|spk_vol
comma
l_int|4
comma
id|MASK_CMUTE
comma
l_int|6
)paren
suffix:semicolon
id|do_line_lev
c_func
(paren
id|line_lev
)paren
suffix:semicolon
id|do_ip_gain
c_func
(paren
id|ip_gain
)paren
suffix:semicolon
id|do_mic_lev
c_func
(paren
id|mic_lev
)paren
suffix:semicolon
id|do_cd_lev
c_func
(paren
id|cd_lev
)paren
suffix:semicolon
id|do_rec_lev
c_func
(paren
id|rec_lev
)paren
suffix:semicolon
id|do_passthru_vol
c_func
(paren
id|passthru_vol
)paren
suffix:semicolon
)brace
DECL|function|burgundy_mixer_ioctl
r_static
r_int
id|burgundy_mixer_ioctl
c_func
(paren
id|u_int
id|cmd
comma
id|u_long
id|arg
)paren
(brace
r_int
id|data
suffix:semicolon
r_int
id|rc
suffix:semicolon
multiline_comment|/* We are, we are, we are... Burgundy or better */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SOUND_MIXER_READ_DEVMASK
suffix:colon
id|data
op_assign
id|SOUND_MASK_VOLUME
op_or
id|SOUND_MASK_CD
op_or
id|SOUND_MASK_LINE
op_or
id|SOUND_MASK_MIC
op_or
id|SOUND_MASK_SPEAKER
op_or
id|SOUND_MASK_ALTPCM
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_READ_RECMASK
suffix:colon
id|data
op_assign
id|SOUND_MASK_LINE
op_or
id|SOUND_MASK_MIC
op_or
id|SOUND_MASK_CD
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_READ_RECSRC
suffix:colon
id|data
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|awacs_reg
(braket
l_int|0
)braket
op_amp
id|MASK_MUX_AUDIN
)paren
id|data
op_or_assign
id|SOUND_MASK_LINE
suffix:semicolon
r_if
c_cond
(paren
id|awacs_reg
(braket
l_int|0
)braket
op_amp
id|MASK_MUX_MIC
)paren
id|data
op_or_assign
id|SOUND_MASK_MIC
suffix:semicolon
r_if
c_cond
(paren
id|awacs_reg
(braket
l_int|0
)braket
op_amp
id|MASK_MUX_CD
)paren
id|data
op_or_assign
id|SOUND_MASK_CD
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_RECSRC
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|data
op_and_assign
(paren
id|SOUND_MASK_LINE
op_or
id|SOUND_MASK_MIC
op_or
id|SOUND_MASK_CD
)paren
suffix:semicolon
id|awacs_reg
(braket
l_int|0
)braket
op_and_assign
op_complement
(paren
id|MASK_MUX_CD
op_or
id|MASK_MUX_MIC
op_or
id|MASK_MUX_AUDIN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_amp
id|SOUND_MASK_LINE
)paren
id|awacs_reg
(braket
l_int|0
)braket
op_or_assign
id|MASK_MUX_AUDIN
suffix:semicolon
r_if
c_cond
(paren
id|data
op_amp
id|SOUND_MASK_MIC
)paren
id|awacs_reg
(braket
l_int|0
)braket
op_or_assign
id|MASK_MUX_MIC
suffix:semicolon
r_if
c_cond
(paren
id|data
op_amp
id|SOUND_MASK_CD
)paren
id|awacs_reg
(braket
l_int|0
)braket
op_or_assign
id|MASK_MUX_CD
suffix:semicolon
id|awacs_write
c_func
(paren
id|awacs_reg
(braket
l_int|0
)braket
op_or
id|MASK_ADDR0
)paren
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_READ_STEREODEVS
suffix:colon
id|data
op_assign
id|SOUND_MASK_VOLUME
op_or
id|SOUND_MASK_SPEAKER
op_or
id|SOUND_MASK_RECLEV
op_or
id|SOUND_MASK_CD
op_or
id|SOUND_MASK_LINE
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_READ_CAPS
suffix:colon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_VOLUME
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|awacs_burgundy_write_mvolume
c_func
(paren
id|MASK_ADDR_BURGUNDY_MASTER_VOLUME
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* Fall through */
r_case
id|SOUND_MIXER_READ_VOLUME
suffix:colon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|awacs_burgundy_read_mvolume
c_func
(paren
id|MASK_ADDR_BURGUNDY_MASTER_VOLUME
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_SPEAKER
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|data
op_amp
l_int|0xff
)paren
)paren
(brace
multiline_comment|/* Mute the left speaker */
id|awacs_burgundy_wcb
c_func
(paren
id|MASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES
comma
id|awacs_burgundy_rcb
c_func
(paren
id|MASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES
)paren
op_amp
op_complement
l_int|0x2
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Unmute the left speaker */
id|awacs_burgundy_wcb
c_func
(paren
id|MASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES
comma
id|awacs_burgundy_rcb
c_func
(paren
id|MASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES
)paren
op_or
l_int|0x2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|data
op_amp
l_int|0xff00
)paren
)paren
(brace
multiline_comment|/* Mute the right speaker */
id|awacs_burgundy_wcb
c_func
(paren
id|MASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES
comma
id|awacs_burgundy_rcb
c_func
(paren
id|MASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES
)paren
op_amp
op_complement
l_int|0x4
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Unmute the right speaker */
id|awacs_burgundy_wcb
c_func
(paren
id|MASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES
comma
id|awacs_burgundy_rcb
c_func
(paren
id|MASK_ADDR_BURGUNDY_MORE_OUTPUTENABLES
)paren
op_or
l_int|0x4
)paren
suffix:semicolon
)brace
id|data
op_assign
(paren
(paren
(paren
id|data
op_amp
l_int|0xff
)paren
op_star
l_int|16
)paren
op_div
l_int|100
OG
l_int|0xf
ques
c_cond
l_int|0xf
suffix:colon
(paren
(paren
(paren
id|data
op_amp
l_int|0xff
)paren
op_star
l_int|16
)paren
op_div
l_int|100
)paren
)paren
op_plus
(paren
(paren
(paren
(paren
id|data
op_rshift
l_int|8
)paren
op_star
l_int|16
)paren
op_div
l_int|100
OG
l_int|0xf
ques
c_cond
l_int|0xf
suffix:colon
(paren
(paren
(paren
(paren
id|data
op_rshift
l_int|8
)paren
op_star
l_int|16
)paren
op_div
l_int|100
)paren
)paren
)paren
op_lshift
l_int|4
)paren
suffix:semicolon
id|awacs_burgundy_wcb
c_func
(paren
id|MASK_ADDR_BURGUNDY_ATTENSPEAKER
comma
op_complement
id|data
)paren
suffix:semicolon
multiline_comment|/* Fall through */
r_case
id|SOUND_MIXER_READ_SPEAKER
suffix:colon
id|data
op_assign
id|awacs_burgundy_rcb
c_func
(paren
id|MASK_ADDR_BURGUNDY_ATTENSPEAKER
)paren
suffix:semicolon
id|data
op_assign
(paren
(paren
(paren
id|data
op_amp
l_int|0xf
)paren
op_star
l_int|100
)paren
op_div
l_int|16
)paren
op_plus
(paren
(paren
(paren
(paren
id|data
op_rshift
l_int|4
)paren
op_star
l_int|100
)paren
op_div
l_int|16
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
op_complement
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_ALTPCM
suffix:colon
multiline_comment|/* really bell volume */
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|beep_vol
op_assign
id|data
op_amp
l_int|0xff
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SOUND_MIXER_READ_ALTPCM
suffix:colon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|beep_vol
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_LINE
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|awacs_burgundy_write_volume
c_func
(paren
id|MASK_ADDR_BURGUNDY_VOLLINE
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SOUND_MIXER_READ_LINE
suffix:colon
id|data
op_assign
id|awacs_burgundy_read_volume
c_func
(paren
id|MASK_ADDR_BURGUNDY_VOLLINE
)paren
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_MIC
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* Mic is mono device */
id|data
op_assign
(paren
id|data
op_lshift
l_int|8
)paren
op_plus
(paren
id|data
op_lshift
l_int|24
)paren
suffix:semicolon
id|awacs_burgundy_write_volume
c_func
(paren
id|MASK_ADDR_BURGUNDY_VOLMIC
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SOUND_MIXER_READ_MIC
suffix:colon
id|data
op_assign
id|awacs_burgundy_read_volume
c_func
(paren
id|MASK_ADDR_BURGUNDY_VOLMIC
)paren
suffix:semicolon
id|data
op_lshift_assign
l_int|24
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_CD
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|awacs_burgundy_write_volume
c_func
(paren
id|MASK_ADDR_BURGUNDY_VOLCD
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SOUND_MIXER_READ_CD
suffix:colon
id|data
op_assign
id|awacs_burgundy_read_volume
c_func
(paren
id|MASK_ADDR_BURGUNDY_VOLCD
)paren
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_RECLEV
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|data
op_assign
id|awacs_volume_setter
c_func
(paren
id|data
comma
l_int|0
comma
l_int|0
comma
l_int|4
)paren
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_READ_RECLEV
suffix:colon
id|data
op_assign
id|awacs_get_volume
c_func
(paren
id|awacs_reg
(braket
l_int|0
)braket
comma
l_int|4
)paren
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_OUTMASK
suffix:colon
r_case
id|SOUND_MIXER_OUTSRC
suffix:colon
r_default
suffix:colon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|tumbler_mixer_ioctl
r_static
r_int
id|tumbler_mixer_ioctl
c_func
(paren
id|u_int
id|cmd
comma
id|u_long
id|arg
)paren
(brace
r_int
id|data
suffix:semicolon
r_int
id|rc
suffix:semicolon
multiline_comment|/* We are, we are, we are... Tumbler (and very dumb) */
multiline_comment|/* Ok, we&squot;re not THAT dumb anymore, but still pretty dumb :-) */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SOUND_MIXER_READ_DEVMASK
suffix:colon
id|data
op_assign
id|SOUND_MASK_VOLUME
op_or
id|SOUND_MASK_ALTPCM
op_or
id|SOUND_MASK_BASS
op_or
id|SOUND_MASK_TREBLE
op_or
id|SOUND_MASK_PCM
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_READ_RECMASK
suffix:colon
id|data
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_READ_RECSRC
suffix:colon
id|data
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_RECSRC
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|data
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_READ_STEREODEVS
suffix:colon
id|data
op_assign
id|SOUND_MASK_VOLUME
op_or
id|SOUND_MASK_PCM
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_READ_CAPS
suffix:colon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_BASS
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|tumbler_set_bass
c_func
(paren
id|data
)paren
suffix:semicolon
multiline_comment|/* Fall through */
r_case
id|SOUND_MIXER_READ_BASS
suffix:colon
id|tumbler_get_bass
c_func
(paren
op_amp
id|data
)paren
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_TREBLE
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|tumbler_set_treble
c_func
(paren
id|data
)paren
suffix:semicolon
multiline_comment|/* Fall through */
r_case
id|SOUND_MIXER_READ_TREBLE
suffix:colon
id|tumbler_get_treble
c_func
(paren
op_amp
id|data
)paren
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_PCM
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|tumbler_set_pcm_lvl
c_func
(paren
id|data
)paren
suffix:semicolon
multiline_comment|/* Fall through */
r_case
id|SOUND_MIXER_READ_PCM
suffix:colon
id|tumbler_get_pcm_lvl
c_func
(paren
op_amp
id|data
)paren
suffix:semicolon
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_VOLUME
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|tumbler_set_volume
c_func
(paren
id|data
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* Fall through */
r_case
id|SOUND_MIXER_READ_VOLUME
suffix:colon
id|tumbler_get_volume
c_func
(paren
op_amp
id|data
comma
op_amp
id|data
)paren
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_ALTPCM
suffix:colon
multiline_comment|/* really bell volume */
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|beep_vol
op_assign
id|data
op_amp
l_int|0xff
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SOUND_MIXER_READ_ALTPCM
suffix:colon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|beep_vol
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_OUTMASK
suffix:colon
r_case
id|SOUND_MIXER_OUTSRC
suffix:colon
r_default
suffix:colon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|daca_mixer_ioctl
r_static
r_int
id|daca_mixer_ioctl
c_func
(paren
id|u_int
id|cmd
comma
id|u_long
id|arg
)paren
(brace
r_int
id|data
suffix:semicolon
r_int
id|rc
suffix:semicolon
multiline_comment|/* And the DACA&squot;s no genius either! */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SOUND_MIXER_READ_DEVMASK
suffix:colon
id|data
op_assign
id|SOUND_MASK_VOLUME
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_READ_RECMASK
suffix:colon
id|data
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_READ_RECSRC
suffix:colon
id|data
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_RECSRC
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|data
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_READ_STEREODEVS
suffix:colon
id|data
op_assign
id|SOUND_MASK_VOLUME
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_READ_CAPS
suffix:colon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_VOLUME
suffix:colon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|daca_set_volume
c_func
(paren
id|data
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* Fall through */
r_case
id|SOUND_MIXER_READ_VOLUME
suffix:colon
id|daca_get_volume
c_func
(paren
op_amp
id|data
comma
op_amp
id|data
)paren
suffix:semicolon
id|rc
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_MIXER_OUTMASK
suffix:colon
r_case
id|SOUND_MIXER_OUTSRC
suffix:colon
r_default
suffix:colon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|PMacMixerIoctl
r_static
r_int
id|PMacMixerIoctl
c_func
(paren
id|u_int
id|cmd
comma
id|u_long
id|arg
)paren
(brace
r_int
id|rc
suffix:semicolon
multiline_comment|/* Different IOCTLS for burgundy and, eventually, DACA &amp; Tumbler */
id|TRY_LOCK
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|awacs_revision
)paren
(brace
r_case
id|AWACS_BURGUNDY
suffix:colon
id|rc
op_assign
id|burgundy_mixer_ioctl
c_func
(paren
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AWACS_DACA
suffix:colon
id|rc
op_assign
id|daca_mixer_ioctl
c_func
(paren
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AWACS_TUMBLER
suffix:colon
id|rc
op_assign
id|tumbler_mixer_ioctl
c_func
(paren
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* ;-)) */
id|rc
op_assign
id|awacs_mixer_ioctl
c_func
(paren
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
id|UNLOCK
c_func
(paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|PMacMixerInit
r_static
r_void
id|PMacMixerInit
c_func
(paren
r_void
)paren
(brace
r_switch
c_cond
(paren
id|awacs_revision
)paren
(brace
r_case
id|AWACS_TUMBLER
suffix:colon
id|printk
c_func
(paren
l_string|&quot;AE-Init tumbler mixer&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AWACS_DACA
suffix:colon
r_case
id|AWACS_BURGUNDY
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* don&squot;t know yet */
r_case
id|AWACS_AWACS
suffix:colon
r_case
id|AWACS_SCREAMER
suffix:colon
r_default
suffix:colon
id|awacs_mixer_init
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Write/Read sq setup functions:&n;   Check to see if we have enough (or any) dbdma cmd buffers for the&n;   user&squot;s fragment settings.  If not, allocate some. If this fails we will&n;   point at the beep buffer - as an emergency provision - to stop dma tromping&n;   on some random bit of memory (if someone lets it go anyway).&n;   The command buffers are then set up to point to the fragment buffers&n;   (allocated elsewhere).  We need n+1 commands the last of which holds&n;   a NOP + loop to start.&n;*/
DECL|function|PMacWriteSqSetup
r_static
r_int
id|PMacWriteSqSetup
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|count
op_assign
l_int|600
suffix:semicolon
r_volatile
r_struct
id|dbdma_cmd
op_star
id|cp
suffix:semicolon
id|LOCK
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* stop the controller from doing any output - if it isn&squot;t already.&n;&t;   it _should_ be before this is called anyway */
id|out_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;control
comma
(paren
id|RUN
op_or
id|PAUSE
op_or
id|FLUSH
op_or
id|WAKE
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|in_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;status
)paren
op_amp
id|RUN
)paren
op_logical_and
id|count
op_decrement
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_DMASOUND
r_if
c_cond
(paren
id|count
op_le
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;dmasound_pmac: write sq setup: timeout waiting for dma to stop&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|write_sq.max_count
op_plus
l_int|1
)paren
OG
id|number_of_tx_cmd_buffers
)paren
(brace
r_if
c_cond
(paren
id|awacs_tx_cmd_space
)paren
id|kfree
c_func
(paren
id|awacs_tx_cmd_space
)paren
suffix:semicolon
id|number_of_tx_cmd_buffers
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we need nbufs + 1 (for the loop) and we should request + 1&n;&t;&t;   again because the DBDMA_ALIGN might pull the start up by up&n;&t;&t;   to sizeof(struct dbdma_cmd) - 4.&n;&t;&t;*/
id|awacs_tx_cmd_space
op_assign
id|kmalloc
(paren
(paren
id|write_sq.max_count
op_plus
l_int|1
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|dbdma_cmd
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|awacs_tx_cmd_space
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* don&squot;t leave it dangling - nasty but better than a&n;&t;&t;&t;   random address */
id|out_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;cmdptr
comma
id|virt_to_bus
c_func
(paren
id|beep_dbdma_cmd
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;dmasound_pmac: can&squot;t allocate dbdma cmd buffers&quot;
l_string|&quot;, driver disabled&bslash;n&quot;
)paren
suffix:semicolon
id|UNLOCK
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|awacs_tx_cmds
op_assign
(paren
r_volatile
r_struct
id|dbdma_cmd
op_star
)paren
id|DBDMA_ALIGN
c_func
(paren
id|awacs_tx_cmd_space
)paren
suffix:semicolon
id|number_of_tx_cmd_buffers
op_assign
id|write_sq.max_count
op_plus
l_int|1
suffix:semicolon
)brace
id|cp
op_assign
id|awacs_tx_cmds
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|cp
comma
l_int|0
comma
(paren
id|write_sq.max_count
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|dbdma_cmd
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|write_sq.max_count
suffix:semicolon
op_increment
id|i
comma
op_increment
id|cp
)paren
(brace
id|st_le32
c_func
(paren
op_amp
id|cp-&gt;phy_addr
comma
id|virt_to_bus
c_func
(paren
id|write_sq.buffers
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
id|st_le16
c_func
(paren
op_amp
id|cp-&gt;command
comma
id|DBDMA_NOP
op_plus
id|BR_ALWAYS
)paren
suffix:semicolon
id|st_le32
c_func
(paren
op_amp
id|cp-&gt;cmd_dep
comma
id|virt_to_bus
c_func
(paren
id|awacs_tx_cmds
)paren
)paren
suffix:semicolon
multiline_comment|/* point the controller at the command stack - ready to go */
id|out_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;cmdptr
comma
id|virt_to_bus
c_func
(paren
id|awacs_tx_cmds
)paren
)paren
suffix:semicolon
id|UNLOCK
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|PMacReadSqSetup
r_static
r_int
id|PMacReadSqSetup
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|count
op_assign
l_int|600
suffix:semicolon
r_volatile
r_struct
id|dbdma_cmd
op_star
id|cp
suffix:semicolon
id|LOCK
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* stop the controller from doing any input - if it isn&squot;t already.&n;&t;   it _should_ be before this is called anyway */
id|out_le32
c_func
(paren
op_amp
id|awacs_rxdma-&gt;control
comma
(paren
id|RUN
op_or
id|PAUSE
op_or
id|FLUSH
op_or
id|WAKE
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|in_le32
c_func
(paren
op_amp
id|awacs_rxdma-&gt;status
)paren
op_amp
id|RUN
)paren
op_logical_and
id|count
op_decrement
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_DMASOUND
r_if
c_cond
(paren
id|count
op_le
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;dmasound_pmac: read sq setup: timeout waiting for dma to stop&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|read_sq.max_count
op_plus
l_int|1
)paren
OG
id|number_of_rx_cmd_buffers
)paren
(brace
r_if
c_cond
(paren
id|awacs_rx_cmd_space
)paren
id|kfree
c_func
(paren
id|awacs_rx_cmd_space
)paren
suffix:semicolon
id|number_of_rx_cmd_buffers
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we need nbufs + 1 (for the loop) and we should request + 1 again&n;&t;&t;   because the DBDMA_ALIGN might pull the start up by up to&n;&t;&t;   sizeof(struct dbdma_cmd) - 4 (assuming kmalloc aligns 32 bits).&n;&t;&t;*/
id|awacs_rx_cmd_space
op_assign
id|kmalloc
(paren
(paren
id|read_sq.max_count
op_plus
l_int|1
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|dbdma_cmd
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|awacs_rx_cmd_space
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* don&squot;t leave it dangling - nasty but better than a&n;&t;&t;&t;   random address */
id|out_le32
c_func
(paren
op_amp
id|awacs_rxdma-&gt;cmdptr
comma
id|virt_to_bus
c_func
(paren
id|beep_dbdma_cmd
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;dmasound_pmac: can&squot;t allocate dbdma cmd buffers&quot;
l_string|&quot;, driver disabled&bslash;n&quot;
)paren
suffix:semicolon
id|UNLOCK
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|awacs_rx_cmds
op_assign
(paren
r_volatile
r_struct
id|dbdma_cmd
op_star
)paren
id|DBDMA_ALIGN
c_func
(paren
id|awacs_rx_cmd_space
)paren
suffix:semicolon
id|number_of_rx_cmd_buffers
op_assign
id|read_sq.max_count
op_plus
l_int|1
suffix:semicolon
)brace
id|cp
op_assign
id|awacs_rx_cmds
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|cp
comma
l_int|0
comma
(paren
id|read_sq.max_count
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|dbdma_cmd
)paren
)paren
suffix:semicolon
multiline_comment|/* Set dma buffers up in a loop */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|read_sq.max_count
suffix:semicolon
id|i
op_increment
comma
id|cp
op_increment
)paren
(brace
id|st_le32
c_func
(paren
op_amp
id|cp-&gt;phy_addr
comma
id|virt_to_bus
c_func
(paren
id|read_sq.buffers
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|st_le16
c_func
(paren
op_amp
id|cp-&gt;command
comma
id|INPUT_MORE
op_plus
id|INTR_ALWAYS
)paren
suffix:semicolon
id|st_le16
c_func
(paren
op_amp
id|cp-&gt;req_count
comma
id|read_sq.block_size
)paren
suffix:semicolon
id|st_le16
c_func
(paren
op_amp
id|cp-&gt;xfer_status
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* The next two lines make the thing loop around.&n;&t;*/
id|st_le16
c_func
(paren
op_amp
id|cp-&gt;command
comma
id|DBDMA_NOP
op_plus
id|BR_ALWAYS
)paren
suffix:semicolon
id|st_le32
c_func
(paren
op_amp
id|cp-&gt;cmd_dep
comma
id|virt_to_bus
c_func
(paren
id|awacs_rx_cmds
)paren
)paren
suffix:semicolon
multiline_comment|/* point the controller at the command stack - ready to go */
id|out_le32
c_func
(paren
op_amp
id|awacs_rxdma-&gt;cmdptr
comma
id|virt_to_bus
c_func
(paren
id|awacs_rx_cmds
)paren
)paren
suffix:semicolon
id|UNLOCK
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* TODO: this needs work to guarantee that when it returns DMA has stopped&n;   but in a more elegant way than is done here....&n;*/
DECL|function|PMacAbortRead
r_static
r_void
id|PMacAbortRead
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_volatile
r_struct
id|dbdma_cmd
op_star
id|cp
suffix:semicolon
id|LOCK
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* give it a chance to update the output and provide the IRQ&n;&t;   that is expected.&n;&t;*/
id|out_le32
c_func
(paren
op_amp
id|awacs_rxdma-&gt;control
comma
(paren
(paren
id|FLUSH
)paren
op_lshift
l_int|16
)paren
op_plus
id|FLUSH
)paren
suffix:semicolon
id|cp
op_assign
id|awacs_rx_cmds
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|read_sq.max_count
suffix:semicolon
id|i
op_increment
comma
id|cp
op_increment
)paren
id|st_le16
c_func
(paren
op_amp
id|cp-&gt;command
comma
id|DBDMA_STOP
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We should probably wait for the thing to stop before we&n;&t; * release the memory.&n;&t; */
id|wait_ms
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* give it a (small) chance to act */
multiline_comment|/* apply the sledgehammer approach - just stop it now */
id|out_le32
c_func
(paren
op_amp
id|awacs_rxdma-&gt;control
comma
(paren
id|RUN
op_or
id|PAUSE
op_or
id|FLUSH
op_or
id|WAKE
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|UNLOCK
c_func
(paren
)paren
suffix:semicolon
)brace
r_extern
r_char
op_star
id|get_afmt_string
c_func
(paren
r_int
)paren
suffix:semicolon
DECL|function|PMacStateInfo
r_static
r_int
id|PMacStateInfo
c_func
(paren
r_char
op_star
id|b
comma
r_int
id|sp
)paren
(brace
r_int
id|i
comma
id|len
op_assign
l_int|0
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|b
comma
l_string|&quot;HW rates: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|awacs_revision
)paren
(brace
r_case
id|AWACS_DACA
suffix:colon
r_case
id|AWACS_BURGUNDY
suffix:colon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|b
comma
l_string|&quot;44100 &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AWACS_TUMBLER
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|tumbler_freqs_ok
(braket
id|i
)braket
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|b
op_plus
id|len
comma
l_string|&quot;%d &quot;
comma
id|tumbler_freqs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AWACS_AWACS
suffix:colon
r_case
id|AWACS_SCREAMER
suffix:colon
r_default
suffix:colon
(brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|awacs_freqs_ok
(braket
id|i
)braket
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|b
op_plus
id|len
comma
l_string|&quot;%d &quot;
comma
id|awacs_freqs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|b
op_plus
id|len
comma
l_string|&quot;s/sec&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|sp
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|b
op_plus
id|len
comma
l_string|&quot;HW AFMTS: &quot;
)paren
suffix:semicolon
id|i
op_assign
id|AFMT_U16_BE
suffix:semicolon
r_while
c_loop
(paren
id|i
)paren
(brace
r_if
c_cond
(paren
id|i
op_amp
id|dmasound.mach.hardware_afmts
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|b
op_plus
id|len
comma
l_string|&quot;%s &quot;
comma
id|get_afmt_string
c_func
(paren
id|i
op_amp
id|dmasound.mach.hardware_afmts
)paren
)paren
suffix:semicolon
id|i
op_rshift_assign
l_int|1
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|b
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*** Machine definitions *****************************************************/
DECL|variable|def_hard
r_static
id|SETTINGS
id|def_hard
op_assign
(brace
id|format
suffix:colon
id|AFMT_S16_BE
comma
id|stereo
suffix:colon
l_int|1
comma
id|size
suffix:colon
l_int|16
comma
id|speed
suffix:colon
l_int|44100
)brace
suffix:semicolon
DECL|variable|def_soft
r_static
id|SETTINGS
id|def_soft
op_assign
(brace
id|format
suffix:colon
id|AFMT_S16_BE
comma
id|stereo
suffix:colon
l_int|1
comma
id|size
suffix:colon
l_int|16
comma
id|speed
suffix:colon
l_int|44100
)brace
suffix:semicolon
DECL|variable|machPMac
r_static
id|MACHINE
id|machPMac
op_assign
(brace
id|name
suffix:colon
id|awacs_name
comma
id|name2
suffix:colon
l_string|&quot;PowerMac Built-in Sound&quot;
comma
id|open
suffix:colon
id|PMacOpen
comma
id|release
suffix:colon
id|PMacRelease
comma
id|dma_alloc
suffix:colon
id|PMacAlloc
comma
id|dma_free
suffix:colon
id|PMacFree
comma
id|irqinit
suffix:colon
id|PMacIrqInit
comma
macro_line|#ifdef MODULE
id|irqcleanup
suffix:colon
id|PMacIrqCleanup
comma
macro_line|#endif /* MODULE */
id|init
suffix:colon
id|PMacInit
comma
id|silence
suffix:colon
id|PMacSilence
comma
id|setFormat
suffix:colon
id|PMacSetFormat
comma
id|setVolume
suffix:colon
id|PMacSetVolume
comma
id|play
suffix:colon
id|PMacPlay
comma
id|record
suffix:colon
l_int|NULL
comma
multiline_comment|/* default to no record */
id|mixer_init
suffix:colon
id|PMacMixerInit
comma
id|mixer_ioctl
suffix:colon
id|PMacMixerIoctl
comma
id|write_sq_setup
suffix:colon
id|PMacWriteSqSetup
comma
id|read_sq_setup
suffix:colon
id|PMacReadSqSetup
comma
id|state_info
suffix:colon
id|PMacStateInfo
comma
id|abort_read
suffix:colon
id|PMacAbortRead
comma
id|min_dsp_speed
suffix:colon
l_int|7350
comma
id|max_dsp_speed
suffix:colon
l_int|44100
comma
id|version
suffix:colon
(paren
(paren
id|DMASOUND_AWACS_REVISION
op_lshift
l_int|8
)paren
op_plus
id|DMASOUND_AWACS_EDITION
)paren
)brace
suffix:semicolon
multiline_comment|/*** Config &amp; Setup **********************************************************/
multiline_comment|/* Check for pmac models that we care about in terms of special actions.&n;*/
r_void
id|__init
DECL|function|set_model
id|set_model
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* portables/lap-tops */
r_if
c_cond
(paren
id|machine_is_compatible
c_func
(paren
l_string|&quot;AAPL,3400/2400&quot;
)paren
op_logical_or
id|machine_is_compatible
c_func
(paren
l_string|&quot;AAPL,3500&quot;
)paren
)paren
(brace
id|is_pbook_3X00
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|machine_is_compatible
c_func
(paren
l_string|&quot;PowerBook1,1&quot;
)paren
op_logical_or
multiline_comment|/* lombard */
id|machine_is_compatible
c_func
(paren
l_string|&quot;AAPL,PowerBook1998&quot;
)paren
)paren
(brace
multiline_comment|/* wallstreet */
id|is_pbook_g3
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Get the OF node that tells us about the registers, interrupts etc. to use&n;   for sound IO.&n;&n;   On most machines the sound IO OF node is the &squot;davbus&squot; node.  On newer pmacs&n;   with DACA (&amp; Tumbler) the node to use is i2s-a.  On much older machines i.e.&n;   before 9500 there is no davbus node and we have to use the &squot;awacs&squot; property.&n;&n;  In the latter case we signal this by setting the codec value - so that the&n;  code that looks for chip properties knows how to go about it.&n;*/
r_static
r_struct
id|device_node
DECL|function|get_snd_io_node
id|__init
op_star
id|get_snd_io_node
c_func
(paren
r_void
)paren
(brace
r_struct
id|device_node
op_star
id|np
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* set up awacs_node for early OF which doesn&squot;t have a full set of&n;&t; * properties on davbus&n;&t;*/
id|awacs_node
op_assign
id|find_devices
c_func
(paren
l_string|&quot;awacs&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|awacs_node
)paren
id|awacs_revision
op_assign
id|AWACS_AWACS
suffix:semicolon
multiline_comment|/* powermac models after 9500 (other than those which use DACA or&n;&t; * Tumbler) have a node called &quot;davbus&quot;.&n;&t; */
id|np
op_assign
id|find_devices
c_func
(paren
l_string|&quot;davbus&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if we didn&squot;t find a davbus device, try &squot;i2s-a&squot; since&n;&t; * this seems to be what iBooks (&amp; Tumbler) have.&n;&t; */
r_if
c_cond
(paren
id|np
op_eq
l_int|NULL
)paren
id|np
op_assign
id|find_devices
c_func
(paren
l_string|&quot;i2s-a&quot;
)paren
suffix:semicolon
multiline_comment|/* if we didn&squot;t find this - perhaps we are on an early model&n;&t; * which _only_ has an &squot;awacs&squot; node&n;&t;*/
r_if
c_cond
(paren
id|np
op_eq
l_int|NULL
op_logical_and
id|awacs_node
)paren
id|np
op_assign
id|awacs_node
suffix:semicolon
multiline_comment|/* if we failed all these return null - this will cause the&n;&t; * driver to give up...&n;&t;*/
r_return
id|np
suffix:semicolon
)brace
multiline_comment|/* Get the OF node that contains the info about the sound chip, inputs s-rates&n;   etc.&n;   This node does not exist (or contains much reduced info) on earlier machines&n;   we have to deduce the info other ways for these.&n;*/
r_static
r_struct
id|device_node
DECL|function|get_snd_info_node
id|__init
op_star
id|get_snd_info_node
c_func
(paren
r_struct
id|device_node
op_star
id|io
)paren
(brace
r_struct
id|device_node
op_star
id|info
suffix:semicolon
id|info
op_assign
id|find_devices
c_func
(paren
l_string|&quot;sound&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|info
op_ne
l_int|0
op_logical_and
id|info-&gt;parent
op_ne
id|io
)paren
id|info
op_assign
id|info-&gt;next
suffix:semicolon
r_return
id|info
suffix:semicolon
)brace
multiline_comment|/* Find out what type of codec we have.&n;*/
r_static
r_int
DECL|function|get_codec_type
id|__init
id|get_codec_type
c_func
(paren
r_struct
id|device_node
op_star
id|info
)paren
(brace
multiline_comment|/* already set if pre-davbus model and info will be NULL */
r_int
id|codec
op_assign
id|awacs_revision
suffix:semicolon
r_if
c_cond
(paren
id|info
)paren
(brace
multiline_comment|/* must do awacs first to allow screamer to overide it */
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|info
comma
l_string|&quot;awacs&quot;
)paren
)paren
id|codec
op_assign
id|AWACS_AWACS
suffix:semicolon
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|info
comma
l_string|&quot;screamer&quot;
)paren
)paren
id|codec
op_assign
id|AWACS_SCREAMER
suffix:semicolon
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|info
comma
l_string|&quot;burgundy&quot;
)paren
)paren
id|codec
op_assign
id|AWACS_BURGUNDY
suffix:semicolon
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|info
comma
l_string|&quot;daca&quot;
)paren
)paren
id|codec
op_assign
id|AWACS_DACA
suffix:semicolon
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|info
comma
l_string|&quot;tumbler&quot;
)paren
)paren
id|codec
op_assign
id|AWACS_TUMBLER
suffix:semicolon
)brace
r_return
id|codec
suffix:semicolon
)brace
multiline_comment|/* find out what type, if any, of expansion card we have&n;*/
r_static
r_void
DECL|function|get_expansion_type
id|__init
id|get_expansion_type
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|find_devices
c_func
(paren
l_string|&quot;perch&quot;
)paren
op_ne
l_int|NULL
)paren
id|has_perch
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|find_devices
c_func
(paren
l_string|&quot;pb-ziva-pc&quot;
)paren
op_ne
l_int|NULL
)paren
id|has_ziva
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* need to work out how we deal with iMac SRS module */
)brace
multiline_comment|/* set up frame rates.&n; * I suspect that these routines don&squot;t quite go about it the right way:&n; * - where there is more than one rate - I think that the first property&n; * value is the number of rates.&n; * TODO: check some more device trees and modify accordingly&n; *       Set dmasound.mach.max_dsp_rate on the basis of these routines.&n;*/
r_static
r_void
DECL|function|init_awacs_frame_rates
id|__init
id|init_awacs_frame_rates
c_func
(paren
r_int
r_int
op_star
id|prop
comma
r_int
r_int
id|l
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|prop
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|awacs_freqs_ok
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|l
op_div_assign
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|l
OG
l_int|0
suffix:semicolon
op_decrement
id|l
)paren
(brace
r_int
r_int
id|r
op_assign
op_star
id|prop
op_increment
suffix:semicolon
multiline_comment|/* Apple &squot;Fixed&squot; format */
r_if
c_cond
(paren
id|r
op_ge
l_int|0x10000
)paren
id|r
op_rshift_assign
l_int|16
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|r
op_eq
id|awacs_freqs
(braket
id|i
)braket
)paren
(brace
id|awacs_freqs_ok
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* else we assume that all the rates are available */
)brace
r_static
r_void
DECL|function|init_tumbler_frame_rates
id|__init
id|init_tumbler_frame_rates
c_func
(paren
r_int
r_int
op_star
id|prop
comma
r_int
r_int
id|l
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|prop
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
id|tumbler_freqs_ok
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|l
op_div_assign
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|l
OG
l_int|0
suffix:semicolon
op_decrement
id|l
)paren
(brace
r_int
r_int
id|r
op_assign
op_star
id|prop
op_increment
suffix:semicolon
multiline_comment|/* Apple &squot;Fixed&squot; format */
r_if
c_cond
(paren
id|r
op_ge
l_int|0x10000
)paren
id|r
op_rshift_assign
l_int|16
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|r
op_eq
id|tumbler_freqs
(braket
id|i
)braket
)paren
(brace
id|tumbler_freqs_ok
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* else we assume that all the rates are available */
)brace
r_static
r_void
DECL|function|init_burgundy_frame_rates
id|__init
id|init_burgundy_frame_rates
c_func
(paren
r_int
r_int
op_star
id|prop
comma
r_int
r_int
id|l
)paren
(brace
r_int
id|temp
(braket
l_int|9
)braket
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|prop
)paren
(brace
r_for
c_loop
(paren
id|l
op_div_assign
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|l
OG
l_int|0
suffix:semicolon
op_decrement
id|l
)paren
(brace
r_int
r_int
id|r
op_assign
op_star
id|prop
op_increment
suffix:semicolon
multiline_comment|/* Apple &squot;Fixed&squot; format */
r_if
c_cond
(paren
id|r
op_ge
l_int|0x10000
)paren
id|r
op_rshift_assign
l_int|16
suffix:semicolon
id|temp
(braket
id|i
)braket
op_assign
id|r
suffix:semicolon
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
l_int|9
)paren
(brace
id|i
op_assign
l_int|8
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef DEBUG_DMASOUND
r_if
c_cond
(paren
id|i
OG
l_int|1
)paren
(brace
r_int
id|j
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;dmasound_pmac: burgundy with multiple frame rates&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|i
suffix:semicolon
id|j
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%d &quot;
comma
id|temp
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_static
r_void
DECL|function|init_daca_frame_rates
id|__init
id|init_daca_frame_rates
c_func
(paren
r_int
r_int
op_star
id|prop
comma
r_int
r_int
id|l
)paren
(brace
r_int
id|temp
(braket
l_int|9
)braket
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|prop
)paren
(brace
r_for
c_loop
(paren
id|l
op_div_assign
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|l
OG
l_int|0
suffix:semicolon
op_decrement
id|l
)paren
(brace
r_int
r_int
id|r
op_assign
op_star
id|prop
op_increment
suffix:semicolon
multiline_comment|/* Apple &squot;Fixed&squot; format */
r_if
c_cond
(paren
id|r
op_ge
l_int|0x10000
)paren
id|r
op_rshift_assign
l_int|16
suffix:semicolon
id|temp
(braket
id|i
)braket
op_assign
id|r
suffix:semicolon
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
l_int|9
)paren
(brace
id|i
op_assign
l_int|8
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef DEBUG_DMASOUND
r_if
c_cond
(paren
id|i
OG
l_int|1
)paren
(brace
r_int
id|j
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;dmasound_pmac: DACA with multiple frame rates&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|i
suffix:semicolon
id|j
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%d &quot;
comma
id|temp
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_static
r_void
DECL|function|init_frame_rates
id|__init
id|init_frame_rates
c_func
(paren
r_int
r_int
op_star
id|prop
comma
r_int
r_int
id|l
)paren
(brace
r_switch
c_cond
(paren
id|awacs_revision
)paren
(brace
r_case
id|AWACS_TUMBLER
suffix:colon
id|init_tumbler_frame_rates
c_func
(paren
id|prop
comma
id|l
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AWACS_DACA
suffix:colon
id|init_daca_frame_rates
c_func
(paren
id|prop
comma
id|l
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AWACS_BURGUNDY
suffix:colon
id|init_burgundy_frame_rates
c_func
(paren
id|prop
comma
id|l
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* ;-))) */
id|init_awacs_frame_rates
c_func
(paren
id|prop
comma
id|l
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* find things/machines that can&squot;t do mac-io byteswap&n;*/
r_static
r_void
DECL|function|set_hw_byteswap
id|__init
id|set_hw_byteswap
c_func
(paren
r_struct
id|device_node
op_star
id|io
)paren
(brace
r_struct
id|device_node
op_star
id|mio
suffix:semicolon
r_int
r_int
op_star
id|p
comma
id|kl
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* if seems that Keylargo can&squot;t byte-swap  */
r_for
c_loop
(paren
id|mio
op_assign
id|io-&gt;parent
suffix:semicolon
id|mio
suffix:semicolon
id|mio
op_assign
id|mio-&gt;parent
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|mio-&gt;name
comma
l_string|&quot;mac-io&quot;
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|mio
comma
l_string|&quot;Keylargo&quot;
)paren
)paren
id|kl
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|hw_can_byteswap
op_assign
op_logical_neg
id|kl
suffix:semicolon
)brace
multiline_comment|/* Allocate the resources necessary for beep generation.  This cannot be (quite)&n;   done statically (yet) because we cannot do virt_to_bus() on static vars when&n;   the code is loaded as a module.&n;&n;   for the sake of saving the possibility that two allocations will incur the&n;   overhead of two pull-ups in DBDMA_ALIGN() we allocate the &squot;emergency&squot; dmdma&n;   command here as well... even tho&squot; it is not part of the beep process.&n;*/
r_int32
DECL|function|setup_beep
id|__init
id|setup_beep
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Initialize beep stuff */
multiline_comment|/* want one cmd buffer for beeps, and a second one for emergencies&n;&t;   - i.e. dbdma error conditions.&n;&t;   ask for three to allow for pull up in DBDMA_ALIGN().&n;&t;*/
id|beep_dbdma_cmd_space
op_assign
id|kmalloc
c_func
(paren
(paren
l_int|2
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|dbdma_cmd
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|beep_dbdma_cmd_space
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;dmasound_pmac: no beep dbdma cmd space&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|beep_dbdma_cmd
op_assign
(paren
r_volatile
r_struct
id|dbdma_cmd
op_star
)paren
id|DBDMA_ALIGN
c_func
(paren
id|beep_dbdma_cmd_space
)paren
suffix:semicolon
multiline_comment|/* set up emergency dbdma cmd */
id|emergency_dbdma_cmd
op_assign
id|beep_dbdma_cmd
op_plus
l_int|1
suffix:semicolon
id|beep_buf
op_assign
(paren
r_int
op_star
)paren
id|kmalloc
c_func
(paren
id|BEEP_BUFLEN
op_star
l_int|4
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|beep_buf
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;dmasound_pmac: no memory for beep buffer&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|beep_dbdma_cmd_space
)paren
(brace
id|kfree
c_func
(paren
id|beep_dbdma_cmd_space
)paren
suffix:semicolon
)brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* OK, we should be safe to claim the mksound vector now */
id|orig_mksound
op_assign
id|kd_mksound
suffix:semicolon
id|kd_mksound
op_assign
id|awacs_mksound
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dmasound_awacs_init
r_int
id|__init
id|dmasound_awacs_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|device_node
op_star
id|io
op_assign
l_int|NULL
comma
op_star
id|info
op_assign
l_int|NULL
suffix:semicolon
r_int
id|vol
comma
id|res
suffix:semicolon
r_if
c_cond
(paren
id|_machine
op_ne
id|_MACH_Pmac
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|awacs_subframe
op_assign
l_int|0
suffix:semicolon
id|awacs_revision
op_assign
l_int|0
suffix:semicolon
id|hw_can_byteswap
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* most can */
multiline_comment|/* look for models we need to handle specially */
id|set_model
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* find the OF node that tells us about the dbdma stuff&n;&t;*/
id|io
op_assign
id|get_snd_io_node
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|io
op_eq
l_int|NULL
)paren
(brace
macro_line|#ifdef DEBUG_DMASOUND
id|printk
c_func
(paren
l_string|&quot;dmasound_pmac: couldn&squot;t find sound io OF node&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* find the OF node that tells us about the sound sub-system&n;&t; * this doesn&squot;t exist on pre-davbus machines (earlier than 9500)&n;&t;*/
r_if
c_cond
(paren
id|awacs_revision
op_ne
id|AWACS_AWACS
)paren
(brace
multiline_comment|/* set for pre-davbus */
id|info
op_assign
id|get_snd_info_node
c_func
(paren
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
op_eq
l_int|NULL
)paren
(brace
macro_line|#ifdef DEBUG_DMASOUND
id|printk
c_func
(paren
l_string|&quot;dmasound_pmac: couldn&squot;t find &squot;sound&squot; OF node&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
id|awacs_revision
op_assign
id|get_codec_type
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|awacs_revision
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG_DMASOUND
id|printk
c_func
(paren
l_string|&quot;dmasound_pmac: couldn&squot;t find a Codec we can handle&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* we don&squot;t know this type of h/w */
)brace
multiline_comment|/* set up perch, ziva, SRS or whatever else we have as sound&n;&t; *  expansion.&n;&t;*/
id|get_expansion_type
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* we&squot;ve now got enough information to make up the audio topology.&n;&t; * we will map the sound part of mac-io now so that we can probe for&n;&t; * other info if necessary (early AWACS we want to read chip ids)&n;&t; */
r_if
c_cond
(paren
id|io-&gt;n_addrs
OL
l_int|3
op_logical_or
id|io-&gt;n_intrs
OL
l_int|3
)paren
(brace
multiline_comment|/* OK - maybe we need to use the &squot;awacs&squot; node (on earlier&n;&t;&t; * machines).&n;&t;&t;*/
r_if
c_cond
(paren
id|awacs_node
)paren
(brace
id|io
op_assign
id|awacs_node
suffix:semicolon
r_if
c_cond
(paren
id|io-&gt;n_addrs
OL
l_int|3
op_logical_or
id|io-&gt;n_intrs
OL
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;dmasound_pmac: can&squot;t use %s&quot;
l_string|&quot; (%d addrs, %d intrs)&bslash;n&quot;
comma
id|io-&gt;full_name
comma
id|io-&gt;n_addrs
comma
id|io-&gt;n_intrs
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;dmasound_pmac: can&squot;t use %s (%d addrs, %d intrs)&bslash;n&quot;
comma
id|io-&gt;full_name
comma
id|io-&gt;n_addrs
comma
id|io-&gt;n_intrs
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|request_OF_resource
c_func
(paren
id|io
comma
l_int|0
comma
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;dmasound: can&squot;t request IO resource !&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|request_OF_resource
c_func
(paren
id|io
comma
l_int|1
comma
l_string|&quot; (tx dma)&quot;
)paren
)paren
(brace
id|release_OF_resource
c_func
(paren
id|io
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;dmasound: can&squot;t request TX DMA resource !&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|request_OF_resource
c_func
(paren
id|io
comma
l_int|2
comma
l_string|&quot; (rx dma)&quot;
)paren
)paren
(brace
id|release_OF_resource
c_func
(paren
id|io
comma
l_int|0
)paren
suffix:semicolon
id|release_OF_resource
c_func
(paren
id|io
comma
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;dmasound: can&squot;t request RX DMA resource !&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* all OF versions I&squot;ve seen use this value */
id|awacs
op_assign
(paren
r_volatile
r_struct
id|awacs_regs
op_star
)paren
id|ioremap
c_func
(paren
id|io-&gt;addrs
(braket
l_int|0
)braket
dot
id|address
comma
l_int|0x1000
)paren
suffix:semicolon
id|awacs_txdma
op_assign
(paren
r_volatile
r_struct
id|dbdma_regs
op_star
)paren
id|ioremap
c_func
(paren
id|io-&gt;addrs
(braket
l_int|1
)braket
dot
id|address
comma
l_int|0x100
)paren
suffix:semicolon
id|awacs_rxdma
op_assign
(paren
r_volatile
r_struct
id|dbdma_regs
op_star
)paren
id|ioremap
c_func
(paren
id|io-&gt;addrs
(braket
l_int|2
)braket
dot
id|address
comma
l_int|0x100
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PMAC_PBOOK
multiline_comment|/* first of all make sure that the chip is powered up....*/
id|pmac_call_feature
c_func
(paren
id|PMAC_FTR_SOUND_CHIP_ENABLE
comma
id|io
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|awacs_revision
op_eq
id|AWACS_SCREAMER
)paren
id|awacs_recalibrate
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|awacs_irq
op_assign
id|io-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
suffix:semicolon
id|awacs_tx_irq
op_assign
id|io-&gt;intrs
(braket
l_int|1
)braket
dot
id|line
suffix:semicolon
id|awacs_rx_irq
op_assign
id|io-&gt;intrs
(braket
l_int|2
)braket
dot
id|line
suffix:semicolon
id|awacs_node
op_assign
id|io
suffix:semicolon
multiline_comment|/* if we have an awacs or screamer - probe the chip to make&n;&t; * sure we have the right revision.&n;&t;*/
r_if
c_cond
(paren
id|awacs_revision
op_le
id|AWACS_SCREAMER
)paren
(brace
r_uint32
id|temp
comma
id|rev
comma
id|mfg
suffix:semicolon
multiline_comment|/* find out the awacs revision from the chip */
id|temp
op_assign
id|in_le32
c_func
(paren
op_amp
id|awacs-&gt;codec_stat
)paren
suffix:semicolon
id|rev
op_assign
(paren
id|temp
op_rshift
l_int|12
)paren
op_amp
l_int|0xf
suffix:semicolon
id|mfg
op_assign
(paren
id|temp
op_rshift
l_int|8
)paren
op_amp
l_int|0xf
suffix:semicolon
macro_line|#ifdef DEBUG_DMASOUND
id|printk
c_func
(paren
l_string|&quot;dmasound_pmac: Awacs/Screamer Codec Mfct: %d Rev %d&bslash;n&quot;
comma
id|mfg
comma
id|rev
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|rev
op_ge
id|AWACS_SCREAMER
)paren
id|awacs_revision
op_assign
id|AWACS_SCREAMER
suffix:semicolon
r_else
id|awacs_revision
op_assign
id|rev
suffix:semicolon
)brace
id|dmasound.mach
op_assign
id|machPMac
suffix:semicolon
multiline_comment|/* find out other bits &amp; pieces from OF, these may be present&n;&t;   only on some models ... so be careful.&n;&t;*/
multiline_comment|/* in the absence of a frame rates property we will use the defaults&n;&t;*/
r_if
c_cond
(paren
id|info
)paren
(brace
r_int
r_int
op_star
id|prop
comma
id|l
suffix:semicolon
id|sound_device_id
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* device ID appears post g3 b&amp;w */
id|prop
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|info
comma
l_string|&quot;device-id&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prop
op_ne
l_int|0
)paren
id|sound_device_id
op_assign
op_star
id|prop
suffix:semicolon
multiline_comment|/* look for a property saying what sample rates&n;&t;&t;   are available */
id|prop
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|info
comma
l_string|&quot;sample-rates&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prop
op_eq
l_int|0
)paren
id|prop
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
(paren
id|info
comma
l_string|&quot;output-frame-rates&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
multiline_comment|/* if it&squot;s there use it to set up frame rates */
id|init_frame_rates
c_func
(paren
id|prop
comma
id|l
)paren
suffix:semicolon
)brace
id|out_le32
c_func
(paren
op_amp
id|awacs-&gt;control
comma
l_int|0x11
)paren
suffix:semicolon
multiline_comment|/* set everything quiesent */
id|set_hw_byteswap
c_func
(paren
id|io
)paren
suffix:semicolon
multiline_comment|/* figure out if the h/w can do it */
multiline_comment|/* get default volume from nvram&n;&t; * vol = (~nvram_read_byte(0x1308) &amp; 7) &lt;&lt; 1;&n;&t;*/
id|vol
op_assign
(paren
(paren
id|pmac_xpram_read
c_func
(paren
l_int|8
)paren
op_amp
l_int|7
)paren
op_lshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* set up tracking values */
id|spk_vol
op_assign
id|vol
op_star
l_int|100
suffix:semicolon
id|spk_vol
op_div_assign
l_int|7
suffix:semicolon
multiline_comment|/* get set value to a percentage */
id|spk_vol
op_or_assign
(paren
id|spk_vol
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* equal left &amp; right */
id|line_vol
op_assign
id|passthru_vol
op_assign
id|spk_vol
suffix:semicolon
multiline_comment|/* fill regs that are shared between AWACS &amp; Burgundy */
id|awacs_reg
(braket
l_int|2
)braket
op_assign
id|vol
op_plus
(paren
id|vol
op_lshift
l_int|6
)paren
suffix:semicolon
id|awacs_reg
(braket
l_int|4
)braket
op_assign
id|vol
op_plus
(paren
id|vol
op_lshift
l_int|6
)paren
suffix:semicolon
id|awacs_reg
(braket
l_int|5
)braket
op_assign
id|vol
op_plus
(paren
id|vol
op_lshift
l_int|6
)paren
suffix:semicolon
multiline_comment|/* screamer has loopthru vol control */
id|awacs_reg
(braket
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* maybe should be vol &lt;&lt; 3 for PCMCIA speaker */
id|awacs_reg
(braket
l_int|7
)braket
op_assign
l_int|0
suffix:semicolon
id|awacs_reg
(braket
l_int|0
)braket
op_assign
id|MASK_MUX_CD
suffix:semicolon
id|awacs_reg
(braket
l_int|1
)braket
op_assign
id|MASK_LOOPTHRU
suffix:semicolon
multiline_comment|/* FIXME: Only machines with external SRS module need MASK_PAROUT */
r_if
c_cond
(paren
id|has_perch
op_logical_or
id|sound_device_id
op_eq
l_int|0x5
op_logical_or
multiline_comment|/*sound_device_id == 0x8 ||*/
id|sound_device_id
op_eq
l_int|0xb
)paren
id|awacs_reg
(braket
l_int|1
)braket
op_or_assign
id|MASK_PAROUT0
op_or
id|MASK_PAROUT1
suffix:semicolon
r_switch
c_cond
(paren
id|awacs_revision
)paren
(brace
r_case
id|AWACS_TUMBLER
suffix:colon
macro_line|#ifdef CONFIG_KMOD
id|request_module
c_func
(paren
l_string|&quot;i2c-keywest&quot;
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_KMOD */&t;
id|awacs_tumbler_init
c_func
(paren
)paren
suffix:semicolon
id|tas_init
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AWACS_DACA
suffix:colon
macro_line|#ifdef CONFIG_KMOD
id|request_module
c_func
(paren
l_string|&quot;i2c-keywest&quot;
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_KMOD */
id|daca_init
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* dont know how yet */
r_case
id|AWACS_BURGUNDY
suffix:colon
id|awacs_burgundy_init
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AWACS_SCREAMER
suffix:colon
r_case
id|AWACS_AWACS
suffix:colon
r_default
suffix:colon
id|load_awacs
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* enable/set-up external modules - when we know how */
r_if
c_cond
(paren
id|has_perch
)paren
id|awacs_enable_amp
c_func
(paren
l_int|100
op_star
l_int|0x101
)paren
suffix:semicolon
multiline_comment|/* Reset dbdma channels */
id|out_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;control
comma
(paren
id|RUN
op_or
id|PAUSE
op_or
id|FLUSH
op_or
id|WAKE
op_or
id|DEAD
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
r_while
c_loop
(paren
id|in_le32
c_func
(paren
op_amp
id|awacs_txdma-&gt;status
)paren
op_amp
id|RUN
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|awacs_rxdma-&gt;control
comma
(paren
id|RUN
op_or
id|PAUSE
op_or
id|FLUSH
op_or
id|WAKE
op_or
id|DEAD
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
r_while
c_loop
(paren
id|in_le32
c_func
(paren
op_amp
id|awacs_rxdma-&gt;status
)paren
op_amp
id|RUN
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Initialize beep stuff */
r_if
c_cond
(paren
(paren
id|res
op_assign
id|setup_beep
c_func
(paren
)paren
)paren
)paren
r_return
id|res
suffix:semicolon
macro_line|#ifdef CONFIG_PMAC_PBOOK
id|pmu_register_sleep_notifier
c_func
(paren
op_amp
id|awacs_sleep_notifier
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PMAC_PBOOK */
multiline_comment|/* Powerbooks have odd ways of enabling inputs such as&n;&t;   an expansion-bay CD or sound from an internal modem&n;&t;   or a PC-card modem. */
r_if
c_cond
(paren
id|is_pbook_3X00
)paren
(brace
multiline_comment|/*&n;&t;&t; * Enable CD and PC-card sound inputs.&n;&t;&t; * This is done by reading from address&n;&t;&t; * f301a000, + 0x10 to enable the expansion-bay&n;&t;&t; * CD sound input, + 0x80 to enable the PC-card&n;&t;&t; * sound input.  The 0x100 enables the SCSI bus&n;&t;&t; * terminator power.&n;&t;&t; */
id|latch_base
op_assign
(paren
r_int
r_char
op_star
)paren
id|ioremap
(paren
l_int|0xf301a000
comma
l_int|0x1000
)paren
suffix:semicolon
id|in_8
c_func
(paren
id|latch_base
op_plus
l_int|0x190
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|is_pbook_g3
)paren
(brace
r_struct
id|device_node
op_star
id|mio
suffix:semicolon
id|macio_base
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|mio
op_assign
id|io-&gt;parent
suffix:semicolon
id|mio
suffix:semicolon
id|mio
op_assign
id|mio-&gt;parent
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|mio-&gt;name
comma
l_string|&quot;mac-io&quot;
)paren
op_eq
l_int|0
op_logical_and
id|mio-&gt;n_addrs
OG
l_int|0
)paren
(brace
id|macio_base
op_assign
(paren
r_int
r_char
op_star
)paren
id|ioremap
(paren
id|mio-&gt;addrs
(braket
l_int|0
)braket
dot
id|address
comma
l_int|0x40
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Enable CD sound input.&n;&t;&t; * The relevant bits for writing to this byte are 0x8f.&n;&t;&t; * I haven&squot;t found out what the 0x80 bit does.&n;&t;&t; * For the 0xf bits, writing 3 or 7 enables the CD&n;&t;&t; * input, any other value disables it.  Values&n;&t;&t; * 1, 3, 5, 7 enable the microphone.  Values 0, 2,&n;&t;&t; * 4, 6, 8 - f enable the input from the modem.&n;&t;&t; *  -- paulus.&n;&t;&t; */
r_if
c_cond
(paren
id|macio_base
)paren
id|out_8
c_func
(paren
id|macio_base
op_plus
l_int|0x37
comma
l_int|3
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hw_can_byteswap
)paren
id|dmasound.mach.hardware_afmts
op_assign
(paren
id|AFMT_S16_BE
op_or
id|AFMT_S16_LE
)paren
suffix:semicolon
r_else
id|dmasound.mach.hardware_afmts
op_assign
id|AFMT_S16_BE
suffix:semicolon
multiline_comment|/* shut out chips that do output only.&n;&t;   may need to extend this to machines which have no inputs - even tho&squot;&n;&t;   they use screamer - IIRC one of the powerbooks is like this.&n;&t;*/
r_if
c_cond
(paren
id|awacs_revision
op_ne
id|AWACS_TUMBLER
op_logical_and
id|awacs_revision
op_ne
id|AWACS_DACA
)paren
(brace
id|dmasound.mach.capabilities
op_assign
id|DSP_CAP_DUPLEX
suffix:semicolon
id|dmasound.mach.record
op_assign
id|PMacRecord
suffix:semicolon
)brace
id|dmasound.mach.default_hard
op_assign
id|def_hard
suffix:semicolon
id|dmasound.mach.default_soft
op_assign
id|def_soft
suffix:semicolon
r_switch
c_cond
(paren
id|awacs_revision
)paren
(brace
r_case
id|AWACS_BURGUNDY
suffix:colon
id|sprintf
c_func
(paren
id|awacs_name
comma
l_string|&quot;PowerMac Burgundy &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AWACS_DACA
suffix:colon
id|sprintf
c_func
(paren
id|awacs_name
comma
l_string|&quot;PowerMac DACA &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AWACS_TUMBLER
suffix:colon
id|sprintf
c_func
(paren
id|awacs_name
comma
l_string|&quot;PowerMac Tumbler &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AWACS_SCREAMER
suffix:colon
id|sprintf
c_func
(paren
id|awacs_name
comma
l_string|&quot;PowerMac Screamer &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AWACS_AWACS
suffix:colon
r_default
suffix:colon
id|sprintf
c_func
(paren
id|awacs_name
comma
l_string|&quot;PowerMac AWACS rev %d &quot;
comma
id|awacs_revision
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|dmasound_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|dmasound_awacs_cleanup
r_static
r_void
id|__exit
id|dmasound_awacs_cleanup
c_func
(paren
r_void
)paren
(brace
r_switch
c_cond
(paren
id|awacs_revision
)paren
(brace
r_case
id|AWACS_TUMBLER
suffix:colon
id|awacs_tumbler_cleanup
c_func
(paren
)paren
suffix:semicolon
id|tas_cleanup
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AWACS_DACA
suffix:colon
id|daca_cleanup
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dmasound_deinit
c_func
(paren
)paren
suffix:semicolon
)brace
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;PowerMac built-in audio driver.&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|dmasound_awacs_init
id|module_init
c_func
(paren
id|dmasound_awacs_init
)paren
suffix:semicolon
DECL|variable|dmasound_awacs_cleanup
id|module_exit
c_func
(paren
id|dmasound_awacs_cleanup
)paren
suffix:semicolon
eof
