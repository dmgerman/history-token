multiline_comment|/*&n; *  linux/drivers/sound/dmasound/dmasound_core.c&n; *&n; *&n; *  OSS/Free compatible Atari TT/Falcon and Amiga DMA sound driver for&n; *  Linux/m68k&n; *  Extended to support Power Macintosh for Linux/ppc by Paul Mackerras&n; *&n; *  (c) 1995 by Michael Schlueter &amp; Michael Marte&n; *&n; *  Michael Schlueter (michael@duck.syd.de) did the basic structure of the VFS&n; *  interface and the u-law to signed byte conversion.&n; *&n; *  Michael Marte (marte@informatik.uni-muenchen.de) did the sound queue,&n; *  /dev/mixer, /dev/sndstat and complemented the VFS interface. He would like&n; *  to thank:&n; *    - Michael Schlueter for initial ideas and documentation on the MFP and&n; *&t;the DMA sound hardware.&n; *    - Therapy? for their CD &squot;Troublegum&squot; which really made me rock.&n; *&n; *  /dev/sndstat is based on code by Hannu Savolainen, the author of the&n; *  VoxWare family of drivers.&n; *&n; *  This file is subject to the terms and conditions of the GNU General Public&n; *  License.  See the file COPYING in the main directory of this archive&n; *  for more details.&n; *&n; *  History:&n; *&n; *&t;1995/8/25&t;First release&n; *&n; *&t;1995/9/02&t;Roman Hodek:&n; *&t;&t;&t;  - Fixed atari_stram_alloc() call, the timer&n; *&t;&t;&t;    programming and several race conditions&n; *&t;1995/9/14&t;Roman Hodek:&n; *&t;&t;&t;  - After some discussion with Michael Schlueter,&n; *&t;&t;&t;    revised the interrupt disabling&n; *&t;&t;&t;  - Slightly speeded up U8-&gt;S8 translation by using&n; *&t;&t;&t;    long operations where possible&n; *&t;&t;&t;  - Added 4:3 interpolation for /dev/audio&n; *&n; *&t;1995/9/20&t;Torsten Scherer:&n; *&t;&t;&t;  - Fixed a bug in sq_write and changed /dev/audio&n; *&t;&t;&t;    converting to play at 12517Hz instead of 6258Hz.&n; *&n; *&t;1995/9/23&t;Torsten Scherer:&n; *&t;&t;&t;  - Changed sq_interrupt() and sq_play() to pre-program&n; *&t;&t;&t;    the DMA for another frame while there&squot;s still one&n; *&t;&t;&t;    running. This allows the IRQ response to be&n; *&t;&t;&t;    arbitrarily delayed and playing will still continue.&n; *&n; *&t;1995/10/14&t;Guenther Kelleter, Torsten Scherer:&n; *&t;&t;&t;  - Better support for Falcon audio (the Falcon doesn&squot;t&n; *&t;&t;&t;    raise an IRQ at the end of a frame, but at the&n; *&t;&t;&t;    beginning instead!). uses &squot;if (codec_dma)&squot; in lots&n; *&t;&t;&t;    of places to simply switch between Falcon and TT&n; *&t;&t;&t;    code.&n; *&n; *&t;1995/11/06&t;Torsten Scherer:&n; *&t;&t;&t;  - Started introducing a hardware abstraction scheme&n; *&t;&t;&t;    (may perhaps also serve for Amigas?)&n; *&t;&t;&t;  - Can now play samples at almost all frequencies by&n; *&t;&t;&t;    means of a more generalized expand routine&n; *&t;&t;&t;  - Takes a good deal of care to cut data only at&n; *&t;&t;&t;    sample sizes&n; *&t;&t;&t;  - Buffer size is now a kernel runtime option&n; *&t;&t;&t;  - Implemented fsync() &amp; several minor improvements&n; *&t;&t;&t;Guenther Kelleter:&n; *&t;&t;&t;  - Useful hints and bug fixes&n; *&t;&t;&t;  - Cross-checked it for Falcons&n; *&n; *&t;1996/3/9&t;Geert Uytterhoeven:&n; *&t;&t;&t;  - Support added for Amiga, A-law, 16-bit little&n; *&t;&t;&t;    endian.&n; *&t;&t;&t;  - Unification to drivers/sound/dmasound.c.&n; *&n; *&t;1996/4/6&t;Martin Mitchell:&n; *&t;&t;&t;  - Updated to 1.3 kernel.&n; *&n; *&t;1996/6/13       Topi Kanerva:&n; *&t;&t;&t;  - Fixed things that were broken (mainly the amiga&n; *&t;&t;&t;    14-bit routines)&n; *&t;&t;&t;  - /dev/sndstat shows now the real hardware frequency&n; *&t;&t;&t;  - The lowpass filter is disabled by default now&n; *&n; *&t;1996/9/25&t;Geert Uytterhoeven:&n; *&t;&t;&t;  - Modularization&n; *&n; *&t;1998/6/10&t;Andreas Schwab:&n; *&t;&t;&t;  - Converted to use sound_core&n; *&n; *&t;1999/12/28&t;Richard Zidlicky:&n; *&t;&t;&t;  - Added support for Q40&n; *&n; *&t;2000/2/27&t;Geert Uytterhoeven:&n; *&t;&t;&t;  - Clean up and split the code into 4 parts:&n; *&t;&t;&t;      o dmasound_core: machine-independent code&n; *&t;&t;&t;      o dmasound_atari: Atari TT and Falcon support&n; *&t;&t;&t;      o dmasound_awacs: Apple PowerMac support&n; *&t;&t;&t;      o dmasound_paula: Amiga support&n; *&n; *&t;2000/3/25&t;Geert Uytterhoeven:&n; *&t;&t;&t;  - Integration of dmasound_q40&n; *&t;&t;&t;  - Small clean ups&n; *&n; *&t;2001/01/26 [1.0] Iain Sandoe&n; *&t;&t;&t;  - make /dev/sndstat show revision &amp; edition info.&n; *&t;&t;&t;  - since dmasound.mach.sq_setup() can fail on pmac&n; *&t;&t;&t;    its type has been changed to int and the returns&n; *&t;&t;&t;    are checked.&n; *&t;&t;   [1.1]  - stop missing translations from being called.&n; *&t;2001/02/08 [1.2]  - remove unused translation tables &amp; move machine-&n; *&t;&t;&t;    specific tables to low-level.&n; *&t;&t;&t;  - return correct info. for SNDCTL_DSP_GETFMTS.&n; *&t;&t;   [1.3]  - implement SNDCTL_DSP_GETCAPS fully.&n; *&t;&t;   [1.4]  - make /dev/sndstat text length usage deterministic.&n; *&t;&t;&t;  - make /dev/sndstat call to low-level&n; *&t;&t;&t;    dmasound.mach.state_info() pass max space to ll driver.&n; *&t;&t;&t;  - tidy startup banners and output info.&n; *&t;&t;   [1.5]  - tidy up a little (removed some unused #defines in&n; *&t;&t;&t;    dmasound.h)&n; *&t;&t;&t;  - fix up HAS_RECORD conditionalisation.&n; *&t;&t;&t;  - add record code in places it is missing...&n; *&t;&t;&t;  - change buf-sizes to bytes to allow &lt; 1kb for pmac&n; *&t;&t;&t;    if user param entry is &lt; 256 the value is taken to&n; *&t;&t;&t;    be in kb &gt; 256 is taken to be in bytes.&n; *&t;&t;&t;  - make default buff/frag params conditional on&n; *&t;&t;&t;    machine to allow smaller values for pmac.&n; *&t;&t;&t;  - made the ioctls, read &amp; write comply with the OSS&n; *&t;&t;&t;    rules on setting params.&n; *&t;&t;&t;  - added parsing of _setup() params for record.&n; *&t;2001/04/04 [1.6]  - fix bug where sample rates higher than maximum were&n; *&t;&t;&t;    being reported as OK.&n; *&t;&t;&t;  - fix open() to return -EBUSY as per OSS doc. when&n; *&t;&t;&t;    audio is in use - this is independent of O_NOBLOCK.&n; *&t;&t;&t;  - fix bug where SNDCTL_DSP_POST was blocking.&n; */
multiline_comment|/* Record capability notes 30/01/2001:&n;  * At present these observations apply only to pmac LL driver (the only one&n;  * that can do record, at present).  However, if other LL drivers for machines&n;  * with record are added they may apply.&n;  *&n;  * The fragment parameters for the record and play channels are separate.&n;  * However, if the driver is opened O_RDWR there is no way (in the current OSS&n;  * API) to specify their values independently for the record and playback&n;  * channels.  Since the only common factor between the input &amp; output is the&n;  * sample rate (on pmac) it should be possible to open /dev/dspX O_WRONLY and&n;  * /dev/dspY O_RDONLY.  The input &amp; output channels could then have different&n;  * characteristics (other than the first that sets sample rate claiming the&n;  * right to set it for ever).  As it stands, the format, channels, number of&n;  * bits &amp; sample rate are assumed to be common.  In the future perhaps these&n;  * should be the responsibility of the LL driver - and then if a card really&n;  * does not share items between record &amp; playback they can be specified&n;  * separately.&n;*/
multiline_comment|/* Thread-safeness of shared_resources notes: 31/01/2001&n; * If the user opens O_RDWR and then splits record &amp; play between two threads&n; * both of which inherit the fd - and then starts changing things from both&n; * - we will have difficulty telling.&n; *&n; * It&squot;s bad application coding - but ...&n; * TODO: think about how to sort this out... without bogging everything down in&n; * semaphores.&n; *&n; * Similarly, the OSS spec says &quot;all changes to parameters must be between&n; * open() and the first read() or write(). - and a bit later on (by&n; * implication) &quot;between SNDCTL_DSP_RESET and the first read() or write() after&n; * it&quot;.  If the app is multi-threaded and this rule is broken between threads&n; * we will have trouble spotting it - and the fault will be rather obscure :-(&n; *&n; * We will try and put out at least a kmsg if we see it happen... but I think&n; * it will be quite hard to trap it with an -EXXX return... because we can&squot;t&n; * see the fault until after the damage is done.&n;*/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/sound.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/soundcard.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;dmasound.h&quot;
DECL|macro|DMASOUND_CORE_REVISION
mdefine_line|#define DMASOUND_CORE_REVISION 1
DECL|macro|DMASOUND_CORE_EDITION
mdefine_line|#define DMASOUND_CORE_EDITION 6
multiline_comment|/*&n;     *  Declarations&n;     */
DECL|variable|dmasound_catchRadius
r_int
id|dmasound_catchRadius
op_assign
l_int|0
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|dmasound_catchRadius
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|variable|numWriteBufs
r_static
r_int
r_int
id|numWriteBufs
op_assign
id|DEFAULT_N_BUFFERS
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|numWriteBufs
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|variable|writeBufSize
r_static
r_int
r_int
id|writeBufSize
op_assign
id|DEFAULT_BUFF_SIZE
suffix:semicolon
multiline_comment|/* in bytes */
id|MODULE_PARM
c_func
(paren
id|writeBufSize
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#ifdef HAS_RECORD
DECL|variable|numReadBufs
r_static
r_int
r_int
id|numReadBufs
op_assign
id|DEFAULT_N_BUFFERS
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|numReadBufs
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|variable|readBufSize
r_static
r_int
r_int
id|readBufSize
op_assign
id|DEFAULT_BUFF_SIZE
suffix:semicolon
multiline_comment|/* in bytes */
id|MODULE_PARM
c_func
(paren
id|readBufSize
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#endif
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
macro_line|#ifdef MODULE
DECL|variable|sq_unit
r_static
r_int
id|sq_unit
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|mixer_unit
r_static
r_int
id|mixer_unit
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|state_unit
r_static
r_int
id|state_unit
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|irq_installed
r_static
r_int
id|irq_installed
suffix:semicolon
macro_line|#endif /* MODULE */
multiline_comment|/* control over who can modify resources shared between play/record */
DECL|variable|shared_resource_owner
r_static
id|mode_t
id|shared_resource_owner
suffix:semicolon
DECL|variable|shared_resources_initialised
r_static
r_int
id|shared_resources_initialised
suffix:semicolon
multiline_comment|/*&n;     *  Mid level stuff&n;     */
DECL|variable|dmasound
r_struct
id|sound_settings
id|dmasound
suffix:semicolon
DECL|function|sound_silence
r_static
r_inline
r_void
id|sound_silence
c_func
(paren
r_void
)paren
(brace
id|dmasound.mach
dot
id|silence
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* _MUST_ stop DMA */
)brace
DECL|function|sound_set_format
r_static
r_inline
r_int
id|sound_set_format
c_func
(paren
r_int
id|format
)paren
(brace
r_return
id|dmasound.mach
dot
id|setFormat
c_func
(paren
id|format
)paren
suffix:semicolon
)brace
DECL|function|sound_set_speed
r_static
r_int
id|sound_set_speed
c_func
(paren
r_int
id|speed
)paren
(brace
r_if
c_cond
(paren
id|speed
OL
l_int|0
)paren
r_return
id|dmasound.soft.speed
suffix:semicolon
multiline_comment|/* trap out-of-range speed settings.&n;&t;   at present we allow (arbitrarily) low rates - using soft&n;&t;   up-conversion - but we can&squot;t allow &gt; max because there is&n;&t;   no soft down-conversion.&n;&t;*/
r_if
c_cond
(paren
id|dmasound.mach.max_dsp_speed
op_logical_and
(paren
id|speed
OG
id|dmasound.mach.max_dsp_speed
)paren
)paren
id|speed
op_assign
id|dmasound.mach.max_dsp_speed
suffix:semicolon
id|dmasound.soft.speed
op_assign
id|speed
suffix:semicolon
r_if
c_cond
(paren
id|dmasound.minDev
op_eq
id|SND_DEV_DSP
)paren
id|dmasound.dsp.speed
op_assign
id|dmasound.soft.speed
suffix:semicolon
r_return
id|dmasound.soft.speed
suffix:semicolon
)brace
DECL|function|sound_set_stereo
r_static
r_int
id|sound_set_stereo
c_func
(paren
r_int
id|stereo
)paren
(brace
r_if
c_cond
(paren
id|stereo
OL
l_int|0
)paren
r_return
id|dmasound.soft.stereo
suffix:semicolon
id|stereo
op_assign
op_logical_neg
op_logical_neg
id|stereo
suffix:semicolon
multiline_comment|/* should be 0 or 1 now */
id|dmasound.soft.stereo
op_assign
id|stereo
suffix:semicolon
r_if
c_cond
(paren
id|dmasound.minDev
op_eq
id|SND_DEV_DSP
)paren
id|dmasound.dsp.stereo
op_assign
id|stereo
suffix:semicolon
r_return
id|stereo
suffix:semicolon
)brace
DECL|function|sound_copy_translate
r_static
id|ssize_t
id|sound_copy_translate
c_func
(paren
id|TRANS
op_star
id|trans
comma
r_const
id|u_char
op_star
id|userPtr
comma
r_int
id|userCount
comma
id|u_char
id|frame
(braket
)braket
comma
id|ssize_t
op_star
id|frameUsed
comma
id|ssize_t
id|frameLeft
)paren
(brace
id|ssize_t
(paren
op_star
id|ct_func
)paren
(paren
r_const
id|u_char
op_star
comma
r_int
comma
id|u_char
op_star
comma
id|ssize_t
op_star
comma
id|ssize_t
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|dmasound.soft.format
)paren
(brace
r_case
id|AFMT_MU_LAW
suffix:colon
id|ct_func
op_assign
id|trans-&gt;ct_ulaw
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_A_LAW
suffix:colon
id|ct_func
op_assign
id|trans-&gt;ct_alaw
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_S8
suffix:colon
id|ct_func
op_assign
id|trans-&gt;ct_s8
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_U8
suffix:colon
id|ct_func
op_assign
id|trans-&gt;ct_u8
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_S16_BE
suffix:colon
id|ct_func
op_assign
id|trans-&gt;ct_s16be
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_U16_BE
suffix:colon
id|ct_func
op_assign
id|trans-&gt;ct_u16be
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_S16_LE
suffix:colon
id|ct_func
op_assign
id|trans-&gt;ct_s16le
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_U16_LE
suffix:colon
id|ct_func
op_assign
id|trans-&gt;ct_u16le
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if the user has requested a non-existent translation don&squot;t try&n;&t;   to call it but just return 0 bytes moved&n;&t;*/
r_if
c_cond
(paren
id|ct_func
)paren
r_return
id|ct_func
c_func
(paren
id|userPtr
comma
id|userCount
comma
id|frame
comma
id|frameUsed
comma
id|frameLeft
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     *  /dev/mixer abstraction&n;     */
r_static
r_struct
(brace
DECL|member|busy
r_int
id|busy
suffix:semicolon
DECL|member|modify_counter
r_int
id|modify_counter
suffix:semicolon
DECL|variable|mixer
)brace
id|mixer
suffix:semicolon
DECL|function|mixer_open
r_static
r_int
id|mixer_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|dmasound.mach
dot
id|open
c_func
(paren
)paren
suffix:semicolon
id|mixer.busy
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mixer_release
r_static
r_int
id|mixer_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|mixer.busy
op_assign
l_int|0
suffix:semicolon
id|dmasound.mach
dot
id|release
c_func
(paren
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mixer_ioctl
r_static
r_int
id|mixer_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
id|u_int
id|cmd
comma
id|u_long
id|arg
)paren
(brace
r_if
c_cond
(paren
id|_SIOC_DIR
c_func
(paren
id|cmd
)paren
op_amp
id|_SIOC_WRITE
)paren
id|mixer.modify_counter
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|OSS_GETVERSION
suffix:colon
r_return
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|SOUND_VERSION
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_INFO
suffix:colon
(brace
id|mixer_info
id|info
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|info
comma
l_int|0
comma
r_sizeof
(paren
id|info
)paren
)paren
suffix:semicolon
id|strlcpy
c_func
(paren
id|info.id
comma
id|dmasound.mach.name2
comma
r_sizeof
(paren
id|info.id
)paren
)paren
suffix:semicolon
id|strlcpy
c_func
(paren
id|info.name
comma
id|dmasound.mach.name2
comma
r_sizeof
(paren
id|info.name
)paren
)paren
suffix:semicolon
id|info.modify_counter
op_assign
id|mixer.modify_counter
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_int
op_star
)paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dmasound.mach.mixer_ioctl
)paren
r_return
id|dmasound.mach
dot
id|mixer_ioctl
c_func
(paren
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|variable|mixer_fops
r_static
r_struct
id|file_operations
id|mixer_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|llseek
op_assign
id|no_llseek
comma
dot
id|ioctl
op_assign
id|mixer_ioctl
comma
dot
id|open
op_assign
id|mixer_open
comma
dot
id|release
op_assign
id|mixer_release
comma
)brace
suffix:semicolon
DECL|function|mixer_init
r_static
r_void
id|__init
id|mixer_init
c_func
(paren
r_void
)paren
(brace
macro_line|#ifndef MODULE
r_int
id|mixer_unit
suffix:semicolon
macro_line|#endif
id|mixer_unit
op_assign
id|register_sound_mixer
c_func
(paren
op_amp
id|mixer_fops
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mixer_unit
OL
l_int|0
)paren
r_return
suffix:semicolon
id|mixer.busy
op_assign
l_int|0
suffix:semicolon
id|dmasound.treble
op_assign
l_int|0
suffix:semicolon
id|dmasound.bass
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dmasound.mach.mixer_init
)paren
id|dmasound.mach
dot
id|mixer_init
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     *  Sound queue stuff, the heart of the driver&n;     */
DECL|variable|dmasound_write_sq
r_struct
id|sound_queue
id|dmasound_write_sq
suffix:semicolon
r_static
r_void
id|sq_reset_output
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef HAS_RECORD
DECL|variable|dmasound_read_sq
r_struct
id|sound_queue
id|dmasound_read_sq
suffix:semicolon
r_static
r_void
id|sq_reset_input
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
DECL|function|sq_allocate_buffers
r_static
r_int
id|sq_allocate_buffers
c_func
(paren
r_struct
id|sound_queue
op_star
id|sq
comma
r_int
id|num
comma
r_int
id|size
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|sq-&gt;buffers
)paren
r_return
l_int|0
suffix:semicolon
id|sq-&gt;numBufs
op_assign
id|num
suffix:semicolon
id|sq-&gt;bufSize
op_assign
id|size
suffix:semicolon
id|sq-&gt;buffers
op_assign
id|kmalloc
(paren
id|num
op_star
r_sizeof
(paren
r_char
op_star
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sq-&gt;buffers
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sq-&gt;buffers
(braket
id|i
)braket
op_assign
id|dmasound.mach
dot
id|dma_alloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sq-&gt;buffers
(braket
id|i
)braket
)paren
(brace
r_while
c_loop
(paren
id|i
op_decrement
)paren
id|dmasound.mach
dot
id|dma_free
c_func
(paren
id|sq-&gt;buffers
(braket
id|i
)braket
comma
id|size
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sq-&gt;buffers
)paren
suffix:semicolon
id|sq-&gt;buffers
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sq_release_buffers
r_static
r_void
id|sq_release_buffers
c_func
(paren
r_struct
id|sound_queue
op_star
id|sq
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|sq-&gt;buffers
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sq-&gt;numBufs
suffix:semicolon
id|i
op_increment
)paren
id|dmasound.mach
dot
id|dma_free
c_func
(paren
id|sq-&gt;buffers
(braket
id|i
)braket
comma
id|sq-&gt;bufSize
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sq-&gt;buffers
)paren
suffix:semicolon
id|sq-&gt;buffers
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|sq_setup
r_static
r_int
id|sq_setup
c_func
(paren
r_struct
id|sound_queue
op_star
id|sq
)paren
(brace
r_int
(paren
op_star
id|setup_func
)paren
(paren
r_void
)paren
op_assign
l_int|0
suffix:semicolon
r_int
id|hard_frame
suffix:semicolon
r_if
c_cond
(paren
id|sq-&gt;locked
)paren
(brace
multiline_comment|/* are we already set? - and not changeable */
macro_line|#ifdef DEBUG_DMASOUND
id|printk
c_func
(paren
l_string|&quot;dmasound_core: tried to sq_setup a locked queue&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|sq-&gt;locked
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* don&squot;t think we have a race prob. here _check_ */
multiline_comment|/* make sure that the parameters are set up&n;&t;   This should have been done already...&n;&t;*/
id|dmasound.mach
dot
id|init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* OK.  If the user has set fragment parameters explicitly, then we&n;&t;   should leave them alone... as long as they are valid.&n;&t;   Invalid user fragment params can occur if we allow the whole buffer&n;&t;   to be used when the user requests the fragments sizes (with no soft&n;&t;   x-lation) and then the user subsequently sets a soft x-lation that&n;&t;   requires increased internal buffering.&n;&n;&t;   Othwerwise (if the user did not set them) OSS says that we should&n;&t;   select frag params on the basis of 0.5 s output &amp; 0.1 s input&n;&t;   latency. (TODO.  For now we will copy in the defaults.)&n;&t;*/
r_if
c_cond
(paren
id|sq-&gt;user_frags
op_le
l_int|0
)paren
(brace
id|sq-&gt;max_count
op_assign
id|sq-&gt;numBufs
suffix:semicolon
id|sq-&gt;max_active
op_assign
id|sq-&gt;numBufs
suffix:semicolon
id|sq-&gt;block_size
op_assign
id|sq-&gt;bufSize
suffix:semicolon
multiline_comment|/* set up the user info */
id|sq-&gt;user_frags
op_assign
id|sq-&gt;numBufs
suffix:semicolon
id|sq-&gt;user_frag_size
op_assign
id|sq-&gt;bufSize
suffix:semicolon
id|sq-&gt;user_frag_size
op_mul_assign
(paren
id|dmasound.soft.size
op_star
(paren
id|dmasound.soft.stereo
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|sq-&gt;user_frag_size
op_div_assign
(paren
id|dmasound.hard.size
op_star
(paren
id|dmasound.hard.stereo
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* work out requested block size */
id|sq-&gt;block_size
op_assign
id|sq-&gt;user_frag_size
suffix:semicolon
id|sq-&gt;block_size
op_mul_assign
(paren
id|dmasound.hard.size
op_star
(paren
id|dmasound.hard.stereo
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|sq-&gt;block_size
op_div_assign
(paren
id|dmasound.soft.size
op_star
(paren
id|dmasound.soft.stereo
op_plus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* the user wants to write frag-size chunks */
id|sq-&gt;block_size
op_mul_assign
id|dmasound.hard.speed
suffix:semicolon
id|sq-&gt;block_size
op_div_assign
id|dmasound.soft.speed
suffix:semicolon
multiline_comment|/* this only works for size values which are powers of 2 */
id|hard_frame
op_assign
(paren
id|dmasound.hard.size
op_star
(paren
id|dmasound.hard.stereo
op_plus
l_int|1
)paren
)paren
op_div
l_int|8
suffix:semicolon
id|sq-&gt;block_size
op_add_assign
(paren
id|hard_frame
op_minus
l_int|1
)paren
suffix:semicolon
id|sq-&gt;block_size
op_and_assign
op_complement
(paren
id|hard_frame
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* make sure we are aligned */
multiline_comment|/* let&squot;s just check for obvious mistakes */
r_if
c_cond
(paren
id|sq-&gt;block_size
op_le
l_int|0
op_logical_or
id|sq-&gt;block_size
OG
id|sq-&gt;bufSize
)paren
(brace
macro_line|#ifdef DEBUG_DMASOUND
id|printk
c_func
(paren
l_string|&quot;dmasound_core: invalid frag size (user set %d)&bslash;n&quot;
comma
id|sq-&gt;user_frag_size
)paren
suffix:semicolon
macro_line|#endif
id|sq-&gt;block_size
op_assign
id|sq-&gt;bufSize
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sq-&gt;user_frags
op_le
id|sq-&gt;numBufs
)paren
(brace
id|sq-&gt;max_count
op_assign
id|sq-&gt;user_frags
suffix:semicolon
multiline_comment|/* if user has set max_active - then use it */
id|sq-&gt;max_active
op_assign
(paren
id|sq-&gt;max_active
op_le
id|sq-&gt;max_count
)paren
ques
c_cond
id|sq-&gt;max_active
suffix:colon
id|sq-&gt;max_count
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef DEBUG_DMASOUND
id|printk
c_func
(paren
l_string|&quot;dmasound_core: invalid frag count (user set %d)&bslash;n&quot;
comma
id|sq-&gt;user_frags
)paren
suffix:semicolon
macro_line|#endif
id|sq-&gt;max_count
op_assign
id|sq-&gt;max_active
op_assign
id|sq-&gt;numBufs
suffix:semicolon
)brace
)brace
id|sq-&gt;front
op_assign
id|sq-&gt;count
op_assign
id|sq-&gt;rear_size
op_assign
l_int|0
suffix:semicolon
id|sq-&gt;syncing
op_assign
l_int|0
suffix:semicolon
id|sq-&gt;active
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sq
op_eq
op_amp
id|write_sq
)paren
(brace
id|sq-&gt;rear
op_assign
op_minus
l_int|1
suffix:semicolon
id|setup_func
op_assign
id|dmasound.mach.write_sq_setup
suffix:semicolon
)brace
macro_line|#ifdef HAS_RECORD
r_else
(brace
id|sq-&gt;rear
op_assign
l_int|0
suffix:semicolon
id|setup_func
op_assign
id|dmasound.mach.read_sq_setup
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|setup_func
)paren
r_return
id|setup_func
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sq_play
r_static
r_inline
r_void
id|sq_play
c_func
(paren
r_void
)paren
(brace
id|dmasound.mach
dot
id|play
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|sq_write
r_static
id|ssize_t
id|sq_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|src
comma
r_int
id|uLeft
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|ssize_t
id|uWritten
op_assign
l_int|0
suffix:semicolon
id|u_char
op_star
id|dest
suffix:semicolon
id|ssize_t
id|uUsed
op_assign
l_int|0
comma
id|bUsed
comma
id|bLeft
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* ++TeSche: Is something like this necessary?&n;&t; * Hey, that&squot;s an honest question! Or does any other part of the&n;&t; * filesystem already checks this situation? I really don&squot;t know.&n;&t; */
r_if
c_cond
(paren
id|uLeft
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* implement any changes we have made to the soft/hard params.&n;&t;   this is not satisfactory really, all we have done up to now is to&n;&t;   say what we would like - there hasn&squot;t been any real checking of capability&n;&t;*/
r_if
c_cond
(paren
id|shared_resources_initialised
op_eq
l_int|0
)paren
(brace
id|dmasound.mach
dot
id|init
c_func
(paren
)paren
suffix:semicolon
id|shared_resources_initialised
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* set up the sq if it is not already done. This may seem a dumb place&n;&t;   to do it - but it is what OSS requires.  It means that write() can&n;&t;   return memory allocation errors.  To avoid this possibility use the&n;&t;   GETBLKSIZE or GETOSPACE ioctls (after you&squot;ve fiddled with all the&n;&t;   params you want to change) - these ioctls also force the setup.&n;&t;*/
r_if
c_cond
(paren
id|write_sq.locked
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|uWritten
op_assign
id|sq_setup
c_func
(paren
op_amp
id|write_sq
)paren
)paren
OL
l_int|0
)paren
r_return
id|uWritten
suffix:semicolon
id|uWritten
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* FIXME: I think that this may be the wrong behaviour when we get strapped&n;&t;for time and the cpu is close to being (or actually) behind in sending data.&n;&t;- because we&squot;ve lost the time that the N samples, already in the buffer,&n;&t;would have given us to get here with the next lot from the user.&n;*/
multiline_comment|/* The interrupt doesn&squot;t start to play the last, incomplete frame.&n;&t; * Thus we can append to it without disabling the interrupts! (Note&n;&t; * also that write_sq.rear isn&squot;t affected by the interrupt.)&n;&t; */
multiline_comment|/* as of 1.6 this behaviour changes if SNDCTL_DSP_POST has been issued:&n;&t;   this will mimic the behaviour of syncing and allow the sq_play() to&n;&t;   queue a partial fragment.  Since sq_play() may/will be called from&n;&t;   the IRQ handler - at least on Pmac we have to deal with it.&n;&t;   The strategy - possibly not optimum - is to kill _POST status if we&n;&t;   get here.  This seems, at least, reasonable - in the sense that POST&n;&t;   is supposed to indicate that we might not write before the queue&n;&t;   is drained - and if we get here in time then it does not apply.&n;&t;*/
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dmasound.lock
comma
id|flags
)paren
suffix:semicolon
id|write_sq.syncing
op_and_assign
op_complement
l_int|2
suffix:semicolon
multiline_comment|/* take out POST status */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dmasound.lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_sq.count
OG
l_int|0
op_logical_and
(paren
id|bLeft
op_assign
id|write_sq.block_size
op_minus
id|write_sq.rear_size
)paren
OG
l_int|0
)paren
(brace
id|dest
op_assign
id|write_sq.buffers
(braket
id|write_sq.rear
)braket
suffix:semicolon
id|bUsed
op_assign
id|write_sq.rear_size
suffix:semicolon
id|uUsed
op_assign
id|sound_copy_translate
c_func
(paren
id|dmasound.trans_write
comma
id|src
comma
id|uLeft
comma
id|dest
comma
op_amp
id|bUsed
comma
id|bLeft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uUsed
op_le
l_int|0
)paren
r_return
id|uUsed
suffix:semicolon
id|src
op_add_assign
id|uUsed
suffix:semicolon
id|uWritten
op_add_assign
id|uUsed
suffix:semicolon
id|uLeft
op_assign
(paren
id|uUsed
op_le
id|uLeft
)paren
ques
c_cond
(paren
id|uLeft
op_minus
id|uUsed
)paren
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* paranoia */
id|write_sq.rear_size
op_assign
id|bUsed
suffix:semicolon
)brace
r_while
c_loop
(paren
id|uLeft
)paren
(brace
r_while
c_loop
(paren
id|write_sq.count
op_ge
id|write_sq.max_active
)paren
(brace
id|sq_play
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_sq.open_mode
op_amp
id|O_NONBLOCK
)paren
r_return
id|uWritten
OG
l_int|0
ques
c_cond
id|uWritten
suffix:colon
op_minus
id|EAGAIN
suffix:semicolon
id|SLEEP
c_func
(paren
id|write_sq.action_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
id|uWritten
OG
l_int|0
ques
c_cond
id|uWritten
suffix:colon
op_minus
id|EINTR
suffix:semicolon
)brace
multiline_comment|/* Here, we can avoid disabling the interrupt by first&n;&t;&t; * copying and translating the data, and then updating&n;&t;&t; * the write_sq variables. Until this is done, the interrupt&n;&t;&t; * won&squot;t see the new frame and we can work on it&n;&t;&t; * undisturbed.&n;&t;&t; */
id|dest
op_assign
id|write_sq.buffers
(braket
(paren
id|write_sq.rear
op_plus
l_int|1
)paren
op_mod
id|write_sq.max_count
)braket
suffix:semicolon
id|bUsed
op_assign
l_int|0
suffix:semicolon
id|bLeft
op_assign
id|write_sq.block_size
suffix:semicolon
id|uUsed
op_assign
id|sound_copy_translate
c_func
(paren
id|dmasound.trans_write
comma
id|src
comma
id|uLeft
comma
id|dest
comma
op_amp
id|bUsed
comma
id|bLeft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uUsed
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|src
op_add_assign
id|uUsed
suffix:semicolon
id|uWritten
op_add_assign
id|uUsed
suffix:semicolon
id|uLeft
op_assign
(paren
id|uUsed
op_le
id|uLeft
)paren
ques
c_cond
(paren
id|uLeft
op_minus
id|uUsed
)paren
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* paranoia */
r_if
c_cond
(paren
id|bUsed
)paren
(brace
id|write_sq.rear
op_assign
(paren
id|write_sq.rear
op_plus
l_int|1
)paren
op_mod
id|write_sq.max_count
suffix:semicolon
id|write_sq.rear_size
op_assign
id|bUsed
suffix:semicolon
id|write_sq.count
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* uUsed may have been 0 */
id|sq_play
c_func
(paren
)paren
suffix:semicolon
r_return
id|uUsed
OL
l_int|0
ques
c_cond
id|uUsed
suffix:colon
id|uWritten
suffix:semicolon
)brace
DECL|function|sq_poll
r_static
r_int
r_int
id|sq_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|poll_table_struct
op_star
id|wait
)paren
(brace
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
r_int
id|retVal
suffix:semicolon
r_if
c_cond
(paren
id|write_sq.locked
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|retVal
op_assign
id|sq_setup
c_func
(paren
op_amp
id|write_sq
)paren
)paren
OL
l_int|0
)paren
r_return
id|retVal
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|write_sq.action_queue
comma
id|wait
)paren
suffix:semicolon
macro_line|#ifdef HAS_RECORD
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|read_sq.action_queue
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
r_if
c_cond
(paren
id|read_sq.block_size
op_minus
id|read_sq.rear_size
OG
l_int|0
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
r_if
c_cond
(paren
id|write_sq.count
template_param
l_int|0
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
macro_line|#ifdef HAS_RECORD
multiline_comment|/*&n;     *  Here is how the values are used for reading.&n;     *  The value &squot;active&squot; simply indicates the DMA is running.  This is done&n;     *  so the driver semantics are DMA starts when the first read is posted.&n;     *  The value &squot;front&squot; indicates the buffer we should next send to the user.&n;     *  The value &squot;rear&squot; indicates the buffer the DMA is currently filling.&n;     *  When &squot;front&squot; == &squot;rear&squot; the buffer &quot;ring&quot; is empty (we always have an&n;     *  empty available).  The &squot;rear_size&squot; is used to track partial offsets&n;     *  into the buffer we are currently returning to the user.&n;&n;     *  This level (&gt; [1.5]) doesn&squot;t care what strategy the LL driver uses with&n;     *  DMA on over-run.  It can leave it running (and keep active == 1) or it&n;     *  can kill it and set active == 0 in which case this routine will spot&n;     *  it and restart the DMA.&n;     */
DECL|function|sq_read
r_static
id|ssize_t
id|sq_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|dst
comma
r_int
id|uLeft
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|ssize_t
id|uRead
comma
id|bLeft
comma
id|bUsed
comma
id|uUsed
suffix:semicolon
r_if
c_cond
(paren
id|uLeft
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* cater for the compatibility mode - record compiled in but no LL */
r_if
c_cond
(paren
id|dmasound.mach.record
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* see comment in sq_write()&n;&t;*/
r_if
c_cond
(paren
id|shared_resources_initialised
op_eq
l_int|0
)paren
(brace
id|dmasound.mach
dot
id|init
c_func
(paren
)paren
suffix:semicolon
id|shared_resources_initialised
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* set up the sq if it is not already done. see comments in sq_write().&n;&t;*/
r_if
c_cond
(paren
id|read_sq.locked
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|uRead
op_assign
id|sq_setup
c_func
(paren
op_amp
id|read_sq
)paren
)paren
OL
l_int|0
)paren
r_return
id|uRead
suffix:semicolon
)brace
id|uRead
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Move what the user requests, depending upon other options.&n;&t;*/
r_while
c_loop
(paren
id|uLeft
OG
l_int|0
)paren
(brace
multiline_comment|/* we happened to get behind and the LL driver killed DMA&n;&t;&t;   then we should set it going again.  This also sets it&n;&t;&t;   going the first time through.&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|read_sq.active
)paren
id|dmasound.mach
dot
id|record
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* When front == rear, the DMA is not done yet.&n;&t;&t;*/
r_while
c_loop
(paren
id|read_sq.front
op_eq
id|read_sq.rear
)paren
(brace
r_if
c_cond
(paren
id|read_sq.open_mode
op_amp
id|O_NONBLOCK
)paren
(brace
r_return
id|uRead
OG
l_int|0
ques
c_cond
id|uRead
suffix:colon
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|SLEEP
c_func
(paren
id|read_sq.action_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
id|uRead
OG
l_int|0
ques
c_cond
id|uRead
suffix:colon
op_minus
id|EINTR
suffix:semicolon
)brace
multiline_comment|/* The amount we move is either what is left in the&n;&t;&t; * current buffer or what the user wants.&n;&t;&t; */
id|bLeft
op_assign
id|read_sq.block_size
op_minus
id|read_sq.rear_size
suffix:semicolon
id|bUsed
op_assign
id|read_sq.rear_size
suffix:semicolon
id|uUsed
op_assign
id|sound_copy_translate
c_func
(paren
id|dmasound.trans_read
comma
id|dst
comma
id|uLeft
comma
id|read_sq.buffers
(braket
id|read_sq.front
)braket
comma
op_amp
id|bUsed
comma
id|bLeft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uUsed
op_le
l_int|0
)paren
r_return
id|uUsed
suffix:semicolon
id|dst
op_add_assign
id|uUsed
suffix:semicolon
id|uRead
op_add_assign
id|uUsed
suffix:semicolon
id|uLeft
op_sub_assign
id|uUsed
suffix:semicolon
id|read_sq.rear_size
op_add_assign
id|bUsed
suffix:semicolon
r_if
c_cond
(paren
id|read_sq.rear_size
op_ge
id|read_sq.block_size
)paren
(brace
id|read_sq.rear_size
op_assign
l_int|0
suffix:semicolon
id|read_sq.front
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|read_sq.front
op_ge
id|read_sq.max_active
)paren
id|read_sq.front
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|uRead
suffix:semicolon
)brace
macro_line|#endif /* HAS_RECORD */
DECL|function|sq_init_waitqueue
r_static
r_inline
r_void
id|sq_init_waitqueue
c_func
(paren
r_struct
id|sound_queue
op_star
id|sq
)paren
(brace
id|init_waitqueue_head
c_func
(paren
op_amp
id|sq-&gt;action_queue
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|sq-&gt;open_queue
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|sq-&gt;sync_queue
)paren
suffix:semicolon
id|sq-&gt;busy
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#if 0 /* blocking open() */
r_static
r_inline
r_void
id|sq_wake_up
c_func
(paren
r_struct
id|sound_queue
op_star
id|sq
comma
r_struct
id|file
op_star
id|file
comma
id|mode_t
id|mode
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|mode
)paren
(brace
id|sq-&gt;busy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* CHECK: IS THIS OK??? */
id|WAKE_UP
c_func
(paren
id|sq-&gt;open_queue
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|function|sq_open2
r_static
r_int
id|sq_open2
c_func
(paren
r_struct
id|sound_queue
op_star
id|sq
comma
r_struct
id|file
op_star
id|file
comma
id|mode_t
id|mode
comma
r_int
id|numbufs
comma
r_int
id|bufsize
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|mode
)paren
(brace
r_if
c_cond
(paren
id|sq-&gt;busy
)paren
(brace
macro_line|#if 0 /* blocking open() */
id|rc
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
id|rc
suffix:semicolon
id|rc
op_assign
op_minus
id|EINTR
suffix:semicolon
r_while
c_loop
(paren
id|sq-&gt;busy
)paren
(brace
id|SLEEP
c_func
(paren
id|sq-&gt;open_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
id|rc
suffix:semicolon
)brace
id|rc
op_assign
l_int|0
suffix:semicolon
macro_line|#else
multiline_comment|/* OSS manual says we will return EBUSY regardless&n;&t;&t;&t;   of O_NOBLOCK.&n;&t;&t;&t;*/
r_return
op_minus
id|EBUSY
suffix:semicolon
macro_line|#endif
)brace
id|sq-&gt;busy
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Let&squot;s play spot-the-race-condition */
multiline_comment|/* allocate the default number &amp; size of buffers.&n;&t;&t;   (i.e. specified in _setup() or as module params)&n;&t;&t;   can&squot;t be changed at the moment - but _could_ be perhaps&n;&t;&t;   in the setfragments ioctl.&n;&t;&t;*/
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|sq_allocate_buffers
c_func
(paren
id|sq
comma
id|numbufs
comma
id|bufsize
)paren
)paren
)paren
(brace
macro_line|#if 0 /* blocking open() */
id|sq_wake_up
c_func
(paren
id|sq
comma
id|file
comma
id|mode
)paren
suffix:semicolon
macro_line|#else
id|sq-&gt;busy
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_return
id|rc
suffix:semicolon
)brace
id|sq-&gt;open_mode
op_assign
id|file-&gt;f_mode
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|macro|write_sq_init_waitqueue
mdefine_line|#define write_sq_init_waitqueue()&t;sq_init_waitqueue(&amp;write_sq)
macro_line|#if 0 /* blocking open() */
mdefine_line|#define write_sq_wake_up(file)&t;&t;sq_wake_up(&amp;write_sq, file, FMODE_WRITE)
macro_line|#endif
DECL|macro|write_sq_release_buffers
mdefine_line|#define write_sq_release_buffers()&t;sq_release_buffers(&amp;write_sq)
DECL|macro|write_sq_open
mdefine_line|#define write_sq_open(file)&t;&bslash;&n;&t;sq_open2(&amp;write_sq, file, FMODE_WRITE, numWriteBufs, writeBufSize )
macro_line|#ifdef HAS_RECORD
DECL|macro|read_sq_init_waitqueue
mdefine_line|#define read_sq_init_waitqueue()&t;sq_init_waitqueue(&amp;read_sq)
macro_line|#if 0 /* blocking open() */
mdefine_line|#define read_sq_wake_up(file)&t;&t;sq_wake_up(&amp;read_sq, file, FMODE_READ)
macro_line|#endif
DECL|macro|read_sq_release_buffers
mdefine_line|#define read_sq_release_buffers()&t;sq_release_buffers(&amp;read_sq)
DECL|macro|read_sq_open
mdefine_line|#define read_sq_open(file)&t;&bslash;&n;&t;sq_open2(&amp;read_sq, file, FMODE_READ, numReadBufs, readBufSize )
macro_line|#else
DECL|macro|read_sq_init_waitqueue
mdefine_line|#define read_sq_init_waitqueue()&t;do {} while (0)
macro_line|#if 0 /* blocking open() */
mdefine_line|#define read_sq_wake_up(file)&t;&t;do {} while (0)
macro_line|#endif
DECL|macro|read_sq_release_buffers
mdefine_line|#define read_sq_release_buffers()&t;do {} while (0)
DECL|macro|sq_reset_input
mdefine_line|#define sq_reset_input()&t;&t;do {} while (0)
macro_line|#endif
DECL|function|sq_open
r_static
r_int
id|sq_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|rc
suffix:semicolon
id|dmasound.mach
dot
id|open
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|write_sq_open
c_func
(paren
id|file
)paren
)paren
)paren
(brace
multiline_comment|/* checks the f_mode */
id|dmasound.mach
dot
id|release
c_func
(paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
macro_line|#ifdef HAS_RECORD
r_if
c_cond
(paren
id|dmasound.mach.record
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|read_sq_open
c_func
(paren
id|file
)paren
)paren
)paren
(brace
multiline_comment|/* checks the f_mode */
id|dmasound.mach
dot
id|release
c_func
(paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* no record function installed; in compat mode */
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
multiline_comment|/* TODO: if O_RDWR, release any resources grabbed by write part */
id|dmasound.mach
dot
id|release
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* I think this is what is required by open(2) */
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
)brace
macro_line|#else /* !HAS_RECORD */
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
multiline_comment|/* TODO: if O_RDWR, release any resources grabbed by write part */
id|dmasound.mach
dot
id|release
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* I think this is what is required by open(2) */
)brace
macro_line|#endif /* HAS_RECORD */
r_if
c_cond
(paren
id|dmasound.mach.sq_open
)paren
id|dmasound.mach
dot
id|sq_open
c_func
(paren
id|file-&gt;f_mode
)paren
suffix:semicolon
multiline_comment|/* CHECK whether this is sensible - in the case that dsp0 could be opened&n;&t;  O_RDONLY and dsp1 could be opened O_WRONLY&n;&t;*/
id|dmasound.minDev
op_assign
id|iminor
c_func
(paren
id|inode
)paren
op_amp
l_int|0x0f
suffix:semicolon
multiline_comment|/* OK. - we should make some attempt at consistency. At least the H&squot;ware&n;&t;   options should be set with a valid mode.  We will make it that the LL&n;&t;   driver must supply defaults for hard &amp; soft params.&n;&t;*/
r_if
c_cond
(paren
id|shared_resource_owner
op_eq
l_int|0
)paren
(brace
multiline_comment|/* you can make this AFMT_U8/mono/8K if you want to mimic old&n;&t;&t;   OSS behaviour - while we still have soft translations ;-) */
id|dmasound.soft
op_assign
id|dmasound.mach.default_soft
suffix:semicolon
id|dmasound.dsp
op_assign
id|dmasound.mach.default_soft
suffix:semicolon
id|dmasound.hard
op_assign
id|dmasound.mach.default_hard
suffix:semicolon
)brace
macro_line|#ifndef DMASOUND_STRICT_OSS_COMPLIANCE
multiline_comment|/* none of the current LL drivers can actually do this &quot;native&quot; at the moment&n;&t;   OSS does not really require us to supply /dev/audio if we can&squot;t do it.&n;&t;*/
r_if
c_cond
(paren
id|dmasound.minDev
op_eq
id|SND_DEV_AUDIO
)paren
(brace
id|sound_set_speed
c_func
(paren
l_int|8000
)paren
suffix:semicolon
id|sound_set_stereo
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|sound_set_format
c_func
(paren
id|AFMT_MU_LAW
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sq_reset_output
r_static
r_void
id|sq_reset_output
c_func
(paren
r_void
)paren
(brace
id|sound_silence
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* this _must_ stop DMA, we might be about to lose the buffers */
id|write_sq.active
op_assign
l_int|0
suffix:semicolon
id|write_sq.count
op_assign
l_int|0
suffix:semicolon
id|write_sq.rear_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* write_sq.front = (write_sq.rear+1) % write_sq.max_count;*/
id|write_sq.front
op_assign
l_int|0
suffix:semicolon
id|write_sq.rear
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* same as for set-up */
multiline_comment|/* OK - we can unlock the parameters and fragment settings */
id|write_sq.locked
op_assign
l_int|0
suffix:semicolon
id|write_sq.user_frags
op_assign
l_int|0
suffix:semicolon
id|write_sq.user_frag_size
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef HAS_RECORD
DECL|function|sq_reset_input
r_static
r_void
id|sq_reset_input
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|dmasound.mach.record
op_logical_and
id|read_sq.active
)paren
(brace
r_if
c_cond
(paren
id|dmasound.mach.abort_read
)paren
(brace
multiline_comment|/* this routine must really be present */
id|read_sq.syncing
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* this can use the read_sq.sync_queue to sleep if&n;&t;&t;&t;   necessary - it should not return until DMA&n;&t;&t;&t;   is really stopped - because we might deallocate&n;&t;&t;&t;   the buffers as the next action...&n;&t;&t;&t;*/
id|dmasound.mach
dot
id|abort_read
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;dmasound_core: %s has no abort_read()!! all bets are off&bslash;n&quot;
comma
id|dmasound.mach.name
)paren
suffix:semicolon
)brace
)brace
id|read_sq.syncing
op_assign
id|read_sq.active
op_assign
id|read_sq.front
op_assign
id|read_sq.count
op_assign
id|read_sq.rear
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* OK - we can unlock the parameters and fragment settings */
id|read_sq.locked
op_assign
l_int|0
suffix:semicolon
id|read_sq.user_frags
op_assign
l_int|0
suffix:semicolon
id|read_sq.user_frag_size
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|sq_reset
r_static
r_void
id|sq_reset
c_func
(paren
r_void
)paren
(brace
id|sq_reset_output
c_func
(paren
)paren
suffix:semicolon
id|sq_reset_input
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* we could consider resetting the shared_resources_owner here... but I&n;&t;   think it is probably still rather non-obvious to application writer&n;&t;*/
multiline_comment|/* we release everything else though */
id|shared_resources_initialised
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|sq_fsync
r_static
r_int
id|sq_fsync
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|write_sq.syncing
op_or_assign
l_int|1
suffix:semicolon
id|sq_play
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* there may be an incomplete frame waiting */
r_while
c_loop
(paren
id|write_sq.active
)paren
(brace
id|SLEEP
c_func
(paren
id|write_sq.sync_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
multiline_comment|/* While waiting for audio output to drain, an&n;&t;&t;&t; * interrupt occurred.  Stop audio output immediately&n;&t;&t;&t; * and clear the queue. */
id|sq_reset_output
c_func
(paren
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* flag no sync regardless of whether we had a DSP_POST or not */
id|write_sq.syncing
op_assign
l_int|0
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|sq_release
r_static
r_int
id|sq_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef HAS_RECORD
multiline_comment|/* probably best to do the read side first - so that time taken to do it&n;&t;   overlaps with playing any remaining output samples.&n;&t;*/
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|sq_reset_input
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* make sure dma is stopped and all is quiet */
id|read_sq_release_buffers
c_func
(paren
)paren
suffix:semicolon
id|read_sq.busy
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|write_sq.busy
)paren
id|rc
op_assign
id|sq_fsync
c_func
(paren
id|file
comma
id|file-&gt;f_dentry
)paren
suffix:semicolon
id|sq_reset_output
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* make sure dma is stopped and all is quiet */
id|write_sq_release_buffers
c_func
(paren
)paren
suffix:semicolon
id|write_sq.busy
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|shared_resource_owner
)paren
(brace
multiline_comment|/* it&squot;s us that has them */
id|shared_resource_owner
op_assign
l_int|0
suffix:semicolon
id|shared_resources_initialised
op_assign
l_int|0
suffix:semicolon
id|dmasound.hard
op_assign
id|dmasound.mach.default_hard
suffix:semicolon
)brace
id|dmasound.mach
dot
id|release
c_func
(paren
)paren
suffix:semicolon
macro_line|#if 0 /* blocking open() */
multiline_comment|/* Wake up a process waiting for the queue being released.&n;&t; * Note: There may be several processes waiting for a call&n;&t; * to open() returning. */
multiline_comment|/* Iain: hmm I don&squot;t understand this next comment ... */
multiline_comment|/* There is probably a DOS atack here. They change the mode flag. */
multiline_comment|/* XXX add check here,*/
id|read_sq_wake_up
c_func
(paren
id|file
)paren
suffix:semicolon
multiline_comment|/* checks f_mode */
id|write_sq_wake_up
c_func
(paren
id|file
)paren
suffix:semicolon
multiline_comment|/* checks f_mode */
macro_line|#endif /* blocking open() */
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* here we see if we have a right to modify format, channels, size and so on&n;   if no-one else has claimed it already then we do...&n;&n;   TODO: We might change this to mask O_RDWR such that only one or the other channel&n;   is the owner - if we have problems.&n;*/
DECL|function|shared_resources_are_mine
r_static
r_int
id|shared_resources_are_mine
c_func
(paren
id|mode_t
id|md
)paren
(brace
r_if
c_cond
(paren
id|shared_resource_owner
)paren
r_return
(paren
id|shared_resource_owner
op_amp
id|md
)paren
suffix:semicolon
r_else
(brace
id|shared_resource_owner
op_assign
id|md
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* if either queue is locked we must deny the right to change shared params&n;*/
DECL|function|queues_are_quiescent
r_static
r_int
id|queues_are_quiescent
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef HAS_RECORD
r_if
c_cond
(paren
id|dmasound.mach.record
)paren
r_if
c_cond
(paren
id|read_sq.locked
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|write_sq.locked
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* check and set a queue&squot;s fragments per user&squot;s wishes...&n;   we will check against the pre-defined literals and the actual sizes.&n;   This is a bit fraught - because soft translations can mess with our&n;   buffer requirements *after* this call - OSS says &quot;call setfrags first&quot;&n;*/
multiline_comment|/* It is possible to replace all the -EINVAL returns with an override that&n;   just puts the allowable value in.  This may be what many OSS apps require&n;*/
DECL|function|set_queue_frags
r_static
r_int
id|set_queue_frags
c_func
(paren
r_struct
id|sound_queue
op_star
id|sq
comma
r_int
id|bufs
comma
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
id|sq-&gt;locked
)paren
(brace
macro_line|#ifdef DEBUG_DMASOUND
id|printk
c_func
(paren
l_string|&quot;dmasound_core: tried to set_queue_frags on a locked queue&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|size
OL
id|MIN_FRAG_SIZE
)paren
op_logical_or
(paren
id|size
OG
id|MAX_FRAG_SIZE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|size
op_assign
(paren
l_int|1
op_lshift
id|size
)paren
suffix:semicolon
multiline_comment|/* now in bytes */
r_if
c_cond
(paren
id|size
OG
id|sq-&gt;bufSize
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* this might still not work */
r_if
c_cond
(paren
id|bufs
op_le
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|bufs
OG
id|sq-&gt;numBufs
)paren
multiline_comment|/* the user is allowed say &quot;don&squot;t care&quot; with 0x7fff */
id|bufs
op_assign
id|sq-&gt;numBufs
suffix:semicolon
multiline_comment|/* there is, currently, no way to specify max_active separately&n;&t;   from max_count.  This could be a LL driver issue - I guess&n;&t;   if there is a requirement for these values to be different then&n;&t;  we will have to pass that info. up to this level.&n;&t;*/
id|sq-&gt;user_frags
op_assign
id|sq-&gt;max_active
op_assign
id|bufs
suffix:semicolon
id|sq-&gt;user_frag_size
op_assign
id|size
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sq_ioctl
r_static
r_int
id|sq_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
id|u_int
id|cmd
comma
id|u_long
id|arg
)paren
(brace
r_int
id|val
comma
id|result
suffix:semicolon
id|u_long
id|fmt
suffix:semicolon
r_int
id|data
suffix:semicolon
r_int
id|size
comma
id|nbufs
suffix:semicolon
id|audio_buf_info
id|info
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SNDCTL_DSP_RESET
suffix:colon
id|sq_reset
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETFMTS
suffix:colon
id|fmt
op_assign
id|dmasound.mach.hardware_afmts
suffix:semicolon
multiline_comment|/* this is what OSS says.. */
r_return
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|fmt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETBLKSIZE
suffix:colon
multiline_comment|/* this should tell the caller about bytes that the app can&n;&t;&t;   read/write - the app doesn&squot;t care about our internal buffers.&n;&t;&t;   We force sq_setup() here as per OSS 1.1 (which should&n;&t;&t;   compute the values necessary).&n;&t;&t;   Since there is no mechanism to specify read/write separately, for&n;&t;&t;   fds opened O_RDWR, the write_sq values will, arbitrarily, overwrite&n;&t;&t;   the read_sq ones.&n;&t;&t;*/
id|size
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef HAS_RECORD
r_if
c_cond
(paren
id|dmasound.mach.record
op_logical_and
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|read_sq.locked
)paren
id|sq_setup
c_func
(paren
op_amp
id|read_sq
)paren
suffix:semicolon
multiline_comment|/* set params */
id|size
op_assign
id|read_sq.user_frag_size
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|write_sq.locked
)paren
id|sq_setup
c_func
(paren
op_amp
id|write_sq
)paren
suffix:semicolon
id|size
op_assign
id|write_sq.user_frag_size
suffix:semicolon
)brace
r_return
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|size
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_POST
suffix:colon
multiline_comment|/* all we are going to do is to tell the LL that any&n;&t;&t;   partial frags can be queued for output.&n;&t;&t;   The LL will have to clear this flag when last output&n;&t;&t;   is queued.&n;&t;&t;*/
id|write_sq.syncing
op_or_assign
l_int|0x2
suffix:semicolon
id|sq_play
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SYNC
suffix:colon
multiline_comment|/* This call, effectively, has the same behaviour as SNDCTL_DSP_RESET&n;&t;&t;   except that it waits for output to finish before resetting&n;&t;&t;   everything - read, however, is killed imediately.&n;&t;&t;*/
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
op_logical_and
id|dmasound.mach.record
)paren
id|sq_reset_input
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|result
op_assign
id|sq_fsync
c_func
(paren
id|file
comma
id|file-&gt;f_dentry
)paren
suffix:semicolon
id|sq_reset_output
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* if we are the shared resource owner then release them */
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|shared_resource_owner
)paren
id|shared_resources_initialised
op_assign
l_int|0
suffix:semicolon
r_return
id|result
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_READ_RATE
suffix:colon
r_return
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|dmasound.soft.speed
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SPEED
suffix:colon
multiline_comment|/* changing this on the fly will have weird effects on the sound.&n;&t;&t;   Where there are rate conversions implemented in soft form - it&n;&t;&t;   will cause the _ctx_xxx() functions to be substituted.&n;&t;&t;   However, there doesn&squot;t appear to be any reason to dis-allow it from&n;&t;&t;   a driver pov.&n;&t;&t;*/
r_if
c_cond
(paren
id|shared_resources_are_mine
c_func
(paren
id|file-&gt;f_mode
)paren
)paren
(brace
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|data
op_assign
id|sound_set_speed
c_func
(paren
id|data
)paren
suffix:semicolon
id|shared_resources_initialised
op_assign
l_int|0
suffix:semicolon
r_return
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* OSS says these next 4 actions are undefined when the device is&n;&t;   busy/active - we will just return -EINVAL.&n;&t;   To be allowed to change one - (a) you have to own the right&n;&t;    (b) the queue(s) must be quiescent&n;&t;*/
r_case
id|SNDCTL_DSP_STEREO
suffix:colon
r_if
c_cond
(paren
id|shared_resources_are_mine
c_func
(paren
id|file-&gt;f_mode
)paren
op_logical_and
id|queues_are_quiescent
c_func
(paren
)paren
)paren
(brace
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|shared_resources_initialised
op_assign
l_int|0
suffix:semicolon
r_return
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|sound_set_stereo
c_func
(paren
id|data
)paren
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SOUND_PCM_WRITE_CHANNELS
suffix:colon
r_if
c_cond
(paren
id|shared_resources_are_mine
c_func
(paren
id|file-&gt;f_mode
)paren
op_logical_and
id|queues_are_quiescent
c_func
(paren
)paren
)paren
(brace
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* the user might ask for 20 channels, we will return 1 or 2 */
id|shared_resources_initialised
op_assign
l_int|0
suffix:semicolon
r_return
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|sound_set_stereo
c_func
(paren
id|data
op_minus
l_int|1
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFMT
suffix:colon
r_if
c_cond
(paren
id|shared_resources_are_mine
c_func
(paren
id|file-&gt;f_mode
)paren
op_logical_and
id|queues_are_quiescent
c_func
(paren
)paren
)paren
(brace
r_int
id|format
suffix:semicolon
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|shared_resources_initialised
op_assign
l_int|0
suffix:semicolon
id|format
op_assign
id|sound_set_format
c_func
(paren
id|data
)paren
suffix:semicolon
id|result
op_assign
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|format
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
id|format
op_ne
id|data
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SUBDIVIDE
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFRAGMENT
suffix:colon
multiline_comment|/* we can do this independently for the two queues - with the&n;&t;&t;   proviso that for fds opened O_RDWR we cannot separate the&n;&t;&t;   actions and both queues will be set per the last call.&n;&t;&t;   NOTE: this does *NOT* actually set the queue up - merely&n;&t;&t;   registers our intentions.&n;&t;&t;*/
id|IOCTL_IN
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
id|nbufs
op_assign
(paren
id|data
op_rshift
l_int|16
)paren
op_amp
l_int|0x7fff
suffix:semicolon
multiline_comment|/* 0x7fff is &squot;use maximum&squot; */
id|size
op_assign
id|data
op_amp
l_int|0xffff
suffix:semicolon
macro_line|#ifdef HAS_RECORD
r_if
c_cond
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
op_logical_and
id|dmasound.mach.record
)paren
(brace
id|result
op_assign
id|set_queue_frags
c_func
(paren
op_amp
id|read_sq
comma
id|nbufs
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|result
op_assign
id|set_queue_frags
c_func
(paren
op_amp
id|write_sq
comma
id|nbufs
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* NOTE: this return value is irrelevant - OSS specifically says that&n;&t;&t;   the value is &squot;random&squot; and that the user _must_ check the actual&n;&t;&t;   frags values using SNDCTL_DSP_GETBLKSIZE or similar */
r_return
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOSPACE
suffix:colon
multiline_comment|/*&n;&t;&t;*/
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|write_sq.locked
)paren
id|sq_setup
c_func
(paren
op_amp
id|write_sq
)paren
suffix:semicolon
id|info.fragments
op_assign
id|write_sq.max_active
op_minus
id|write_sq.count
suffix:semicolon
id|info.fragstotal
op_assign
id|write_sq.max_active
suffix:semicolon
id|info.fragsize
op_assign
id|write_sq.user_frag_size
suffix:semicolon
id|info.bytes
op_assign
id|info.fragments
op_star
id|info.fragsize
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETCAPS
suffix:colon
id|val
op_assign
id|dmasound.mach.capabilities
op_amp
l_int|0xffffff00
suffix:semicolon
r_return
id|IOCTL_OUT
c_func
(paren
id|arg
comma
id|val
)paren
suffix:semicolon
r_default
suffix:colon
r_return
id|mixer_ioctl
c_func
(paren
id|inode
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|variable|sq_fops
r_static
r_struct
id|file_operations
id|sq_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|llseek
op_assign
id|no_llseek
comma
dot
id|write
op_assign
id|sq_write
comma
dot
id|poll
op_assign
id|sq_poll
comma
dot
id|ioctl
op_assign
id|sq_ioctl
comma
dot
id|open
op_assign
id|sq_open
comma
dot
id|release
op_assign
id|sq_release
comma
macro_line|#ifdef HAS_RECORD
dot
id|read
op_assign
l_int|NULL
multiline_comment|/* default to no read for compat mode */
macro_line|#endif
)brace
suffix:semicolon
DECL|function|sq_init
r_static
r_int
id|__init
id|sq_init
c_func
(paren
r_void
)paren
(brace
macro_line|#ifndef MODULE
r_int
id|sq_unit
suffix:semicolon
macro_line|#endif
macro_line|#ifdef HAS_RECORD
r_if
c_cond
(paren
id|dmasound.mach.record
)paren
id|sq_fops.read
op_assign
id|sq_read
suffix:semicolon
macro_line|#endif
id|spin_lock_init
c_func
(paren
op_amp
id|dmasound.lock
)paren
suffix:semicolon
id|sq_unit
op_assign
id|register_sound_dsp
c_func
(paren
op_amp
id|sq_fops
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sq_unit
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;dmasound_core: couldn&squot;t register fops&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|sq_unit
suffix:semicolon
)brace
id|write_sq_init_waitqueue
c_func
(paren
)paren
suffix:semicolon
id|read_sq_init_waitqueue
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* These parameters will be restored for every clean open()&n;&t; * in the case of multiple open()s (e.g. dsp0 &amp; dsp1) they&n;&t; * will be set so long as the shared resources have no owner.&n;&t; */
r_if
c_cond
(paren
id|shared_resource_owner
op_eq
l_int|0
)paren
(brace
id|dmasound.soft
op_assign
id|dmasound.mach.default_soft
suffix:semicolon
id|dmasound.hard
op_assign
id|dmasound.mach.default_hard
suffix:semicolon
id|dmasound.dsp
op_assign
id|dmasound.mach.default_soft
suffix:semicolon
id|shared_resources_initialised
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     *  /dev/sndstat&n;     */
multiline_comment|/* we allow more space for record-enabled because there are extra output lines.&n;   the number here must include the amount we are prepared to give to the low-level&n;   driver.&n;*/
macro_line|#ifdef HAS_RECORD
DECL|macro|STAT_BUFF_LEN
mdefine_line|#define STAT_BUFF_LEN 1024
macro_line|#else
DECL|macro|STAT_BUFF_LEN
mdefine_line|#define STAT_BUFF_LEN 768
macro_line|#endif
multiline_comment|/* this is how much space we will allow the low-level driver to use&n;   in the stat buffer.  Currently, 2 * (80 character line + &lt;NL&gt;).&n;   We do not police this (it is up to the ll driver to be honest).&n;*/
DECL|macro|LOW_LEVEL_STAT_ALLOC
mdefine_line|#define LOW_LEVEL_STAT_ALLOC 162
r_static
r_struct
(brace
DECL|member|busy
r_int
id|busy
suffix:semicolon
DECL|member|buf
r_char
id|buf
(braket
id|STAT_BUFF_LEN
)braket
suffix:semicolon
multiline_comment|/* state.buf should not overflow! */
DECL|member|len
DECL|member|ptr
r_int
id|len
comma
id|ptr
suffix:semicolon
DECL|variable|state
)brace
id|state
suffix:semicolon
multiline_comment|/* publish this function for use by low-level code, if required */
DECL|function|get_afmt_string
r_char
op_star
id|get_afmt_string
c_func
(paren
r_int
id|afmt
)paren
(brace
r_switch
c_cond
(paren
id|afmt
)paren
(brace
r_case
id|AFMT_MU_LAW
suffix:colon
r_return
l_string|&quot;mu-law&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_A_LAW
suffix:colon
r_return
l_string|&quot;A-law&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_U8
suffix:colon
r_return
l_string|&quot;unsigned 8 bit&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_S8
suffix:colon
r_return
l_string|&quot;signed 8 bit&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_S16_BE
suffix:colon
r_return
l_string|&quot;signed 16 bit BE&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_U16_BE
suffix:colon
r_return
l_string|&quot;unsigned 16 bit BE&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_S16_LE
suffix:colon
r_return
l_string|&quot;signed 16 bit LE&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_U16_LE
suffix:colon
r_return
l_string|&quot;unsigned 16 bit LE&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_return
l_string|&quot;format not set&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
l_string|&quot;ERROR: Unsupported AFMT_XXXX code&quot;
suffix:semicolon
)brace
DECL|function|state_open
r_static
r_int
id|state_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_char
op_star
id|buffer
op_assign
id|state.buf
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|state.busy
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|dmasound.mach
dot
id|open
c_func
(paren
)paren
suffix:semicolon
id|state.ptr
op_assign
l_int|0
suffix:semicolon
id|state.busy
op_assign
l_int|1
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%sDMA sound driver rev %03d :&bslash;n&quot;
comma
id|dmasound.mach.name
comma
(paren
id|DMASOUND_CORE_REVISION
op_lshift
l_int|4
)paren
op_plus
(paren
(paren
id|dmasound.mach.version
op_rshift
l_int|8
)paren
op_amp
l_int|0x0f
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Core driver edition %02d.%02d : %s driver edition %02d.%02d&bslash;n&quot;
comma
id|DMASOUND_CORE_REVISION
comma
id|DMASOUND_CORE_EDITION
comma
id|dmasound.mach.name2
comma
(paren
id|dmasound.mach.version
op_rshift
l_int|8
)paren
comma
(paren
id|dmasound.mach.version
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
multiline_comment|/* call the low-level module to fill in any stat info. that it has&n;&t;   if present.  Maximum buffer usage is specified.&n;&t;*/
r_if
c_cond
(paren
id|dmasound.mach.state_info
)paren
id|len
op_add_assign
id|dmasound.mach
dot
id|state_info
c_func
(paren
id|buffer
op_plus
id|len
comma
(paren
r_int
)paren
id|LOW_LEVEL_STAT_ALLOC
)paren
suffix:semicolon
multiline_comment|/* make usage of the state buffer as deterministic as poss.&n;&t;   exceptional conditions could cause overrun - and this is flagged as&n;&t;   a kernel error.&n;&t;*/
multiline_comment|/* formats and settings */
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;t&bslash;t === Formats &amp; settings ===&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Parameter %20s%20s&bslash;n&quot;
comma
l_string|&quot;soft&quot;
comma
l_string|&quot;hard&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Format   :%20s%20s&bslash;n&quot;
comma
id|get_afmt_string
c_func
(paren
id|dmasound.soft.format
)paren
comma
id|get_afmt_string
c_func
(paren
id|dmasound.hard.format
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Samp Rate:%14d s/sec%14d s/sec&bslash;n&quot;
comma
id|dmasound.soft.speed
comma
id|dmasound.hard.speed
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Channels :%20s%20s&bslash;n&quot;
comma
id|dmasound.soft.stereo
ques
c_cond
l_string|&quot;stereo&quot;
suffix:colon
l_string|&quot;mono&quot;
comma
id|dmasound.hard.stereo
ques
c_cond
l_string|&quot;stereo&quot;
suffix:colon
l_string|&quot;mono&quot;
)paren
suffix:semicolon
multiline_comment|/* sound queue status */
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;t&bslash;t === Sound Queue status ===&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Allocated:%8s%6s&bslash;n&quot;
comma
l_string|&quot;Buffers&quot;
comma
l_string|&quot;Size&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%9s:%8d%6d&bslash;n&quot;
comma
l_string|&quot;write&quot;
comma
id|write_sq.numBufs
comma
id|write_sq.bufSize
)paren
suffix:semicolon
macro_line|#ifdef HAS_RECORD
r_if
c_cond
(paren
id|dmasound.mach.record
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%9s:%8d%6d&bslash;n&quot;
comma
l_string|&quot;read&quot;
comma
id|read_sq.numBufs
comma
id|read_sq.bufSize
)paren
suffix:semicolon
macro_line|#endif
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Current  : MaxFrg FragSiz MaxAct Frnt Rear &quot;
l_string|&quot;Cnt RrSize A B S L  xruns&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%9s:%7d%8d%7d%5d%5d%4d%7d%2d%2d%2d%2d%7d&bslash;n&quot;
comma
l_string|&quot;write&quot;
comma
id|write_sq.max_count
comma
id|write_sq.block_size
comma
id|write_sq.max_active
comma
id|write_sq.front
comma
id|write_sq.rear
comma
id|write_sq.count
comma
id|write_sq.rear_size
comma
id|write_sq.active
comma
id|write_sq.busy
comma
id|write_sq.syncing
comma
id|write_sq.locked
comma
id|write_sq.xruns
)paren
suffix:semicolon
macro_line|#ifdef HAS_RECORD
r_if
c_cond
(paren
id|dmasound.mach.record
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%9s:%7d%8d%7d%5d%5d%4d%7d%2d%2d%2d%2d%7d&bslash;n&quot;
comma
l_string|&quot;read&quot;
comma
id|read_sq.max_count
comma
id|read_sq.block_size
comma
id|read_sq.max_active
comma
id|read_sq.front
comma
id|read_sq.rear
comma
id|read_sq.count
comma
id|read_sq.rear_size
comma
id|read_sq.active
comma
id|read_sq.busy
comma
id|read_sq.syncing
comma
id|read_sq.locked
comma
id|read_sq.xruns
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG_DMASOUND
id|printk
c_func
(paren
l_string|&quot;dmasound: stat buffer used %d bytes&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|len
op_ge
id|STAT_BUFF_LEN
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;dmasound_core: stat buffer overflowed!&bslash;n&quot;
)paren
suffix:semicolon
id|state.len
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|state_release
r_static
r_int
id|state_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|state.busy
op_assign
l_int|0
suffix:semicolon
id|dmasound.mach
dot
id|release
c_func
(paren
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|state_read
r_static
id|ssize_t
id|state_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
id|n
op_assign
id|state.len
op_minus
id|state.ptr
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
id|count
)paren
id|n
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|n
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
op_amp
id|state.buf
(braket
id|state.ptr
)braket
comma
id|n
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|state.ptr
op_add_assign
id|n
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|variable|state_fops
r_static
r_struct
id|file_operations
id|state_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|llseek
op_assign
id|no_llseek
comma
dot
id|read
op_assign
id|state_read
comma
dot
id|open
op_assign
id|state_open
comma
dot
id|release
op_assign
id|state_release
comma
)brace
suffix:semicolon
DECL|function|state_init
r_static
r_int
id|__init
id|state_init
c_func
(paren
r_void
)paren
(brace
macro_line|#ifndef MODULE
r_int
id|state_unit
suffix:semicolon
macro_line|#endif
id|state_unit
op_assign
id|register_sound_special
c_func
(paren
op_amp
id|state_fops
comma
id|SND_DEV_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state_unit
OL
l_int|0
)paren
r_return
id|state_unit
suffix:semicolon
id|state.busy
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     *  Config &amp; Setup&n;     *&n;     *  This function is called by _one_ chipset-specific driver&n;     */
DECL|function|dmasound_init
r_int
id|__init
id|dmasound_init
c_func
(paren
r_void
)paren
(brace
r_int
id|res
suffix:semicolon
macro_line|#ifdef MODULE
r_if
c_cond
(paren
id|irq_installed
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
macro_line|#endif
multiline_comment|/* Set up sound queue, /dev/audio and /dev/dsp. */
multiline_comment|/* Set default settings. */
r_if
c_cond
(paren
(paren
id|res
op_assign
id|sq_init
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
r_return
id|res
suffix:semicolon
multiline_comment|/* Set up /dev/sndstat. */
r_if
c_cond
(paren
(paren
id|res
op_assign
id|state_init
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
r_return
id|res
suffix:semicolon
multiline_comment|/* Set up /dev/mixer. */
id|mixer_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmasound.mach
dot
id|irqinit
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;DMA sound driver: Interrupt initialization failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|irq_installed
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s DMA sound driver rev %03d installed&bslash;n&quot;
comma
id|dmasound.mach.name
comma
(paren
id|DMASOUND_CORE_REVISION
op_lshift
l_int|4
)paren
op_plus
(paren
(paren
id|dmasound.mach.version
op_rshift
l_int|8
)paren
op_amp
l_int|0x0f
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Core driver edition %02d.%02d : %s driver edition %02d.%02d&bslash;n&quot;
comma
id|DMASOUND_CORE_REVISION
comma
id|DMASOUND_CORE_EDITION
comma
id|dmasound.mach.name2
comma
(paren
id|dmasound.mach.version
op_rshift
l_int|8
)paren
comma
(paren
id|dmasound.mach.version
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Write will use %4d fragments of %7d bytes as default&bslash;n&quot;
comma
id|numWriteBufs
comma
id|writeBufSize
)paren
suffix:semicolon
macro_line|#ifdef HAS_RECORD
r_if
c_cond
(paren
id|dmasound.mach.record
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Read  will use %4d fragments of %7d bytes as default&bslash;n&quot;
comma
id|numReadBufs
comma
id|readBufSize
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|dmasound_deinit
r_void
id|dmasound_deinit
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|irq_installed
)paren
(brace
id|sound_silence
c_func
(paren
)paren
suffix:semicolon
id|dmasound.mach
dot
id|irqcleanup
c_func
(paren
)paren
suffix:semicolon
id|irq_installed
op_assign
l_int|0
suffix:semicolon
)brace
id|write_sq_release_buffers
c_func
(paren
)paren
suffix:semicolon
id|read_sq_release_buffers
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mixer_unit
op_ge
l_int|0
)paren
id|unregister_sound_mixer
c_func
(paren
id|mixer_unit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state_unit
op_ge
l_int|0
)paren
id|unregister_sound_special
c_func
(paren
id|state_unit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sq_unit
op_ge
l_int|0
)paren
id|unregister_sound_dsp
c_func
(paren
id|sq_unit
)paren
suffix:semicolon
)brace
macro_line|#else /* !MODULE */
DECL|function|dmasound_setup
r_static
r_int
id|__init
id|dmasound_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|ints
(braket
l_int|6
)braket
comma
id|size
suffix:semicolon
id|str
op_assign
id|get_options
c_func
(paren
id|str
comma
id|ARRAY_SIZE
c_func
(paren
id|ints
)paren
comma
id|ints
)paren
suffix:semicolon
multiline_comment|/* check the bootstrap parameter for &quot;dmasound=&quot; */
multiline_comment|/* FIXME: other than in the most naive of cases there is no sense in these&n;&t; *&t;  buffers being other than powers of two.  This is not checked yet.&n;&t; */
r_switch
c_cond
(paren
id|ints
(braket
l_int|0
)braket
)paren
(brace
macro_line|#ifdef HAS_RECORD
r_case
l_int|5
suffix:colon
r_if
c_cond
(paren
(paren
id|ints
(braket
l_int|5
)braket
OL
l_int|0
)paren
op_logical_or
(paren
id|ints
(braket
l_int|5
)braket
OG
id|MAX_CATCH_RADIUS
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;dmasound_setup: invalid catch radius, using default = %d&bslash;n&quot;
comma
id|catchRadius
)paren
suffix:semicolon
r_else
id|catchRadius
op_assign
id|ints
(braket
l_int|5
)braket
suffix:semicolon
multiline_comment|/* fall through */
r_case
l_int|4
suffix:colon
r_if
c_cond
(paren
id|ints
(braket
l_int|4
)braket
OL
id|MIN_BUFFERS
)paren
id|printk
c_func
(paren
l_string|&quot;dmasound_setup: invalid number of read buffers, using default = %d&bslash;n&quot;
comma
id|numReadBufs
)paren
suffix:semicolon
r_else
id|numReadBufs
op_assign
id|ints
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* fall through */
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
(paren
id|size
op_assign
id|ints
(braket
l_int|3
)braket
)paren
OL
l_int|256
)paren
multiline_comment|/* check for small buffer specs */
id|size
op_lshift_assign
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|size
template_param
id|MAX_BUFSIZE
)paren
id|printk
c_func
(paren
l_string|&quot;dmasound_setup: invalid read buffer size, using default = %d&bslash;n&quot;
comma
id|readBufSize
)paren
suffix:semicolon
r_else
id|readBufSize
op_assign
id|size
suffix:semicolon
multiline_comment|/* fall through */
macro_line|#else
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
(paren
id|ints
(braket
l_int|3
)braket
OL
l_int|0
)paren
op_logical_or
(paren
id|ints
(braket
l_int|3
)braket
OG
id|MAX_CATCH_RADIUS
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;dmasound_setup: invalid catch radius, using default = %d&bslash;n&quot;
comma
id|catchRadius
)paren
suffix:semicolon
r_else
id|catchRadius
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* fall through */
macro_line|#endif
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|ints
(braket
l_int|1
)braket
OL
id|MIN_BUFFERS
)paren
id|printk
c_func
(paren
l_string|&quot;dmasound_setup: invalid number of buffers, using default = %d&bslash;n&quot;
comma
id|numWriteBufs
)paren
suffix:semicolon
r_else
id|numWriteBufs
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* fall through */
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
(paren
id|size
op_assign
id|ints
(braket
l_int|2
)braket
)paren
OL
l_int|256
)paren
multiline_comment|/* check for small buffer specs */
id|size
op_lshift_assign
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|size
template_param
id|MAX_BUFSIZE
)paren
id|printk
c_func
(paren
l_string|&quot;dmasound_setup: invalid write buffer size, using default = %d&bslash;n&quot;
comma
id|writeBufSize
)paren
suffix:semicolon
r_else
id|writeBufSize
op_assign
id|size
suffix:semicolon
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;dmasound_setup: invalid number of arguments&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;dmasound=&quot;
comma
id|dmasound_setup
)paren
suffix:semicolon
macro_line|#endif /* !MODULE */
multiline_comment|/*&n;     *  Conversion tables&n;     */
macro_line|#ifdef HAS_8BIT_TABLES
multiline_comment|/* 8 bit mu-law */
DECL|variable|dmasound_ulaw2dma8
r_char
id|dmasound_ulaw2dma8
(braket
)braket
op_assign
(brace
op_minus
l_int|126
comma
op_minus
l_int|122
comma
op_minus
l_int|118
comma
op_minus
l_int|114
comma
op_minus
l_int|110
comma
op_minus
l_int|106
comma
op_minus
l_int|102
comma
op_minus
l_int|98
comma
op_minus
l_int|94
comma
op_minus
l_int|90
comma
op_minus
l_int|86
comma
op_minus
l_int|82
comma
op_minus
l_int|78
comma
op_minus
l_int|74
comma
op_minus
l_int|70
comma
op_minus
l_int|66
comma
op_minus
l_int|63
comma
op_minus
l_int|61
comma
op_minus
l_int|59
comma
op_minus
l_int|57
comma
op_minus
l_int|55
comma
op_minus
l_int|53
comma
op_minus
l_int|51
comma
op_minus
l_int|49
comma
op_minus
l_int|47
comma
op_minus
l_int|45
comma
op_minus
l_int|43
comma
op_minus
l_int|41
comma
op_minus
l_int|39
comma
op_minus
l_int|37
comma
op_minus
l_int|35
comma
op_minus
l_int|33
comma
op_minus
l_int|31
comma
op_minus
l_int|30
comma
op_minus
l_int|29
comma
op_minus
l_int|28
comma
op_minus
l_int|27
comma
op_minus
l_int|26
comma
op_minus
l_int|25
comma
op_minus
l_int|24
comma
op_minus
l_int|23
comma
op_minus
l_int|22
comma
op_minus
l_int|21
comma
op_minus
l_int|20
comma
op_minus
l_int|19
comma
op_minus
l_int|18
comma
op_minus
l_int|17
comma
op_minus
l_int|16
comma
op_minus
l_int|16
comma
op_minus
l_int|15
comma
op_minus
l_int|15
comma
op_minus
l_int|14
comma
op_minus
l_int|14
comma
op_minus
l_int|13
comma
op_minus
l_int|13
comma
op_minus
l_int|12
comma
op_minus
l_int|12
comma
op_minus
l_int|11
comma
op_minus
l_int|11
comma
op_minus
l_int|10
comma
op_minus
l_int|10
comma
op_minus
l_int|9
comma
op_minus
l_int|9
comma
op_minus
l_int|8
comma
op_minus
l_int|8
comma
op_minus
l_int|8
comma
op_minus
l_int|7
comma
op_minus
l_int|7
comma
op_minus
l_int|7
comma
op_minus
l_int|7
comma
op_minus
l_int|6
comma
op_minus
l_int|6
comma
op_minus
l_int|6
comma
op_minus
l_int|6
comma
op_minus
l_int|5
comma
op_minus
l_int|5
comma
op_minus
l_int|5
comma
op_minus
l_int|5
comma
op_minus
l_int|4
comma
op_minus
l_int|4
comma
op_minus
l_int|4
comma
op_minus
l_int|4
comma
op_minus
l_int|4
comma
op_minus
l_int|4
comma
op_minus
l_int|3
comma
op_minus
l_int|3
comma
op_minus
l_int|3
comma
op_minus
l_int|3
comma
op_minus
l_int|3
comma
op_minus
l_int|3
comma
op_minus
l_int|3
comma
op_minus
l_int|3
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_int|0
comma
l_int|125
comma
l_int|121
comma
l_int|117
comma
l_int|113
comma
l_int|109
comma
l_int|105
comma
l_int|101
comma
l_int|97
comma
l_int|93
comma
l_int|89
comma
l_int|85
comma
l_int|81
comma
l_int|77
comma
l_int|73
comma
l_int|69
comma
l_int|65
comma
l_int|62
comma
l_int|60
comma
l_int|58
comma
l_int|56
comma
l_int|54
comma
l_int|52
comma
l_int|50
comma
l_int|48
comma
l_int|46
comma
l_int|44
comma
l_int|42
comma
l_int|40
comma
l_int|38
comma
l_int|36
comma
l_int|34
comma
l_int|32
comma
l_int|30
comma
l_int|29
comma
l_int|28
comma
l_int|27
comma
l_int|26
comma
l_int|25
comma
l_int|24
comma
l_int|23
comma
l_int|22
comma
l_int|21
comma
l_int|20
comma
l_int|19
comma
l_int|18
comma
l_int|17
comma
l_int|16
comma
l_int|15
comma
l_int|15
comma
l_int|14
comma
l_int|14
comma
l_int|13
comma
l_int|13
comma
l_int|12
comma
l_int|12
comma
l_int|11
comma
l_int|11
comma
l_int|10
comma
l_int|10
comma
l_int|9
comma
l_int|9
comma
l_int|8
comma
l_int|8
comma
l_int|7
comma
l_int|7
comma
l_int|7
comma
l_int|6
comma
l_int|6
comma
l_int|6
comma
l_int|6
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* 8 bit A-law */
DECL|variable|dmasound_alaw2dma8
r_char
id|dmasound_alaw2dma8
(braket
)braket
op_assign
(brace
op_minus
l_int|22
comma
op_minus
l_int|21
comma
op_minus
l_int|24
comma
op_minus
l_int|23
comma
op_minus
l_int|18
comma
op_minus
l_int|17
comma
op_minus
l_int|20
comma
op_minus
l_int|19
comma
op_minus
l_int|30
comma
op_minus
l_int|29
comma
op_minus
l_int|32
comma
op_minus
l_int|31
comma
op_minus
l_int|26
comma
op_minus
l_int|25
comma
op_minus
l_int|28
comma
op_minus
l_int|27
comma
op_minus
l_int|11
comma
op_minus
l_int|11
comma
op_minus
l_int|12
comma
op_minus
l_int|12
comma
op_minus
l_int|9
comma
op_minus
l_int|9
comma
op_minus
l_int|10
comma
op_minus
l_int|10
comma
op_minus
l_int|15
comma
op_minus
l_int|15
comma
op_minus
l_int|16
comma
op_minus
l_int|16
comma
op_minus
l_int|13
comma
op_minus
l_int|13
comma
op_minus
l_int|14
comma
op_minus
l_int|14
comma
op_minus
l_int|86
comma
op_minus
l_int|82
comma
op_minus
l_int|94
comma
op_minus
l_int|90
comma
op_minus
l_int|70
comma
op_minus
l_int|66
comma
op_minus
l_int|78
comma
op_minus
l_int|74
comma
op_minus
l_int|118
comma
op_minus
l_int|114
comma
op_minus
l_int|126
comma
op_minus
l_int|122
comma
op_minus
l_int|102
comma
op_minus
l_int|98
comma
op_minus
l_int|110
comma
op_minus
l_int|106
comma
op_minus
l_int|43
comma
op_minus
l_int|41
comma
op_minus
l_int|47
comma
op_minus
l_int|45
comma
op_minus
l_int|35
comma
op_minus
l_int|33
comma
op_minus
l_int|39
comma
op_minus
l_int|37
comma
op_minus
l_int|59
comma
op_minus
l_int|57
comma
op_minus
l_int|63
comma
op_minus
l_int|61
comma
op_minus
l_int|51
comma
op_minus
l_int|49
comma
op_minus
l_int|55
comma
op_minus
l_int|53
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|2
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|6
comma
op_minus
l_int|6
comma
op_minus
l_int|6
comma
op_minus
l_int|6
comma
op_minus
l_int|5
comma
op_minus
l_int|5
comma
op_minus
l_int|5
comma
op_minus
l_int|5
comma
op_minus
l_int|8
comma
op_minus
l_int|8
comma
op_minus
l_int|8
comma
op_minus
l_int|8
comma
op_minus
l_int|7
comma
op_minus
l_int|7
comma
op_minus
l_int|7
comma
op_minus
l_int|7
comma
op_minus
l_int|3
comma
op_minus
l_int|3
comma
op_minus
l_int|3
comma
op_minus
l_int|3
comma
op_minus
l_int|3
comma
op_minus
l_int|3
comma
op_minus
l_int|3
comma
op_minus
l_int|3
comma
op_minus
l_int|4
comma
op_minus
l_int|4
comma
op_minus
l_int|4
comma
op_minus
l_int|4
comma
op_minus
l_int|4
comma
op_minus
l_int|4
comma
op_minus
l_int|4
comma
op_minus
l_int|4
comma
l_int|21
comma
l_int|20
comma
l_int|23
comma
l_int|22
comma
l_int|17
comma
l_int|16
comma
l_int|19
comma
l_int|18
comma
l_int|29
comma
l_int|28
comma
l_int|31
comma
l_int|30
comma
l_int|25
comma
l_int|24
comma
l_int|27
comma
l_int|26
comma
l_int|10
comma
l_int|10
comma
l_int|11
comma
l_int|11
comma
l_int|8
comma
l_int|8
comma
l_int|9
comma
l_int|9
comma
l_int|14
comma
l_int|14
comma
l_int|15
comma
l_int|15
comma
l_int|12
comma
l_int|12
comma
l_int|13
comma
l_int|13
comma
l_int|86
comma
l_int|82
comma
l_int|94
comma
l_int|90
comma
l_int|70
comma
l_int|66
comma
l_int|78
comma
l_int|74
comma
l_int|118
comma
l_int|114
comma
l_int|126
comma
l_int|122
comma
l_int|102
comma
l_int|98
comma
l_int|110
comma
l_int|106
comma
l_int|43
comma
l_int|41
comma
l_int|47
comma
l_int|45
comma
l_int|35
comma
l_int|33
comma
l_int|39
comma
l_int|37
comma
l_int|59
comma
l_int|57
comma
l_int|63
comma
l_int|61
comma
l_int|51
comma
l_int|49
comma
l_int|55
comma
l_int|53
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|5
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|7
comma
l_int|7
comma
l_int|7
comma
l_int|7
comma
l_int|6
comma
l_int|6
comma
l_int|6
comma
l_int|6
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|3
)brace
suffix:semicolon
macro_line|#endif /* HAS_8BIT_TABLES */
multiline_comment|/*&n;     *  Visible symbols for modules&n;     */
DECL|variable|dmasound
id|EXPORT_SYMBOL
c_func
(paren
id|dmasound
)paren
suffix:semicolon
DECL|variable|dmasound_init
id|EXPORT_SYMBOL
c_func
(paren
id|dmasound_init
)paren
suffix:semicolon
macro_line|#ifdef MODULE
DECL|variable|dmasound_deinit
id|EXPORT_SYMBOL
c_func
(paren
id|dmasound_deinit
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|dmasound_write_sq
id|EXPORT_SYMBOL
c_func
(paren
id|dmasound_write_sq
)paren
suffix:semicolon
macro_line|#ifdef HAS_RECORD
DECL|variable|dmasound_read_sq
id|EXPORT_SYMBOL
c_func
(paren
id|dmasound_read_sq
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|dmasound_catchRadius
id|EXPORT_SYMBOL
c_func
(paren
id|dmasound_catchRadius
)paren
suffix:semicolon
macro_line|#ifdef HAS_8BIT_TABLES
DECL|variable|dmasound_ulaw2dma8
id|EXPORT_SYMBOL
c_func
(paren
id|dmasound_ulaw2dma8
)paren
suffix:semicolon
DECL|variable|dmasound_alaw2dma8
id|EXPORT_SYMBOL
c_func
(paren
id|dmasound_alaw2dma8
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|get_afmt_string
id|EXPORT_SYMBOL
c_func
(paren
id|get_afmt_string
)paren
suffix:semicolon
eof
