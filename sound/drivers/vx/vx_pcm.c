multiline_comment|/*&n; * Driver for Digigram VX soundcards&n; *&n; * PCM part&n; *&n; * Copyright (c) 2002,2003 by Takashi Iwai &lt;tiwai@suse.de&gt;&n; *&n; *   This program is free software; you can redistribute it and/or modify&n; *   it under the terms of the GNU General Public License as published by&n; *   the Free Software Foundation; either version 2 of the License, or&n; *   (at your option) any later version.&n; *&n; *   This program is distributed in the hope that it will be useful,&n; *   but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *   GNU General Public License for more details.&n; *&n; *   You should have received a copy of the GNU General Public License&n; *   along with this program; if not, write to the Free Software&n; *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA&n; *&n; *&n; * STRATEGY&n; *  for playback, we send series of &quot;chunks&quot;, which size is equal with the&n; *  IBL size, typically 126 samples.  at each end of chunk, the end-of-buffer&n; *  interrupt is notified, and the interrupt handler will feed the next chunk.&n; *&n; *  the current position is calculated from the sample count RMH.&n; *  pipe-&gt;transferred is the counter of data which has been already transferred.&n; *  if this counter reaches to the period size, snd_pcm_period_elapsed() will&n; *  be issued.&n; *&n; *  for capture, the situation is much easier.&n; *  to get a low latency response, we&squot;ll check the capture streams at each&n; *  interrupt (capture stream has no EOB notification).  if the pending&n; *  data is accumulated to the period size, snd_pcm_period_elapsed() is&n; *  called and the pointer is updated.&n; *&n; *  the current point of read buffer is kept in pipe-&gt;hw_ptr.  note that&n; *  this is in bytes.&n; *&n; *&n; * TODO&n; *  - linked trigger for full-duplex mode.&n; *  - scheduled action on the stream.&n; */
macro_line|#include &lt;sound/driver.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;sound/core.h&gt;
macro_line|#include &lt;sound/asoundef.h&gt;
macro_line|#include &lt;sound/pcm.h&gt;
macro_line|#include &lt;sound/vx_core.h&gt;
macro_line|#include &quot;vx_cmd.h&quot;
multiline_comment|/*&n; * we use a vmalloc&squot;ed (sg-)buffer&n; */
multiline_comment|/* get the physical page pointer on the given offset */
DECL|function|snd_pcm_get_vmalloc_page
r_static
r_struct
id|page
op_star
id|snd_pcm_get_vmalloc_page
c_func
(paren
id|snd_pcm_substream_t
op_star
id|subs
comma
r_int
r_int
id|offset
)paren
(brace
r_void
op_star
id|pageptr
op_assign
id|subs-&gt;runtime-&gt;dma_area
op_plus
id|offset
suffix:semicolon
r_return
id|vmalloc_to_page
c_func
(paren
id|pageptr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * allocate a buffer via vmalloc_32().&n; * called from hw_params&n; * NOTE: this may be called not only once per pcm open!&n; */
DECL|function|snd_pcm_alloc_vmalloc_buffer
r_static
r_int
id|snd_pcm_alloc_vmalloc_buffer
c_func
(paren
id|snd_pcm_substream_t
op_star
id|subs
comma
r_int
id|size
)paren
(brace
id|snd_pcm_runtime_t
op_star
id|runtime
op_assign
id|subs-&gt;runtime
suffix:semicolon
r_if
c_cond
(paren
id|runtime-&gt;dma_area
)paren
(brace
multiline_comment|/* already allocated */
r_if
c_cond
(paren
id|runtime-&gt;dma_bytes
op_ge
id|size
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* already enough large */
id|vfree_nocheck
c_func
(paren
id|runtime-&gt;dma_area
)paren
suffix:semicolon
multiline_comment|/* bypass the memory wrapper */
)brace
id|runtime-&gt;dma_area
op_assign
id|vmalloc_32
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|runtime-&gt;dma_area
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|runtime-&gt;dma_area
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|runtime-&gt;dma_bytes
op_assign
id|size
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* changed */
)brace
multiline_comment|/*&n; * free the buffer.&n; * called from hw_free callback&n; * NOTE: this may be called not only once per pcm open!&n; */
DECL|function|snd_pcm_free_vmalloc_buffer
r_static
r_int
id|snd_pcm_free_vmalloc_buffer
c_func
(paren
id|snd_pcm_substream_t
op_star
id|subs
)paren
(brace
id|snd_pcm_runtime_t
op_star
id|runtime
op_assign
id|subs-&gt;runtime
suffix:semicolon
r_if
c_cond
(paren
id|runtime-&gt;dma_area
)paren
(brace
id|vfree_nocheck
c_func
(paren
id|runtime-&gt;dma_area
)paren
suffix:semicolon
multiline_comment|/* bypass the memory wrapper */
id|runtime-&gt;dma_area
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * read three pending pcm bytes via inb()&n; */
DECL|function|vx_pcm_read_per_bytes
r_static
r_void
id|vx_pcm_read_per_bytes
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
id|snd_pcm_runtime_t
op_star
id|runtime
comma
id|vx_pipe_t
op_star
id|pipe
)paren
(brace
r_int
id|offset
op_assign
id|pipe-&gt;hw_ptr
suffix:semicolon
r_int
r_char
op_star
id|buf
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|runtime-&gt;dma_area
op_plus
id|offset
)paren
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|vx_inb
c_func
(paren
id|chip
comma
id|RXH
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|offset
op_ge
id|pipe-&gt;buffer_bytes
)paren
(brace
id|offset
op_assign
l_int|0
suffix:semicolon
id|buf
op_assign
(paren
r_int
r_char
op_star
)paren
id|runtime-&gt;dma_area
suffix:semicolon
)brace
op_star
id|buf
op_increment
op_assign
id|vx_inb
c_func
(paren
id|chip
comma
id|RXM
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|offset
op_ge
id|pipe-&gt;buffer_bytes
)paren
(brace
id|offset
op_assign
l_int|0
suffix:semicolon
id|buf
op_assign
(paren
r_int
r_char
op_star
)paren
id|runtime-&gt;dma_area
suffix:semicolon
)brace
op_star
id|buf
op_increment
op_assign
id|vx_inb
c_func
(paren
id|chip
comma
id|RXL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|offset
op_ge
id|pipe-&gt;buffer_bytes
)paren
(brace
id|offset
op_assign
l_int|0
suffix:semicolon
id|buf
op_assign
(paren
r_int
r_char
op_star
)paren
id|runtime-&gt;dma_area
suffix:semicolon
)brace
id|pipe-&gt;hw_ptr
op_assign
id|offset
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_set_pcx_time - convert from the PC time to the RMH status time.&n; * @pc_time: the pointer for the PC-time to set&n; * @dsp_time: the pointer for RMH status time array&n; */
DECL|function|vx_set_pcx_time
r_static
r_void
id|vx_set_pcx_time
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
id|pcx_time_t
op_star
id|pc_time
comma
r_int
r_int
op_star
id|dsp_time
)paren
(brace
id|dsp_time
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_int
)paren
(paren
(paren
op_star
id|pc_time
)paren
op_rshift
l_int|24
)paren
op_amp
id|PCX_TIME_HI_MASK
suffix:semicolon
id|dsp_time
(braket
l_int|1
)braket
op_assign
(paren
r_int
r_int
)paren
(paren
op_star
id|pc_time
)paren
op_amp
id|MASK_DSP_WORD
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_set_differed_time - set the differed time if specified&n; * @rmh: the rmh record to modify&n; * @pipe: the pipe to be checked&n; *&n; * if the pipe is programmed with the differed time, set the DSP time&n; * on the rmh and changes its command length.&n; *&n; * returns the increase of the command length.&n; */
DECL|function|vx_set_differed_time
r_static
r_int
id|vx_set_differed_time
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
r_struct
id|vx_rmh
op_star
id|rmh
comma
id|vx_pipe_t
op_star
id|pipe
)paren
(brace
multiline_comment|/* Update The length added to the RMH command by the timestamp */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pipe-&gt;differed_type
op_amp
id|DC_DIFFERED_DELAY
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Set the T bit */
id|rmh-&gt;Cmd
(braket
l_int|0
)braket
op_or_assign
id|DSP_DIFFERED_COMMAND_MASK
suffix:semicolon
multiline_comment|/* Time stamp is the 1st following parameter */
id|vx_set_pcx_time
c_func
(paren
id|chip
comma
op_amp
id|pipe-&gt;pcx_time
comma
op_amp
id|rmh-&gt;Cmd
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* Add the flags to a notified differed command */
r_if
c_cond
(paren
id|pipe-&gt;differed_type
op_amp
id|DC_NOTIFY_DELAY
)paren
id|rmh-&gt;Cmd
(braket
l_int|1
)braket
op_or_assign
id|NOTIFY_MASK_TIME_HIGH
suffix:semicolon
multiline_comment|/* Add the flags to a multiple differed command */
r_if
c_cond
(paren
id|pipe-&gt;differed_type
op_amp
id|DC_MULTIPLE_DELAY
)paren
id|rmh-&gt;Cmd
(braket
l_int|1
)braket
op_or_assign
id|MULTIPLE_MASK_TIME_HIGH
suffix:semicolon
multiline_comment|/* Add the flags to a stream-time differed command */
r_if
c_cond
(paren
id|pipe-&gt;differed_type
op_amp
id|DC_STREAM_TIME_DELAY
)paren
id|rmh-&gt;Cmd
(braket
l_int|1
)braket
op_or_assign
id|STREAM_MASK_TIME_HIGH
suffix:semicolon
id|rmh-&gt;LgCmd
op_add_assign
l_int|2
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_set_stream_format - send the stream format command&n; * @pipe: the affected pipe&n; * @data: format bitmask&n; */
DECL|function|vx_set_stream_format
r_static
r_int
id|vx_set_stream_format
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
id|vx_pipe_t
op_star
id|pipe
comma
r_int
r_int
id|data
)paren
(brace
r_struct
id|vx_rmh
id|rmh
suffix:semicolon
id|vx_init_rmh
c_func
(paren
op_amp
id|rmh
comma
id|pipe-&gt;is_capture
ques
c_cond
id|CMD_FORMAT_STREAM_IN
suffix:colon
id|CMD_FORMAT_STREAM_OUT
)paren
suffix:semicolon
id|rmh.Cmd
(braket
l_int|0
)braket
op_or_assign
id|pipe-&gt;number
op_lshift
id|FIELD_SIZE
suffix:semicolon
multiline_comment|/* Command might be longer since we may have to add a timestamp */
id|vx_set_differed_time
c_func
(paren
id|chip
comma
op_amp
id|rmh
comma
id|pipe
)paren
suffix:semicolon
id|rmh.Cmd
(braket
id|rmh.LgCmd
)braket
op_assign
(paren
id|data
op_amp
l_int|0xFFFFFF00
)paren
op_rshift
l_int|8
suffix:semicolon
id|rmh.Cmd
(braket
id|rmh.LgCmd
op_plus
l_int|1
)braket
op_assign
(paren
id|data
op_amp
l_int|0xFF
)paren
op_lshift
l_int|16
multiline_comment|/*| (datal &amp; 0xFFFF00) &gt;&gt; 8*/
suffix:semicolon
id|rmh.LgCmd
op_add_assign
l_int|2
suffix:semicolon
r_return
id|vx_send_msg
c_func
(paren
id|chip
comma
op_amp
id|rmh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_set_format - set the format of a pipe&n; * @pipe: the affected pipe&n; * @runtime: pcm runtime instance to be referred&n; *&n; * returns 0 if successful, or a negative error code.&n; */
DECL|function|vx_set_format
r_static
r_int
id|vx_set_format
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
id|vx_pipe_t
op_star
id|pipe
comma
id|snd_pcm_runtime_t
op_star
id|runtime
)paren
(brace
r_int
r_int
id|header
op_assign
id|HEADER_FMT_BASE
suffix:semicolon
r_if
c_cond
(paren
id|runtime-&gt;channels
op_eq
l_int|1
)paren
id|header
op_or_assign
id|HEADER_FMT_MONO
suffix:semicolon
r_if
c_cond
(paren
id|snd_pcm_format_little_endian
c_func
(paren
id|runtime-&gt;format
)paren
)paren
id|header
op_or_assign
id|HEADER_FMT_INTEL
suffix:semicolon
r_if
c_cond
(paren
id|runtime-&gt;rate
template_param
l_int|11025
)paren
id|header
op_or_assign
id|HEADER_FMT_UPTO32
suffix:semicolon
r_else
r_if
c_cond
(paren
id|runtime-&gt;rate
op_le
l_int|11025
)paren
id|header
op_or_assign
id|HEADER_FMT_UPTO11
suffix:semicolon
r_switch
c_cond
(paren
id|snd_pcm_format_physical_width
c_func
(paren
id|runtime-&gt;format
)paren
)paren
(brace
singleline_comment|// case 8: break;
r_case
l_int|16
suffix:colon
id|header
op_or_assign
id|HEADER_FMT_16BITS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|24
suffix:colon
id|header
op_or_assign
id|HEADER_FMT_24BITS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|snd_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
suffix:semicolon
r_return
id|vx_set_stream_format
c_func
(paren
id|chip
comma
id|pipe
comma
id|header
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * set / query the IBL size&n; */
DECL|function|vx_set_ibl
r_static
r_int
id|vx_set_ibl
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
r_struct
id|vx_ibl_info
op_star
id|info
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|vx_rmh
id|rmh
suffix:semicolon
id|vx_init_rmh
c_func
(paren
op_amp
id|rmh
comma
id|CMD_IBL
)paren
suffix:semicolon
id|rmh.Cmd
(braket
l_int|0
)braket
op_or_assign
id|info-&gt;size
op_amp
l_int|0x03ffff
suffix:semicolon
id|err
op_assign
id|vx_send_msg
c_func
(paren
id|chip
comma
op_amp
id|rmh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|info-&gt;size
op_assign
id|rmh.Stat
(braket
l_int|0
)braket
suffix:semicolon
id|info-&gt;max_size
op_assign
id|rmh.Stat
(braket
l_int|1
)braket
suffix:semicolon
id|info-&gt;min_size
op_assign
id|rmh.Stat
(braket
l_int|2
)braket
suffix:semicolon
id|info-&gt;granularity
op_assign
id|rmh.Stat
(braket
l_int|3
)braket
suffix:semicolon
id|snd_printdd
c_func
(paren
id|KERN_DEBUG
l_string|&quot;vx_set_ibl: size = %d, max = %d, min = %d, gran = %d&bslash;n&quot;
comma
id|info-&gt;size
comma
id|info-&gt;max_size
comma
id|info-&gt;min_size
comma
id|info-&gt;granularity
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_get_pipe_state - get the state of a pipe&n; * @pipe: the pipe to be checked&n; * @state: the pointer for the returned state&n; *&n; * checks the state of a given pipe, and stores the state (1 = running,&n; * 0 = paused) on the given pointer.&n; *&n; * called from trigger callback only&n; */
DECL|function|vx_get_pipe_state
r_static
r_int
id|vx_get_pipe_state
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
id|vx_pipe_t
op_star
id|pipe
comma
r_int
op_star
id|state
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|vx_rmh
id|rmh
suffix:semicolon
id|vx_init_rmh
c_func
(paren
op_amp
id|rmh
comma
id|CMD_PIPE_STATE
)paren
suffix:semicolon
id|vx_set_pipe_cmd_params
c_func
(paren
op_amp
id|rmh
comma
id|pipe-&gt;is_capture
comma
id|pipe-&gt;number
comma
l_int|0
)paren
suffix:semicolon
id|err
op_assign
id|vx_send_msg_nolock
c_func
(paren
id|chip
comma
op_amp
id|rmh
)paren
suffix:semicolon
multiline_comment|/* no lock needed for trigger */
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
op_star
id|state
op_assign
(paren
id|rmh.Stat
(braket
l_int|0
)braket
op_amp
(paren
l_int|1
op_lshift
id|pipe-&gt;number
)paren
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_query_hbuffer_size - query available h-buffer size in bytes&n; * @pipe: the pipe to be checked&n; *&n; * return the available size on h-buffer in bytes,&n; * or a negative error code.&n; *&n; * NOTE: calling this function always switches to the stream mode.&n; *       you&squot;ll need to disconnect the host to get back to the&n; *       normal mode.&n; */
DECL|function|vx_query_hbuffer_size
r_static
r_int
id|vx_query_hbuffer_size
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
id|vx_pipe_t
op_star
id|pipe
)paren
(brace
r_int
id|result
suffix:semicolon
r_struct
id|vx_rmh
id|rmh
suffix:semicolon
id|vx_init_rmh
c_func
(paren
op_amp
id|rmh
comma
id|CMD_SIZE_HBUFFER
)paren
suffix:semicolon
id|vx_set_pipe_cmd_params
c_func
(paren
op_amp
id|rmh
comma
id|pipe-&gt;is_capture
comma
id|pipe-&gt;number
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pipe-&gt;is_capture
)paren
id|rmh.Cmd
(braket
l_int|0
)braket
op_or_assign
l_int|0x00000001
suffix:semicolon
id|result
op_assign
id|vx_send_msg
c_func
(paren
id|chip
comma
op_amp
id|rmh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
id|result
op_assign
id|rmh.Stat
(braket
l_int|0
)braket
op_amp
l_int|0xffff
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_pipe_can_start - query whether a pipe is ready for start&n; * @pipe: the pipe to be checked&n; *&n; * return 1 if ready, 0 if not ready, and negative value on error.&n; *&n; * called from trigger callback only&n; */
DECL|function|vx_pipe_can_start
r_static
r_int
id|vx_pipe_can_start
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
id|vx_pipe_t
op_star
id|pipe
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|vx_rmh
id|rmh
suffix:semicolon
id|vx_init_rmh
c_func
(paren
op_amp
id|rmh
comma
id|CMD_CAN_START_PIPE
)paren
suffix:semicolon
id|vx_set_pipe_cmd_params
c_func
(paren
op_amp
id|rmh
comma
id|pipe-&gt;is_capture
comma
id|pipe-&gt;number
comma
l_int|0
)paren
suffix:semicolon
id|rmh.Cmd
(braket
l_int|0
)braket
op_or_assign
l_int|1
suffix:semicolon
id|err
op_assign
id|vx_send_msg_nolock
c_func
(paren
id|chip
comma
op_amp
id|rmh
)paren
suffix:semicolon
multiline_comment|/* no lock needed for trigger */
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
r_if
c_cond
(paren
id|rmh.Stat
(braket
l_int|0
)braket
)paren
id|err
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_conf_pipe - tell the pipe to stand by and wait for IRQA.&n; * @pipe: the pipe to be configured&n; */
DECL|function|vx_conf_pipe
r_static
r_int
id|vx_conf_pipe
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
id|vx_pipe_t
op_star
id|pipe
)paren
(brace
r_struct
id|vx_rmh
id|rmh
suffix:semicolon
id|vx_init_rmh
c_func
(paren
op_amp
id|rmh
comma
id|CMD_CONF_PIPE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pipe-&gt;is_capture
)paren
id|rmh.Cmd
(braket
l_int|0
)braket
op_or_assign
id|COMMAND_RECORD_MASK
suffix:semicolon
id|rmh.Cmd
(braket
l_int|1
)braket
op_assign
l_int|1
op_lshift
id|pipe-&gt;number
suffix:semicolon
r_return
id|vx_send_msg_nolock
c_func
(paren
id|chip
comma
op_amp
id|rmh
)paren
suffix:semicolon
multiline_comment|/* no lock needed for trigger */
)brace
multiline_comment|/*&n; * vx_send_irqa - trigger IRQA&n; */
DECL|function|vx_send_irqa
r_static
r_int
id|vx_send_irqa
c_func
(paren
id|vx_core_t
op_star
id|chip
)paren
(brace
r_struct
id|vx_rmh
id|rmh
suffix:semicolon
id|vx_init_rmh
c_func
(paren
op_amp
id|rmh
comma
id|CMD_SEND_IRQA
)paren
suffix:semicolon
r_return
id|vx_send_msg_nolock
c_func
(paren
id|chip
comma
op_amp
id|rmh
)paren
suffix:semicolon
multiline_comment|/* no lock needed for trigger */
)brace
DECL|macro|MAX_WAIT_FOR_DSP
mdefine_line|#define MAX_WAIT_FOR_DSP        250
multiline_comment|/*&n; * vx boards do not support inter-card sync, besides&n; * only 126 samples require to be prepared before a pipe can start&n; */
DECL|macro|CAN_START_DELAY
mdefine_line|#define CAN_START_DELAY         2&t;/* wait 2ms only before asking if the pipe is ready*/
DECL|macro|WAIT_STATE_DELAY
mdefine_line|#define WAIT_STATE_DELAY        2&t;/* wait 2ms after irqA was requested and check if the pipe state toggled*/
multiline_comment|/*&n; * vx_toggle_pipe - start / pause a pipe&n; * @pipe: the pipe to be triggered&n; * @state: start = 1, pause = 0&n; *&n; * called from trigger callback only&n; *&n; */
DECL|function|vx_toggle_pipe
r_static
r_int
id|vx_toggle_pipe
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
id|vx_pipe_t
op_star
id|pipe
comma
r_int
id|state
)paren
(brace
r_int
id|err
comma
id|i
comma
id|cur_state
suffix:semicolon
multiline_comment|/* Check the pipe is not already in the requested state */
r_if
c_cond
(paren
id|vx_get_pipe_state
c_func
(paren
id|chip
comma
id|pipe
comma
op_amp
id|cur_state
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EBADFD
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
id|cur_state
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* If a start is requested, ask the DSP to get prepared&n;&t; * and wait for a positive acknowledge (when there are&n;&t; * enough sound buffer for this pipe)&n;&t; */
r_if
c_cond
(paren
id|state
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_WAIT_FOR_DSP
suffix:semicolon
id|i
op_increment
)paren
(brace
id|err
op_assign
id|vx_pipe_can_start
c_func
(paren
id|chip
comma
id|pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OG
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* Wait for a few, before asking again&n;&t;&t;&t; * to avoid flooding the DSP with our requests&n;&t;&t;&t; */
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|vx_conf_pipe
c_func
(paren
id|chip
comma
id|pipe
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|vx_send_irqa
c_func
(paren
id|chip
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* If it completes successfully, wait for the pipes&n;&t; * reaching the expected state before returning&n;&t; * Check one pipe only (since they are synchronous)&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_WAIT_FOR_DSP
suffix:semicolon
id|i
op_increment
)paren
(brace
id|err
op_assign
id|vx_get_pipe_state
c_func
(paren
id|chip
comma
id|pipe
comma
op_amp
id|cur_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
op_logical_or
id|cur_state
op_eq
id|state
)paren
r_break
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|err
OL
l_int|0
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_stop_pipe - stop a pipe&n; * @pipe: the pipe to be stopped&n; *&n; * called from trigger callback only&n; */
DECL|function|vx_stop_pipe
r_static
r_int
id|vx_stop_pipe
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
id|vx_pipe_t
op_star
id|pipe
)paren
(brace
r_struct
id|vx_rmh
id|rmh
suffix:semicolon
id|vx_init_rmh
c_func
(paren
op_amp
id|rmh
comma
id|CMD_STOP_PIPE
)paren
suffix:semicolon
id|vx_set_pipe_cmd_params
c_func
(paren
op_amp
id|rmh
comma
id|pipe-&gt;is_capture
comma
id|pipe-&gt;number
comma
l_int|0
)paren
suffix:semicolon
r_return
id|vx_send_msg_nolock
c_func
(paren
id|chip
comma
op_amp
id|rmh
)paren
suffix:semicolon
multiline_comment|/* no lock needed for trigger */
)brace
multiline_comment|/*&n; * vx_alloc_pipe - allocate a pipe and initialize the pipe instance&n; * @capture: 0 = playback, 1 = capture operation&n; * @audioid: the audio id to be assigned&n; * @num_audio: number of audio channels&n; * @pipep: the returned pipe instance&n; *&n; * return 0 on success, or a negative error code.&n; */
DECL|function|vx_alloc_pipe
r_static
r_int
id|vx_alloc_pipe
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
r_int
id|capture
comma
r_int
id|audioid
comma
r_int
id|num_audio
comma
id|vx_pipe_t
op_star
op_star
id|pipep
)paren
(brace
r_int
id|err
suffix:semicolon
id|vx_pipe_t
op_star
id|pipe
suffix:semicolon
r_struct
id|vx_rmh
id|rmh
suffix:semicolon
r_int
id|data_mode
suffix:semicolon
op_star
id|pipep
op_assign
l_int|NULL
suffix:semicolon
id|vx_init_rmh
c_func
(paren
op_amp
id|rmh
comma
id|CMD_RES_PIPE
)paren
suffix:semicolon
id|vx_set_pipe_cmd_params
c_func
(paren
op_amp
id|rmh
comma
id|capture
comma
id|audioid
comma
id|num_audio
)paren
suffix:semicolon
macro_line|#if 0&t;
singleline_comment|// NYI
r_if
c_cond
(paren
id|underrun_skip_sound
)paren
id|rmh.Cmd
(braket
l_int|0
)braket
op_or_assign
id|BIT_SKIP_SOUND
suffix:semicolon
macro_line|#endif&t;
singleline_comment|// NYI
id|data_mode
op_assign
(paren
id|chip-&gt;uer_bits
op_amp
id|IEC958_AES0_NONAUDIO
)paren
op_ne
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capture
op_logical_and
id|data_mode
)paren
id|rmh.Cmd
(braket
l_int|0
)braket
op_or_assign
id|BIT_DATA_MODE
suffix:semicolon
id|err
op_assign
id|vx_send_msg
c_func
(paren
id|chip
comma
op_amp
id|rmh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* initialize the pipe record */
id|pipe
op_assign
id|kcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|pipe
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pipe
)paren
(brace
multiline_comment|/* release the pipe */
id|vx_init_rmh
c_func
(paren
op_amp
id|rmh
comma
id|CMD_FREE_PIPE
)paren
suffix:semicolon
id|vx_set_pipe_cmd_params
c_func
(paren
op_amp
id|rmh
comma
id|capture
comma
id|audioid
comma
l_int|0
)paren
suffix:semicolon
id|vx_send_msg
c_func
(paren
id|chip
comma
op_amp
id|rmh
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* the pipe index should be identical with the audio index */
id|pipe-&gt;number
op_assign
id|audioid
suffix:semicolon
id|pipe-&gt;is_capture
op_assign
id|capture
suffix:semicolon
id|pipe-&gt;channels
op_assign
id|num_audio
suffix:semicolon
id|pipe-&gt;differed_type
op_assign
l_int|0
suffix:semicolon
id|pipe-&gt;pcx_time
op_assign
l_int|0
suffix:semicolon
id|pipe-&gt;data_mode
op_assign
id|data_mode
suffix:semicolon
op_star
id|pipep
op_assign
id|pipe
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_free_pipe - release a pipe&n; * @pipe: pipe to be released&n; */
DECL|function|vx_free_pipe
r_static
r_int
id|vx_free_pipe
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
id|vx_pipe_t
op_star
id|pipe
)paren
(brace
r_struct
id|vx_rmh
id|rmh
suffix:semicolon
id|vx_init_rmh
c_func
(paren
op_amp
id|rmh
comma
id|CMD_FREE_PIPE
)paren
suffix:semicolon
id|vx_set_pipe_cmd_params
c_func
(paren
op_amp
id|rmh
comma
id|pipe-&gt;is_capture
comma
id|pipe-&gt;number
comma
l_int|0
)paren
suffix:semicolon
id|vx_send_msg
c_func
(paren
id|chip
comma
op_amp
id|rmh
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pipe
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_start_stream - start the stream&n; *&n; * called from trigger callback only&n; */
DECL|function|vx_start_stream
r_static
r_int
id|vx_start_stream
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
id|vx_pipe_t
op_star
id|pipe
)paren
(brace
r_struct
id|vx_rmh
id|rmh
suffix:semicolon
id|vx_init_rmh
c_func
(paren
op_amp
id|rmh
comma
id|CMD_START_ONE_STREAM
)paren
suffix:semicolon
id|vx_set_stream_cmd_params
c_func
(paren
op_amp
id|rmh
comma
id|pipe-&gt;is_capture
comma
id|pipe-&gt;number
)paren
suffix:semicolon
id|vx_set_differed_time
c_func
(paren
id|chip
comma
op_amp
id|rmh
comma
id|pipe
)paren
suffix:semicolon
r_return
id|vx_send_msg_nolock
c_func
(paren
id|chip
comma
op_amp
id|rmh
)paren
suffix:semicolon
multiline_comment|/* no lock needed for trigger */
)brace
multiline_comment|/*&n; * vx_stop_stream - stop the stream&n; *&n; * called from trigger callback only&n; */
DECL|function|vx_stop_stream
r_static
r_int
id|vx_stop_stream
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
id|vx_pipe_t
op_star
id|pipe
)paren
(brace
r_struct
id|vx_rmh
id|rmh
suffix:semicolon
id|vx_init_rmh
c_func
(paren
op_amp
id|rmh
comma
id|CMD_STOP_STREAM
)paren
suffix:semicolon
id|vx_set_stream_cmd_params
c_func
(paren
op_amp
id|rmh
comma
id|pipe-&gt;is_capture
comma
id|pipe-&gt;number
)paren
suffix:semicolon
r_return
id|vx_send_msg_nolock
c_func
(paren
id|chip
comma
op_amp
id|rmh
)paren
suffix:semicolon
multiline_comment|/* no lock needed for trigger */
)brace
multiline_comment|/*&n; * playback hw information&n; */
DECL|variable|vx_pcm_playback_hw
r_static
id|snd_pcm_hardware_t
id|vx_pcm_playback_hw
op_assign
(brace
dot
id|info
op_assign
(paren
id|SNDRV_PCM_INFO_MMAP
op_or
id|SNDRV_PCM_INFO_INTERLEAVED
op_or
id|SNDRV_PCM_INFO_PAUSE
op_or
id|SNDRV_PCM_INFO_MMAP_VALID
op_or
id|SNDRV_PCM_INFO_RESUME
)paren
comma
dot
id|formats
op_assign
multiline_comment|/*SNDRV_PCM_FMTBIT_U8 |*/
id|SNDRV_PCM_FMTBIT_S16_LE
op_or
id|SNDRV_PCM_FMTBIT_S24_3LE
comma
dot
id|rates
op_assign
id|SNDRV_PCM_RATE_CONTINUOUS
op_or
id|SNDRV_PCM_RATE_8000_48000
comma
dot
id|rate_min
op_assign
l_int|5000
comma
dot
id|rate_max
op_assign
l_int|48000
comma
dot
id|channels_min
op_assign
l_int|1
comma
dot
id|channels_max
op_assign
l_int|2
comma
dot
id|buffer_bytes_max
op_assign
(paren
l_int|128
op_star
l_int|1024
)paren
comma
dot
id|period_bytes_min
op_assign
l_int|126
comma
dot
id|period_bytes_max
op_assign
(paren
l_int|128
op_star
l_int|1024
)paren
comma
dot
id|periods_min
op_assign
l_int|2
comma
dot
id|periods_max
op_assign
id|VX_MAX_PERIODS
comma
dot
id|fifo_size
op_assign
l_int|126
comma
)brace
suffix:semicolon
r_static
r_void
id|vx_pcm_delayed_start
c_func
(paren
r_int
r_int
id|arg
)paren
suffix:semicolon
multiline_comment|/*&n; * vx_pcm_playback_open - open callback for playback&n; */
DECL|function|vx_pcm_playback_open
r_static
r_int
id|vx_pcm_playback_open
c_func
(paren
id|snd_pcm_substream_t
op_star
id|subs
)paren
(brace
id|snd_pcm_runtime_t
op_star
id|runtime
op_assign
id|subs-&gt;runtime
suffix:semicolon
id|vx_core_t
op_star
id|chip
op_assign
id|snd_pcm_substream_chip
c_func
(paren
id|subs
)paren
suffix:semicolon
id|vx_pipe_t
op_star
id|pipe
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|audio
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;chip_status
op_amp
id|VX_STAT_IS_STALE
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|audio
op_assign
id|subs-&gt;pcm-&gt;device
op_star
l_int|2
suffix:semicolon
id|snd_assert
c_func
(paren
id|audio
OL
id|chip-&gt;audio_outs
comma
r_return
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* playback pipe may have been already allocated for monitoring */
id|pipe
op_assign
id|chip-&gt;playback_pipes
(braket
id|audio
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pipe
)paren
(brace
multiline_comment|/* not allocated yet */
id|err
op_assign
id|vx_alloc_pipe
c_func
(paren
id|chip
comma
l_int|0
comma
id|audio
comma
l_int|2
comma
op_amp
id|pipe
)paren
suffix:semicolon
multiline_comment|/* stereo playback */
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|chip-&gt;playback_pipes
(braket
id|audio
)braket
op_assign
id|pipe
suffix:semicolon
)brace
multiline_comment|/* open for playback */
id|pipe-&gt;references
op_increment
suffix:semicolon
id|pipe-&gt;substream
op_assign
id|subs
suffix:semicolon
id|tasklet_init
c_func
(paren
op_amp
id|pipe-&gt;start_tq
comma
id|vx_pcm_delayed_start
comma
(paren
r_int
r_int
)paren
id|subs
)paren
suffix:semicolon
id|chip-&gt;playback_pipes
(braket
id|audio
)braket
op_assign
id|pipe
suffix:semicolon
id|runtime-&gt;hw
op_assign
id|vx_pcm_playback_hw
suffix:semicolon
id|runtime-&gt;hw.period_bytes_min
op_assign
id|chip-&gt;ibl.size
suffix:semicolon
id|runtime-&gt;private_data
op_assign
id|pipe
suffix:semicolon
multiline_comment|/* align to 4 bytes (otherwise will be problematic when 24bit is used) */
id|snd_pcm_hw_constraint_step
c_func
(paren
id|runtime
comma
l_int|0
comma
id|SNDRV_PCM_HW_PARAM_BUFFER_BYTES
comma
l_int|4
)paren
suffix:semicolon
id|snd_pcm_hw_constraint_step
c_func
(paren
id|runtime
comma
l_int|0
comma
id|SNDRV_PCM_HW_PARAM_PERIOD_BYTES
comma
l_int|4
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_pcm_playback_close - close callback for playback&n; */
DECL|function|vx_pcm_playback_close
r_static
r_int
id|vx_pcm_playback_close
c_func
(paren
id|snd_pcm_substream_t
op_star
id|subs
)paren
(brace
id|vx_core_t
op_star
id|chip
op_assign
id|snd_pcm_substream_chip
c_func
(paren
id|subs
)paren
suffix:semicolon
id|vx_pipe_t
op_star
id|pipe
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subs-&gt;runtime-&gt;private_data
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|pipe
op_assign
id|subs-&gt;runtime-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|pipe-&gt;references
op_eq
l_int|0
)paren
(brace
id|chip-&gt;playback_pipes
(braket
id|pipe-&gt;number
)braket
op_assign
l_int|NULL
suffix:semicolon
id|vx_free_pipe
c_func
(paren
id|chip
comma
id|pipe
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_notify_end_of_buffer - send &quot;end-of-buffer&quot; notifier at the given pipe&n; * @pipe: the pipe to notify&n; *&n; * NB: call with a certain lock.&n; */
DECL|function|vx_notify_end_of_buffer
r_static
r_int
id|vx_notify_end_of_buffer
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
id|vx_pipe_t
op_star
id|pipe
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|vx_rmh
id|rmh
suffix:semicolon
multiline_comment|/* use a temporary rmh here */
multiline_comment|/* Toggle Dsp Host Interface into Message mode */
id|vx_send_rih_nolock
c_func
(paren
id|chip
comma
id|IRQ_PAUSE_START_CONNECT
)paren
suffix:semicolon
id|vx_init_rmh
c_func
(paren
op_amp
id|rmh
comma
id|CMD_NOTIFY_END_OF_BUFFER
)paren
suffix:semicolon
id|vx_set_stream_cmd_params
c_func
(paren
op_amp
id|rmh
comma
l_int|0
comma
id|pipe-&gt;number
)paren
suffix:semicolon
id|err
op_assign
id|vx_send_msg_nolock
c_func
(paren
id|chip
comma
op_amp
id|rmh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* Toggle Dsp Host Interface back to sound transfer mode */
id|vx_send_rih_nolock
c_func
(paren
id|chip
comma
id|IRQ_PAUSE_START_CONNECT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_pcm_playback_transfer_chunk - transfer a single chunk&n; * @subs: substream&n; * @pipe: the pipe to transfer&n; * @size: chunk size in bytes&n; *&n; * transfer a single buffer chunk.  EOB notificaton is added after that.&n; * called from the interrupt handler, too.&n; *&n; * return 0 if ok.&n; */
DECL|function|vx_pcm_playback_transfer_chunk
r_static
r_int
id|vx_pcm_playback_transfer_chunk
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
id|snd_pcm_runtime_t
op_star
id|runtime
comma
id|vx_pipe_t
op_star
id|pipe
comma
r_int
id|size
)paren
(brace
r_int
id|space
comma
id|err
op_assign
l_int|0
suffix:semicolon
id|space
op_assign
id|vx_query_hbuffer_size
c_func
(paren
id|chip
comma
id|pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|space
OL
l_int|0
)paren
(brace
multiline_comment|/* disconnect the host, SIZE_HBUF command always switches to the stream mode */
id|vx_send_rih
c_func
(paren
id|chip
comma
id|IRQ_CONNECT_STREAM_NEXT
)paren
suffix:semicolon
id|snd_printd
c_func
(paren
l_string|&quot;error hbuffer&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|space
suffix:semicolon
)brace
r_if
c_cond
(paren
id|space
OL
id|size
)paren
(brace
id|vx_send_rih
c_func
(paren
id|chip
comma
id|IRQ_CONNECT_STREAM_NEXT
)paren
suffix:semicolon
id|snd_printd
c_func
(paren
l_string|&quot;no enough hbuffer space %d&bslash;n&quot;
comma
id|space
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* XRUN */
)brace
multiline_comment|/* we don&squot;t need irqsave here, because this function&n;&t; * is called from either trigger callback or irq handler&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|chip-&gt;lock
)paren
suffix:semicolon
id|vx_pseudo_dma_write
c_func
(paren
id|chip
comma
id|runtime
comma
id|pipe
comma
id|size
)paren
suffix:semicolon
id|err
op_assign
id|vx_notify_end_of_buffer
c_func
(paren
id|chip
comma
id|pipe
)paren
suffix:semicolon
multiline_comment|/* disconnect the host, SIZE_HBUF command always switches to the stream mode */
id|vx_send_rih_nolock
c_func
(paren
id|chip
comma
id|IRQ_CONNECT_STREAM_NEXT
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|chip-&gt;lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * update the position of the given pipe.&n; * pipe-&gt;position is updated and wrapped within the buffer size.&n; * pipe-&gt;transferred is updated, too, but the size is not wrapped,&n; * so that the caller can check the total transferred size later&n; * (to call snd_pcm_period_elapsed).&n; */
DECL|function|vx_update_pipe_position
r_static
r_int
id|vx_update_pipe_position
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
id|snd_pcm_runtime_t
op_star
id|runtime
comma
id|vx_pipe_t
op_star
id|pipe
)paren
(brace
r_struct
id|vx_rmh
id|rmh
suffix:semicolon
r_int
id|err
comma
id|update
suffix:semicolon
id|u64
id|count
suffix:semicolon
id|vx_init_rmh
c_func
(paren
op_amp
id|rmh
comma
id|CMD_STREAM_SAMPLE_COUNT
)paren
suffix:semicolon
id|vx_set_pipe_cmd_params
c_func
(paren
op_amp
id|rmh
comma
id|pipe-&gt;is_capture
comma
id|pipe-&gt;number
comma
l_int|0
)paren
suffix:semicolon
id|err
op_assign
id|vx_send_msg
c_func
(paren
id|chip
comma
op_amp
id|rmh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|count
op_assign
(paren
(paren
id|u64
)paren
(paren
id|rmh.Stat
(braket
l_int|0
)braket
op_amp
l_int|0xfffff
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|u64
)paren
id|rmh.Stat
(braket
l_int|1
)braket
suffix:semicolon
id|update
op_assign
(paren
r_int
)paren
(paren
id|count
op_minus
id|pipe-&gt;cur_count
)paren
suffix:semicolon
id|pipe-&gt;cur_count
op_assign
id|count
suffix:semicolon
id|pipe-&gt;position
op_add_assign
id|update
suffix:semicolon
r_if
c_cond
(paren
id|pipe-&gt;position
op_ge
(paren
r_int
)paren
id|runtime-&gt;buffer_size
)paren
id|pipe-&gt;position
op_mod_assign
id|runtime-&gt;buffer_size
suffix:semicolon
id|pipe-&gt;transferred
op_add_assign
id|update
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * transfer the pending playback buffer data to DSP&n; * called from interrupt handler&n; */
DECL|function|vx_pcm_playback_transfer
r_static
r_void
id|vx_pcm_playback_transfer
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
id|snd_pcm_substream_t
op_star
id|subs
comma
id|vx_pipe_t
op_star
id|pipe
comma
r_int
id|nchunks
)paren
(brace
r_int
id|i
comma
id|err
suffix:semicolon
id|snd_pcm_runtime_t
op_star
id|runtime
op_assign
id|subs-&gt;runtime
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pipe-&gt;prepared
op_logical_or
(paren
id|chip-&gt;chip_status
op_amp
id|VX_STAT_IS_STALE
)paren
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nchunks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|vx_pcm_playback_transfer_chunk
c_func
(paren
id|chip
comma
id|runtime
comma
id|pipe
comma
id|chip-&gt;ibl.size
)paren
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * update the playback position and call snd_pcm_period_elapsed() if necessary&n; * called from interrupt handler&n; */
DECL|function|vx_pcm_playback_update
r_static
r_void
id|vx_pcm_playback_update
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
id|snd_pcm_substream_t
op_star
id|subs
comma
id|vx_pipe_t
op_star
id|pipe
)paren
(brace
r_int
id|err
suffix:semicolon
id|snd_pcm_runtime_t
op_star
id|runtime
op_assign
id|subs-&gt;runtime
suffix:semicolon
r_if
c_cond
(paren
id|pipe-&gt;running
op_logical_and
op_logical_neg
(paren
id|chip-&gt;chip_status
op_amp
id|VX_STAT_IS_STALE
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|vx_update_pipe_position
c_func
(paren
id|chip
comma
id|runtime
comma
id|pipe
)paren
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|pipe-&gt;transferred
op_ge
(paren
r_int
)paren
id|runtime-&gt;period_size
)paren
(brace
id|pipe-&gt;transferred
op_mod_assign
id|runtime-&gt;period_size
suffix:semicolon
id|snd_pcm_period_elapsed
c_func
(paren
id|subs
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * start the stream and pipe.&n; * this function is called from tasklet, which is invoked by the trigger&n; * START callback.&n; */
DECL|function|vx_pcm_delayed_start
r_static
r_void
id|vx_pcm_delayed_start
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
id|snd_pcm_substream_t
op_star
id|subs
op_assign
(paren
id|snd_pcm_substream_t
op_star
)paren
id|arg
suffix:semicolon
id|vx_core_t
op_star
id|chip
op_assign
id|subs-&gt;pcm-&gt;private_data
suffix:semicolon
id|vx_pipe_t
op_star
id|pipe
op_assign
id|subs-&gt;runtime-&gt;private_data
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/*  printk( KERN_DEBUG &quot;DDDD tasklet delayed start jiffies = %ld&bslash;n&quot;, jiffies);*/
r_if
c_cond
(paren
(paren
id|err
op_assign
id|vx_start_stream
c_func
(paren
id|chip
comma
id|pipe
)paren
)paren
OL
l_int|0
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;vx: cannot start stream&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|vx_toggle_pipe
c_func
(paren
id|chip
comma
id|pipe
comma
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;vx: cannot start pipe&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*   printk( KERN_DEBUG &quot;dddd tasklet delayed start jiffies = %ld &bslash;n&quot;, jiffies);*/
)brace
multiline_comment|/*&n; * vx_pcm_playback_trigger - trigger callback for playback&n; */
DECL|function|vx_pcm_trigger
r_static
r_int
id|vx_pcm_trigger
c_func
(paren
id|snd_pcm_substream_t
op_star
id|subs
comma
r_int
id|cmd
)paren
(brace
id|vx_core_t
op_star
id|chip
op_assign
id|snd_pcm_substream_chip
c_func
(paren
id|subs
)paren
suffix:semicolon
id|vx_pipe_t
op_star
id|pipe
op_assign
id|subs-&gt;runtime-&gt;private_data
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;chip_status
op_amp
id|VX_STAT_IS_STALE
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SNDRV_PCM_TRIGGER_START
suffix:colon
r_case
id|SNDRV_PCM_TRIGGER_RESUME
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|pipe-&gt;is_capture
)paren
id|vx_pcm_playback_transfer
c_func
(paren
id|chip
comma
id|subs
comma
id|pipe
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* FIXME:&n;&t;&t; * we trigger the pipe using tasklet, so that the interrupts are&n;&t;&t; * issued surely after the trigger is completed.&n;&t;&t; */
id|tasklet_hi_schedule
c_func
(paren
op_amp
id|pipe-&gt;start_tq
)paren
suffix:semicolon
id|chip-&gt;pcm_running
op_increment
suffix:semicolon
id|pipe-&gt;running
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDRV_PCM_TRIGGER_STOP
suffix:colon
r_case
id|SNDRV_PCM_TRIGGER_SUSPEND
suffix:colon
id|vx_toggle_pipe
c_func
(paren
id|chip
comma
id|pipe
comma
l_int|0
)paren
suffix:semicolon
id|vx_stop_pipe
c_func
(paren
id|chip
comma
id|pipe
)paren
suffix:semicolon
id|vx_stop_stream
c_func
(paren
id|chip
comma
id|pipe
)paren
suffix:semicolon
id|chip-&gt;pcm_running
op_decrement
suffix:semicolon
id|pipe-&gt;running
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDRV_PCM_TRIGGER_PAUSE_PUSH
suffix:colon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|vx_toggle_pipe
c_func
(paren
id|chip
comma
id|pipe
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDRV_PCM_TRIGGER_PAUSE_RELEASE
suffix:colon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|vx_toggle_pipe
c_func
(paren
id|chip
comma
id|pipe
comma
l_int|1
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_pcm_playback_pointer - pointer callback for playback&n; */
DECL|function|vx_pcm_playback_pointer
r_static
id|snd_pcm_uframes_t
id|vx_pcm_playback_pointer
c_func
(paren
id|snd_pcm_substream_t
op_star
id|subs
)paren
(brace
id|snd_pcm_runtime_t
op_star
id|runtime
op_assign
id|subs-&gt;runtime
suffix:semicolon
id|vx_pipe_t
op_star
id|pipe
op_assign
id|runtime-&gt;private_data
suffix:semicolon
r_return
id|pipe-&gt;position
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_pcm_hw_params - hw_params callback for playback and capture&n; */
DECL|function|vx_pcm_hw_params
r_static
r_int
id|vx_pcm_hw_params
c_func
(paren
id|snd_pcm_substream_t
op_star
id|subs
comma
id|snd_pcm_hw_params_t
op_star
id|hw_params
)paren
(brace
r_return
id|snd_pcm_alloc_vmalloc_buffer
c_func
(paren
id|subs
comma
id|params_buffer_bytes
c_func
(paren
id|hw_params
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_pcm_hw_free - hw_free callback for playback and capture&n; */
DECL|function|vx_pcm_hw_free
r_static
r_int
id|vx_pcm_hw_free
c_func
(paren
id|snd_pcm_substream_t
op_star
id|subs
)paren
(brace
r_return
id|snd_pcm_free_vmalloc_buffer
c_func
(paren
id|subs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_pcm_prepare - prepare callback for playback and capture&n; */
DECL|function|vx_pcm_prepare
r_static
r_int
id|vx_pcm_prepare
c_func
(paren
id|snd_pcm_substream_t
op_star
id|subs
)paren
(brace
id|vx_core_t
op_star
id|chip
op_assign
id|snd_pcm_substream_chip
c_func
(paren
id|subs
)paren
suffix:semicolon
id|snd_pcm_runtime_t
op_star
id|runtime
op_assign
id|subs-&gt;runtime
suffix:semicolon
id|vx_pipe_t
op_star
id|pipe
op_assign
id|runtime-&gt;private_data
suffix:semicolon
r_int
id|err
comma
id|data_mode
suffix:semicolon
singleline_comment|// int max_size, nchunks;
r_if
c_cond
(paren
id|chip-&gt;chip_status
op_amp
id|VX_STAT_IS_STALE
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|data_mode
op_assign
(paren
id|chip-&gt;uer_bits
op_amp
id|IEC958_AES0_NONAUDIO
)paren
op_ne
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|data_mode
op_ne
id|pipe-&gt;data_mode
op_logical_and
op_logical_neg
id|pipe-&gt;is_capture
)paren
(brace
multiline_comment|/* IEC958 status (raw-mode) was changed */
multiline_comment|/* we reopen the pipe */
r_struct
id|vx_rmh
id|rmh
suffix:semicolon
id|snd_printdd
c_func
(paren
id|KERN_DEBUG
l_string|&quot;reopen the pipe with data_mode = %d&bslash;n&quot;
comma
id|data_mode
)paren
suffix:semicolon
id|vx_init_rmh
c_func
(paren
op_amp
id|rmh
comma
id|CMD_FREE_PIPE
)paren
suffix:semicolon
id|vx_set_pipe_cmd_params
c_func
(paren
op_amp
id|rmh
comma
l_int|0
comma
id|pipe-&gt;number
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|vx_send_msg
c_func
(paren
id|chip
comma
op_amp
id|rmh
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|vx_init_rmh
c_func
(paren
op_amp
id|rmh
comma
id|CMD_RES_PIPE
)paren
suffix:semicolon
id|vx_set_pipe_cmd_params
c_func
(paren
op_amp
id|rmh
comma
l_int|0
comma
id|pipe-&gt;number
comma
id|pipe-&gt;channels
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data_mode
)paren
id|rmh.Cmd
(braket
l_int|0
)braket
op_or_assign
id|BIT_DATA_MODE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|vx_send_msg
c_func
(paren
id|chip
comma
op_amp
id|rmh
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|pipe-&gt;data_mode
op_assign
id|data_mode
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chip-&gt;pcm_running
op_logical_and
id|chip-&gt;freq
op_ne
id|runtime-&gt;rate
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;vx: cannot set different clock %d from the current %d&bslash;n&quot;
comma
id|runtime-&gt;rate
comma
id|chip-&gt;freq
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|vx_set_clock
c_func
(paren
id|chip
comma
id|runtime-&gt;rate
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|vx_set_format
c_func
(paren
id|chip
comma
id|pipe
comma
id|runtime
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|vx_is_pcmcia
c_func
(paren
id|chip
)paren
)paren
(brace
id|pipe-&gt;align
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* 16bit word */
)brace
r_else
(brace
id|pipe-&gt;align
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* 32bit word */
)brace
id|pipe-&gt;buffer_bytes
op_assign
id|frames_to_bytes
c_func
(paren
id|runtime
comma
id|runtime-&gt;buffer_size
)paren
suffix:semicolon
id|pipe-&gt;period_bytes
op_assign
id|frames_to_bytes
c_func
(paren
id|runtime
comma
id|runtime-&gt;period_size
)paren
suffix:semicolon
id|pipe-&gt;hw_ptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set the timestamp */
id|vx_update_pipe_position
c_func
(paren
id|chip
comma
id|runtime
comma
id|pipe
)paren
suffix:semicolon
multiline_comment|/* clear again */
id|pipe-&gt;transferred
op_assign
l_int|0
suffix:semicolon
id|pipe-&gt;position
op_assign
l_int|0
suffix:semicolon
id|pipe-&gt;prepared
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * operators for PCM playback&n; */
DECL|variable|vx_pcm_playback_ops
r_static
id|snd_pcm_ops_t
id|vx_pcm_playback_ops
op_assign
(brace
dot
id|open
op_assign
id|vx_pcm_playback_open
comma
dot
id|close
op_assign
id|vx_pcm_playback_close
comma
dot
id|ioctl
op_assign
id|snd_pcm_lib_ioctl
comma
dot
id|hw_params
op_assign
id|vx_pcm_hw_params
comma
dot
id|hw_free
op_assign
id|vx_pcm_hw_free
comma
dot
id|prepare
op_assign
id|vx_pcm_prepare
comma
dot
id|trigger
op_assign
id|vx_pcm_trigger
comma
dot
id|pointer
op_assign
id|vx_pcm_playback_pointer
comma
dot
id|page
op_assign
id|snd_pcm_get_vmalloc_page
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * playback hw information&n; */
DECL|variable|vx_pcm_capture_hw
r_static
id|snd_pcm_hardware_t
id|vx_pcm_capture_hw
op_assign
(brace
dot
id|info
op_assign
(paren
id|SNDRV_PCM_INFO_MMAP
op_or
id|SNDRV_PCM_INFO_INTERLEAVED
op_or
id|SNDRV_PCM_INFO_PAUSE
op_or
id|SNDRV_PCM_INFO_MMAP_VALID
op_or
id|SNDRV_PCM_INFO_RESUME
)paren
comma
dot
id|formats
op_assign
multiline_comment|/*SNDRV_PCM_FMTBIT_U8 |*/
id|SNDRV_PCM_FMTBIT_S16_LE
op_or
id|SNDRV_PCM_FMTBIT_S24_3LE
comma
dot
id|rates
op_assign
id|SNDRV_PCM_RATE_CONTINUOUS
op_or
id|SNDRV_PCM_RATE_8000_48000
comma
dot
id|rate_min
op_assign
l_int|5000
comma
dot
id|rate_max
op_assign
l_int|48000
comma
dot
id|channels_min
op_assign
l_int|1
comma
dot
id|channels_max
op_assign
l_int|2
comma
dot
id|buffer_bytes_max
op_assign
(paren
l_int|128
op_star
l_int|1024
)paren
comma
dot
id|period_bytes_min
op_assign
l_int|126
comma
dot
id|period_bytes_max
op_assign
(paren
l_int|128
op_star
l_int|1024
)paren
comma
dot
id|periods_min
op_assign
l_int|2
comma
dot
id|periods_max
op_assign
id|VX_MAX_PERIODS
comma
dot
id|fifo_size
op_assign
l_int|126
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * vx_pcm_capture_open - open callback for capture&n; */
DECL|function|vx_pcm_capture_open
r_static
r_int
id|vx_pcm_capture_open
c_func
(paren
id|snd_pcm_substream_t
op_star
id|subs
)paren
(brace
id|snd_pcm_runtime_t
op_star
id|runtime
op_assign
id|subs-&gt;runtime
suffix:semicolon
id|vx_core_t
op_star
id|chip
op_assign
id|snd_pcm_substream_chip
c_func
(paren
id|subs
)paren
suffix:semicolon
id|vx_pipe_t
op_star
id|pipe
suffix:semicolon
id|vx_pipe_t
op_star
id|pipe_out_monitoring
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|audio
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;chip_status
op_amp
id|VX_STAT_IS_STALE
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|audio
op_assign
id|subs-&gt;pcm-&gt;device
op_star
l_int|2
suffix:semicolon
id|snd_assert
c_func
(paren
id|audio
OL
id|chip-&gt;audio_ins
comma
r_return
op_minus
id|EINVAL
)paren
suffix:semicolon
id|err
op_assign
id|vx_alloc_pipe
c_func
(paren
id|chip
comma
l_int|1
comma
id|audio
comma
l_int|2
comma
op_amp
id|pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|pipe-&gt;substream
op_assign
id|subs
suffix:semicolon
id|tasklet_init
c_func
(paren
op_amp
id|pipe-&gt;start_tq
comma
id|vx_pcm_delayed_start
comma
(paren
r_int
r_int
)paren
id|subs
)paren
suffix:semicolon
id|chip-&gt;capture_pipes
(braket
id|audio
)braket
op_assign
id|pipe
suffix:semicolon
multiline_comment|/* check if monitoring is needed */
r_if
c_cond
(paren
id|chip-&gt;audio_monitor_active
(braket
id|audio
)braket
)paren
(brace
id|pipe_out_monitoring
op_assign
id|chip-&gt;playback_pipes
(braket
id|audio
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pipe_out_monitoring
)paren
(brace
multiline_comment|/* allocate a pipe */
id|err
op_assign
id|vx_alloc_pipe
c_func
(paren
id|chip
comma
l_int|0
comma
id|audio
comma
l_int|2
comma
op_amp
id|pipe_out_monitoring
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|chip-&gt;playback_pipes
(braket
id|audio
)braket
op_assign
id|pipe_out_monitoring
suffix:semicolon
)brace
id|pipe_out_monitoring-&gt;references
op_increment
suffix:semicolon
multiline_comment|/* &n;&t;&t;   if an output pipe is available, it&squot;s audios still may need to be &n;&t;&t;   unmuted. hence we&squot;ll have to call a mixer entry point.&n;&t;&t;*/
id|vx_set_monitor_level
c_func
(paren
id|chip
comma
id|audio
comma
id|chip-&gt;audio_monitor
(braket
id|audio
)braket
comma
id|chip-&gt;audio_monitor_active
(braket
id|audio
)braket
)paren
suffix:semicolon
multiline_comment|/* assuming stereo */
id|vx_set_monitor_level
c_func
(paren
id|chip
comma
id|audio
op_plus
l_int|1
comma
id|chip-&gt;audio_monitor
(braket
id|audio
op_plus
l_int|1
)braket
comma
id|chip-&gt;audio_monitor_active
(braket
id|audio
op_plus
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|pipe-&gt;monitoring_pipe
op_assign
id|pipe_out_monitoring
suffix:semicolon
multiline_comment|/* default value NULL */
id|runtime-&gt;hw
op_assign
id|vx_pcm_capture_hw
suffix:semicolon
id|runtime-&gt;hw.period_bytes_min
op_assign
id|chip-&gt;ibl.size
suffix:semicolon
id|runtime-&gt;private_data
op_assign
id|pipe
suffix:semicolon
multiline_comment|/* align to 4 bytes (otherwise will be problematic when 24bit is used) */
id|snd_pcm_hw_constraint_step
c_func
(paren
id|runtime
comma
l_int|0
comma
id|SNDRV_PCM_HW_PARAM_BUFFER_BYTES
comma
l_int|4
)paren
suffix:semicolon
id|snd_pcm_hw_constraint_step
c_func
(paren
id|runtime
comma
l_int|0
comma
id|SNDRV_PCM_HW_PARAM_PERIOD_BYTES
comma
l_int|4
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_pcm_capture_close - close callback for capture&n; */
DECL|function|vx_pcm_capture_close
r_static
r_int
id|vx_pcm_capture_close
c_func
(paren
id|snd_pcm_substream_t
op_star
id|subs
)paren
(brace
id|vx_core_t
op_star
id|chip
op_assign
id|snd_pcm_substream_chip
c_func
(paren
id|subs
)paren
suffix:semicolon
id|vx_pipe_t
op_star
id|pipe
suffix:semicolon
id|vx_pipe_t
op_star
id|pipe_out_monitoring
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subs-&gt;runtime-&gt;private_data
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|pipe
op_assign
id|subs-&gt;runtime-&gt;private_data
suffix:semicolon
id|chip-&gt;capture_pipes
(braket
id|pipe-&gt;number
)braket
op_assign
l_int|NULL
suffix:semicolon
id|pipe_out_monitoring
op_assign
id|pipe-&gt;monitoring_pipe
suffix:semicolon
multiline_comment|/*&n;&t;  if an output pipe is attached to this input, &n;&t;  check if it needs to be released.&n;&t;*/
r_if
c_cond
(paren
id|pipe_out_monitoring
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|pipe_out_monitoring-&gt;references
op_eq
l_int|0
)paren
(brace
id|vx_free_pipe
c_func
(paren
id|chip
comma
id|pipe_out_monitoring
)paren
suffix:semicolon
id|chip-&gt;playback_pipes
(braket
id|pipe-&gt;number
)braket
op_assign
l_int|NULL
suffix:semicolon
id|pipe-&gt;monitoring_pipe
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|vx_free_pipe
c_func
(paren
id|chip
comma
id|pipe
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|DMA_READ_ALIGN
mdefine_line|#define DMA_READ_ALIGN&t;6&t;/* hardware alignment for read */
multiline_comment|/*&n; * vx_pcm_capture_update - update the capture buffer&n; */
DECL|function|vx_pcm_capture_update
r_static
r_void
id|vx_pcm_capture_update
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
id|snd_pcm_substream_t
op_star
id|subs
comma
id|vx_pipe_t
op_star
id|pipe
)paren
(brace
r_int
id|size
comma
id|space
comma
id|count
suffix:semicolon
id|snd_pcm_runtime_t
op_star
id|runtime
op_assign
id|subs-&gt;runtime
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pipe-&gt;prepared
op_logical_or
(paren
id|chip-&gt;chip_status
op_amp
id|VX_STAT_IS_STALE
)paren
)paren
r_return
suffix:semicolon
id|size
op_assign
id|runtime-&gt;buffer_size
op_minus
id|snd_pcm_capture_avail
c_func
(paren
id|runtime
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
r_return
suffix:semicolon
id|size
op_assign
id|frames_to_bytes
c_func
(paren
id|runtime
comma
id|size
)paren
suffix:semicolon
id|space
op_assign
id|vx_query_hbuffer_size
c_func
(paren
id|chip
comma
id|pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|space
OL
l_int|0
)paren
r_goto
id|_error
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|space
)paren
id|size
op_assign
id|space
suffix:semicolon
id|size
op_assign
(paren
id|size
op_div
l_int|3
)paren
op_star
l_int|3
suffix:semicolon
multiline_comment|/* align to 3 bytes */
r_if
c_cond
(paren
id|size
OL
id|DMA_READ_ALIGN
)paren
r_goto
id|_error
suffix:semicolon
multiline_comment|/* keep the last 6 bytes, they will be read after disconnection */
id|count
op_assign
id|size
op_minus
id|DMA_READ_ALIGN
suffix:semicolon
multiline_comment|/* read bytes until the current pointer reaches to the aligned position&n;&t; * for word-transfer&n;&t; */
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|pipe-&gt;hw_ptr
op_mod
id|pipe-&gt;align
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|vx_wait_for_rx_full
c_func
(paren
id|chip
)paren
OL
l_int|0
)paren
r_goto
id|_error
suffix:semicolon
id|vx_pcm_read_per_bytes
c_func
(paren
id|chip
comma
id|runtime
comma
id|pipe
)paren
suffix:semicolon
id|count
op_sub_assign
l_int|3
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
(brace
multiline_comment|/* ok, let&squot;s accelerate! */
r_int
id|align
op_assign
id|pipe-&gt;align
op_star
l_int|3
suffix:semicolon
id|space
op_assign
(paren
id|count
op_div
id|align
)paren
op_star
id|align
suffix:semicolon
id|vx_pseudo_dma_read
c_func
(paren
id|chip
comma
id|runtime
comma
id|pipe
comma
id|space
)paren
suffix:semicolon
id|count
op_sub_assign
id|space
suffix:semicolon
)brace
multiline_comment|/* read the rest of bytes */
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|vx_wait_for_rx_full
c_func
(paren
id|chip
)paren
OL
l_int|0
)paren
r_goto
id|_error
suffix:semicolon
id|vx_pcm_read_per_bytes
c_func
(paren
id|chip
comma
id|runtime
comma
id|pipe
)paren
suffix:semicolon
id|count
op_sub_assign
l_int|3
suffix:semicolon
)brace
multiline_comment|/* disconnect the host, SIZE_HBUF command always switches to the stream mode */
id|vx_send_rih_nolock
c_func
(paren
id|chip
comma
id|IRQ_CONNECT_STREAM_NEXT
)paren
suffix:semicolon
multiline_comment|/* read the last pending 6 bytes */
id|count
op_assign
id|DMA_READ_ALIGN
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|vx_pcm_read_per_bytes
c_func
(paren
id|chip
comma
id|runtime
comma
id|pipe
)paren
suffix:semicolon
id|count
op_sub_assign
l_int|3
suffix:semicolon
)brace
multiline_comment|/* update the position */
id|pipe-&gt;transferred
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|pipe-&gt;transferred
op_ge
id|pipe-&gt;period_bytes
)paren
(brace
id|pipe-&gt;transferred
op_mod_assign
id|pipe-&gt;period_bytes
suffix:semicolon
id|snd_pcm_period_elapsed
c_func
(paren
id|subs
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
id|_error
suffix:colon
multiline_comment|/* disconnect the host, SIZE_HBUF command always switches to the stream mode */
id|vx_send_rih_nolock
c_func
(paren
id|chip
comma
id|IRQ_CONNECT_STREAM_NEXT
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_pcm_capture_pointer - pointer callback for capture&n; */
DECL|function|vx_pcm_capture_pointer
r_static
id|snd_pcm_uframes_t
id|vx_pcm_capture_pointer
c_func
(paren
id|snd_pcm_substream_t
op_star
id|subs
)paren
(brace
id|snd_pcm_runtime_t
op_star
id|runtime
op_assign
id|subs-&gt;runtime
suffix:semicolon
id|vx_pipe_t
op_star
id|pipe
op_assign
id|runtime-&gt;private_data
suffix:semicolon
r_return
id|bytes_to_frames
c_func
(paren
id|runtime
comma
id|pipe-&gt;hw_ptr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * operators for PCM capture&n; */
DECL|variable|vx_pcm_capture_ops
r_static
id|snd_pcm_ops_t
id|vx_pcm_capture_ops
op_assign
(brace
dot
id|open
op_assign
id|vx_pcm_capture_open
comma
dot
id|close
op_assign
id|vx_pcm_capture_close
comma
dot
id|ioctl
op_assign
id|snd_pcm_lib_ioctl
comma
dot
id|hw_params
op_assign
id|vx_pcm_hw_params
comma
dot
id|hw_free
op_assign
id|vx_pcm_hw_free
comma
dot
id|prepare
op_assign
id|vx_pcm_prepare
comma
dot
id|trigger
op_assign
id|vx_pcm_trigger
comma
dot
id|pointer
op_assign
id|vx_pcm_capture_pointer
comma
dot
id|page
op_assign
id|snd_pcm_get_vmalloc_page
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * interrupt handler for pcm streams&n; */
DECL|function|vx_pcm_update_intr
r_void
id|vx_pcm_update_intr
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
r_int
r_int
id|events
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|vx_pipe_t
op_star
id|pipe
suffix:semicolon
DECL|macro|EVENT_MASK
mdefine_line|#define EVENT_MASK&t;(END_OF_BUFFER_EVENTS_PENDING|ASYNC_EVENTS_PENDING)
r_if
c_cond
(paren
id|events
op_amp
id|EVENT_MASK
)paren
(brace
id|vx_init_rmh
c_func
(paren
op_amp
id|chip-&gt;irq_rmh
comma
id|CMD_ASYNC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|events
op_amp
id|ASYNC_EVENTS_PENDING
)paren
id|chip-&gt;irq_rmh.Cmd
(braket
l_int|0
)braket
op_or_assign
l_int|0x00000001
suffix:semicolon
multiline_comment|/* SEL_ASYNC_EVENTS */
r_if
c_cond
(paren
id|events
op_amp
id|END_OF_BUFFER_EVENTS_PENDING
)paren
id|chip-&gt;irq_rmh.Cmd
(braket
l_int|0
)braket
op_or_assign
l_int|0x00000002
suffix:semicolon
multiline_comment|/* SEL_END_OF_BUF_EVENTS */
r_if
c_cond
(paren
id|vx_send_msg
c_func
(paren
id|chip
comma
op_amp
id|chip-&gt;irq_rmh
)paren
OL
l_int|0
)paren
(brace
id|snd_printdd
c_func
(paren
id|KERN_ERR
l_string|&quot;msg send error!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|i
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|chip-&gt;irq_rmh.LgStat
)paren
(brace
r_int
id|p
comma
id|buf
comma
id|capture
comma
id|eob
suffix:semicolon
id|p
op_assign
id|chip-&gt;irq_rmh.Stat
(braket
id|i
)braket
op_amp
id|MASK_FIRST_FIELD
suffix:semicolon
id|capture
op_assign
(paren
id|chip-&gt;irq_rmh.Stat
(braket
id|i
)braket
op_amp
l_int|0x400000
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|eob
op_assign
(paren
id|chip-&gt;irq_rmh.Stat
(braket
id|i
)braket
op_amp
l_int|0x800000
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|events
op_amp
id|ASYNC_EVENTS_PENDING
)paren
id|i
op_increment
suffix:semicolon
id|buf
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* force to transfer */
r_if
c_cond
(paren
id|events
op_amp
id|END_OF_BUFFER_EVENTS_PENDING
)paren
(brace
r_if
c_cond
(paren
id|eob
)paren
id|buf
op_assign
id|chip-&gt;irq_rmh.Stat
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|capture
)paren
r_continue
suffix:semicolon
id|snd_assert
c_func
(paren
id|p
op_ge
l_int|0
op_logical_and
(paren
r_int
r_int
)paren
id|p
OL
id|chip-&gt;audio_outs
comma
)paren
suffix:semicolon
id|pipe
op_assign
id|chip-&gt;playback_pipes
(braket
id|p
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pipe
op_logical_and
id|pipe-&gt;substream
)paren
(brace
id|vx_pcm_playback_update
c_func
(paren
id|chip
comma
id|pipe-&gt;substream
comma
id|pipe
)paren
suffix:semicolon
id|vx_pcm_playback_transfer
c_func
(paren
id|chip
comma
id|pipe-&gt;substream
comma
id|pipe
comma
id|buf
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* update the capture pcm pointers as frequently as possible */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|chip-&gt;audio_ins
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pipe
op_assign
id|chip-&gt;capture_pipes
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pipe
op_logical_and
id|pipe-&gt;substream
)paren
id|vx_pcm_capture_update
c_func
(paren
id|chip
comma
id|pipe-&gt;substream
comma
id|pipe
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * vx_init_audio_io - check the availabe audio i/o and allocate pipe arrays&n; */
DECL|function|vx_init_audio_io
r_static
r_int
id|vx_init_audio_io
c_func
(paren
id|vx_core_t
op_star
id|chip
)paren
(brace
r_struct
id|vx_rmh
id|rmh
suffix:semicolon
r_int
id|preferred
suffix:semicolon
id|vx_init_rmh
c_func
(paren
op_amp
id|rmh
comma
id|CMD_SUPPORTED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vx_send_msg
c_func
(paren
id|chip
comma
op_amp
id|rmh
)paren
OL
l_int|0
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;vx: cannot get the supported audio data&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|chip-&gt;audio_outs
op_assign
id|rmh.Stat
(braket
l_int|0
)braket
op_amp
id|MASK_FIRST_FIELD
suffix:semicolon
id|chip-&gt;audio_ins
op_assign
(paren
id|rmh.Stat
(braket
l_int|0
)braket
op_rshift
(paren
id|FIELD_SIZE
op_star
l_int|2
)paren
)paren
op_amp
id|MASK_FIRST_FIELD
suffix:semicolon
id|chip-&gt;audio_info
op_assign
id|rmh.Stat
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* allocate pipes */
id|chip-&gt;playback_pipes
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|vx_pipe_t
op_star
)paren
op_star
id|chip-&gt;audio_outs
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|chip-&gt;capture_pipes
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|vx_pipe_t
op_star
)paren
op_star
id|chip-&gt;audio_ins
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chip-&gt;playback_pipes
op_logical_or
op_logical_neg
id|chip-&gt;capture_pipes
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|chip-&gt;playback_pipes
comma
l_int|0
comma
r_sizeof
(paren
id|vx_pipe_t
op_star
)paren
op_star
id|chip-&gt;audio_outs
)paren
suffix:semicolon
id|memset
c_func
(paren
id|chip-&gt;capture_pipes
comma
l_int|0
comma
r_sizeof
(paren
id|vx_pipe_t
op_star
)paren
op_star
id|chip-&gt;audio_ins
)paren
suffix:semicolon
id|preferred
op_assign
id|chip-&gt;ibl.size
suffix:semicolon
id|chip-&gt;ibl.size
op_assign
l_int|0
suffix:semicolon
id|vx_set_ibl
c_func
(paren
id|chip
comma
op_amp
id|chip-&gt;ibl
)paren
suffix:semicolon
multiline_comment|/* query the info */
r_if
c_cond
(paren
id|preferred
OG
l_int|0
)paren
(brace
id|chip-&gt;ibl.size
op_assign
(paren
(paren
id|preferred
op_plus
id|chip-&gt;ibl.granularity
op_minus
l_int|1
)paren
op_div
id|chip-&gt;ibl.granularity
)paren
op_star
id|chip-&gt;ibl.granularity
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;ibl.size
OG
id|chip-&gt;ibl.max_size
)paren
id|chip-&gt;ibl.size
op_assign
id|chip-&gt;ibl.max_size
suffix:semicolon
)brace
r_else
id|chip-&gt;ibl.size
op_assign
id|chip-&gt;ibl.min_size
suffix:semicolon
multiline_comment|/* set to the minimum */
id|vx_set_ibl
c_func
(paren
id|chip
comma
op_amp
id|chip-&gt;ibl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * free callback for pcm&n; */
DECL|function|snd_vx_pcm_free
r_static
r_void
id|snd_vx_pcm_free
c_func
(paren
id|snd_pcm_t
op_star
id|pcm
)paren
(brace
id|vx_core_t
op_star
id|chip
op_assign
id|pcm-&gt;private_data
suffix:semicolon
id|chip-&gt;pcm
(braket
id|pcm-&gt;device
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;playback_pipes
)paren
(brace
id|kfree
c_func
(paren
id|chip-&gt;playback_pipes
)paren
suffix:semicolon
id|chip-&gt;playback_pipes
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chip-&gt;capture_pipes
)paren
(brace
id|kfree
c_func
(paren
id|chip-&gt;capture_pipes
)paren
suffix:semicolon
id|chip-&gt;capture_pipes
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * snd_vx_pcm_new - create and initialize a pcm&n; */
DECL|function|snd_vx_pcm_new
r_int
id|snd_vx_pcm_new
c_func
(paren
id|vx_core_t
op_star
id|chip
)paren
(brace
id|snd_pcm_t
op_star
id|pcm
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|vx_init_audio_io
c_func
(paren
id|chip
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|chip-&gt;hw-&gt;num_codecs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|outs
comma
id|ins
suffix:semicolon
id|outs
op_assign
id|chip-&gt;audio_outs
OG
id|i
op_star
l_int|2
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ins
op_assign
id|chip-&gt;audio_ins
OG
id|i
op_star
l_int|2
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|outs
op_logical_and
op_logical_neg
id|ins
)paren
r_break
suffix:semicolon
id|err
op_assign
id|snd_pcm_new
c_func
(paren
id|chip-&gt;card
comma
l_string|&quot;VX PCM&quot;
comma
id|i
comma
id|outs
comma
id|ins
comma
op_amp
id|pcm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|outs
)paren
id|snd_pcm_set_ops
c_func
(paren
id|pcm
comma
id|SNDRV_PCM_STREAM_PLAYBACK
comma
op_amp
id|vx_pcm_playback_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ins
)paren
id|snd_pcm_set_ops
c_func
(paren
id|pcm
comma
id|SNDRV_PCM_STREAM_CAPTURE
comma
op_amp
id|vx_pcm_capture_ops
)paren
suffix:semicolon
id|pcm-&gt;private_data
op_assign
id|chip
suffix:semicolon
id|pcm-&gt;private_free
op_assign
id|snd_vx_pcm_free
suffix:semicolon
id|pcm-&gt;info_flags
op_assign
l_int|0
suffix:semicolon
id|strcpy
c_func
(paren
id|pcm-&gt;name
comma
id|chip-&gt;card-&gt;shortname
)paren
suffix:semicolon
id|chip-&gt;pcm
(braket
id|i
)braket
op_assign
id|pcm
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
