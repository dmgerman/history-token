multiline_comment|/*&n; *  Driver for Philips UDA1341TS on Compaq iPAQ H3600 soundcard&n; *  Copyright (C) 2002 Tomas Kasparek &lt;tomas.kasparek@seznam.cz&gt;&n; *&n; *   This program is free software; you can redistribute it and/or modify&n; *   it under the terms of the GNU General Public License.&n; * &n; * History:&n; *&n; * 2002-03-13   Tomas Kasparek  initial release - based on h3600-uda1341.c from OSS&n; * 2002-03-20   Tomas Kasparek  playback over ALSA is working&n; * 2002-03-28   Tomas Kasparek  playback over OSS emulation is working&n; * 2002-03-29   Tomas Kasparek  basic capture is working (native ALSA)&n; * 2002-03-29   Tomas Kasparek  capture is working (OSS emulation)&n; * 2002-04-04   Tomas Kasparek  better rates handling (allow non-standard rates)&n; * 2003-02-14   Brian Avery     fixed full duplex mode, other updates&n; * 2003-02-20   Tomas Kasparek  merged updates by Brian (except HAL)&n; * 2003-04-19   Jaroslav Kysela recoded DMA stuff to follow 2.4.18rmk3-hh24 kernel&n; *                              working suspend and resume&n; * 2003-04-28   Tomas Kasparek  updated work by Jaroslav to compile it under 2.5.x again&n; *                              merged HAL layer (patches from Brian)&n; */
multiline_comment|/* $Id: sa11xx-uda1341.c,v 1.18 2004/07/20 15:54:09 cladisch Exp $ */
multiline_comment|/***************************************************************************************************&n;*&n;* To understand what Alsa Drivers should be doing look at &quot;Writing an Alsa Driver&quot; by Takashi Iwai&n;* available in the Alsa doc section on the website&t;&t;&n;* &n;* A few notes to make things clearer. The UDA1341 is hooked up to Serial port 4 on the SA1100.&n;* We are using  SSP mode to talk to the UDA1341. The UDA1341 bit &amp; wordselect clocks are generated&n;* by this UART. Unfortunately, the clock only runs if the transmit buffer has something in it.&n;* So, if we are just recording, we feed the transmit DMA stream a bunch of 0x0000 so that the&n;* transmit buffer is full and the clock keeps going. The zeroes come from FLUSH_BASE_PHYS which&n;* is a mem loc that always decodes to 0&squot;s w/ no off chip access.&n;*&n;* Some alsa terminology:&n;*&t;frame =&gt; num_channels * sample_size  e.g stereo 16 bit is 2 * 16 = 32 bytes&n;*&t;period =&gt; the least number of bytes that will generate an interrupt e.g. we have a 1024 byte&n;*             buffer and 4 periods in the runtime structure this means we&squot;ll get an int every 256&n;*             bytes or 4 times per buffer.&n;*             A number of the sizes are in frames rather than bytes, use frames_to_bytes and&n;*             bytes_to_frames to convert.  The easiest way to tell the units is to look at the&n;*             type i.e. runtime-&gt; buffer_size is in frames and its type is snd_pcm_uframes_t&n;*             &n;*&t;Notes about the pointer fxn:&n;*&t;The pointer fxn needs to return the offset into the dma buffer in frames.&n;*&t;Interrupts must be blocked before calling the dma_get_pos fxn to avoid race with interrupts.&n;*&n;*&t;Notes about pause/resume&n;*&t;Implementing this would be complicated so it&squot;s skipped.  The problem case is:&n;*&t;A full duplex connection is going, then play is paused. At this point you need to start xmitting&n;*&t;0&squot;s to keep the record active which means you cant just freeze the dma and resume it later you&squot;d&n;*&t;need to&t;save off the dma info, and restore it properly on a resume.  Yeach!&n;*&n;*&t;Notes about transfer methods:&n;*&t;The async write calls fail.  I probably need to implement something else to support them?&n;* &n;***************************************************************************************************/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;sound/driver.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#ifdef CONFIG_PM
macro_line|#include &lt;linux/pm.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/arch/h3600.h&gt;
macro_line|#include &lt;asm/mach-types.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#ifdef CONFIG_H3600_HAL
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/arch/h3600_hal.h&gt;
macro_line|#endif
macro_line|#include &lt;sound/core.h&gt;
macro_line|#include &lt;sound/pcm.h&gt;
macro_line|#include &lt;sound/initval.h&gt;
macro_line|#include &lt;linux/l3/l3.h&gt;
DECL|macro|DEBUG_MODE
macro_line|#undef DEBUG_MODE
DECL|macro|DEBUG_FUNCTION_NAMES
macro_line|#undef DEBUG_FUNCTION_NAMES
macro_line|#include &lt;sound/uda1341.h&gt;
multiline_comment|/*&n; * FIXME: Is this enough as autodetection of 2.4.X-rmkY-hhZ kernels?&n; * We use DMA stuff from 2.4.18-rmk3-hh24 here to be able to compile this&n; * module for Familiar 0.6.1&n; */
macro_line|#ifdef CONFIG_H3600_HAL
DECL|macro|HH_VERSION
mdefine_line|#define HH_VERSION 1
macro_line|#endif
multiline_comment|/* {{{ Type definitions */
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Tomas Kasparek &lt;tomas.kasparek@seznam.cz&gt;&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;SA1100/SA1111 + UDA1341TS driver for ALSA&quot;
)paren
suffix:semicolon
id|MODULE_SUPPORTED_DEVICE
c_func
(paren
l_string|&quot;{{UDA1341,iPAQ H3600 UDA1341TS}}&quot;
)paren
suffix:semicolon
DECL|variable|id
r_static
r_char
op_star
id|id
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* ID for this card */
id|module_param
c_func
(paren
id|id
comma
id|charp
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|id
comma
l_string|&quot;ID string for SA1100/SA1111 + UDA1341TS soundcard.&quot;
)paren
suffix:semicolon
DECL|struct|audio_stream
r_typedef
r_struct
id|audio_stream
(brace
DECL|member|id
r_char
op_star
id|id
suffix:semicolon
multiline_comment|/* identification string */
DECL|member|stream_id
r_int
id|stream_id
suffix:semicolon
multiline_comment|/* numeric identification */
DECL|member|dma_dev
id|dma_device_t
id|dma_dev
suffix:semicolon
multiline_comment|/* device identifier for DMA */
macro_line|#ifdef HH_VERSION
DECL|member|dmach
id|dmach_t
id|dmach
suffix:semicolon
multiline_comment|/* dma channel identification */
macro_line|#else
DECL|member|dma_regs
id|dma_regs_t
op_star
id|dma_regs
suffix:semicolon
multiline_comment|/* points to our DMA registers */
macro_line|#endif
DECL|member|active
r_int
id|active
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* we are using this stream for transfer now */
DECL|member|period
r_int
id|period
suffix:semicolon
multiline_comment|/* current transfer period */
DECL|member|periods
r_int
id|periods
suffix:semicolon
multiline_comment|/* current count of periods registerd in the DMA engine */
DECL|member|tx_spin
r_int
id|tx_spin
suffix:semicolon
multiline_comment|/* are we recoding - flag used to do DMA trans. for sync */
DECL|member|old_offset
r_int
r_int
id|old_offset
suffix:semicolon
DECL|member|dma_lock
id|spinlock_t
id|dma_lock
suffix:semicolon
multiline_comment|/* for locking in DMA operations (see dma-sa1100.c in the kernel) */
DECL|member|stream
id|snd_pcm_substream_t
op_star
id|stream
suffix:semicolon
DECL|typedef|audio_stream_t
)brace
id|audio_stream_t
suffix:semicolon
DECL|struct|snd_card_sa11xx_uda1341
r_typedef
r_struct
id|snd_card_sa11xx_uda1341
(brace
DECL|member|card
id|snd_card_t
op_star
id|card
suffix:semicolon
DECL|member|uda1341
r_struct
id|l3_client
op_star
id|uda1341
suffix:semicolon
DECL|member|pcm
id|snd_pcm_t
op_star
id|pcm
suffix:semicolon
DECL|member|samplerate
r_int
id|samplerate
suffix:semicolon
DECL|member|s
id|audio_stream_t
id|s
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* playback &amp; capture */
DECL|typedef|sa11xx_uda1341_t
)brace
id|sa11xx_uda1341_t
suffix:semicolon
DECL|variable|sa11xx_uda1341
r_static
r_struct
id|snd_card_sa11xx_uda1341
op_star
id|sa11xx_uda1341
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|rates
r_static
r_int
r_int
id|rates
(braket
)braket
op_assign
(brace
l_int|8000
comma
l_int|10666
comma
l_int|10985
comma
l_int|14647
comma
l_int|16000
comma
l_int|21970
comma
l_int|22050
comma
l_int|24000
comma
l_int|29400
comma
l_int|32000
comma
l_int|44100
comma
l_int|48000
comma
)brace
suffix:semicolon
DECL|variable|hw_constraints_rates
r_static
id|snd_pcm_hw_constraint_list_t
id|hw_constraints_rates
op_assign
(brace
dot
id|count
op_assign
id|ARRAY_SIZE
c_func
(paren
id|rates
)paren
comma
dot
id|list
op_assign
id|rates
comma
dot
id|mask
op_assign
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* }}} */
multiline_comment|/* {{{ Clock and sample rate stuff */
multiline_comment|/*&n; * Stop-gap solution until rest of hh.org HAL stuff is merged.&n; */
DECL|macro|GPIO_H3600_CLK_SET0
mdefine_line|#define GPIO_H3600_CLK_SET0&t;&t;GPIO_GPIO (12)
DECL|macro|GPIO_H3600_CLK_SET1
mdefine_line|#define GPIO_H3600_CLK_SET1&t;&t;GPIO_GPIO (13)
macro_line|#ifdef CONFIG_SA1100_H3XXX
DECL|macro|clr_sa11xx_uda1341_egpio
mdefine_line|#define&t;clr_sa11xx_uda1341_egpio(x)&t;clr_h3600_egpio(x)
DECL|macro|set_sa11xx_uda1341_egpio
mdefine_line|#define set_sa11xx_uda1341_egpio(x)&t;set_h3600_egpio(x)
macro_line|#else
macro_line|#error This driver could serve H3x00 handhelds only!
macro_line|#endif
DECL|function|sa11xx_uda1341_set_audio_clock
r_static
r_void
id|sa11xx_uda1341_set_audio_clock
c_func
(paren
r_int
id|val
)paren
(brace
r_switch
c_cond
(paren
id|val
)paren
(brace
r_case
l_int|24000
suffix:colon
r_case
l_int|32000
suffix:colon
r_case
l_int|48000
suffix:colon
multiline_comment|/* 00: 12.288 MHz */
id|GPCR
op_assign
id|GPIO_H3600_CLK_SET0
op_or
id|GPIO_H3600_CLK_SET1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|22050
suffix:colon
r_case
l_int|29400
suffix:colon
r_case
l_int|44100
suffix:colon
multiline_comment|/* 01: 11.2896 MHz */
id|GPSR
op_assign
id|GPIO_H3600_CLK_SET0
suffix:semicolon
id|GPCR
op_assign
id|GPIO_H3600_CLK_SET1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8000
suffix:colon
r_case
l_int|10666
suffix:colon
r_case
l_int|16000
suffix:colon
multiline_comment|/* 10: 4.096 MHz */
id|GPCR
op_assign
id|GPIO_H3600_CLK_SET0
suffix:semicolon
id|GPSR
op_assign
id|GPIO_H3600_CLK_SET1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10985
suffix:colon
r_case
l_int|14647
suffix:colon
r_case
l_int|21970
suffix:colon
multiline_comment|/* 11: 5.6245 MHz */
id|GPSR
op_assign
id|GPIO_H3600_CLK_SET0
op_or
id|GPIO_H3600_CLK_SET1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|sa11xx_uda1341_set_samplerate
r_static
r_void
id|sa11xx_uda1341_set_samplerate
c_func
(paren
id|sa11xx_uda1341_t
op_star
id|sa11xx_uda1341
comma
r_int
id|rate
)paren
(brace
r_int
id|clk_div
op_assign
l_int|0
suffix:semicolon
r_int
id|clk
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We don&squot;t want to mess with clocks when frames are in flight */
id|Ser4SSCR0
op_and_assign
op_complement
id|SSCR0_SSE
suffix:semicolon
multiline_comment|/* wait for any frame to complete */
id|udelay
c_func
(paren
l_int|125
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have the following clock sources:&n;&t; * 4.096 MHz, 5.6245 MHz, 11.2896 MHz, 12.288 MHz&n;&t; * Those can be divided either by 256, 384 or 512.&n;&t; * This makes up 12 combinations for the following samplerates...&n;&t; */
r_if
c_cond
(paren
id|rate
op_ge
l_int|48000
)paren
id|rate
op_assign
l_int|48000
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rate
op_ge
l_int|44100
)paren
id|rate
op_assign
l_int|44100
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rate
op_ge
l_int|32000
)paren
id|rate
op_assign
l_int|32000
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rate
op_ge
l_int|29400
)paren
id|rate
op_assign
l_int|29400
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rate
op_ge
l_int|24000
)paren
id|rate
op_assign
l_int|24000
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rate
op_ge
l_int|22050
)paren
id|rate
op_assign
l_int|22050
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rate
op_ge
l_int|21970
)paren
id|rate
op_assign
l_int|21970
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rate
op_ge
l_int|16000
)paren
id|rate
op_assign
l_int|16000
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rate
op_ge
l_int|14647
)paren
id|rate
op_assign
l_int|14647
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rate
op_ge
l_int|10985
)paren
id|rate
op_assign
l_int|10985
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rate
op_ge
l_int|10666
)paren
id|rate
op_assign
l_int|10666
suffix:semicolon
r_else
id|rate
op_assign
l_int|8000
suffix:semicolon
multiline_comment|/* Set the external clock generator */
macro_line|#ifdef CONFIG_H3600_HAL
id|h3600_audio_clock
c_func
(paren
id|rate
)paren
suffix:semicolon
macro_line|#else&t;
id|sa11xx_uda1341_set_audio_clock
c_func
(paren
id|rate
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Select the clock divisor */
r_switch
c_cond
(paren
id|rate
)paren
(brace
r_case
l_int|8000
suffix:colon
r_case
l_int|10985
suffix:colon
r_case
l_int|22050
suffix:colon
r_case
l_int|24000
suffix:colon
id|clk
op_assign
id|F512
suffix:semicolon
id|clk_div
op_assign
id|SSCR0_SerClkDiv
c_func
(paren
l_int|16
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|16000
suffix:colon
r_case
l_int|21970
suffix:colon
r_case
l_int|44100
suffix:colon
r_case
l_int|48000
suffix:colon
id|clk
op_assign
id|F256
suffix:semicolon
id|clk_div
op_assign
id|SSCR0_SerClkDiv
c_func
(paren
l_int|8
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10666
suffix:colon
r_case
l_int|14647
suffix:colon
r_case
l_int|29400
suffix:colon
r_case
l_int|32000
suffix:colon
id|clk
op_assign
id|F384
suffix:semicolon
id|clk_div
op_assign
id|SSCR0_SerClkDiv
c_func
(paren
l_int|12
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* FMT setting should be moved away when other FMTs are added (FIXME) */
id|l3_command
c_func
(paren
id|sa11xx_uda1341-&gt;uda1341
comma
id|CMD_FORMAT
comma
(paren
r_void
op_star
)paren
id|LSB16
)paren
suffix:semicolon
id|l3_command
c_func
(paren
id|sa11xx_uda1341-&gt;uda1341
comma
id|CMD_FS
comma
(paren
r_void
op_star
)paren
id|clk
)paren
suffix:semicolon
id|Ser4SSCR0
op_assign
(paren
id|Ser4SSCR0
op_amp
op_complement
l_int|0xff00
)paren
op_plus
id|clk_div
op_plus
id|SSCR0_SSE
suffix:semicolon
id|sa11xx_uda1341-&gt;samplerate
op_assign
id|rate
suffix:semicolon
)brace
multiline_comment|/* }}} */
multiline_comment|/* {{{ HW init and shutdown */
DECL|function|sa11xx_uda1341_audio_init
r_static
r_void
id|sa11xx_uda1341_audio_init
c_func
(paren
id|sa11xx_uda1341_t
op_star
id|sa11xx_uda1341
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Setup DMA stuff */
id|sa11xx_uda1341-&gt;s
(braket
id|SNDRV_PCM_STREAM_PLAYBACK
)braket
dot
id|id
op_assign
l_string|&quot;UDA1341 out&quot;
suffix:semicolon
id|sa11xx_uda1341-&gt;s
(braket
id|SNDRV_PCM_STREAM_PLAYBACK
)braket
dot
id|stream_id
op_assign
id|SNDRV_PCM_STREAM_PLAYBACK
suffix:semicolon
id|sa11xx_uda1341-&gt;s
(braket
id|SNDRV_PCM_STREAM_PLAYBACK
)braket
dot
id|dma_dev
op_assign
id|DMA_Ser4SSPWr
suffix:semicolon
id|sa11xx_uda1341-&gt;s
(braket
id|SNDRV_PCM_STREAM_CAPTURE
)braket
dot
id|id
op_assign
l_string|&quot;UDA1341 in&quot;
suffix:semicolon
id|sa11xx_uda1341-&gt;s
(braket
id|SNDRV_PCM_STREAM_CAPTURE
)braket
dot
id|stream_id
op_assign
id|SNDRV_PCM_STREAM_CAPTURE
suffix:semicolon
id|sa11xx_uda1341-&gt;s
(braket
id|SNDRV_PCM_STREAM_CAPTURE
)braket
dot
id|dma_dev
op_assign
id|DMA_Ser4SSPRd
suffix:semicolon
multiline_comment|/* Initialize the UDA1341 internal state */
multiline_comment|/* Setup the uarts */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|GAFR
op_or_assign
(paren
id|GPIO_SSP_CLK
)paren
suffix:semicolon
id|GPDR
op_and_assign
op_complement
(paren
id|GPIO_SSP_CLK
)paren
suffix:semicolon
id|Ser4SSCR0
op_assign
l_int|0
suffix:semicolon
id|Ser4SSCR0
op_assign
id|SSCR0_DataSize
c_func
(paren
l_int|16
)paren
op_plus
id|SSCR0_TI
op_plus
id|SSCR0_SerClkDiv
c_func
(paren
l_int|8
)paren
suffix:semicolon
id|Ser4SSCR1
op_assign
id|SSCR1_SClkIactL
op_plus
id|SSCR1_SClk1P
op_plus
id|SSCR1_ExtClk
suffix:semicolon
id|Ser4SSCR0
op_or_assign
id|SSCR0_SSE
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Enable the audio power */
macro_line|#ifdef CONFIG_H3600_HAL
id|h3600_audio_power
c_func
(paren
id|AUDIO_RATE_DEFAULT
)paren
suffix:semicolon
macro_line|#else
id|clr_sa11xx_uda1341_egpio
c_func
(paren
id|IPAQ_EGPIO_CODEC_NRESET
)paren
suffix:semicolon
id|set_sa11xx_uda1341_egpio
c_func
(paren
id|IPAQ_EGPIO_AUDIO_ON
)paren
suffix:semicolon
id|set_sa11xx_uda1341_egpio
c_func
(paren
id|IPAQ_EGPIO_QMUTE
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Wait for the UDA1341 to wake up */
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
singleline_comment|//FIXME - was removed by Perex - Why?
multiline_comment|/* Initialize the UDA1341 internal state */
id|l3_open
c_func
(paren
id|sa11xx_uda1341-&gt;uda1341
)paren
suffix:semicolon
multiline_comment|/* external clock configuration (after l3_open - regs must be initialized */
id|sa11xx_uda1341_set_samplerate
c_func
(paren
id|sa11xx_uda1341
comma
id|sa11xx_uda1341-&gt;samplerate
)paren
suffix:semicolon
multiline_comment|/* Wait for the UDA1341 to wake up */
id|set_sa11xx_uda1341_egpio
c_func
(paren
id|IPAQ_EGPIO_CODEC_NRESET
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* make the left and right channels unswapped (flip the WS latch) */
id|Ser4SSDR
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_H3600_HAL
id|h3600_audio_mute
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#else&t;
id|clr_sa11xx_uda1341_egpio
c_func
(paren
id|IPAQ_EGPIO_QMUTE
)paren
suffix:semicolon
macro_line|#endif     
)brace
DECL|function|sa11xx_uda1341_audio_shutdown
r_static
r_void
id|sa11xx_uda1341_audio_shutdown
c_func
(paren
id|sa11xx_uda1341_t
op_star
id|sa11xx_uda1341
)paren
(brace
multiline_comment|/* mute on */
macro_line|#ifdef CONFIG_H3600_HAL
id|h3600_audio_mute
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#else&t;
id|set_sa11xx_uda1341_egpio
c_func
(paren
id|IPAQ_EGPIO_QMUTE
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* disable the audio power and all signals leading to the audio chip */
id|l3_close
c_func
(paren
id|sa11xx_uda1341-&gt;uda1341
)paren
suffix:semicolon
id|Ser4SSCR0
op_assign
l_int|0
suffix:semicolon
id|clr_sa11xx_uda1341_egpio
c_func
(paren
id|IPAQ_EGPIO_CODEC_NRESET
)paren
suffix:semicolon
multiline_comment|/* power off and mute off */
multiline_comment|/* FIXME - is muting off necesary??? */
macro_line|#ifdef CONFIG_H3600_HAL
id|h3600_audio_power
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|h3600_audio_mute
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#else&t;
id|clr_sa11xx_uda1341_egpio
c_func
(paren
id|IPAQ_EGPIO_AUDIO_ON
)paren
suffix:semicolon
id|clr_sa11xx_uda1341_egpio
c_func
(paren
id|IPAQ_EGPIO_QMUTE
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
multiline_comment|/* }}} */
multiline_comment|/* {{{ DMA staff */
multiline_comment|/*&n; * these are the address and sizes used to fill the xmit buffer&n; * so we can get a clock in record only mode&n; */
DECL|macro|FORCE_CLOCK_ADDR
mdefine_line|#define FORCE_CLOCK_ADDR&t;&t;(dma_addr_t)FLUSH_BASE_PHYS
DECL|macro|FORCE_CLOCK_SIZE
mdefine_line|#define FORCE_CLOCK_SIZE&t;&t;4096 
singleline_comment|// was 2048
singleline_comment|// FIXME Why this value exactly - wrote comment
DECL|macro|DMA_BUF_SIZE
mdefine_line|#define DMA_BUF_SIZE&t;8176&t;/* &lt;= MAX_DMA_SIZE from asm/arch-sa1100/dma.h */
macro_line|#ifdef HH_VERSION
DECL|function|audio_dma_request
r_static
r_int
id|audio_dma_request
c_func
(paren
id|audio_stream_t
op_star
id|s
comma
r_void
(paren
op_star
id|callback
)paren
(paren
r_void
op_star
comma
r_int
)paren
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|sa1100_request_dma
c_func
(paren
op_amp
id|s-&gt;dmach
comma
id|s-&gt;id
comma
id|s-&gt;dma_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;unable to grab audio dma 0x%x&bslash;n&quot;
comma
id|s-&gt;dma_dev
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|sa1100_dma_set_callback
c_func
(paren
id|s-&gt;dmach
comma
id|callback
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|audio_dma_free
r_static
r_inline
r_void
id|audio_dma_free
c_func
(paren
id|audio_stream_t
op_star
id|s
)paren
(brace
id|sa1100_free_dma
c_func
(paren
id|s-&gt;dmach
)paren
suffix:semicolon
id|s-&gt;dmach
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#else
DECL|function|audio_dma_request
r_static
r_int
id|audio_dma_request
c_func
(paren
id|audio_stream_t
op_star
id|s
comma
r_void
(paren
op_star
id|callback
)paren
(paren
r_void
op_star
)paren
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|sa1100_request_dma
c_func
(paren
id|s-&gt;dma_dev
comma
id|s-&gt;id
comma
id|callback
comma
id|s
comma
op_amp
id|s-&gt;dma_regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;unable to grab audio dma 0x%x&bslash;n&quot;
comma
id|s-&gt;dma_dev
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|audio_dma_free
r_static
r_void
id|audio_dma_free
c_func
(paren
id|audio_stream_t
op_star
id|s
)paren
(brace
id|sa1100_free_dma
c_func
(paren
(paren
id|s
)paren
op_member_access_from_pointer
id|dma_regs
)paren
suffix:semicolon
(paren
id|s
)paren
op_member_access_from_pointer
id|dma_regs
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|audio_get_dma_pos
r_static
id|u_int
id|audio_get_dma_pos
c_func
(paren
id|audio_stream_t
op_star
id|s
)paren
(brace
id|snd_pcm_substream_t
op_star
id|substream
op_assign
id|s-&gt;stream
suffix:semicolon
id|snd_pcm_runtime_t
op_star
id|runtime
op_assign
id|substream-&gt;runtime
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|dma_addr_t
id|addr
suffix:semicolon
singleline_comment|// this must be called w/ interrupts locked out see dma-sa1100.c in the kernel
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;dma_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef HH_VERSION&t;
id|sa1100_dma_get_current
c_func
(paren
id|s-&gt;dmach
comma
l_int|NULL
comma
op_amp
id|addr
)paren
suffix:semicolon
macro_line|#else
id|addr
op_assign
id|sa1100_get_dma_pos
c_func
(paren
(paren
id|s
)paren
op_member_access_from_pointer
id|dma_regs
)paren
suffix:semicolon
macro_line|#endif
id|offset
op_assign
id|addr
op_minus
id|runtime-&gt;dma_addr
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;dma_lock
comma
id|flags
)paren
suffix:semicolon
id|offset
op_assign
id|bytes_to_frames
c_func
(paren
id|runtime
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|runtime-&gt;buffer_size
)paren
id|offset
op_assign
l_int|0
suffix:semicolon
r_return
id|offset
suffix:semicolon
)brace
multiline_comment|/*&n; * this stops the dma and clears the dma ptrs&n; */
DECL|function|audio_stop_dma
r_static
r_void
id|audio_stop_dma
c_func
(paren
id|audio_stream_t
op_star
id|s
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;dma_lock
comma
id|flags
)paren
suffix:semicolon
id|s-&gt;active
op_assign
l_int|0
suffix:semicolon
id|s-&gt;period
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* this stops the dma channel and clears the buffer ptrs */
macro_line|#ifdef HH_VERSION
id|sa1100_dma_flush_all
c_func
(paren
id|s-&gt;dmach
)paren
suffix:semicolon
macro_line|#else
id|sa1100_clear_dma
c_func
(paren
id|s-&gt;dma_regs
)paren
suffix:semicolon
macro_line|#endif
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;dma_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|audio_process_dma
r_static
r_void
id|audio_process_dma
c_func
(paren
id|audio_stream_t
op_star
id|s
)paren
(brace
id|snd_pcm_substream_t
op_star
id|substream
op_assign
id|s-&gt;stream
suffix:semicolon
id|snd_pcm_runtime_t
op_star
id|runtime
suffix:semicolon
r_int
r_int
id|dma_size
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* we are requested to process synchronization DMA transfer */
r_if
c_cond
(paren
id|s-&gt;tx_spin
)paren
(brace
id|snd_assert
c_func
(paren
id|s-&gt;stream_id
op_eq
id|SNDRV_PCM_STREAM_PLAYBACK
comma
r_return
)paren
suffix:semicolon
multiline_comment|/* fill the xmit dma buffers and return */
macro_line|#ifdef HH_VERSION
id|sa1100_dma_set_spin
c_func
(paren
id|s-&gt;dmach
comma
id|FORCE_CLOCK_ADDR
comma
id|FORCE_CLOCK_SIZE
)paren
suffix:semicolon
macro_line|#else
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|ret
op_assign
id|sa1100_start_dma
c_func
(paren
id|s-&gt;dma_regs
comma
id|FORCE_CLOCK_ADDR
comma
id|FORCE_CLOCK_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
suffix:semicolon
)brace
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/* must be set here - only valid for running streams, not for forced_clock dma fills  */
id|runtime
op_assign
id|substream-&gt;runtime
suffix:semicolon
r_while
c_loop
(paren
id|s-&gt;active
op_logical_and
id|s-&gt;periods
OL
id|runtime-&gt;periods
)paren
(brace
id|dma_size
op_assign
id|frames_to_bytes
c_func
(paren
id|runtime
comma
id|runtime-&gt;period_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;old_offset
)paren
(brace
multiline_comment|/* a little trick, we need resume from old position */
id|offset
op_assign
id|frames_to_bytes
c_func
(paren
id|runtime
comma
id|s-&gt;old_offset
op_minus
l_int|1
)paren
suffix:semicolon
id|s-&gt;old_offset
op_assign
l_int|0
suffix:semicolon
id|s-&gt;periods
op_assign
l_int|0
suffix:semicolon
id|s-&gt;period
op_assign
id|offset
op_div
id|dma_size
suffix:semicolon
id|offset
op_mod_assign
id|dma_size
suffix:semicolon
id|dma_size
op_assign
id|dma_size
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dma_size
)paren
r_continue
suffix:semicolon
multiline_comment|/* special case */
)brace
r_else
(brace
id|offset
op_assign
id|dma_size
op_star
id|s-&gt;period
suffix:semicolon
id|snd_assert
c_func
(paren
id|dma_size
op_le
id|DMA_BUF_SIZE
comma
)paren
suffix:semicolon
)brace
macro_line|#ifdef HH_VERSION
id|ret
op_assign
id|sa1100_dma_queue_buffer
c_func
(paren
id|s-&gt;dmach
comma
id|s
comma
id|runtime-&gt;dma_addr
op_plus
id|offset
comma
id|dma_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
suffix:semicolon
singleline_comment|//FIXME
macro_line|#else
id|ret
op_assign
id|sa1100_start_dma
c_func
(paren
(paren
id|s
)paren
op_member_access_from_pointer
id|dma_regs
comma
id|runtime-&gt;dma_addr
op_plus
id|offset
comma
id|dma_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;audio_process_dma: cannot queue DMA buffer (%i)&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|s-&gt;period
op_increment
suffix:semicolon
id|s-&gt;period
op_mod_assign
id|runtime-&gt;periods
suffix:semicolon
id|s-&gt;periods
op_increment
suffix:semicolon
)brace
)brace
macro_line|#ifdef HH_VERSION
DECL|function|audio_dma_callback
r_static
r_void
id|audio_dma_callback
c_func
(paren
r_void
op_star
id|data
comma
r_int
id|size
)paren
macro_line|#else
r_static
r_void
id|audio_dma_callback
c_func
(paren
r_void
op_star
id|data
)paren
macro_line|#endif
(brace
id|audio_stream_t
op_star
id|s
op_assign
id|data
suffix:semicolon
multiline_comment|/* &n;&t; * If we are getting a callback for an active stream then we inform&n;&t; * the PCM middle layer we&squot;ve finished a period&n;&t; */
r_if
c_cond
(paren
id|s-&gt;active
)paren
id|snd_pcm_period_elapsed
c_func
(paren
id|s-&gt;stream
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|s-&gt;dma_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;tx_spin
op_logical_and
id|s-&gt;periods
OG
l_int|0
)paren
id|s-&gt;periods
op_decrement
suffix:semicolon
id|audio_process_dma
c_func
(paren
id|s
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|s-&gt;dma_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* }}} */
multiline_comment|/* {{{ PCM setting */
multiline_comment|/* {{{ trigger &amp; timer */
DECL|function|snd_sa11xx_uda1341_trigger
r_static
r_int
id|snd_sa11xx_uda1341_trigger
c_func
(paren
id|snd_pcm_substream_t
op_star
id|substream
comma
r_int
id|cmd
)paren
(brace
id|sa11xx_uda1341_t
op_star
id|chip
op_assign
id|snd_pcm_substream_chip
c_func
(paren
id|substream
)paren
suffix:semicolon
r_int
id|stream_id
op_assign
id|substream-&gt;pstr-&gt;stream
suffix:semicolon
id|audio_stream_t
op_star
id|s
op_assign
op_amp
id|chip-&gt;s
(braket
id|stream_id
)braket
suffix:semicolon
id|audio_stream_t
op_star
id|s1
op_assign
op_amp
id|chip-&gt;s
(braket
id|stream_id
op_xor
l_int|1
)braket
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* note local interrupts are already disabled in the midlevel code */
id|spin_lock
c_func
(paren
op_amp
id|s-&gt;dma_lock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SNDRV_PCM_TRIGGER_START
suffix:colon
multiline_comment|/* now we need to make sure a record only stream has a clock */
r_if
c_cond
(paren
id|stream_id
op_eq
id|SNDRV_PCM_STREAM_CAPTURE
op_logical_and
op_logical_neg
id|s1-&gt;active
)paren
(brace
multiline_comment|/* we need to force fill the xmit DMA with zeros */
id|s1-&gt;tx_spin
op_assign
l_int|1
suffix:semicolon
id|audio_process_dma
c_func
(paren
id|s1
)paren
suffix:semicolon
)brace
multiline_comment|/* this case is when you were recording then you turn on a&n;&t;&t; * playback stream so we stop (also clears it) the dma first,&n;&t;&t; * clear the sync flag and then we let it turned on&n;&t;&t; */
r_else
(brace
id|s-&gt;tx_spin
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* requested stream startup */
id|s-&gt;active
op_assign
l_int|1
suffix:semicolon
id|audio_process_dma
c_func
(paren
id|s
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDRV_PCM_TRIGGER_STOP
suffix:colon
multiline_comment|/* requested stream shutdown */
id|audio_stop_dma
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * now we need to make sure a record only stream has a clock&n;&t;&t; * so if we&squot;re stopping a playback with an active capture&n;&t;&t; * we need to turn the 0 fill dma on for the xmit side&n;&t;&t; */
r_if
c_cond
(paren
id|stream_id
op_eq
id|SNDRV_PCM_STREAM_PLAYBACK
op_logical_and
id|s1-&gt;active
)paren
(brace
multiline_comment|/* we need to force fill the xmit DMA with zeros */
id|s-&gt;tx_spin
op_assign
l_int|1
suffix:semicolon
id|audio_process_dma
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * we killed a capture only stream, so we should also kill&n;&t;&t; * the zero fill transmit&n;&t;&t; */
r_else
(brace
r_if
c_cond
(paren
id|s1-&gt;tx_spin
)paren
(brace
id|s1-&gt;tx_spin
op_assign
l_int|0
suffix:semicolon
id|audio_stop_dma
c_func
(paren
id|s1
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|SNDRV_PCM_TRIGGER_SUSPEND
suffix:colon
id|s-&gt;active
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef HH_VERSION&t;&t;
id|sa1100_dma_stop
c_func
(paren
id|s-&gt;dmach
)paren
suffix:semicolon
macro_line|#else
singleline_comment|//FIXME - DMA API
macro_line|#endif&t;&t;
id|s-&gt;old_offset
op_assign
id|audio_get_dma_pos
c_func
(paren
id|s
)paren
op_plus
l_int|1
suffix:semicolon
macro_line|#ifdef HH_VERSION&t;&t;
id|sa1100_dma_flush_all
c_func
(paren
id|s-&gt;dmach
)paren
suffix:semicolon
macro_line|#else
singleline_comment|//FIXME - DMA API
macro_line|#endif&t;&t;
id|s-&gt;periods
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDRV_PCM_TRIGGER_RESUME
suffix:colon
id|s-&gt;active
op_assign
l_int|1
suffix:semicolon
id|s-&gt;tx_spin
op_assign
l_int|0
suffix:semicolon
id|audio_process_dma
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stream_id
op_eq
id|SNDRV_PCM_STREAM_CAPTURE
op_logical_and
op_logical_neg
id|s1-&gt;active
)paren
(brace
id|s1-&gt;tx_spin
op_assign
l_int|1
suffix:semicolon
id|audio_process_dma
c_func
(paren
id|s1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SNDRV_PCM_TRIGGER_PAUSE_PUSH
suffix:colon
macro_line|#ifdef HH_VERSION&t;&t;
id|sa1100_dma_stop
c_func
(paren
id|s-&gt;dmach
)paren
suffix:semicolon
macro_line|#else
singleline_comment|//FIXME - DMA API
macro_line|#endif
id|s-&gt;active
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|stream_id
op_eq
id|SNDRV_PCM_STREAM_PLAYBACK
)paren
(brace
r_if
c_cond
(paren
id|s1-&gt;active
)paren
(brace
id|s-&gt;tx_spin
op_assign
l_int|1
suffix:semicolon
id|s-&gt;old_offset
op_assign
id|audio_get_dma_pos
c_func
(paren
id|s
)paren
op_plus
l_int|1
suffix:semicolon
macro_line|#ifdef HH_VERSION&t;&t;&t;&t;
id|sa1100_dma_flush_all
c_func
(paren
id|s-&gt;dmach
)paren
suffix:semicolon
macro_line|#else
singleline_comment|//FIXME - DMA API
macro_line|#endif&t;&t;&t;&t;
id|audio_process_dma
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|s1-&gt;tx_spin
)paren
(brace
id|s1-&gt;tx_spin
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef HH_VERSION&t;&t;&t;&t;
id|sa1100_dma_flush_all
c_func
(paren
id|s1-&gt;dmach
)paren
suffix:semicolon
macro_line|#else
singleline_comment|//FIXME - DMA API
macro_line|#endif&t;&t;&t;&t;
)brace
)brace
r_break
suffix:semicolon
r_case
id|SNDRV_PCM_TRIGGER_PAUSE_RELEASE
suffix:colon
id|s-&gt;active
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;old_offset
)paren
(brace
id|s-&gt;tx_spin
op_assign
l_int|0
suffix:semicolon
id|audio_process_dma
c_func
(paren
id|s
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stream_id
op_eq
id|SNDRV_PCM_STREAM_CAPTURE
op_logical_and
op_logical_neg
id|s1-&gt;active
)paren
(brace
id|s1-&gt;tx_spin
op_assign
l_int|1
suffix:semicolon
id|audio_process_dma
c_func
(paren
id|s1
)paren
suffix:semicolon
)brace
macro_line|#ifdef HH_VERSION&t;&t;
id|sa1100_dma_resume
c_func
(paren
id|s-&gt;dmach
)paren
suffix:semicolon
macro_line|#else
singleline_comment|//FIXME - DMA API
macro_line|#endif
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|s-&gt;dma_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|snd_sa11xx_uda1341_prepare
r_static
r_int
id|snd_sa11xx_uda1341_prepare
c_func
(paren
id|snd_pcm_substream_t
op_star
id|substream
)paren
(brace
id|sa11xx_uda1341_t
op_star
id|chip
op_assign
id|snd_pcm_substream_chip
c_func
(paren
id|substream
)paren
suffix:semicolon
id|snd_pcm_runtime_t
op_star
id|runtime
op_assign
id|substream-&gt;runtime
suffix:semicolon
id|audio_stream_t
op_star
id|s
op_assign
op_amp
id|chip-&gt;s
(braket
id|substream-&gt;pstr-&gt;stream
)braket
suffix:semicolon
multiline_comment|/* set requested samplerate */
id|sa11xx_uda1341_set_samplerate
c_func
(paren
id|chip
comma
id|runtime-&gt;rate
)paren
suffix:semicolon
multiline_comment|/* set requestd format when available */
multiline_comment|/* set FMT here !!! FIXME */
id|s-&gt;period
op_assign
l_int|0
suffix:semicolon
id|s-&gt;periods
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|snd_sa11xx_uda1341_pointer
r_static
id|snd_pcm_uframes_t
id|snd_sa11xx_uda1341_pointer
c_func
(paren
id|snd_pcm_substream_t
op_star
id|substream
)paren
(brace
id|sa11xx_uda1341_t
op_star
id|chip
op_assign
id|snd_pcm_substream_chip
c_func
(paren
id|substream
)paren
suffix:semicolon
r_return
id|audio_get_dma_pos
c_func
(paren
op_amp
id|chip-&gt;s
(braket
id|substream-&gt;pstr-&gt;stream
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* }}} */
DECL|variable|snd_sa11xx_uda1341_capture
r_static
id|snd_pcm_hardware_t
id|snd_sa11xx_uda1341_capture
op_assign
(brace
dot
id|info
op_assign
(paren
id|SNDRV_PCM_INFO_INTERLEAVED
op_or
id|SNDRV_PCM_INFO_BLOCK_TRANSFER
op_or
id|SNDRV_PCM_INFO_MMAP
op_or
id|SNDRV_PCM_INFO_MMAP_VALID
op_or
id|SNDRV_PCM_INFO_PAUSE
op_or
id|SNDRV_PCM_INFO_RESUME
)paren
comma
dot
id|formats
op_assign
id|SNDRV_PCM_FMTBIT_S16_LE
comma
dot
id|rates
op_assign
(paren
id|SNDRV_PCM_RATE_8000
op_or
id|SNDRV_PCM_RATE_16000
op_or
"&bslash;"
id|SNDRV_PCM_RATE_22050
op_or
id|SNDRV_PCM_RATE_32000
op_or
"&bslash;"
id|SNDRV_PCM_RATE_44100
op_or
id|SNDRV_PCM_RATE_48000
op_or
"&bslash;"
id|SNDRV_PCM_RATE_KNOT
)paren
comma
dot
id|rate_min
op_assign
l_int|8000
comma
dot
id|rate_max
op_assign
l_int|48000
comma
dot
id|channels_min
op_assign
l_int|2
comma
dot
id|channels_max
op_assign
l_int|2
comma
dot
id|buffer_bytes_max
op_assign
l_int|64
op_star
l_int|1024
comma
dot
id|period_bytes_min
op_assign
l_int|64
comma
dot
id|period_bytes_max
op_assign
id|DMA_BUF_SIZE
comma
dot
id|periods_min
op_assign
l_int|2
comma
dot
id|periods_max
op_assign
l_int|255
comma
dot
id|fifo_size
op_assign
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|snd_sa11xx_uda1341_playback
r_static
id|snd_pcm_hardware_t
id|snd_sa11xx_uda1341_playback
op_assign
(brace
dot
id|info
op_assign
(paren
id|SNDRV_PCM_INFO_INTERLEAVED
op_or
id|SNDRV_PCM_INFO_BLOCK_TRANSFER
op_or
id|SNDRV_PCM_INFO_MMAP
op_or
id|SNDRV_PCM_INFO_MMAP_VALID
op_or
id|SNDRV_PCM_INFO_PAUSE
op_or
id|SNDRV_PCM_INFO_RESUME
)paren
comma
dot
id|formats
op_assign
id|SNDRV_PCM_FMTBIT_S16_LE
comma
dot
id|rates
op_assign
(paren
id|SNDRV_PCM_RATE_8000
op_or
id|SNDRV_PCM_RATE_16000
op_or
"&bslash;"
id|SNDRV_PCM_RATE_22050
op_or
id|SNDRV_PCM_RATE_32000
op_or
"&bslash;"
id|SNDRV_PCM_RATE_44100
op_or
id|SNDRV_PCM_RATE_48000
op_or
"&bslash;"
id|SNDRV_PCM_RATE_KNOT
)paren
comma
dot
id|rate_min
op_assign
l_int|8000
comma
dot
id|rate_max
op_assign
l_int|48000
comma
dot
id|channels_min
op_assign
l_int|2
comma
dot
id|channels_max
op_assign
l_int|2
comma
dot
id|buffer_bytes_max
op_assign
l_int|64
op_star
l_int|1024
comma
dot
id|period_bytes_min
op_assign
l_int|64
comma
dot
id|period_bytes_max
op_assign
id|DMA_BUF_SIZE
comma
dot
id|periods_min
op_assign
l_int|2
comma
dot
id|periods_max
op_assign
l_int|255
comma
dot
id|fifo_size
op_assign
l_int|0
comma
)brace
suffix:semicolon
DECL|function|snd_card_sa11xx_uda1341_open
r_static
r_int
id|snd_card_sa11xx_uda1341_open
c_func
(paren
id|snd_pcm_substream_t
op_star
id|substream
)paren
(brace
id|sa11xx_uda1341_t
op_star
id|chip
op_assign
id|snd_pcm_substream_chip
c_func
(paren
id|substream
)paren
suffix:semicolon
id|snd_pcm_runtime_t
op_star
id|runtime
op_assign
id|substream-&gt;runtime
suffix:semicolon
r_int
id|stream_id
op_assign
id|substream-&gt;pstr-&gt;stream
suffix:semicolon
r_int
id|err
suffix:semicolon
id|chip-&gt;s
(braket
id|stream_id
)braket
dot
id|stream
op_assign
id|substream
suffix:semicolon
r_if
c_cond
(paren
id|stream_id
op_eq
id|SNDRV_PCM_STREAM_PLAYBACK
)paren
id|runtime-&gt;hw
op_assign
id|snd_sa11xx_uda1341_playback
suffix:semicolon
r_else
id|runtime-&gt;hw
op_assign
id|snd_sa11xx_uda1341_capture
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_pcm_hw_constraint_integer
c_func
(paren
id|runtime
comma
id|SNDRV_PCM_HW_PARAM_PERIODS
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_pcm_hw_constraint_list
c_func
(paren
id|runtime
comma
l_int|0
comma
id|SNDRV_PCM_HW_PARAM_RATE
comma
op_amp
id|hw_constraints_rates
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|snd_card_sa11xx_uda1341_close
r_static
r_int
id|snd_card_sa11xx_uda1341_close
c_func
(paren
id|snd_pcm_substream_t
op_star
id|substream
)paren
(brace
id|sa11xx_uda1341_t
op_star
id|chip
op_assign
id|snd_pcm_substream_chip
c_func
(paren
id|substream
)paren
suffix:semicolon
id|chip-&gt;s
(braket
id|substream-&gt;pstr-&gt;stream
)braket
dot
id|stream
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* {{{ HW params &amp; free */
DECL|function|snd_sa11xx_uda1341_hw_params
r_static
r_int
id|snd_sa11xx_uda1341_hw_params
c_func
(paren
id|snd_pcm_substream_t
op_star
id|substream
comma
id|snd_pcm_hw_params_t
op_star
id|hw_params
)paren
(brace
r_return
id|snd_pcm_lib_malloc_pages
c_func
(paren
id|substream
comma
id|params_buffer_bytes
c_func
(paren
id|hw_params
)paren
)paren
suffix:semicolon
)brace
DECL|function|snd_sa11xx_uda1341_hw_free
r_static
r_int
id|snd_sa11xx_uda1341_hw_free
c_func
(paren
id|snd_pcm_substream_t
op_star
id|substream
)paren
(brace
r_return
id|snd_pcm_lib_free_pages
c_func
(paren
id|substream
)paren
suffix:semicolon
)brace
multiline_comment|/* }}} */
DECL|variable|snd_card_sa11xx_uda1341_playback_ops
r_static
id|snd_pcm_ops_t
id|snd_card_sa11xx_uda1341_playback_ops
op_assign
(brace
dot
id|open
op_assign
id|snd_card_sa11xx_uda1341_open
comma
dot
id|close
op_assign
id|snd_card_sa11xx_uda1341_close
comma
dot
id|ioctl
op_assign
id|snd_pcm_lib_ioctl
comma
dot
id|hw_params
op_assign
id|snd_sa11xx_uda1341_hw_params
comma
dot
id|hw_free
op_assign
id|snd_sa11xx_uda1341_hw_free
comma
dot
id|prepare
op_assign
id|snd_sa11xx_uda1341_prepare
comma
dot
id|trigger
op_assign
id|snd_sa11xx_uda1341_trigger
comma
dot
id|pointer
op_assign
id|snd_sa11xx_uda1341_pointer
comma
)brace
suffix:semicolon
DECL|variable|snd_card_sa11xx_uda1341_capture_ops
r_static
id|snd_pcm_ops_t
id|snd_card_sa11xx_uda1341_capture_ops
op_assign
(brace
dot
id|open
op_assign
id|snd_card_sa11xx_uda1341_open
comma
dot
id|close
op_assign
id|snd_card_sa11xx_uda1341_close
comma
dot
id|ioctl
op_assign
id|snd_pcm_lib_ioctl
comma
dot
id|hw_params
op_assign
id|snd_sa11xx_uda1341_hw_params
comma
dot
id|hw_free
op_assign
id|snd_sa11xx_uda1341_hw_free
comma
dot
id|prepare
op_assign
id|snd_sa11xx_uda1341_prepare
comma
dot
id|trigger
op_assign
id|snd_sa11xx_uda1341_trigger
comma
dot
id|pointer
op_assign
id|snd_sa11xx_uda1341_pointer
comma
)brace
suffix:semicolon
DECL|function|snd_card_sa11xx_uda1341_pcm
r_static
r_int
id|__init
id|snd_card_sa11xx_uda1341_pcm
c_func
(paren
id|sa11xx_uda1341_t
op_star
id|sa11xx_uda1341
comma
r_int
id|device
)paren
(brace
id|snd_pcm_t
op_star
id|pcm
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_pcm_new
c_func
(paren
id|sa11xx_uda1341-&gt;card
comma
l_string|&quot;UDA1341 PCM&quot;
comma
id|device
comma
l_int|1
comma
l_int|1
comma
op_amp
id|pcm
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/*&n;&t; * this sets up our initial buffers and sets the dma_type to isa.&n;&t; * isa works but I&squot;m not sure why (or if) it&squot;s the right choice&n;&t; * this may be too large, trying it for now&n;&t; */
id|snd_pcm_lib_preallocate_pages_for_all
c_func
(paren
id|pcm
comma
id|SNDRV_DMA_TYPE_ISA
comma
id|snd_pcm_dma_flags
c_func
(paren
l_int|0
)paren
comma
l_int|64
op_star
l_int|1024
comma
l_int|64
op_star
l_int|1024
)paren
suffix:semicolon
id|snd_pcm_set_ops
c_func
(paren
id|pcm
comma
id|SNDRV_PCM_STREAM_PLAYBACK
comma
op_amp
id|snd_card_sa11xx_uda1341_playback_ops
)paren
suffix:semicolon
id|snd_pcm_set_ops
c_func
(paren
id|pcm
comma
id|SNDRV_PCM_STREAM_CAPTURE
comma
op_amp
id|snd_card_sa11xx_uda1341_capture_ops
)paren
suffix:semicolon
id|pcm-&gt;private_data
op_assign
id|sa11xx_uda1341
suffix:semicolon
id|pcm-&gt;info_flags
op_assign
l_int|0
suffix:semicolon
id|strcpy
c_func
(paren
id|pcm-&gt;name
comma
l_string|&quot;UDA1341 PCM&quot;
)paren
suffix:semicolon
id|sa11xx_uda1341_audio_init
c_func
(paren
id|sa11xx_uda1341
)paren
suffix:semicolon
multiline_comment|/* setup DMA controller */
id|audio_dma_request
c_func
(paren
op_amp
id|sa11xx_uda1341-&gt;s
(braket
id|SNDRV_PCM_STREAM_PLAYBACK
)braket
comma
id|audio_dma_callback
)paren
suffix:semicolon
id|audio_dma_request
c_func
(paren
op_amp
id|sa11xx_uda1341-&gt;s
(braket
id|SNDRV_PCM_STREAM_CAPTURE
)braket
comma
id|audio_dma_callback
)paren
suffix:semicolon
id|sa11xx_uda1341-&gt;pcm
op_assign
id|pcm
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* }}} */
multiline_comment|/* {{{ module init &amp; exit */
macro_line|#ifdef CONFIG_PM
DECL|function|snd_sa11xx_uda1341_suspend
r_static
r_int
id|snd_sa11xx_uda1341_suspend
c_func
(paren
id|snd_card_t
op_star
id|card
comma
r_int
r_int
id|state
)paren
(brace
id|sa11xx_uda1341_t
op_star
id|chip
op_assign
id|card-&gt;pm_private_data
suffix:semicolon
id|snd_pcm_suspend_all
c_func
(paren
id|chip-&gt;pcm
)paren
suffix:semicolon
macro_line|#ifdef HH_VERSION&t;
id|sa1100_dma_sleep
c_func
(paren
id|chip-&gt;s
(braket
id|SNDRV_PCM_STREAM_PLAYBACK
)braket
dot
id|dmach
)paren
suffix:semicolon
id|sa1100_dma_sleep
c_func
(paren
id|chip-&gt;s
(braket
id|SNDRV_PCM_STREAM_CAPTURE
)braket
dot
id|dmach
)paren
suffix:semicolon
macro_line|#else
singleline_comment|//FIXME
macro_line|#endif
id|l3_command
c_func
(paren
id|chip-&gt;uda1341
comma
id|CMD_SUSPEND
comma
l_int|NULL
)paren
suffix:semicolon
id|sa11xx_uda1341_audio_shutdown
c_func
(paren
id|chip
)paren
suffix:semicolon
id|snd_power_change_state
c_func
(paren
id|card
comma
id|SNDRV_CTL_POWER_D3hot
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|snd_sa11xx_uda1341_resume
r_static
r_int
id|snd_sa11xx_uda1341_resume
c_func
(paren
id|snd_card_t
op_star
id|card
comma
r_int
r_int
id|state
)paren
(brace
id|sa11xx_uda1341_t
op_star
id|chip
op_assign
id|card-&gt;pm_private_data
suffix:semicolon
id|sa11xx_uda1341_audio_init
c_func
(paren
id|chip
)paren
suffix:semicolon
id|l3_command
c_func
(paren
id|chip-&gt;uda1341
comma
id|CMD_RESUME
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef HH_VERSION&t;
id|sa1100_dma_wakeup
c_func
(paren
id|chip-&gt;s
(braket
id|SNDRV_PCM_STREAM_PLAYBACK
)braket
dot
id|dmach
)paren
suffix:semicolon
id|sa1100_dma_wakeup
c_func
(paren
id|chip-&gt;s
(braket
id|SNDRV_PCM_STREAM_CAPTURE
)braket
dot
id|dmach
)paren
suffix:semicolon
macro_line|#else
singleline_comment|//FIXME
macro_line|#endif
id|snd_power_change_state
c_func
(paren
id|card
comma
id|SNDRV_CTL_POWER_D0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* COMFIG_PM */
DECL|function|snd_sa11xx_uda1341_free
r_void
id|snd_sa11xx_uda1341_free
c_func
(paren
id|snd_card_t
op_star
id|card
)paren
(brace
id|sa11xx_uda1341_t
op_star
id|chip
op_assign
id|card-&gt;private_data
suffix:semicolon
id|audio_dma_free
c_func
(paren
op_amp
id|chip-&gt;s
(braket
id|SNDRV_PCM_STREAM_PLAYBACK
)braket
)paren
suffix:semicolon
id|audio_dma_free
c_func
(paren
op_amp
id|chip-&gt;s
(braket
id|SNDRV_PCM_STREAM_CAPTURE
)braket
)paren
suffix:semicolon
id|sa11xx_uda1341
op_assign
l_int|NULL
suffix:semicolon
id|card-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|chip
)paren
suffix:semicolon
)brace
DECL|function|sa11xx_uda1341_init
r_static
r_int
id|__init
id|sa11xx_uda1341_init
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
id|snd_card_t
op_star
id|card
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|machine_is_h3xxx
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* register the soundcard */
id|card
op_assign
id|snd_card_new
c_func
(paren
op_minus
l_int|1
comma
id|id
comma
id|THIS_MODULE
comma
r_sizeof
(paren
id|sa11xx_uda1341_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|sa11xx_uda1341
op_assign
id|kcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|sa11xx_uda1341
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sa11xx_uda1341
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|chip-&gt;s
(braket
l_int|0
)braket
dot
id|dma_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|chip-&gt;s
(braket
l_int|1
)braket
dot
id|dma_lock
)paren
suffix:semicolon
id|card-&gt;private_data
op_assign
(paren
r_void
op_star
)paren
id|sa11xx_uda1341
suffix:semicolon
id|card-&gt;private_free
op_assign
id|snd_sa11xx_uda1341_free
suffix:semicolon
id|sa11xx_uda1341-&gt;card
op_assign
id|card
suffix:semicolon
id|sa11xx_uda1341-&gt;samplerate
op_assign
id|AUDIO_RATE_DEFAULT
suffix:semicolon
singleline_comment|// mixer
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_chip_uda1341_mixer_new
c_func
(paren
id|sa11xx_uda1341-&gt;card
comma
op_amp
id|sa11xx_uda1341-&gt;uda1341
)paren
)paren
)paren
r_goto
id|nodev
suffix:semicolon
singleline_comment|// PCM
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_card_sa11xx_uda1341_pcm
c_func
(paren
id|sa11xx_uda1341
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
r_goto
id|nodev
suffix:semicolon
id|snd_card_set_dev_pm_callback
c_func
(paren
id|card
comma
id|PM_SYS_DEV
comma
id|snd_sa11xx_uda1341_suspend
comma
id|snd_sa11_uda1341_resume
comma
id|sa11xx_uda1341
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|card-&gt;driver
comma
l_string|&quot;UDA1341&quot;
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|card-&gt;shortname
comma
l_string|&quot;H3600 UDA1341TS&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|card-&gt;longname
comma
l_string|&quot;Compaq iPAQ H3600 with Philips UDA1341TS&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_card_register
c_func
(paren
id|card
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;iPAQ audio support initialized&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|nodev
suffix:colon
id|snd_card_free
c_func
(paren
id|card
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sa11xx_uda1341_exit
r_static
r_void
id|__exit
id|sa11xx_uda1341_exit
c_func
(paren
r_void
)paren
(brace
id|snd_card_free
c_func
(paren
id|sa11xx_uda1341-&gt;card
)paren
suffix:semicolon
)brace
DECL|variable|sa11xx_uda1341_init
id|module_init
c_func
(paren
id|sa11xx_uda1341_init
)paren
suffix:semicolon
DECL|variable|sa11xx_uda1341_exit
id|module_exit
c_func
(paren
id|sa11xx_uda1341_exit
)paren
suffix:semicolon
multiline_comment|/* }}} */
multiline_comment|/*&n; * Local variables:&n; * indent-tabs-mode: t&n; * End:&n; */
eof
