multiline_comment|/*&n; *   (Tentative) USB Audio Driver for ALSA&n; *&n; *   Main and PCM part&n; *&n; *   Copyright (c) 2002 by Takashi Iwai &lt;tiwai@suse.de&gt;&n; *&n; *   Many codes borrowed from audio.c by&n; *&t;    Alan Cox (alan@lxorguk.ukuu.org.uk)&n; *&t;    Thomas Sailer (sailer@ife.ee.ethz.ch)&n; *&n; *&n; *   This program is free software; you can redistribute it and/or modify&n; *   it under the terms of the GNU General Public License as published by&n; *   the Free Software Foundation; either version 2 of the License, or&n; *   (at your option) any later version.&n; *&n; *   This program is distributed in the hope that it will be useful,&n; *   but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *   GNU General Public License for more details.&n; *&n; *   You should have received a copy of the GNU General Public License&n; *   along with this program; if not, write to the Free Software&n; *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA&n; *&n; *&n; *  NOTES:&n; *&n; *   - async unlink should be used for avoiding the sleep inside lock.&n; *     2.4.22 usb-uhci seems buggy for async unlinking and results in&n; *     oops.  in such a cse, pass async_unlink=0 option.&n; *   - the linked URBs would be preferred but not used so far because of&n; *     the instability of unlinking.&n; *   - type II is not supported properly.  there is no device which supports&n; *     this type *correctly*.  SB extigy looks as if it supports, but it&squot;s&n; *     indeed an AC3 stream packed in SPDIF frames (i.e. no real AC3 stream).&n; */
macro_line|#include &lt;sound/driver.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;sound/core.h&gt;
macro_line|#include &lt;sound/info.h&gt;
macro_line|#include &lt;sound/pcm.h&gt;
macro_line|#include &lt;sound/pcm_params.h&gt;
macro_line|#include &lt;sound/initval.h&gt;
macro_line|#include &quot;usbaudio.h&quot;
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Takashi Iwai &lt;tiwai@suse.de&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;USB Audio&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_SUPPORTED_DEVICE
c_func
(paren
l_string|&quot;{{Generic,USB Audio}}&quot;
)paren
suffix:semicolon
DECL|variable|index
r_static
r_int
id|index
(braket
id|SNDRV_CARDS
)braket
op_assign
id|SNDRV_DEFAULT_IDX
suffix:semicolon
multiline_comment|/* Index 0-MAX */
DECL|variable|id
r_static
r_char
op_star
id|id
(braket
id|SNDRV_CARDS
)braket
op_assign
id|SNDRV_DEFAULT_STR
suffix:semicolon
multiline_comment|/* ID for this card */
DECL|variable|enable
r_static
r_int
id|enable
(braket
id|SNDRV_CARDS
)braket
op_assign
id|SNDRV_DEFAULT_ENABLE_PNP
suffix:semicolon
multiline_comment|/* Enable this card */
DECL|variable|vid
r_static
r_int
id|vid
(braket
id|SNDRV_CARDS
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
(paren
id|SNDRV_CARDS
op_minus
l_int|1
)paren
)braket
op_assign
op_minus
l_int|1
)brace
suffix:semicolon
multiline_comment|/* Vendor ID for this card */
DECL|variable|pid
r_static
r_int
id|pid
(braket
id|SNDRV_CARDS
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
(paren
id|SNDRV_CARDS
op_minus
l_int|1
)paren
)braket
op_assign
op_minus
l_int|1
)brace
suffix:semicolon
multiline_comment|/* Product ID for this card */
DECL|variable|nrpacks
r_static
r_int
id|nrpacks
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* max. number of packets per urb */
DECL|variable|async_unlink
r_static
r_int
id|async_unlink
op_assign
l_int|1
suffix:semicolon
id|module_param_array
c_func
(paren
id|index
comma
r_int
comma
l_int|NULL
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|index
comma
l_string|&quot;Index value for the USB audio adapter.&quot;
)paren
suffix:semicolon
id|module_param_array
c_func
(paren
id|id
comma
id|charp
comma
l_int|NULL
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|id
comma
l_string|&quot;ID string for the USB audio adapter.&quot;
)paren
suffix:semicolon
id|module_param_array
c_func
(paren
id|enable
comma
r_bool
comma
l_int|NULL
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|enable
comma
l_string|&quot;Enable USB audio adapter.&quot;
)paren
suffix:semicolon
id|module_param_array
c_func
(paren
id|vid
comma
r_int
comma
l_int|NULL
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|vid
comma
l_string|&quot;Vendor ID for the USB audio device.&quot;
)paren
suffix:semicolon
id|module_param_array
c_func
(paren
id|pid
comma
r_int
comma
l_int|NULL
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|pid
comma
l_string|&quot;Product ID for the USB audio device.&quot;
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|nrpacks
comma
r_int
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|nrpacks
comma
l_string|&quot;Max. number of packets per URB.&quot;
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|async_unlink
comma
r_bool
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|async_unlink
comma
l_string|&quot;Use async unlink mode.&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * debug the h/w constraints&n; */
multiline_comment|/* #define HW_CONST_DEBUG */
multiline_comment|/*&n; *&n; */
DECL|macro|MAX_PACKS
mdefine_line|#define MAX_PACKS&t;10
DECL|macro|MAX_PACKS_HS
mdefine_line|#define MAX_PACKS_HS&t;(MAX_PACKS * 8)&t;/* in high speed mode */
DECL|macro|MAX_URBS
mdefine_line|#define MAX_URBS&t;5&t;/* max. 20ms long packets */
DECL|macro|SYNC_URBS
mdefine_line|#define SYNC_URBS&t;2&t;/* always two urbs for sync */
DECL|macro|MIN_PACKS_URB
mdefine_line|#define MIN_PACKS_URB&t;1&t;/* minimum 1 packet per urb */
DECL|typedef|snd_usb_substream_t
r_typedef
r_struct
id|snd_usb_substream
id|snd_usb_substream_t
suffix:semicolon
DECL|typedef|snd_usb_stream_t
r_typedef
r_struct
id|snd_usb_stream
id|snd_usb_stream_t
suffix:semicolon
DECL|typedef|snd_urb_ctx_t
r_typedef
r_struct
id|snd_urb_ctx
id|snd_urb_ctx_t
suffix:semicolon
DECL|struct|audioformat
r_struct
id|audioformat
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|format
id|snd_pcm_format_t
id|format
suffix:semicolon
multiline_comment|/* format type */
DECL|member|channels
r_int
r_int
id|channels
suffix:semicolon
multiline_comment|/* # channels */
DECL|member|fmt_type
r_int
r_int
id|fmt_type
suffix:semicolon
multiline_comment|/* USB audio format type (1-3) */
DECL|member|frame_size
r_int
r_int
id|frame_size
suffix:semicolon
multiline_comment|/* samples per frame for non-audio */
DECL|member|iface
r_int
id|iface
suffix:semicolon
multiline_comment|/* interface number */
DECL|member|altsetting
r_int
r_char
id|altsetting
suffix:semicolon
multiline_comment|/* corresponding alternate setting */
DECL|member|altset_idx
r_int
r_char
id|altset_idx
suffix:semicolon
multiline_comment|/* array index of altenate setting */
DECL|member|attributes
r_int
r_char
id|attributes
suffix:semicolon
multiline_comment|/* corresponding attributes of cs endpoint */
DECL|member|endpoint
r_int
r_char
id|endpoint
suffix:semicolon
multiline_comment|/* endpoint */
DECL|member|ep_attr
r_int
r_char
id|ep_attr
suffix:semicolon
multiline_comment|/* endpoint attributes */
DECL|member|maxpacksize
r_int
r_int
id|maxpacksize
suffix:semicolon
multiline_comment|/* max. packet size */
DECL|member|rates
r_int
r_int
id|rates
suffix:semicolon
multiline_comment|/* rate bitmasks */
DECL|member|rate_min
DECL|member|rate_max
r_int
r_int
id|rate_min
comma
id|rate_max
suffix:semicolon
multiline_comment|/* min/max rates */
DECL|member|nr_rates
r_int
r_int
id|nr_rates
suffix:semicolon
multiline_comment|/* number of rate table entries */
DECL|member|rate_table
r_int
r_int
op_star
id|rate_table
suffix:semicolon
multiline_comment|/* rate table */
)brace
suffix:semicolon
DECL|struct|snd_urb_ctx
r_struct
id|snd_urb_ctx
(brace
DECL|member|urb
r_struct
id|urb
op_star
id|urb
suffix:semicolon
DECL|member|subs
id|snd_usb_substream_t
op_star
id|subs
suffix:semicolon
DECL|member|index
r_int
id|index
suffix:semicolon
multiline_comment|/* index for urb array */
DECL|member|packets
r_int
id|packets
suffix:semicolon
multiline_comment|/* number of packets per urb */
DECL|member|transfer
r_int
id|transfer
suffix:semicolon
multiline_comment|/* transferred size */
DECL|member|buf
r_char
op_star
id|buf
suffix:semicolon
multiline_comment|/* buffer for capture */
)brace
suffix:semicolon
DECL|struct|snd_urb_ops
r_struct
id|snd_urb_ops
(brace
DECL|member|prepare
r_int
(paren
op_star
id|prepare
)paren
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
id|snd_pcm_runtime_t
op_star
id|runtime
comma
r_struct
id|urb
op_star
id|u
)paren
suffix:semicolon
DECL|member|retire
r_int
(paren
op_star
id|retire
)paren
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
id|snd_pcm_runtime_t
op_star
id|runtime
comma
r_struct
id|urb
op_star
id|u
)paren
suffix:semicolon
DECL|member|prepare_sync
r_int
(paren
op_star
id|prepare_sync
)paren
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
id|snd_pcm_runtime_t
op_star
id|runtime
comma
r_struct
id|urb
op_star
id|u
)paren
suffix:semicolon
DECL|member|retire_sync
r_int
(paren
op_star
id|retire_sync
)paren
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
id|snd_pcm_runtime_t
op_star
id|runtime
comma
r_struct
id|urb
op_star
id|u
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|snd_usb_substream
r_struct
id|snd_usb_substream
(brace
DECL|member|stream
id|snd_usb_stream_t
op_star
id|stream
suffix:semicolon
DECL|member|dev
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
DECL|member|pcm_substream
id|snd_pcm_substream_t
op_star
id|pcm_substream
suffix:semicolon
DECL|member|direction
r_int
id|direction
suffix:semicolon
multiline_comment|/* playback or capture */
DECL|member|interface
r_int
id|interface
suffix:semicolon
multiline_comment|/* current interface */
DECL|member|endpoint
r_int
id|endpoint
suffix:semicolon
multiline_comment|/* assigned endpoint */
DECL|member|cur_audiofmt
r_struct
id|audioformat
op_star
id|cur_audiofmt
suffix:semicolon
multiline_comment|/* current audioformat pointer (for hw_params callback) */
DECL|member|cur_rate
r_int
r_int
id|cur_rate
suffix:semicolon
multiline_comment|/* current rate (for hw_params callback) */
DECL|member|period_bytes
r_int
r_int
id|period_bytes
suffix:semicolon
multiline_comment|/* current period bytes (for hw_params callback) */
DECL|member|format
r_int
r_int
id|format
suffix:semicolon
multiline_comment|/* USB data format */
DECL|member|datapipe
r_int
r_int
id|datapipe
suffix:semicolon
multiline_comment|/* the data i/o pipe */
DECL|member|syncpipe
r_int
r_int
id|syncpipe
suffix:semicolon
multiline_comment|/* 1 - async out or adaptive in */
DECL|member|syncinterval
r_int
r_int
id|syncinterval
suffix:semicolon
multiline_comment|/* P for adaptive mode, 0 otherwise */
DECL|member|freqn
r_int
r_int
id|freqn
suffix:semicolon
multiline_comment|/* nominal sampling rate in fs/fps in Q16.16 format */
DECL|member|freqm
r_int
r_int
id|freqm
suffix:semicolon
multiline_comment|/* momentary sampling rate in fs/fps in Q16.16 format */
DECL|member|freqmax
r_int
r_int
id|freqmax
suffix:semicolon
multiline_comment|/* maximum sampling rate, used for buffer management */
DECL|member|phase
r_int
r_int
id|phase
suffix:semicolon
multiline_comment|/* phase accumulator */
DECL|member|maxpacksize
r_int
r_int
id|maxpacksize
suffix:semicolon
multiline_comment|/* max packet size in bytes */
DECL|member|maxframesize
r_int
r_int
id|maxframesize
suffix:semicolon
multiline_comment|/* max packet size in frames */
DECL|member|curpacksize
r_int
r_int
id|curpacksize
suffix:semicolon
multiline_comment|/* current packet size in bytes (for capture) */
DECL|member|curframesize
r_int
r_int
id|curframesize
suffix:semicolon
multiline_comment|/* current packet size in frames (for capture) */
DECL|member|fill_max
r_int
r_int
id|fill_max
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* fill max packet size always */
DECL|member|fmt_type
r_int
r_int
id|fmt_type
suffix:semicolon
multiline_comment|/* USB audio format type (1-3) */
DECL|member|running
r_int
r_int
id|running
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* running status */
DECL|member|hwptr
r_int
r_int
id|hwptr
suffix:semicolon
multiline_comment|/* free frame position in the buffer (only for playback) */
DECL|member|hwptr_done
r_int
r_int
id|hwptr_done
suffix:semicolon
multiline_comment|/* processed frame position in the buffer */
DECL|member|transfer_sched
r_int
r_int
id|transfer_sched
suffix:semicolon
multiline_comment|/* scheduled frames since last period (for playback) */
DECL|member|transfer_done
r_int
r_int
id|transfer_done
suffix:semicolon
multiline_comment|/* processed frames since last period update */
DECL|member|active_mask
r_int
r_int
id|active_mask
suffix:semicolon
multiline_comment|/* bitmask of active urbs */
DECL|member|unlink_mask
r_int
r_int
id|unlink_mask
suffix:semicolon
multiline_comment|/* bitmask of unlinked urbs */
DECL|member|nurbs
r_int
r_int
id|nurbs
suffix:semicolon
multiline_comment|/* # urbs */
DECL|member|dataurb
id|snd_urb_ctx_t
id|dataurb
(braket
id|MAX_URBS
)braket
suffix:semicolon
multiline_comment|/* data urb table */
DECL|member|syncurb
id|snd_urb_ctx_t
id|syncurb
(braket
id|SYNC_URBS
)braket
suffix:semicolon
multiline_comment|/* sync urb table */
DECL|member|syncbuf
r_char
id|syncbuf
(braket
id|SYNC_URBS
op_star
id|MAX_PACKS
op_star
l_int|4
)braket
suffix:semicolon
multiline_comment|/* sync buffer; it&squot;s so small - let&squot;s get static */
DECL|member|tmpbuf
r_char
op_star
id|tmpbuf
suffix:semicolon
multiline_comment|/* temporary buffer for playback */
DECL|member|formats
id|u64
id|formats
suffix:semicolon
multiline_comment|/* format bitmasks (all or&squot;ed) */
DECL|member|num_formats
r_int
r_int
id|num_formats
suffix:semicolon
multiline_comment|/* number of supported audio formats (list) */
DECL|member|fmt_list
r_struct
id|list_head
id|fmt_list
suffix:semicolon
multiline_comment|/* format list */
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|ops
r_struct
id|snd_urb_ops
id|ops
suffix:semicolon
multiline_comment|/* callbacks (must be filled at init) */
)brace
suffix:semicolon
DECL|struct|snd_usb_stream
r_struct
id|snd_usb_stream
(brace
DECL|member|chip
id|snd_usb_audio_t
op_star
id|chip
suffix:semicolon
DECL|member|pcm
id|snd_pcm_t
op_star
id|pcm
suffix:semicolon
DECL|member|pcm_index
r_int
id|pcm_index
suffix:semicolon
DECL|member|fmt_type
r_int
r_int
id|fmt_type
suffix:semicolon
multiline_comment|/* USB audio format type (1-3) */
DECL|member|substream
id|snd_usb_substream_t
id|substream
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * we keep the snd_usb_audio_t instances by ourselves for merging&n; * the all interfaces on the same card as one sound device.&n; */
r_static
id|DECLARE_MUTEX
c_func
(paren
id|register_mutex
)paren
suffix:semicolon
DECL|variable|usb_chip
r_static
id|snd_usb_audio_t
op_star
id|usb_chip
(braket
id|SNDRV_CARDS
)braket
suffix:semicolon
multiline_comment|/*&n; * convert a sampling rate into our full speed format (fs/1000 in Q16.16)&n; * this will overflow at approx 524 kHz&n; */
DECL|function|get_usb_full_speed_rate
r_inline
r_static
r_int
id|get_usb_full_speed_rate
c_func
(paren
r_int
r_int
id|rate
)paren
(brace
r_return
(paren
(paren
id|rate
op_lshift
l_int|13
)paren
op_plus
l_int|62
)paren
op_div
l_int|125
suffix:semicolon
)brace
multiline_comment|/*&n; * convert a sampling rate into USB high speed format (fs/8000 in Q16.16)&n; * this will overflow at approx 4 MHz&n; */
DECL|function|get_usb_high_speed_rate
r_inline
r_static
r_int
id|get_usb_high_speed_rate
c_func
(paren
r_int
r_int
id|rate
)paren
(brace
r_return
(paren
(paren
id|rate
op_lshift
l_int|10
)paren
op_plus
l_int|62
)paren
op_div
l_int|125
suffix:semicolon
)brace
multiline_comment|/* convert our full speed USB rate into sampling rate in Hz */
DECL|function|get_full_speed_hz
r_inline
r_static
r_int
id|get_full_speed_hz
c_func
(paren
r_int
r_int
id|usb_rate
)paren
(brace
r_return
(paren
id|usb_rate
op_star
l_int|125
op_plus
(paren
l_int|1
op_lshift
l_int|12
)paren
)paren
op_rshift
l_int|13
suffix:semicolon
)brace
multiline_comment|/* convert our high speed USB rate into sampling rate in Hz */
DECL|function|get_high_speed_hz
r_inline
r_static
r_int
id|get_high_speed_hz
c_func
(paren
r_int
r_int
id|usb_rate
)paren
(brace
r_return
(paren
id|usb_rate
op_star
l_int|125
op_plus
(paren
l_int|1
op_lshift
l_int|9
)paren
)paren
op_rshift
l_int|10
suffix:semicolon
)brace
multiline_comment|/*&n; * prepare urb for full speed capture sync pipe&n; *&n; * fill the length and offset of each urb descriptor.&n; * the fixed 10.14 frequency is passed through the pipe.&n; */
DECL|function|prepare_capture_sync_urb
r_static
r_int
id|prepare_capture_sync_urb
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
id|snd_pcm_runtime_t
op_star
id|runtime
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
r_char
op_star
id|cp
op_assign
id|urb-&gt;transfer_buffer
suffix:semicolon
id|snd_urb_ctx_t
op_star
id|ctx
op_assign
(paren
id|snd_urb_ctx_t
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_int
id|i
comma
id|offs
suffix:semicolon
id|urb-&gt;number_of_packets
op_assign
id|ctx-&gt;packets
suffix:semicolon
id|urb-&gt;dev
op_assign
id|ctx-&gt;subs-&gt;dev
suffix:semicolon
multiline_comment|/* we need to set this at each time */
r_for
c_loop
(paren
id|i
op_assign
id|offs
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
comma
id|offs
op_add_assign
l_int|4
comma
id|cp
op_add_assign
l_int|4
)paren
(brace
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|length
op_assign
l_int|3
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|offset
op_assign
id|offs
suffix:semicolon
id|cp
(braket
l_int|0
)braket
op_assign
id|subs-&gt;freqn
op_rshift
l_int|2
suffix:semicolon
id|cp
(braket
l_int|1
)braket
op_assign
id|subs-&gt;freqn
op_rshift
l_int|10
suffix:semicolon
id|cp
(braket
l_int|2
)braket
op_assign
id|subs-&gt;freqn
op_rshift
l_int|18
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * prepare urb for high speed capture sync pipe&n; *&n; * fill the length and offset of each urb descriptor.&n; * the fixed 12.13 frequency is passed as 16.16 through the pipe.&n; */
DECL|function|prepare_capture_sync_urb_hs
r_static
r_int
id|prepare_capture_sync_urb_hs
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
id|snd_pcm_runtime_t
op_star
id|runtime
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
r_char
op_star
id|cp
op_assign
id|urb-&gt;transfer_buffer
suffix:semicolon
id|snd_urb_ctx_t
op_star
id|ctx
op_assign
(paren
id|snd_urb_ctx_t
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_int
id|i
comma
id|offs
suffix:semicolon
id|urb-&gt;number_of_packets
op_assign
id|ctx-&gt;packets
suffix:semicolon
id|urb-&gt;dev
op_assign
id|ctx-&gt;subs-&gt;dev
suffix:semicolon
multiline_comment|/* we need to set this at each time */
r_for
c_loop
(paren
id|i
op_assign
id|offs
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
comma
id|offs
op_add_assign
l_int|4
comma
id|cp
op_add_assign
l_int|4
)paren
(brace
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|length
op_assign
l_int|4
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|offset
op_assign
id|offs
suffix:semicolon
id|cp
(braket
l_int|0
)braket
op_assign
id|subs-&gt;freqn
suffix:semicolon
id|cp
(braket
l_int|1
)braket
op_assign
id|subs-&gt;freqn
op_rshift
l_int|8
suffix:semicolon
id|cp
(braket
l_int|2
)braket
op_assign
id|subs-&gt;freqn
op_rshift
l_int|16
suffix:semicolon
id|cp
(braket
l_int|3
)braket
op_assign
id|subs-&gt;freqn
op_rshift
l_int|24
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * process after capture sync complete&n; * - nothing to do&n; */
DECL|function|retire_capture_sync_urb
r_static
r_int
id|retire_capture_sync_urb
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
id|snd_pcm_runtime_t
op_star
id|runtime
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * prepare urb for capture data pipe&n; *&n; * fill the offset and length of each descriptor.&n; *&n; * we use a temporary buffer to write the captured data.&n; * since the length of written data is determined by host, we cannot&n; * write onto the pcm buffer directly...  the data is thus copied&n; * later at complete callback to the global buffer.&n; */
DECL|function|prepare_capture_urb
r_static
r_int
id|prepare_capture_urb
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
id|snd_pcm_runtime_t
op_star
id|runtime
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|i
comma
id|offs
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|snd_urb_ctx_t
op_star
id|ctx
op_assign
(paren
id|snd_urb_ctx_t
op_star
)paren
id|urb-&gt;context
suffix:semicolon
id|offs
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;dev
op_assign
id|ctx-&gt;subs-&gt;dev
suffix:semicolon
multiline_comment|/* we need to set this at each time */
id|urb-&gt;number_of_packets
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|subs-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ctx-&gt;packets
suffix:semicolon
id|i
op_increment
)paren
(brace
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|offset
op_assign
id|offs
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|length
op_assign
id|subs-&gt;curpacksize
suffix:semicolon
id|offs
op_add_assign
id|subs-&gt;curpacksize
suffix:semicolon
id|urb-&gt;number_of_packets
op_increment
suffix:semicolon
id|subs-&gt;transfer_sched
op_add_assign
id|subs-&gt;curframesize
suffix:semicolon
r_if
c_cond
(paren
id|subs-&gt;transfer_sched
op_ge
id|runtime-&gt;period_size
)paren
(brace
id|subs-&gt;transfer_sched
op_sub_assign
id|runtime-&gt;period_size
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|subs-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|urb-&gt;transfer_buffer
op_assign
id|ctx-&gt;buf
suffix:semicolon
id|urb-&gt;transfer_buffer_length
op_assign
id|offs
suffix:semicolon
macro_line|#if 0 
singleline_comment|// for check
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;bandwidth
)paren
(brace
r_int
id|bustime
suffix:semicolon
id|bustime
op_assign
id|usb_check_bandwidth
c_func
(paren
id|urb-&gt;dev
comma
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bustime
OL
l_int|0
)paren
r_return
id|bustime
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;urb %d: bandwidth = %d (packets = %d)&bslash;n&quot;
comma
id|ctx-&gt;index
comma
id|bustime
comma
id|urb-&gt;number_of_packets
)paren
suffix:semicolon
id|usb_claim_bandwidth
c_func
(paren
id|urb-&gt;dev
comma
id|urb
comma
id|bustime
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif 
singleline_comment|// for check
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * process after capture complete&n; *&n; * copy the data from each desctiptor to the pcm buffer, and&n; * update the current position.&n; */
DECL|function|retire_capture_urb
r_static
r_int
id|retire_capture_urb
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
id|snd_pcm_runtime_t
op_star
id|runtime
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
op_star
id|cp
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|stride
comma
id|len
comma
id|oldptr
suffix:semicolon
id|stride
op_assign
id|runtime-&gt;frame_bits
op_rshift
l_int|3
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cp
op_assign
(paren
r_int
r_char
op_star
)paren
id|urb-&gt;transfer_buffer
op_plus
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|status
)paren
(brace
id|snd_printd
c_func
(paren
id|KERN_ERR
l_string|&quot;frame %d active: %d&bslash;n&quot;
comma
id|i
comma
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|status
)paren
suffix:semicolon
singleline_comment|// continue;
)brace
id|len
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|actual_length
op_div
id|stride
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_continue
suffix:semicolon
multiline_comment|/* update the current pointer */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|subs-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|oldptr
op_assign
id|subs-&gt;hwptr_done
suffix:semicolon
id|subs-&gt;hwptr_done
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|subs-&gt;hwptr_done
op_ge
id|runtime-&gt;buffer_size
)paren
id|subs-&gt;hwptr_done
op_sub_assign
id|runtime-&gt;buffer_size
suffix:semicolon
id|subs-&gt;transfer_done
op_add_assign
id|len
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|subs-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* copy a data chunk */
r_if
c_cond
(paren
id|oldptr
op_plus
id|len
OG
id|runtime-&gt;buffer_size
)paren
(brace
r_int
r_int
id|cnt
op_assign
id|runtime-&gt;buffer_size
op_minus
id|oldptr
suffix:semicolon
r_int
r_int
id|blen
op_assign
id|cnt
op_star
id|stride
suffix:semicolon
id|memcpy
c_func
(paren
id|runtime-&gt;dma_area
op_plus
id|oldptr
op_star
id|stride
comma
id|cp
comma
id|blen
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|runtime-&gt;dma_area
comma
id|cp
op_plus
id|blen
comma
id|len
op_star
id|stride
op_minus
id|blen
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|runtime-&gt;dma_area
op_plus
id|oldptr
op_star
id|stride
comma
id|cp
comma
id|len
op_star
id|stride
)paren
suffix:semicolon
)brace
multiline_comment|/* update the pointer, call callback if necessary */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|subs-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subs-&gt;transfer_done
op_ge
id|runtime-&gt;period_size
)paren
(brace
id|subs-&gt;transfer_done
op_sub_assign
id|runtime-&gt;period_size
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|subs-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|snd_pcm_period_elapsed
c_func
(paren
id|subs-&gt;pcm_substream
)paren
suffix:semicolon
)brace
r_else
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|subs-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * prepare urb for full speed playback sync pipe&n; *&n; * set up the offset and length to receive the current frequency.&n; */
DECL|function|prepare_playback_sync_urb
r_static
r_int
id|prepare_playback_sync_urb
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
id|snd_pcm_runtime_t
op_star
id|runtime
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|i
comma
id|offs
suffix:semicolon
id|snd_urb_ctx_t
op_star
id|ctx
op_assign
(paren
id|snd_urb_ctx_t
op_star
)paren
id|urb-&gt;context
suffix:semicolon
id|urb-&gt;number_of_packets
op_assign
id|ctx-&gt;packets
suffix:semicolon
id|urb-&gt;dev
op_assign
id|ctx-&gt;subs-&gt;dev
suffix:semicolon
multiline_comment|/* we need to set this at each time */
r_for
c_loop
(paren
id|i
op_assign
id|offs
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
comma
id|offs
op_add_assign
l_int|4
)paren
(brace
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|length
op_assign
l_int|3
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|offset
op_assign
id|offs
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * prepare urb for high speed playback sync pipe&n; *&n; * set up the offset and length to receive the current frequency.&n; */
DECL|function|prepare_playback_sync_urb_hs
r_static
r_int
id|prepare_playback_sync_urb_hs
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
id|snd_pcm_runtime_t
op_star
id|runtime
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|i
comma
id|offs
suffix:semicolon
id|snd_urb_ctx_t
op_star
id|ctx
op_assign
(paren
id|snd_urb_ctx_t
op_star
)paren
id|urb-&gt;context
suffix:semicolon
id|urb-&gt;number_of_packets
op_assign
id|ctx-&gt;packets
suffix:semicolon
id|urb-&gt;dev
op_assign
id|ctx-&gt;subs-&gt;dev
suffix:semicolon
multiline_comment|/* we need to set this at each time */
r_for
c_loop
(paren
id|i
op_assign
id|offs
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
comma
id|offs
op_add_assign
l_int|4
)paren
(brace
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|length
op_assign
l_int|4
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|offset
op_assign
id|offs
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * process after full speed playback sync complete&n; *&n; * retrieve the current 10.14 frequency from pipe, and set it.&n; * the value is referred in prepare_playback_urb().&n; */
DECL|function|retire_playback_sync_urb
r_static
r_int
id|retire_playback_sync_urb
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
id|snd_pcm_runtime_t
op_star
id|runtime
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|f
comma
id|found
suffix:semicolon
r_int
r_char
op_star
id|cp
op_assign
id|urb-&gt;transfer_buffer
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|found
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
comma
id|cp
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|status
op_logical_or
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|actual_length
OL
l_int|3
)paren
r_continue
suffix:semicolon
id|f
op_assign
id|combine_triple
c_func
(paren
id|cp
)paren
op_lshift
l_int|2
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|f
template_param
id|subs-&gt;freqmax
)paren
(brace
id|snd_printd
c_func
(paren
id|KERN_WARNING
l_string|&quot;requested frequency %d (%u,%03uHz) out of range (current nominal %d (%u,%03uHz))&bslash;n&quot;
comma
id|f
comma
id|f
op_rshift
l_int|14
comma
(paren
id|f
op_amp
(paren
(paren
l_int|1
op_lshift
l_int|14
)paren
op_minus
l_int|1
)paren
op_star
l_int|1000
)paren
op_div
(paren
(paren
l_int|1
op_lshift
l_int|14
)paren
op_minus
l_int|1
)paren
comma
id|subs-&gt;freqn
comma
id|subs-&gt;freqn
op_rshift
l_int|14
comma
(paren
id|subs-&gt;freqn
op_amp
(paren
(paren
l_int|1
op_lshift
l_int|14
)paren
op_minus
l_int|1
)paren
op_star
l_int|1000
)paren
op_div
(paren
(paren
l_int|1
op_lshift
l_int|14
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#endif
id|found
op_assign
id|f
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|subs-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|subs-&gt;freqm
op_assign
id|found
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|subs-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * process after high speed playback sync complete&n; *&n; * retrieve the current 12.13 frequency from pipe, and set it.&n; * the value is referred in prepare_playback_urb().&n; */
DECL|function|retire_playback_sync_urb_hs
r_static
r_int
id|retire_playback_sync_urb_hs
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
id|snd_pcm_runtime_t
op_star
id|runtime
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|found
suffix:semicolon
r_int
r_char
op_star
id|cp
op_assign
id|urb-&gt;transfer_buffer
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|found
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
comma
id|cp
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|status
op_logical_or
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|actual_length
OL
l_int|4
)paren
r_continue
suffix:semicolon
id|found
op_assign
id|combine_quad
c_func
(paren
id|cp
)paren
op_amp
l_int|0x0fffffff
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|subs-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|subs-&gt;freqm
op_assign
id|found
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|subs-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * prepare urb for playback data pipe&n; *&n; * we copy the data directly from the pcm buffer.&n; * the current position to be copied is held in hwptr field.&n; * since a urb can handle only a single linear buffer, if the total&n; * transferred area overflows the buffer boundary, we cannot send&n; * it directly from the buffer.  thus the data is once copied to&n; * a temporary buffer and urb points to that.&n; */
DECL|function|prepare_playback_urb
r_static
r_int
id|prepare_playback_urb
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
id|snd_pcm_runtime_t
op_star
id|runtime
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|i
comma
id|stride
comma
id|offs
suffix:semicolon
r_int
r_int
id|counts
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|snd_urb_ctx_t
op_star
id|ctx
op_assign
(paren
id|snd_urb_ctx_t
op_star
)paren
id|urb-&gt;context
suffix:semicolon
id|stride
op_assign
id|runtime-&gt;frame_bits
op_rshift
l_int|3
suffix:semicolon
id|offs
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;dev
op_assign
id|ctx-&gt;subs-&gt;dev
suffix:semicolon
multiline_comment|/* we need to set this at each time */
id|urb-&gt;number_of_packets
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|subs-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ctx-&gt;packets
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* calculate the size of a packet */
r_if
c_cond
(paren
id|subs-&gt;fill_max
)paren
id|counts
op_assign
id|subs-&gt;maxframesize
suffix:semicolon
multiline_comment|/* fixed */
r_else
(brace
id|subs-&gt;phase
op_assign
(paren
id|subs-&gt;phase
op_amp
l_int|0xffff
)paren
op_plus
id|subs-&gt;freqm
suffix:semicolon
id|counts
op_assign
id|subs-&gt;phase
op_rshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|counts
OG
id|subs-&gt;maxframesize
)paren
id|counts
op_assign
id|subs-&gt;maxframesize
suffix:semicolon
)brace
multiline_comment|/* set up descriptor */
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|offset
op_assign
id|offs
op_star
id|stride
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|length
op_assign
id|counts
op_star
id|stride
suffix:semicolon
id|offs
op_add_assign
id|counts
suffix:semicolon
id|urb-&gt;number_of_packets
op_increment
suffix:semicolon
id|subs-&gt;transfer_sched
op_add_assign
id|counts
suffix:semicolon
r_if
c_cond
(paren
id|subs-&gt;transfer_sched
op_ge
id|runtime-&gt;period_size
)paren
(brace
id|subs-&gt;transfer_sched
op_sub_assign
id|runtime-&gt;period_size
suffix:semicolon
r_if
c_cond
(paren
id|subs-&gt;fmt_type
op_eq
id|USB_FORMAT_TYPE_II
)paren
(brace
r_if
c_cond
(paren
id|subs-&gt;transfer_sched
OG
l_int|0
)paren
(brace
multiline_comment|/* FIXME: fill-max mode is not supported yet */
id|offs
op_sub_assign
id|subs-&gt;transfer_sched
suffix:semicolon
id|counts
op_sub_assign
id|subs-&gt;transfer_sched
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|length
op_assign
id|counts
op_star
id|stride
suffix:semicolon
id|subs-&gt;transfer_sched
op_assign
l_int|0
suffix:semicolon
)brace
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|ctx-&gt;packets
)paren
(brace
multiline_comment|/* add a transfer delimiter */
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|offset
op_assign
id|offs
op_star
id|stride
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|length
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;number_of_packets
op_increment
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|subs-&gt;hwptr
op_plus
id|offs
OG
id|runtime-&gt;buffer_size
)paren
(brace
multiline_comment|/* err, the transferred area goes over buffer boundary.&n;&t;&t; * copy the data to the temp buffer.&n;&t;&t; */
r_int
id|len
suffix:semicolon
id|len
op_assign
id|runtime-&gt;buffer_size
op_minus
id|subs-&gt;hwptr
suffix:semicolon
id|urb-&gt;transfer_buffer
op_assign
id|subs-&gt;tmpbuf
suffix:semicolon
id|memcpy
c_func
(paren
id|subs-&gt;tmpbuf
comma
id|runtime-&gt;dma_area
op_plus
id|subs-&gt;hwptr
op_star
id|stride
comma
id|len
op_star
id|stride
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|subs-&gt;tmpbuf
op_plus
id|len
op_star
id|stride
comma
id|runtime-&gt;dma_area
comma
(paren
id|offs
op_minus
id|len
)paren
op_star
id|stride
)paren
suffix:semicolon
id|subs-&gt;hwptr
op_add_assign
id|offs
suffix:semicolon
id|subs-&gt;hwptr
op_sub_assign
id|runtime-&gt;buffer_size
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* set the buffer pointer */
id|urb-&gt;transfer_buffer
op_assign
id|runtime-&gt;dma_area
op_plus
id|subs-&gt;hwptr
op_star
id|stride
suffix:semicolon
id|subs-&gt;hwptr
op_add_assign
id|offs
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|subs-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|urb-&gt;transfer_buffer_length
op_assign
id|offs
op_star
id|stride
suffix:semicolon
id|ctx-&gt;transfer
op_assign
id|offs
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * process after playback data complete&n; *&n; * update the current position and call callback if a period is processed.&n; */
DECL|function|retire_playback_urb
r_static
r_int
id|retire_playback_urb
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
id|snd_pcm_runtime_t
op_star
id|runtime
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|snd_urb_ctx_t
op_star
id|ctx
op_assign
(paren
id|snd_urb_ctx_t
op_star
)paren
id|urb-&gt;context
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|subs-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|subs-&gt;transfer_done
op_add_assign
id|ctx-&gt;transfer
suffix:semicolon
id|subs-&gt;hwptr_done
op_add_assign
id|ctx-&gt;transfer
suffix:semicolon
id|ctx-&gt;transfer
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|subs-&gt;hwptr_done
op_ge
id|runtime-&gt;buffer_size
)paren
id|subs-&gt;hwptr_done
op_sub_assign
id|runtime-&gt;buffer_size
suffix:semicolon
r_if
c_cond
(paren
id|subs-&gt;transfer_done
op_ge
id|runtime-&gt;period_size
)paren
(brace
id|subs-&gt;transfer_done
op_sub_assign
id|runtime-&gt;period_size
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|subs-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|snd_pcm_period_elapsed
c_func
(paren
id|subs-&gt;pcm_substream
)paren
suffix:semicolon
)brace
r_else
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|subs-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; */
DECL|variable|audio_urb_ops
r_static
r_struct
id|snd_urb_ops
id|audio_urb_ops
(braket
l_int|2
)braket
op_assign
(brace
(brace
dot
id|prepare
op_assign
id|prepare_playback_urb
comma
dot
id|retire
op_assign
id|retire_playback_urb
comma
dot
id|prepare_sync
op_assign
id|prepare_playback_sync_urb
comma
dot
id|retire_sync
op_assign
id|retire_playback_sync_urb
comma
)brace
comma
(brace
dot
id|prepare
op_assign
id|prepare_capture_urb
comma
dot
id|retire
op_assign
id|retire_capture_urb
comma
dot
id|prepare_sync
op_assign
id|prepare_capture_sync_urb
comma
dot
id|retire_sync
op_assign
id|retire_capture_sync_urb
comma
)brace
comma
)brace
suffix:semicolon
DECL|variable|audio_urb_ops_high_speed
r_static
r_struct
id|snd_urb_ops
id|audio_urb_ops_high_speed
(braket
l_int|2
)braket
op_assign
(brace
(brace
dot
id|prepare
op_assign
id|prepare_playback_urb
comma
dot
id|retire
op_assign
id|retire_playback_urb
comma
dot
id|prepare_sync
op_assign
id|prepare_playback_sync_urb_hs
comma
dot
id|retire_sync
op_assign
id|retire_playback_sync_urb_hs
comma
)brace
comma
(brace
dot
id|prepare
op_assign
id|prepare_capture_urb
comma
dot
id|retire
op_assign
id|retire_capture_urb
comma
dot
id|prepare_sync
op_assign
id|prepare_capture_sync_urb_hs
comma
dot
id|retire_sync
op_assign
id|retire_capture_sync_urb
comma
)brace
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * complete callback from data urb&n; */
DECL|function|snd_complete_urb
r_static
r_void
id|snd_complete_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|snd_urb_ctx_t
op_star
id|ctx
op_assign
(paren
id|snd_urb_ctx_t
op_star
)paren
id|urb-&gt;context
suffix:semicolon
id|snd_usb_substream_t
op_star
id|subs
op_assign
id|ctx-&gt;subs
suffix:semicolon
id|snd_pcm_substream_t
op_star
id|substream
op_assign
id|ctx-&gt;subs-&gt;pcm_substream
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|subs-&gt;running
op_logical_and
id|subs-&gt;ops
dot
id|retire
c_func
(paren
id|subs
comma
id|substream-&gt;runtime
comma
id|urb
)paren
)paren
op_logical_or
op_logical_neg
id|subs-&gt;running
op_logical_or
multiline_comment|/* can be stopped during retire callback */
(paren
id|err
op_assign
id|subs-&gt;ops
dot
id|prepare
c_func
(paren
id|subs
comma
id|substream-&gt;runtime
comma
id|urb
)paren
)paren
OL
l_int|0
op_logical_or
(paren
id|err
op_assign
id|usb_submit_urb
c_func
(paren
id|urb
comma
id|GFP_ATOMIC
)paren
)paren
OL
l_int|0
)paren
(brace
id|clear_bit
c_func
(paren
id|ctx-&gt;index
comma
op_amp
id|subs-&gt;active_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|snd_printd
c_func
(paren
id|KERN_ERR
l_string|&quot;cannot submit urb (err = %d)&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
id|snd_pcm_stop
c_func
(paren
id|substream
comma
id|SNDRV_PCM_STATE_XRUN
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * complete callback from sync urb&n; */
DECL|function|snd_complete_sync_urb
r_static
r_void
id|snd_complete_sync_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|snd_urb_ctx_t
op_star
id|ctx
op_assign
(paren
id|snd_urb_ctx_t
op_star
)paren
id|urb-&gt;context
suffix:semicolon
id|snd_usb_substream_t
op_star
id|subs
op_assign
id|ctx-&gt;subs
suffix:semicolon
id|snd_pcm_substream_t
op_star
id|substream
op_assign
id|ctx-&gt;subs-&gt;pcm_substream
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|subs-&gt;running
op_logical_and
id|subs-&gt;ops
dot
id|retire_sync
c_func
(paren
id|subs
comma
id|substream-&gt;runtime
comma
id|urb
)paren
)paren
op_logical_or
op_logical_neg
id|subs-&gt;running
op_logical_or
multiline_comment|/* can be stopped during retire callback */
(paren
id|err
op_assign
id|subs-&gt;ops
dot
id|prepare_sync
c_func
(paren
id|subs
comma
id|substream-&gt;runtime
comma
id|urb
)paren
)paren
OL
l_int|0
op_logical_or
(paren
id|err
op_assign
id|usb_submit_urb
c_func
(paren
id|urb
comma
id|GFP_ATOMIC
)paren
)paren
OL
l_int|0
)paren
(brace
id|clear_bit
c_func
(paren
id|ctx-&gt;index
op_plus
l_int|16
comma
op_amp
id|subs-&gt;active_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|snd_printd
c_func
(paren
id|KERN_ERR
l_string|&quot;cannot submit sync urb (err = %d)&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
id|snd_pcm_stop
c_func
(paren
id|substream
comma
id|SNDRV_PCM_STATE_XRUN
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * unlink active urbs.&n; */
DECL|function|deactivate_urbs
r_static
r_int
id|deactivate_urbs
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
r_int
id|force
comma
r_int
id|can_sleep
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
id|async
suffix:semicolon
id|subs-&gt;running
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|force
op_logical_and
id|subs-&gt;stream-&gt;chip-&gt;shutdown
)paren
multiline_comment|/* to be sure... */
r_return
l_int|0
suffix:semicolon
id|async
op_assign
op_logical_neg
id|can_sleep
op_logical_and
id|async_unlink
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|async
op_logical_and
id|in_interrupt
c_func
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|subs-&gt;nurbs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|i
comma
op_amp
id|subs-&gt;active_mask
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|i
comma
op_amp
id|subs-&gt;unlink_mask
)paren
)paren
(brace
r_struct
id|urb
op_star
id|u
op_assign
id|subs-&gt;dataurb
(braket
id|i
)braket
dot
id|urb
suffix:semicolon
r_if
c_cond
(paren
id|async
)paren
(brace
id|u-&gt;transfer_flags
op_or_assign
id|URB_ASYNC_UNLINK
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
id|u
)paren
suffix:semicolon
)brace
r_else
id|usb_kill_urb
c_func
(paren
id|u
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|subs-&gt;syncpipe
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SYNC_URBS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|i
op_plus
l_int|16
comma
op_amp
id|subs-&gt;active_mask
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|i
op_plus
l_int|16
comma
op_amp
id|subs-&gt;unlink_mask
)paren
)paren
(brace
r_struct
id|urb
op_star
id|u
op_assign
id|subs-&gt;syncurb
(braket
id|i
)braket
dot
id|urb
suffix:semicolon
r_if
c_cond
(paren
id|async
)paren
(brace
id|u-&gt;transfer_flags
op_or_assign
id|URB_ASYNC_UNLINK
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
id|u
)paren
suffix:semicolon
)brace
r_else
id|usb_kill_urb
c_func
(paren
id|u
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * set up and start data/sync urbs&n; */
DECL|function|start_urbs
r_static
r_int
id|start_urbs
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
id|snd_pcm_runtime_t
op_star
id|runtime
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
id|err
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|subs-&gt;nurbs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|snd_assert
c_func
(paren
id|subs-&gt;dataurb
(braket
id|i
)braket
dot
id|urb
comma
r_return
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subs-&gt;ops
dot
id|prepare
c_func
(paren
id|subs
comma
id|runtime
comma
id|subs-&gt;dataurb
(braket
id|i
)braket
dot
id|urb
)paren
OL
l_int|0
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cannot prepare datapipe for urb %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_goto
id|__error
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|subs-&gt;syncpipe
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SYNC_URBS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|snd_assert
c_func
(paren
id|subs-&gt;syncurb
(braket
id|i
)braket
dot
id|urb
comma
r_return
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subs-&gt;ops
dot
id|prepare_sync
c_func
(paren
id|subs
comma
id|runtime
comma
id|subs-&gt;syncurb
(braket
id|i
)braket
dot
id|urb
)paren
OL
l_int|0
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cannot prepare syncpipe for urb %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_goto
id|__error
suffix:semicolon
)brace
)brace
)brace
id|subs-&gt;active_mask
op_assign
l_int|0
suffix:semicolon
id|subs-&gt;unlink_mask
op_assign
l_int|0
suffix:semicolon
id|subs-&gt;running
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|subs-&gt;nurbs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|usb_submit_urb
c_func
(paren
id|subs-&gt;dataurb
(braket
id|i
)braket
dot
id|urb
comma
id|GFP_ATOMIC
)paren
)paren
OL
l_int|0
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cannot submit datapipe for urb %d, err = %d&bslash;n&quot;
comma
id|i
comma
id|err
)paren
suffix:semicolon
r_goto
id|__error
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|i
comma
op_amp
id|subs-&gt;active_mask
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|subs-&gt;syncpipe
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SYNC_URBS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|usb_submit_urb
c_func
(paren
id|subs-&gt;syncurb
(braket
id|i
)braket
dot
id|urb
comma
id|GFP_ATOMIC
)paren
)paren
OL
l_int|0
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cannot submit syncpipe for urb %d, err = %d&bslash;n&quot;
comma
id|i
comma
id|err
)paren
suffix:semicolon
r_goto
id|__error
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|i
op_plus
l_int|16
comma
op_amp
id|subs-&gt;active_mask
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
id|__error
suffix:colon
singleline_comment|// snd_pcm_stop(subs-&gt;pcm_substream, SNDRV_PCM_STATE_XRUN);
id|deactivate_urbs
c_func
(paren
id|subs
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|EPIPE
suffix:semicolon
)brace
multiline_comment|/*&n; *  wait until all urbs are processed.&n; */
DECL|function|wait_clear_urbs
r_static
r_int
id|wait_clear_urbs
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
)paren
(brace
r_int
id|timeout
op_assign
id|HZ
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_int
id|alive
suffix:semicolon
r_do
(brace
id|alive
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|subs-&gt;nurbs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|i
comma
op_amp
id|subs-&gt;active_mask
)paren
)paren
id|alive
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|subs-&gt;syncpipe
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SYNC_URBS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|i
op_plus
l_int|16
comma
op_amp
id|subs-&gt;active_mask
)paren
)paren
id|alive
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|alive
)paren
r_break
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|timeout
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|alive
)paren
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;timeout: still %d active urbs..&bslash;n&quot;
comma
id|alive
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * return the current pcm pointer.  just return the hwptr_done value.&n; */
DECL|function|snd_usb_pcm_pointer
r_static
id|snd_pcm_uframes_t
id|snd_usb_pcm_pointer
c_func
(paren
id|snd_pcm_substream_t
op_star
id|substream
)paren
(brace
id|snd_usb_substream_t
op_star
id|subs
op_assign
(paren
id|snd_usb_substream_t
op_star
)paren
id|substream-&gt;runtime-&gt;private_data
suffix:semicolon
r_return
id|subs-&gt;hwptr_done
suffix:semicolon
)brace
multiline_comment|/*&n; * start/stop substream&n; */
DECL|function|snd_usb_pcm_trigger
r_static
r_int
id|snd_usb_pcm_trigger
c_func
(paren
id|snd_pcm_substream_t
op_star
id|substream
comma
r_int
id|cmd
)paren
(brace
id|snd_usb_substream_t
op_star
id|subs
op_assign
(paren
id|snd_usb_substream_t
op_star
)paren
id|substream-&gt;runtime-&gt;private_data
suffix:semicolon
r_int
id|err
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SNDRV_PCM_TRIGGER_START
suffix:colon
id|err
op_assign
id|start_urbs
c_func
(paren
id|subs
comma
id|substream-&gt;runtime
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDRV_PCM_TRIGGER_STOP
suffix:colon
id|err
op_assign
id|deactivate_urbs
c_func
(paren
id|subs
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|err
OL
l_int|0
ques
c_cond
id|err
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * release a urb data&n; */
DECL|function|release_urb_ctx
r_static
r_void
id|release_urb_ctx
c_func
(paren
id|snd_urb_ctx_t
op_star
id|u
)paren
(brace
r_if
c_cond
(paren
id|u-&gt;urb
)paren
(brace
id|usb_free_urb
c_func
(paren
id|u-&gt;urb
)paren
suffix:semicolon
id|u-&gt;urb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|u-&gt;buf
)paren
(brace
id|kfree
c_func
(paren
id|u-&gt;buf
)paren
suffix:semicolon
id|u-&gt;buf
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * release a substream&n; */
DECL|function|release_substream_urbs
r_static
r_void
id|release_substream_urbs
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
r_int
id|force
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* stop urbs (to be sure) */
id|deactivate_urbs
c_func
(paren
id|subs
comma
id|force
comma
l_int|1
)paren
suffix:semicolon
id|wait_clear_urbs
c_func
(paren
id|subs
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_URBS
suffix:semicolon
id|i
op_increment
)paren
id|release_urb_ctx
c_func
(paren
op_amp
id|subs-&gt;dataurb
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SYNC_URBS
suffix:semicolon
id|i
op_increment
)paren
id|release_urb_ctx
c_func
(paren
op_amp
id|subs-&gt;syncurb
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subs-&gt;tmpbuf
)paren
(brace
id|kfree
c_func
(paren
id|subs-&gt;tmpbuf
)paren
suffix:semicolon
id|subs-&gt;tmpbuf
op_assign
l_int|NULL
suffix:semicolon
)brace
id|subs-&gt;nurbs
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * initialize a substream for plaback/capture&n; */
DECL|function|init_substream_urbs
r_static
r_int
id|init_substream_urbs
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
r_int
r_int
id|period_bytes
comma
r_int
r_int
id|rate
comma
r_int
r_int
id|frame_bits
)paren
(brace
r_int
r_int
id|maxsize
comma
id|n
comma
id|i
suffix:semicolon
r_int
id|is_playback
op_assign
id|subs-&gt;direction
op_eq
id|SNDRV_PCM_STREAM_PLAYBACK
suffix:semicolon
r_int
r_int
id|npacks
(braket
id|MAX_URBS
)braket
comma
id|urb_packs
comma
id|total_packs
suffix:semicolon
multiline_comment|/* calculate the frequency in 16.16 format */
r_if
c_cond
(paren
id|snd_usb_get_speed
c_func
(paren
id|subs-&gt;dev
)paren
op_eq
id|USB_SPEED_FULL
)paren
id|subs-&gt;freqn
op_assign
id|get_usb_full_speed_rate
c_func
(paren
id|rate
)paren
suffix:semicolon
r_else
id|subs-&gt;freqn
op_assign
id|get_usb_high_speed_rate
c_func
(paren
id|rate
)paren
suffix:semicolon
id|subs-&gt;freqm
op_assign
id|subs-&gt;freqn
suffix:semicolon
id|subs-&gt;freqmax
op_assign
id|subs-&gt;freqn
op_plus
(paren
id|subs-&gt;freqn
op_rshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/* max. allowed frequency */
id|subs-&gt;phase
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* calculate the max. size of packet */
id|maxsize
op_assign
(paren
(paren
id|subs-&gt;freqmax
op_plus
l_int|0xffff
)paren
op_star
(paren
id|frame_bits
op_rshift
l_int|3
)paren
)paren
op_rshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|subs-&gt;maxpacksize
op_logical_and
id|maxsize
OG
id|subs-&gt;maxpacksize
)paren
(brace
singleline_comment|//snd_printd(KERN_DEBUG &quot;maxsize %d is greater than defined size %d&bslash;n&quot;,
singleline_comment|//&t;   maxsize, subs-&gt;maxpacksize);
id|maxsize
op_assign
id|subs-&gt;maxpacksize
suffix:semicolon
)brace
r_if
c_cond
(paren
id|subs-&gt;fill_max
)paren
id|subs-&gt;curpacksize
op_assign
id|subs-&gt;maxpacksize
suffix:semicolon
r_else
id|subs-&gt;curpacksize
op_assign
id|maxsize
suffix:semicolon
r_if
c_cond
(paren
id|snd_usb_get_speed
c_func
(paren
id|subs-&gt;dev
)paren
op_eq
id|USB_SPEED_FULL
)paren
id|urb_packs
op_assign
id|nrpacks
suffix:semicolon
r_else
id|urb_packs
op_assign
id|nrpacks
op_star
l_int|8
suffix:semicolon
multiline_comment|/* allocate a temporary buffer for playback */
r_if
c_cond
(paren
id|is_playback
)paren
(brace
id|subs-&gt;tmpbuf
op_assign
id|kmalloc
c_func
(paren
id|maxsize
op_star
id|urb_packs
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subs-&gt;tmpbuf
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cannot malloc tmpbuf&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
multiline_comment|/* decide how many packets to be used */
id|total_packs
op_assign
(paren
id|period_bytes
op_plus
id|maxsize
op_minus
l_int|1
)paren
op_div
id|maxsize
suffix:semicolon
r_if
c_cond
(paren
id|total_packs
OL
l_int|2
op_star
id|MIN_PACKS_URB
)paren
id|total_packs
op_assign
l_int|2
op_star
id|MIN_PACKS_URB
suffix:semicolon
id|subs-&gt;nurbs
op_assign
(paren
id|total_packs
op_plus
id|urb_packs
op_minus
l_int|1
)paren
op_div
id|urb_packs
suffix:semicolon
r_if
c_cond
(paren
id|subs-&gt;nurbs
OG
id|MAX_URBS
)paren
(brace
multiline_comment|/* too much... */
id|subs-&gt;nurbs
op_assign
id|MAX_URBS
suffix:semicolon
id|total_packs
op_assign
id|MAX_URBS
op_star
id|urb_packs
suffix:semicolon
)brace
id|n
op_assign
id|total_packs
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|subs-&gt;nurbs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|npacks
(braket
id|i
)braket
op_assign
id|n
OG
id|urb_packs
ques
c_cond
id|urb_packs
suffix:colon
id|n
suffix:semicolon
id|n
op_sub_assign
id|urb_packs
suffix:semicolon
)brace
r_if
c_cond
(paren
id|subs-&gt;nurbs
op_le
l_int|1
)paren
(brace
multiline_comment|/* too little - we need at least two packets&n;&t;&t; * to ensure contiguous playback/capture&n;&t;&t; */
id|subs-&gt;nurbs
op_assign
l_int|2
suffix:semicolon
id|npacks
(braket
l_int|0
)braket
op_assign
(paren
id|total_packs
op_plus
l_int|1
)paren
op_div
l_int|2
suffix:semicolon
id|npacks
(braket
l_int|1
)braket
op_assign
id|total_packs
op_minus
id|npacks
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|npacks
(braket
id|subs-&gt;nurbs
op_minus
l_int|1
)braket
OL
id|MIN_PACKS_URB
)paren
(brace
multiline_comment|/* the last packet is too small.. */
r_if
c_cond
(paren
id|subs-&gt;nurbs
OG
l_int|2
)paren
(brace
multiline_comment|/* merge to the first one */
id|npacks
(braket
l_int|0
)braket
op_add_assign
id|npacks
(braket
id|subs-&gt;nurbs
op_minus
l_int|1
)braket
suffix:semicolon
id|subs-&gt;nurbs
op_decrement
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* divide to two */
id|subs-&gt;nurbs
op_assign
l_int|2
suffix:semicolon
id|npacks
(braket
l_int|0
)braket
op_assign
(paren
id|total_packs
op_plus
l_int|1
)paren
op_div
l_int|2
suffix:semicolon
id|npacks
(braket
l_int|1
)braket
op_assign
id|total_packs
op_minus
id|npacks
(braket
l_int|0
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/* allocate and initialize data urbs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|subs-&gt;nurbs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|snd_urb_ctx_t
op_star
id|u
op_assign
op_amp
id|subs-&gt;dataurb
(braket
id|i
)braket
suffix:semicolon
id|u-&gt;index
op_assign
id|i
suffix:semicolon
id|u-&gt;subs
op_assign
id|subs
suffix:semicolon
id|u-&gt;transfer
op_assign
l_int|0
suffix:semicolon
id|u-&gt;packets
op_assign
id|npacks
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|subs-&gt;fmt_type
op_eq
id|USB_FORMAT_TYPE_II
)paren
id|u-&gt;packets
op_increment
suffix:semicolon
multiline_comment|/* for transfer delimiter */
r_if
c_cond
(paren
op_logical_neg
id|is_playback
)paren
(brace
multiline_comment|/* allocate a capture buffer per urb */
id|u-&gt;buf
op_assign
id|kmalloc
c_func
(paren
id|maxsize
op_star
id|u-&gt;packets
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|u-&gt;buf
)paren
(brace
id|release_substream_urbs
c_func
(paren
id|subs
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
id|u-&gt;urb
op_assign
id|usb_alloc_urb
c_func
(paren
id|u-&gt;packets
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|u-&gt;urb
)paren
(brace
id|release_substream_urbs
c_func
(paren
id|subs
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|u-&gt;urb-&gt;dev
op_assign
id|subs-&gt;dev
suffix:semicolon
id|u-&gt;urb-&gt;pipe
op_assign
id|subs-&gt;datapipe
suffix:semicolon
id|u-&gt;urb-&gt;transfer_flags
op_assign
id|URB_ISO_ASAP
suffix:semicolon
id|u-&gt;urb-&gt;number_of_packets
op_assign
id|u-&gt;packets
suffix:semicolon
id|u-&gt;urb-&gt;interval
op_assign
l_int|1
suffix:semicolon
id|u-&gt;urb-&gt;context
op_assign
id|u
suffix:semicolon
id|u-&gt;urb-&gt;complete
op_assign
id|snd_usb_complete_callback
c_func
(paren
id|snd_complete_urb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|subs-&gt;syncpipe
)paren
(brace
multiline_comment|/* allocate and initialize sync urbs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SYNC_URBS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|snd_urb_ctx_t
op_star
id|u
op_assign
op_amp
id|subs-&gt;syncurb
(braket
id|i
)braket
suffix:semicolon
id|u-&gt;index
op_assign
id|i
suffix:semicolon
id|u-&gt;subs
op_assign
id|subs
suffix:semicolon
id|u-&gt;packets
op_assign
id|nrpacks
suffix:semicolon
id|u-&gt;urb
op_assign
id|usb_alloc_urb
c_func
(paren
id|u-&gt;packets
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|u-&gt;urb
)paren
(brace
id|release_substream_urbs
c_func
(paren
id|subs
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|u-&gt;urb-&gt;transfer_buffer
op_assign
id|subs-&gt;syncbuf
op_plus
id|i
op_star
id|nrpacks
op_star
l_int|4
suffix:semicolon
id|u-&gt;urb-&gt;transfer_buffer_length
op_assign
id|nrpacks
op_star
l_int|4
suffix:semicolon
id|u-&gt;urb-&gt;dev
op_assign
id|subs-&gt;dev
suffix:semicolon
id|u-&gt;urb-&gt;pipe
op_assign
id|subs-&gt;syncpipe
suffix:semicolon
id|u-&gt;urb-&gt;transfer_flags
op_assign
id|URB_ISO_ASAP
suffix:semicolon
id|u-&gt;urb-&gt;number_of_packets
op_assign
id|u-&gt;packets
suffix:semicolon
r_if
c_cond
(paren
id|snd_usb_get_speed
c_func
(paren
id|subs-&gt;dev
)paren
op_eq
id|USB_SPEED_HIGH
)paren
id|u-&gt;urb-&gt;interval
op_assign
l_int|8
suffix:semicolon
r_else
id|u-&gt;urb-&gt;interval
op_assign
l_int|1
suffix:semicolon
id|u-&gt;urb-&gt;context
op_assign
id|u
suffix:semicolon
id|u-&gt;urb-&gt;complete
op_assign
id|snd_usb_complete_callback
c_func
(paren
id|snd_complete_sync_urb
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * find a matching audio format&n; */
DECL|function|find_format
r_static
r_struct
id|audioformat
op_star
id|find_format
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
r_int
r_int
id|format
comma
r_int
r_int
id|rate
comma
r_int
r_int
id|channels
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_struct
id|audioformat
op_star
id|found
op_assign
l_int|NULL
suffix:semicolon
r_int
id|cur_attr
op_assign
l_int|0
comma
id|attr
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|subs-&gt;fmt_list
)paren
(brace
r_struct
id|audioformat
op_star
id|fp
suffix:semicolon
id|fp
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|audioformat
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fp-&gt;format
op_ne
id|format
op_logical_or
id|fp-&gt;channels
op_ne
id|channels
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|rate
template_param
id|fp-&gt;rate_max
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|fp-&gt;rates
op_amp
id|SNDRV_PCM_RATE_CONTINUOUS
)paren
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fp-&gt;nr_rates
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|fp-&gt;rate_table
(braket
id|i
)braket
op_eq
id|rate
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|fp-&gt;nr_rates
)paren
r_continue
suffix:semicolon
)brace
id|attr
op_assign
id|fp-&gt;ep_attr
op_amp
id|EP_ATTR_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|found
op_assign
id|fp
suffix:semicolon
id|cur_attr
op_assign
id|attr
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* avoid async out and adaptive in if the other method&n;&t;&t; * supports the same format.&n;&t;&t; * this is a workaround for the case like&n;&t;&t; * M-audio audiophile USB.&n;&t;&t; */
r_if
c_cond
(paren
id|attr
op_ne
id|cur_attr
)paren
(brace
r_if
c_cond
(paren
(paren
id|attr
op_eq
id|EP_ATTR_ASYNC
op_logical_and
id|subs-&gt;direction
op_eq
id|SNDRV_PCM_STREAM_PLAYBACK
)paren
op_logical_or
(paren
id|attr
op_eq
id|EP_ATTR_ADAPTIVE
op_logical_and
id|subs-&gt;direction
op_eq
id|SNDRV_PCM_STREAM_CAPTURE
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cur_attr
op_eq
id|EP_ATTR_ASYNC
op_logical_and
id|subs-&gt;direction
op_eq
id|SNDRV_PCM_STREAM_PLAYBACK
)paren
op_logical_or
(paren
id|cur_attr
op_eq
id|EP_ATTR_ADAPTIVE
op_logical_and
id|subs-&gt;direction
op_eq
id|SNDRV_PCM_STREAM_CAPTURE
)paren
)paren
(brace
id|found
op_assign
id|fp
suffix:semicolon
id|cur_attr
op_assign
id|attr
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/* find the format with the largest max. packet size */
r_if
c_cond
(paren
id|fp-&gt;maxpacksize
OG
id|found-&gt;maxpacksize
)paren
(brace
id|found
op_assign
id|fp
suffix:semicolon
id|cur_attr
op_assign
id|attr
suffix:semicolon
)brace
)brace
r_return
id|found
suffix:semicolon
)brace
multiline_comment|/*&n; * initialize the picth control and sample rate&n; */
DECL|function|init_usb_pitch
r_static
r_int
id|init_usb_pitch
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|iface
comma
r_struct
id|usb_host_interface
op_star
id|alts
comma
r_struct
id|audioformat
op_star
id|fmt
)paren
(brace
r_int
r_int
id|ep
suffix:semicolon
r_int
r_char
id|data
(braket
l_int|1
)braket
suffix:semicolon
r_int
id|err
suffix:semicolon
id|ep
op_assign
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|0
)paren
op_member_access_from_pointer
id|bEndpointAddress
suffix:semicolon
multiline_comment|/* if endpoint has pitch control, enable it */
r_if
c_cond
(paren
id|fmt-&gt;attributes
op_amp
id|EP_CS_ATTR_PITCH_CONTROL
)paren
(brace
id|data
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_usb_ctl_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|SET_CUR
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_ENDPOINT
op_or
id|USB_DIR_OUT
comma
id|PITCH_CONTROL
op_lshift
l_int|8
comma
id|ep
comma
id|data
comma
l_int|1
comma
id|HZ
)paren
)paren
OL
l_int|0
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%d:%d:%d: cannot set enable PITCH&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|iface
comma
id|ep
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|init_usb_sample_rate
r_static
r_int
id|init_usb_sample_rate
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|iface
comma
r_struct
id|usb_host_interface
op_star
id|alts
comma
r_struct
id|audioformat
op_star
id|fmt
comma
r_int
id|rate
)paren
(brace
r_int
r_int
id|ep
suffix:semicolon
r_int
r_char
id|data
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|err
suffix:semicolon
id|ep
op_assign
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|0
)paren
op_member_access_from_pointer
id|bEndpointAddress
suffix:semicolon
multiline_comment|/* if endpoint has sampling rate control, set it */
r_if
c_cond
(paren
id|fmt-&gt;attributes
op_amp
id|EP_CS_ATTR_SAMPLE_RATE
)paren
(brace
r_int
id|crate
suffix:semicolon
id|data
(braket
l_int|0
)braket
op_assign
id|rate
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
id|rate
op_rshift
l_int|8
suffix:semicolon
id|data
(braket
l_int|2
)braket
op_assign
id|rate
op_rshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_usb_ctl_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|SET_CUR
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_ENDPOINT
op_or
id|USB_DIR_OUT
comma
id|SAMPLING_FREQ_CONTROL
op_lshift
l_int|8
comma
id|ep
comma
id|data
comma
l_int|3
comma
id|HZ
)paren
)paren
OL
l_int|0
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%d:%d:%d: cannot set freq %d to ep 0x%x&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|iface
comma
id|fmt-&gt;altsetting
comma
id|rate
comma
id|ep
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_usb_ctl_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|GET_CUR
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_ENDPOINT
op_or
id|USB_DIR_IN
comma
id|SAMPLING_FREQ_CONTROL
op_lshift
l_int|8
comma
id|ep
comma
id|data
comma
l_int|3
comma
id|HZ
)paren
)paren
OL
l_int|0
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%d:%d:%d: cannot get freq at ep 0x%x&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|iface
comma
id|fmt-&gt;altsetting
comma
id|ep
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* some devices don&squot;t support reading */
)brace
id|crate
op_assign
id|data
(braket
l_int|0
)braket
op_or
(paren
id|data
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
op_or
(paren
id|data
(braket
l_int|2
)braket
op_lshift
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crate
op_ne
id|rate
)paren
(brace
id|snd_printd
c_func
(paren
id|KERN_WARNING
l_string|&quot;current rate %d is different from the runtime rate %d&bslash;n&quot;
comma
id|crate
comma
id|rate
)paren
suffix:semicolon
singleline_comment|// runtime-&gt;rate = crate;
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * find a matching format and set up the interface&n; */
DECL|function|set_format
r_static
r_int
id|set_format
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
r_struct
id|audioformat
op_star
id|fmt
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
op_assign
id|subs-&gt;dev
suffix:semicolon
r_struct
id|usb_host_interface
op_star
id|alts
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|altsd
suffix:semicolon
r_struct
id|usb_interface
op_star
id|iface
suffix:semicolon
r_int
r_int
id|ep
comma
id|attr
suffix:semicolon
r_int
id|is_playback
op_assign
id|subs-&gt;direction
op_eq
id|SNDRV_PCM_STREAM_PLAYBACK
suffix:semicolon
r_int
id|err
suffix:semicolon
id|iface
op_assign
id|usb_ifnum_to_if
c_func
(paren
id|dev
comma
id|fmt-&gt;iface
)paren
suffix:semicolon
id|snd_assert
c_func
(paren
id|iface
comma
r_return
op_minus
id|EINVAL
)paren
suffix:semicolon
id|alts
op_assign
op_amp
id|iface-&gt;altsetting
(braket
id|fmt-&gt;altset_idx
)braket
suffix:semicolon
id|altsd
op_assign
id|get_iface_desc
c_func
(paren
id|alts
)paren
suffix:semicolon
id|snd_assert
c_func
(paren
id|altsd-&gt;bAlternateSetting
op_eq
id|fmt-&gt;altsetting
comma
r_return
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_eq
id|subs-&gt;cur_audiofmt
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* close the old interface */
r_if
c_cond
(paren
id|subs-&gt;interface
op_ge
l_int|0
op_logical_and
id|subs-&gt;interface
op_ne
id|fmt-&gt;iface
)paren
(brace
id|usb_set_interface
c_func
(paren
id|subs-&gt;dev
comma
id|subs-&gt;interface
comma
l_int|0
)paren
suffix:semicolon
id|subs-&gt;interface
op_assign
op_minus
l_int|1
suffix:semicolon
id|subs-&gt;format
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* set interface */
r_if
c_cond
(paren
id|subs-&gt;interface
op_ne
id|fmt-&gt;iface
op_logical_or
id|subs-&gt;format
op_ne
id|fmt-&gt;altset_idx
)paren
(brace
r_if
c_cond
(paren
id|usb_set_interface
c_func
(paren
id|dev
comma
id|fmt-&gt;iface
comma
id|fmt-&gt;altsetting
)paren
OL
l_int|0
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%d:%d:%d: usb_set_interface failed&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|fmt-&gt;iface
comma
id|fmt-&gt;altsetting
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|snd_printdd
c_func
(paren
id|KERN_INFO
l_string|&quot;setting usb interface %d:%d&bslash;n&quot;
comma
id|fmt-&gt;iface
comma
id|fmt-&gt;altsetting
)paren
suffix:semicolon
id|subs-&gt;interface
op_assign
id|fmt-&gt;iface
suffix:semicolon
id|subs-&gt;format
op_assign
id|fmt-&gt;altset_idx
suffix:semicolon
)brace
multiline_comment|/* create a data pipe */
id|ep
op_assign
id|fmt-&gt;endpoint
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
r_if
c_cond
(paren
id|is_playback
)paren
id|subs-&gt;datapipe
op_assign
id|usb_sndisocpipe
c_func
(paren
id|dev
comma
id|ep
)paren
suffix:semicolon
r_else
id|subs-&gt;datapipe
op_assign
id|usb_rcvisocpipe
c_func
(paren
id|dev
comma
id|ep
)paren
suffix:semicolon
id|subs-&gt;syncpipe
op_assign
id|subs-&gt;syncinterval
op_assign
l_int|0
suffix:semicolon
id|subs-&gt;maxpacksize
op_assign
id|fmt-&gt;maxpacksize
suffix:semicolon
id|subs-&gt;fill_max
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we need a sync pipe in async OUT or adaptive IN mode */
multiline_comment|/* check the number of EP, since some devices have broken&n;&t; * descriptors which fool us.  if it has only one EP,&n;&t; * assume it as adaptive-out or sync-in.&n;&t; */
id|attr
op_assign
id|fmt-&gt;ep_attr
op_amp
id|EP_ATTR_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|is_playback
op_logical_and
id|attr
op_eq
id|EP_ATTR_ASYNC
)paren
op_logical_or
(paren
op_logical_neg
id|is_playback
op_logical_and
id|attr
op_eq
id|EP_ATTR_ADAPTIVE
)paren
)paren
op_logical_and
id|altsd-&gt;bNumEndpoints
op_ge
l_int|2
)paren
(brace
multiline_comment|/* check sync-pipe endpoint */
multiline_comment|/* ... and check descriptor size before accessing bSynchAddress&n;&t;&t;   because there is a version of the SB Audigy 2 NX firmware lacking&n;&t;&t;   the audio fields in the endpoint descriptors */
r_if
c_cond
(paren
(paren
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|1
)paren
op_member_access_from_pointer
id|bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_ne
l_int|0x01
op_logical_or
(paren
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|1
)paren
op_member_access_from_pointer
id|bLength
op_ge
id|USB_DT_ENDPOINT_AUDIO_SIZE
op_logical_and
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|1
)paren
op_member_access_from_pointer
id|bSynchAddress
op_ne
l_int|0
)paren
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%d:%d:%d : invalid synch pipe&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|fmt-&gt;iface
comma
id|fmt-&gt;altsetting
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ep
op_assign
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|1
)paren
op_member_access_from_pointer
id|bEndpointAddress
suffix:semicolon
r_if
c_cond
(paren
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|0
)paren
op_member_access_from_pointer
id|bLength
op_ge
id|USB_DT_ENDPOINT_AUDIO_SIZE
op_logical_and
(paren
(paren
id|is_playback
op_logical_and
id|ep
op_ne
(paren
r_int
r_int
)paren
(paren
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|0
)paren
op_member_access_from_pointer
id|bSynchAddress
op_or
id|USB_DIR_IN
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|is_playback
op_logical_and
id|ep
op_ne
(paren
r_int
r_int
)paren
(paren
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|0
)paren
op_member_access_from_pointer
id|bSynchAddress
op_amp
op_complement
id|USB_DIR_IN
)paren
)paren
)paren
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%d:%d:%d : invalid synch pipe&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|fmt-&gt;iface
comma
id|fmt-&gt;altsetting
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ep
op_and_assign
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
r_if
c_cond
(paren
id|is_playback
)paren
id|subs-&gt;syncpipe
op_assign
id|usb_rcvisocpipe
c_func
(paren
id|dev
comma
id|ep
)paren
suffix:semicolon
r_else
id|subs-&gt;syncpipe
op_assign
id|usb_sndisocpipe
c_func
(paren
id|dev
comma
id|ep
)paren
suffix:semicolon
id|subs-&gt;syncinterval
op_assign
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|1
)paren
op_member_access_from_pointer
id|bRefresh
suffix:semicolon
)brace
multiline_comment|/* always fill max packet size */
r_if
c_cond
(paren
id|fmt-&gt;attributes
op_amp
id|EP_CS_ATTR_FILL_MAX
)paren
id|subs-&gt;fill_max
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|init_usb_pitch
c_func
(paren
id|dev
comma
id|subs-&gt;interface
comma
id|alts
comma
id|fmt
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|subs-&gt;cur_audiofmt
op_assign
id|fmt
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;setting done: format = %d, rate = %d, channels = %d&bslash;n&quot;
comma
id|fmt-&gt;format
comma
id|fmt-&gt;rate
comma
id|fmt-&gt;channels
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  datapipe = 0x%0x, syncpipe = 0x%0x&bslash;n&quot;
comma
id|subs-&gt;datapipe
comma
id|subs-&gt;syncpipe
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * hw_params callback&n; *&n; * allocate a buffer and set the given audio format.&n; *&n; * so far we use a physically linear buffer although packetize transfer&n; * doesn&squot;t need a continuous area.&n; * if sg buffer is supported on the later version of alsa, we&squot;ll follow&n; * that.&n; */
DECL|function|snd_usb_hw_params
r_static
r_int
id|snd_usb_hw_params
c_func
(paren
id|snd_pcm_substream_t
op_star
id|substream
comma
id|snd_pcm_hw_params_t
op_star
id|hw_params
)paren
(brace
id|snd_usb_substream_t
op_star
id|subs
op_assign
(paren
id|snd_usb_substream_t
op_star
)paren
id|substream-&gt;runtime-&gt;private_data
suffix:semicolon
r_struct
id|audioformat
op_star
id|fmt
suffix:semicolon
r_int
r_int
id|channels
comma
id|rate
comma
id|format
suffix:semicolon
r_int
id|ret
comma
id|changed
suffix:semicolon
id|ret
op_assign
id|snd_pcm_lib_malloc_pages
c_func
(paren
id|substream
comma
id|params_buffer_bytes
c_func
(paren
id|hw_params
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|format
op_assign
id|params_format
c_func
(paren
id|hw_params
)paren
suffix:semicolon
id|rate
op_assign
id|params_rate
c_func
(paren
id|hw_params
)paren
suffix:semicolon
id|channels
op_assign
id|params_channels
c_func
(paren
id|hw_params
)paren
suffix:semicolon
id|fmt
op_assign
id|find_format
c_func
(paren
id|subs
comma
id|format
comma
id|rate
comma
id|channels
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fmt
)paren
(brace
id|snd_printd
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cannot set format: format = %s, rate = %d, channels = %d&bslash;n&quot;
comma
id|snd_pcm_format_name
c_func
(paren
id|format
)paren
comma
id|rate
comma
id|channels
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|changed
op_assign
id|subs-&gt;cur_audiofmt
op_ne
id|fmt
op_logical_or
id|subs-&gt;period_bytes
op_ne
id|params_period_bytes
c_func
(paren
id|hw_params
)paren
op_logical_or
id|subs-&gt;cur_rate
op_ne
id|rate
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|set_format
c_func
(paren
id|subs
comma
id|fmt
)paren
)paren
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|subs-&gt;cur_rate
op_ne
id|rate
)paren
(brace
r_struct
id|usb_host_interface
op_star
id|alts
suffix:semicolon
r_struct
id|usb_interface
op_star
id|iface
suffix:semicolon
id|iface
op_assign
id|usb_ifnum_to_if
c_func
(paren
id|subs-&gt;dev
comma
id|fmt-&gt;iface
)paren
suffix:semicolon
id|alts
op_assign
op_amp
id|iface-&gt;altsetting
(braket
id|fmt-&gt;altset_idx
)braket
suffix:semicolon
id|ret
op_assign
id|init_usb_sample_rate
c_func
(paren
id|subs-&gt;dev
comma
id|subs-&gt;interface
comma
id|alts
comma
id|fmt
comma
id|rate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|subs-&gt;cur_rate
op_assign
id|rate
suffix:semicolon
)brace
r_if
c_cond
(paren
id|changed
)paren
(brace
multiline_comment|/* format changed */
id|release_substream_urbs
c_func
(paren
id|subs
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* influenced: period_bytes, channels, rate, format, */
id|ret
op_assign
id|init_substream_urbs
c_func
(paren
id|subs
comma
id|params_period_bytes
c_func
(paren
id|hw_params
)paren
comma
id|params_rate
c_func
(paren
id|hw_params
)paren
comma
id|snd_pcm_format_physical_width
c_func
(paren
id|params_format
c_func
(paren
id|hw_params
)paren
)paren
op_star
id|params_channels
c_func
(paren
id|hw_params
)paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * hw_free callback&n; *&n; * reset the audio format and release the buffer&n; */
DECL|function|snd_usb_hw_free
r_static
r_int
id|snd_usb_hw_free
c_func
(paren
id|snd_pcm_substream_t
op_star
id|substream
)paren
(brace
id|snd_usb_substream_t
op_star
id|subs
op_assign
(paren
id|snd_usb_substream_t
op_star
)paren
id|substream-&gt;runtime-&gt;private_data
suffix:semicolon
id|subs-&gt;cur_audiofmt
op_assign
l_int|NULL
suffix:semicolon
id|subs-&gt;cur_rate
op_assign
l_int|0
suffix:semicolon
id|subs-&gt;period_bytes
op_assign
l_int|0
suffix:semicolon
id|release_substream_urbs
c_func
(paren
id|subs
comma
l_int|0
)paren
suffix:semicolon
r_return
id|snd_pcm_lib_free_pages
c_func
(paren
id|substream
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * prepare callback&n; *&n; * only a few subtle things...&n; */
DECL|function|snd_usb_pcm_prepare
r_static
r_int
id|snd_usb_pcm_prepare
c_func
(paren
id|snd_pcm_substream_t
op_star
id|substream
)paren
(brace
id|snd_pcm_runtime_t
op_star
id|runtime
op_assign
id|substream-&gt;runtime
suffix:semicolon
id|snd_usb_substream_t
op_star
id|subs
op_assign
(paren
id|snd_usb_substream_t
op_star
)paren
id|runtime-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subs-&gt;cur_audiofmt
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usbaudio: no format is specified!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* some unit conversions in runtime */
id|subs-&gt;maxframesize
op_assign
id|bytes_to_frames
c_func
(paren
id|runtime
comma
id|subs-&gt;maxpacksize
)paren
suffix:semicolon
id|subs-&gt;curframesize
op_assign
id|bytes_to_frames
c_func
(paren
id|runtime
comma
id|subs-&gt;curpacksize
)paren
suffix:semicolon
multiline_comment|/* reset the pointer */
id|subs-&gt;hwptr
op_assign
l_int|0
suffix:semicolon
id|subs-&gt;hwptr_done
op_assign
l_int|0
suffix:semicolon
id|subs-&gt;transfer_sched
op_assign
l_int|0
suffix:semicolon
id|subs-&gt;transfer_done
op_assign
l_int|0
suffix:semicolon
id|subs-&gt;phase
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* clear urbs (to be sure) */
id|deactivate_urbs
c_func
(paren
id|subs
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|wait_clear_urbs
c_func
(paren
id|subs
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|snd_usb_playback
r_static
id|snd_pcm_hardware_t
id|snd_usb_playback
op_assign
(brace
dot
id|info
op_assign
(paren
id|SNDRV_PCM_INFO_MMAP
op_or
id|SNDRV_PCM_INFO_INTERLEAVED
op_or
id|SNDRV_PCM_INFO_BLOCK_TRANSFER
op_or
id|SNDRV_PCM_INFO_MMAP_VALID
)paren
comma
dot
id|buffer_bytes_max
op_assign
(paren
l_int|128
op_star
l_int|1024
)paren
comma
dot
id|period_bytes_min
op_assign
l_int|64
comma
dot
id|period_bytes_max
op_assign
(paren
l_int|128
op_star
l_int|1024
)paren
comma
dot
id|periods_min
op_assign
l_int|2
comma
dot
id|periods_max
op_assign
l_int|1024
comma
)brace
suffix:semicolon
DECL|variable|snd_usb_capture
r_static
id|snd_pcm_hardware_t
id|snd_usb_capture
op_assign
(brace
dot
id|info
op_assign
(paren
id|SNDRV_PCM_INFO_MMAP
op_or
id|SNDRV_PCM_INFO_INTERLEAVED
op_or
id|SNDRV_PCM_INFO_BLOCK_TRANSFER
op_or
id|SNDRV_PCM_INFO_MMAP_VALID
)paren
comma
dot
id|buffer_bytes_max
op_assign
(paren
l_int|128
op_star
l_int|1024
)paren
comma
dot
id|period_bytes_min
op_assign
l_int|64
comma
dot
id|period_bytes_max
op_assign
(paren
l_int|128
op_star
l_int|1024
)paren
comma
dot
id|periods_min
op_assign
l_int|2
comma
dot
id|periods_max
op_assign
l_int|1024
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * h/w constraints&n; */
macro_line|#ifdef HW_CONST_DEBUG
DECL|macro|hwc_debug
mdefine_line|#define hwc_debug(fmt, args...) printk(KERN_DEBUG fmt, ##args)
macro_line|#else
DECL|macro|hwc_debug
mdefine_line|#define hwc_debug(fmt, args...) /**/
macro_line|#endif
DECL|function|hw_check_valid_format
r_static
r_int
id|hw_check_valid_format
c_func
(paren
id|snd_pcm_hw_params_t
op_star
id|params
comma
r_struct
id|audioformat
op_star
id|fp
)paren
(brace
id|snd_interval_t
op_star
id|it
op_assign
id|hw_param_interval
c_func
(paren
id|params
comma
id|SNDRV_PCM_HW_PARAM_RATE
)paren
suffix:semicolon
id|snd_interval_t
op_star
id|ct
op_assign
id|hw_param_interval
c_func
(paren
id|params
comma
id|SNDRV_PCM_HW_PARAM_CHANNELS
)paren
suffix:semicolon
id|snd_mask_t
op_star
id|fmts
op_assign
id|hw_param_mask
c_func
(paren
id|params
comma
id|SNDRV_PCM_HW_PARAM_FORMAT
)paren
suffix:semicolon
multiline_comment|/* check the format */
r_if
c_cond
(paren
op_logical_neg
id|snd_mask_test
c_func
(paren
id|fmts
comma
id|fp-&gt;format
)paren
)paren
(brace
id|hwc_debug
c_func
(paren
l_string|&quot;   &gt; check: no supported format %d&bslash;n&quot;
comma
id|fp-&gt;format
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* check the channels */
r_if
c_cond
(paren
id|fp-&gt;channels
template_param
id|ct-&gt;max
)paren
(brace
id|hwc_debug
c_func
(paren
l_string|&quot;   &gt; check: no valid channels %d (%d/%d)&bslash;n&quot;
comma
id|fp-&gt;channels
comma
id|ct-&gt;min
comma
id|ct-&gt;max
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* check the rate is within the range */
r_if
c_cond
(paren
id|fp-&gt;rate_min
OG
id|it-&gt;max
op_logical_or
(paren
id|fp-&gt;rate_min
op_eq
id|it-&gt;max
op_logical_and
id|it-&gt;openmax
)paren
)paren
(brace
id|hwc_debug
c_func
(paren
l_string|&quot;   &gt; check: rate_min %d &gt; max %d&bslash;n&quot;
comma
id|fp-&gt;rate_min
comma
id|it-&gt;max
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fp-&gt;rate_max
OL
id|it-&gt;min
op_logical_or
(paren
id|fp-&gt;rate_max
op_eq
id|it-&gt;min
op_logical_and
id|it-&gt;openmin
)paren
)paren
(brace
id|hwc_debug
c_func
(paren
l_string|&quot;   &gt; check: rate_max %d &lt; min %d&bslash;n&quot;
comma
id|fp-&gt;rate_max
comma
id|it-&gt;min
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|hw_rule_rate
r_static
r_int
id|hw_rule_rate
c_func
(paren
id|snd_pcm_hw_params_t
op_star
id|params
comma
id|snd_pcm_hw_rule_t
op_star
id|rule
)paren
(brace
id|snd_usb_substream_t
op_star
id|subs
op_assign
id|rule
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|snd_interval_t
op_star
id|it
op_assign
id|hw_param_interval
c_func
(paren
id|params
comma
id|SNDRV_PCM_HW_PARAM_RATE
)paren
suffix:semicolon
r_int
r_int
id|rmin
comma
id|rmax
suffix:semicolon
r_int
id|changed
suffix:semicolon
id|hwc_debug
c_func
(paren
l_string|&quot;hw_rule_rate: (%d,%d)&bslash;n&quot;
comma
id|it-&gt;min
comma
id|it-&gt;max
)paren
suffix:semicolon
id|changed
op_assign
l_int|0
suffix:semicolon
id|rmin
op_assign
id|rmax
op_assign
l_int|0
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|subs-&gt;fmt_list
)paren
(brace
r_struct
id|audioformat
op_star
id|fp
suffix:semicolon
id|fp
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|audioformat
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hw_check_valid_format
c_func
(paren
id|params
comma
id|fp
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|changed
op_increment
)paren
(brace
r_if
c_cond
(paren
id|rmin
OG
id|fp-&gt;rate_min
)paren
id|rmin
op_assign
id|fp-&gt;rate_min
suffix:semicolon
r_if
c_cond
(paren
id|rmax
OL
id|fp-&gt;rate_max
)paren
id|rmax
op_assign
id|fp-&gt;rate_max
suffix:semicolon
)brace
r_else
(brace
id|rmin
op_assign
id|fp-&gt;rate_min
suffix:semicolon
id|rmax
op_assign
id|fp-&gt;rate_max
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|changed
)paren
(brace
id|hwc_debug
c_func
(paren
l_string|&quot;  --&gt; get empty&bslash;n&quot;
)paren
suffix:semicolon
id|it-&gt;empty
op_assign
l_int|1
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|changed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|it-&gt;min
OL
id|rmin
)paren
(brace
id|it-&gt;min
op_assign
id|rmin
suffix:semicolon
id|it-&gt;openmin
op_assign
l_int|0
suffix:semicolon
id|changed
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|it-&gt;max
OG
id|rmax
)paren
(brace
id|it-&gt;max
op_assign
id|rmax
suffix:semicolon
id|it-&gt;openmax
op_assign
l_int|0
suffix:semicolon
id|changed
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|snd_interval_checkempty
c_func
(paren
id|it
)paren
)paren
(brace
id|it-&gt;empty
op_assign
l_int|1
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|hwc_debug
c_func
(paren
l_string|&quot;  --&gt; (%d, %d) (changed = %d)&bslash;n&quot;
comma
id|it-&gt;min
comma
id|it-&gt;max
comma
id|changed
)paren
suffix:semicolon
r_return
id|changed
suffix:semicolon
)brace
DECL|function|hw_rule_channels
r_static
r_int
id|hw_rule_channels
c_func
(paren
id|snd_pcm_hw_params_t
op_star
id|params
comma
id|snd_pcm_hw_rule_t
op_star
id|rule
)paren
(brace
id|snd_usb_substream_t
op_star
id|subs
op_assign
id|rule
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|snd_interval_t
op_star
id|it
op_assign
id|hw_param_interval
c_func
(paren
id|params
comma
id|SNDRV_PCM_HW_PARAM_CHANNELS
)paren
suffix:semicolon
r_int
r_int
id|rmin
comma
id|rmax
suffix:semicolon
r_int
id|changed
suffix:semicolon
id|hwc_debug
c_func
(paren
l_string|&quot;hw_rule_channels: (%d,%d)&bslash;n&quot;
comma
id|it-&gt;min
comma
id|it-&gt;max
)paren
suffix:semicolon
id|changed
op_assign
l_int|0
suffix:semicolon
id|rmin
op_assign
id|rmax
op_assign
l_int|0
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|subs-&gt;fmt_list
)paren
(brace
r_struct
id|audioformat
op_star
id|fp
suffix:semicolon
id|fp
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|audioformat
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hw_check_valid_format
c_func
(paren
id|params
comma
id|fp
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|changed
op_increment
)paren
(brace
r_if
c_cond
(paren
id|rmin
OG
id|fp-&gt;channels
)paren
id|rmin
op_assign
id|fp-&gt;channels
suffix:semicolon
r_if
c_cond
(paren
id|rmax
OL
id|fp-&gt;channels
)paren
id|rmax
op_assign
id|fp-&gt;channels
suffix:semicolon
)brace
r_else
(brace
id|rmin
op_assign
id|fp-&gt;channels
suffix:semicolon
id|rmax
op_assign
id|fp-&gt;channels
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|changed
)paren
(brace
id|hwc_debug
c_func
(paren
l_string|&quot;  --&gt; get empty&bslash;n&quot;
)paren
suffix:semicolon
id|it-&gt;empty
op_assign
l_int|1
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|changed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|it-&gt;min
OL
id|rmin
)paren
(brace
id|it-&gt;min
op_assign
id|rmin
suffix:semicolon
id|it-&gt;openmin
op_assign
l_int|0
suffix:semicolon
id|changed
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|it-&gt;max
OG
id|rmax
)paren
(brace
id|it-&gt;max
op_assign
id|rmax
suffix:semicolon
id|it-&gt;openmax
op_assign
l_int|0
suffix:semicolon
id|changed
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|snd_interval_checkempty
c_func
(paren
id|it
)paren
)paren
(brace
id|it-&gt;empty
op_assign
l_int|1
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|hwc_debug
c_func
(paren
l_string|&quot;  --&gt; (%d, %d) (changed = %d)&bslash;n&quot;
comma
id|it-&gt;min
comma
id|it-&gt;max
comma
id|changed
)paren
suffix:semicolon
r_return
id|changed
suffix:semicolon
)brace
DECL|function|hw_rule_format
r_static
r_int
id|hw_rule_format
c_func
(paren
id|snd_pcm_hw_params_t
op_star
id|params
comma
id|snd_pcm_hw_rule_t
op_star
id|rule
)paren
(brace
id|snd_usb_substream_t
op_star
id|subs
op_assign
id|rule
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|snd_mask_t
op_star
id|fmt
op_assign
id|hw_param_mask
c_func
(paren
id|params
comma
id|SNDRV_PCM_HW_PARAM_FORMAT
)paren
suffix:semicolon
id|u64
id|fbits
suffix:semicolon
id|u32
id|oldbits
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|changed
suffix:semicolon
id|hwc_debug
c_func
(paren
l_string|&quot;hw_rule_format: %x:%x&bslash;n&quot;
comma
id|fmt-&gt;bits
(braket
l_int|0
)braket
comma
id|fmt-&gt;bits
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|fbits
op_assign
l_int|0
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|subs-&gt;fmt_list
)paren
(brace
r_struct
id|audioformat
op_star
id|fp
suffix:semicolon
id|fp
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|audioformat
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hw_check_valid_format
c_func
(paren
id|params
comma
id|fp
)paren
)paren
r_continue
suffix:semicolon
id|fbits
op_or_assign
(paren
l_int|1ULL
op_lshift
id|fp-&gt;format
)paren
suffix:semicolon
)brace
id|oldbits
(braket
l_int|0
)braket
op_assign
id|fmt-&gt;bits
(braket
l_int|0
)braket
suffix:semicolon
id|oldbits
(braket
l_int|1
)braket
op_assign
id|fmt-&gt;bits
(braket
l_int|1
)braket
suffix:semicolon
id|fmt-&gt;bits
(braket
l_int|0
)braket
op_and_assign
(paren
id|u32
)paren
id|fbits
suffix:semicolon
id|fmt-&gt;bits
(braket
l_int|1
)braket
op_and_assign
(paren
id|u32
)paren
(paren
id|fbits
op_rshift
l_int|32
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fmt-&gt;bits
(braket
l_int|0
)braket
op_logical_and
op_logical_neg
id|fmt-&gt;bits
(braket
l_int|1
)braket
)paren
(brace
id|hwc_debug
c_func
(paren
l_string|&quot;  --&gt; get empty&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|changed
op_assign
(paren
id|oldbits
(braket
l_int|0
)braket
op_ne
id|fmt-&gt;bits
(braket
l_int|0
)braket
op_logical_or
id|oldbits
(braket
l_int|1
)braket
op_ne
id|fmt-&gt;bits
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|hwc_debug
c_func
(paren
l_string|&quot;  --&gt; %x:%x (changed = %d)&bslash;n&quot;
comma
id|fmt-&gt;bits
(braket
l_int|0
)braket
comma
id|fmt-&gt;bits
(braket
l_int|1
)braket
comma
id|changed
)paren
suffix:semicolon
r_return
id|changed
suffix:semicolon
)brace
multiline_comment|/*&n; * check whether the registered audio formats need special hw-constraints&n; */
DECL|function|check_hw_params_convention
r_static
r_int
id|check_hw_params_convention
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
)paren
(brace
r_int
id|i
suffix:semicolon
id|u32
id|channels
(braket
l_int|64
)braket
suffix:semicolon
id|u32
id|rates
(braket
l_int|64
)braket
suffix:semicolon
id|u32
id|cmaster
comma
id|rmaster
suffix:semicolon
id|u32
id|rate_min
op_assign
l_int|0
comma
id|rate_max
op_assign
l_int|0
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|memset
c_func
(paren
id|channels
comma
l_int|0
comma
r_sizeof
(paren
id|channels
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|rates
comma
l_int|0
comma
r_sizeof
(paren
id|rates
)paren
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|subs-&gt;fmt_list
)paren
(brace
r_struct
id|audioformat
op_star
id|f
suffix:semicolon
id|f
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|audioformat
comma
id|list
)paren
suffix:semicolon
multiline_comment|/* unconventional channels? */
r_if
c_cond
(paren
id|f-&gt;channels
OG
l_int|32
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* continuous rate min/max matches? */
r_if
c_cond
(paren
id|f-&gt;rates
op_amp
id|SNDRV_PCM_RATE_CONTINUOUS
)paren
(brace
r_if
c_cond
(paren
id|rate_min
op_logical_and
id|f-&gt;rate_min
op_ne
id|rate_min
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|rate_max
op_logical_and
id|f-&gt;rate_max
op_ne
id|rate_max
)paren
r_return
l_int|1
suffix:semicolon
id|rate_min
op_assign
id|f-&gt;rate_min
suffix:semicolon
id|rate_max
op_assign
id|f-&gt;rate_max
suffix:semicolon
)brace
multiline_comment|/* combination of continuous rates and fixed rates? */
r_if
c_cond
(paren
id|rates
(braket
id|f-&gt;format
)braket
op_amp
id|SNDRV_PCM_RATE_CONTINUOUS
)paren
(brace
r_if
c_cond
(paren
id|f-&gt;rates
op_ne
id|rates
(braket
id|f-&gt;format
)braket
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|f-&gt;rates
op_amp
id|SNDRV_PCM_RATE_CONTINUOUS
)paren
(brace
r_if
c_cond
(paren
id|rates
(braket
id|f-&gt;format
)braket
op_logical_and
id|rates
(braket
id|f-&gt;format
)braket
op_ne
id|f-&gt;rates
)paren
r_return
l_int|1
suffix:semicolon
)brace
id|channels
(braket
id|f-&gt;format
)braket
op_or_assign
(paren
l_int|1
op_lshift
id|f-&gt;channels
)paren
suffix:semicolon
id|rates
(braket
id|f-&gt;format
)braket
op_or_assign
id|f-&gt;rates
suffix:semicolon
)brace
multiline_comment|/* check whether channels and rates match for all formats */
id|cmaster
op_assign
id|rmaster
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cmaster
op_ne
id|channels
(braket
id|i
)braket
op_logical_and
id|cmaster
op_logical_and
id|channels
(braket
id|i
)braket
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|rmaster
op_ne
id|rates
(braket
id|i
)braket
op_logical_and
id|rmaster
op_logical_and
id|rates
(braket
id|i
)braket
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|channels
(braket
id|i
)braket
)paren
id|cmaster
op_assign
id|channels
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|rates
(braket
id|i
)braket
)paren
id|rmaster
op_assign
id|rates
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/* check whether channels match for all distinct rates */
id|memset
c_func
(paren
id|channels
comma
l_int|0
comma
r_sizeof
(paren
id|channels
)paren
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|subs-&gt;fmt_list
)paren
(brace
r_struct
id|audioformat
op_star
id|f
suffix:semicolon
id|f
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|audioformat
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;rates
op_amp
id|SNDRV_PCM_RATE_CONTINUOUS
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|f-&gt;rates
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
id|channels
(braket
id|i
)braket
op_or_assign
(paren
l_int|1
op_lshift
id|f-&gt;channels
)paren
suffix:semicolon
)brace
)brace
id|cmaster
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cmaster
op_ne
id|channels
(braket
id|i
)braket
op_logical_and
id|cmaster
op_logical_and
id|channels
(braket
id|i
)braket
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|channels
(braket
id|i
)braket
)paren
id|cmaster
op_assign
id|channels
(braket
id|i
)braket
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * set up the runtime hardware information.&n; */
DECL|function|setup_hw_info
r_static
r_int
id|setup_hw_info
c_func
(paren
id|snd_pcm_runtime_t
op_star
id|runtime
comma
id|snd_usb_substream_t
op_star
id|subs
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_int
id|err
suffix:semicolon
id|runtime-&gt;hw.formats
op_assign
id|subs-&gt;formats
suffix:semicolon
id|runtime-&gt;hw.rate_min
op_assign
l_int|0x7fffffff
suffix:semicolon
id|runtime-&gt;hw.rate_max
op_assign
l_int|0
suffix:semicolon
id|runtime-&gt;hw.channels_min
op_assign
l_int|256
suffix:semicolon
id|runtime-&gt;hw.channels_max
op_assign
l_int|0
suffix:semicolon
id|runtime-&gt;hw.rates
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* check min/max rates and channels */
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|subs-&gt;fmt_list
)paren
(brace
r_struct
id|audioformat
op_star
id|fp
suffix:semicolon
id|fp
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|audioformat
comma
id|list
)paren
suffix:semicolon
id|runtime-&gt;hw.rates
op_or_assign
id|fp-&gt;rates
suffix:semicolon
r_if
c_cond
(paren
id|runtime-&gt;hw.rate_min
OG
id|fp-&gt;rate_min
)paren
id|runtime-&gt;hw.rate_min
op_assign
id|fp-&gt;rate_min
suffix:semicolon
r_if
c_cond
(paren
id|runtime-&gt;hw.rate_max
OL
id|fp-&gt;rate_max
)paren
id|runtime-&gt;hw.rate_max
op_assign
id|fp-&gt;rate_max
suffix:semicolon
r_if
c_cond
(paren
id|runtime-&gt;hw.channels_min
OG
id|fp-&gt;channels
)paren
id|runtime-&gt;hw.channels_min
op_assign
id|fp-&gt;channels
suffix:semicolon
r_if
c_cond
(paren
id|runtime-&gt;hw.channels_max
OL
id|fp-&gt;channels
)paren
id|runtime-&gt;hw.channels_max
op_assign
id|fp-&gt;channels
suffix:semicolon
r_if
c_cond
(paren
id|fp-&gt;fmt_type
op_eq
id|USB_FORMAT_TYPE_II
op_logical_and
id|fp-&gt;frame_size
OG
l_int|0
)paren
(brace
multiline_comment|/* FIXME: there might be more than one audio formats... */
id|runtime-&gt;hw.period_bytes_min
op_assign
id|runtime-&gt;hw.period_bytes_max
op_assign
id|fp-&gt;frame_size
suffix:semicolon
)brace
)brace
multiline_comment|/* set the period time minimum 1ms */
id|snd_pcm_hw_constraint_minmax
c_func
(paren
id|runtime
comma
id|SNDRV_PCM_HW_PARAM_PERIOD_TIME
comma
l_int|1000
op_star
id|MIN_PACKS_URB
comma
multiline_comment|/*(nrpacks * MAX_URBS) * 1000*/
id|UINT_MAX
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_hw_params_convention
c_func
(paren
id|subs
)paren
)paren
(brace
id|hwc_debug
c_func
(paren
l_string|&quot;setting extra hw constraints...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_pcm_hw_rule_add
c_func
(paren
id|runtime
comma
l_int|0
comma
id|SNDRV_PCM_HW_PARAM_RATE
comma
id|hw_rule_rate
comma
id|subs
comma
id|SNDRV_PCM_HW_PARAM_FORMAT
comma
id|SNDRV_PCM_HW_PARAM_CHANNELS
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_pcm_hw_rule_add
c_func
(paren
id|runtime
comma
l_int|0
comma
id|SNDRV_PCM_HW_PARAM_CHANNELS
comma
id|hw_rule_channels
comma
id|subs
comma
id|SNDRV_PCM_HW_PARAM_FORMAT
comma
id|SNDRV_PCM_HW_PARAM_RATE
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_pcm_hw_rule_add
c_func
(paren
id|runtime
comma
l_int|0
comma
id|SNDRV_PCM_HW_PARAM_FORMAT
comma
id|hw_rule_format
comma
id|subs
comma
id|SNDRV_PCM_HW_PARAM_RATE
comma
id|SNDRV_PCM_HW_PARAM_CHANNELS
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|snd_usb_pcm_open
r_static
r_int
id|snd_usb_pcm_open
c_func
(paren
id|snd_pcm_substream_t
op_star
id|substream
comma
r_int
id|direction
comma
id|snd_pcm_hardware_t
op_star
id|hw
)paren
(brace
id|snd_usb_stream_t
op_star
id|as
op_assign
id|snd_pcm_substream_chip
c_func
(paren
id|substream
)paren
suffix:semicolon
id|snd_pcm_runtime_t
op_star
id|runtime
op_assign
id|substream-&gt;runtime
suffix:semicolon
id|snd_usb_substream_t
op_star
id|subs
op_assign
op_amp
id|as-&gt;substream
(braket
id|direction
)braket
suffix:semicolon
id|subs-&gt;interface
op_assign
op_minus
l_int|1
suffix:semicolon
id|subs-&gt;format
op_assign
l_int|0
suffix:semicolon
id|runtime-&gt;hw
op_assign
op_star
id|hw
suffix:semicolon
id|runtime-&gt;private_data
op_assign
id|subs
suffix:semicolon
id|subs-&gt;pcm_substream
op_assign
id|substream
suffix:semicolon
r_return
id|setup_hw_info
c_func
(paren
id|runtime
comma
id|subs
)paren
suffix:semicolon
)brace
DECL|function|snd_usb_pcm_close
r_static
r_int
id|snd_usb_pcm_close
c_func
(paren
id|snd_pcm_substream_t
op_star
id|substream
comma
r_int
id|direction
)paren
(brace
id|snd_usb_stream_t
op_star
id|as
op_assign
id|snd_pcm_substream_chip
c_func
(paren
id|substream
)paren
suffix:semicolon
id|snd_usb_substream_t
op_star
id|subs
op_assign
op_amp
id|as-&gt;substream
(braket
id|direction
)braket
suffix:semicolon
r_if
c_cond
(paren
id|subs-&gt;interface
op_ge
l_int|0
)paren
(brace
id|usb_set_interface
c_func
(paren
id|subs-&gt;dev
comma
id|subs-&gt;interface
comma
l_int|0
)paren
suffix:semicolon
id|subs-&gt;interface
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|subs-&gt;pcm_substream
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|snd_usb_playback_open
r_static
r_int
id|snd_usb_playback_open
c_func
(paren
id|snd_pcm_substream_t
op_star
id|substream
)paren
(brace
r_return
id|snd_usb_pcm_open
c_func
(paren
id|substream
comma
id|SNDRV_PCM_STREAM_PLAYBACK
comma
op_amp
id|snd_usb_playback
)paren
suffix:semicolon
)brace
DECL|function|snd_usb_playback_close
r_static
r_int
id|snd_usb_playback_close
c_func
(paren
id|snd_pcm_substream_t
op_star
id|substream
)paren
(brace
r_return
id|snd_usb_pcm_close
c_func
(paren
id|substream
comma
id|SNDRV_PCM_STREAM_PLAYBACK
)paren
suffix:semicolon
)brace
DECL|function|snd_usb_capture_open
r_static
r_int
id|snd_usb_capture_open
c_func
(paren
id|snd_pcm_substream_t
op_star
id|substream
)paren
(brace
r_return
id|snd_usb_pcm_open
c_func
(paren
id|substream
comma
id|SNDRV_PCM_STREAM_CAPTURE
comma
op_amp
id|snd_usb_capture
)paren
suffix:semicolon
)brace
DECL|function|snd_usb_capture_close
r_static
r_int
id|snd_usb_capture_close
c_func
(paren
id|snd_pcm_substream_t
op_star
id|substream
)paren
(brace
r_return
id|snd_usb_pcm_close
c_func
(paren
id|substream
comma
id|SNDRV_PCM_STREAM_CAPTURE
)paren
suffix:semicolon
)brace
DECL|variable|snd_usb_playback_ops
r_static
id|snd_pcm_ops_t
id|snd_usb_playback_ops
op_assign
(brace
dot
id|open
op_assign
id|snd_usb_playback_open
comma
dot
id|close
op_assign
id|snd_usb_playback_close
comma
dot
id|ioctl
op_assign
id|snd_pcm_lib_ioctl
comma
dot
id|hw_params
op_assign
id|snd_usb_hw_params
comma
dot
id|hw_free
op_assign
id|snd_usb_hw_free
comma
dot
id|prepare
op_assign
id|snd_usb_pcm_prepare
comma
dot
id|trigger
op_assign
id|snd_usb_pcm_trigger
comma
dot
id|pointer
op_assign
id|snd_usb_pcm_pointer
comma
)brace
suffix:semicolon
DECL|variable|snd_usb_capture_ops
r_static
id|snd_pcm_ops_t
id|snd_usb_capture_ops
op_assign
(brace
dot
id|open
op_assign
id|snd_usb_capture_open
comma
dot
id|close
op_assign
id|snd_usb_capture_close
comma
dot
id|ioctl
op_assign
id|snd_pcm_lib_ioctl
comma
dot
id|hw_params
op_assign
id|snd_usb_hw_params
comma
dot
id|hw_free
op_assign
id|snd_usb_hw_free
comma
dot
id|prepare
op_assign
id|snd_usb_pcm_prepare
comma
dot
id|trigger
op_assign
id|snd_usb_pcm_trigger
comma
dot
id|pointer
op_assign
id|snd_usb_pcm_pointer
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * helper functions&n; */
multiline_comment|/*&n; * combine bytes and get an integer value&n; */
DECL|function|snd_usb_combine_bytes
r_int
r_int
id|snd_usb_combine_bytes
c_func
(paren
r_int
r_char
op_star
id|bytes
comma
r_int
id|size
)paren
(brace
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|1
suffix:colon
r_return
op_star
id|bytes
suffix:semicolon
r_case
l_int|2
suffix:colon
r_return
id|combine_word
c_func
(paren
id|bytes
)paren
suffix:semicolon
r_case
l_int|3
suffix:colon
r_return
id|combine_triple
c_func
(paren
id|bytes
)paren
suffix:semicolon
r_case
l_int|4
suffix:colon
r_return
id|combine_quad
c_func
(paren
id|bytes
)paren
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * parse descriptor buffer and return the pointer starting the given&n; * descriptor type.&n; */
DECL|function|snd_usb_find_desc
r_void
op_star
id|snd_usb_find_desc
c_func
(paren
r_void
op_star
id|descstart
comma
r_int
id|desclen
comma
r_void
op_star
id|after
comma
id|u8
id|dtype
)paren
(brace
id|u8
op_star
id|p
comma
op_star
id|end
comma
op_star
id|next
suffix:semicolon
id|p
op_assign
id|descstart
suffix:semicolon
id|end
op_assign
id|p
op_plus
id|desclen
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|p
OL
id|end
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
OL
l_int|2
)paren
r_return
l_int|NULL
suffix:semicolon
id|next
op_assign
id|p
op_plus
id|p
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|next
OG
id|end
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|1
)braket
op_eq
id|dtype
op_logical_and
(paren
op_logical_neg
id|after
op_logical_or
(paren
r_void
op_star
)paren
id|p
OG
id|after
)paren
)paren
(brace
r_return
id|p
suffix:semicolon
)brace
id|p
op_assign
id|next
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * find a class-specified interface descriptor with the given subtype.&n; */
DECL|function|snd_usb_find_csint_desc
r_void
op_star
id|snd_usb_find_csint_desc
c_func
(paren
r_void
op_star
id|buffer
comma
r_int
id|buflen
comma
r_void
op_star
id|after
comma
id|u8
id|dsubtype
)paren
(brace
r_int
r_char
op_star
id|p
op_assign
id|after
suffix:semicolon
r_while
c_loop
(paren
(paren
id|p
op_assign
id|snd_usb_find_desc
c_func
(paren
id|buffer
comma
id|buflen
comma
id|p
comma
id|USB_DT_CS_INTERFACE
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_ge
l_int|3
op_logical_and
id|p
(braket
l_int|2
)braket
op_eq
id|dsubtype
)paren
r_return
id|p
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Wrapper for usb_control_msg().&n; * Allocates a temp buffer to prevent dmaing from/to the stack.&n; */
DECL|function|snd_usb_ctl_msg
r_int
id|snd_usb_ctl_msg
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|pipe
comma
id|__u8
id|request
comma
id|__u8
id|requesttype
comma
id|__u16
id|value
comma
id|__u16
id|index
comma
r_void
op_star
id|data
comma
id|__u16
id|size
comma
r_int
id|timeout
)paren
(brace
r_int
id|err
suffix:semicolon
r_void
op_star
id|buf
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
l_int|0
)paren
(brace
id|buf
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
id|data
comma
id|size
)paren
suffix:semicolon
)brace
id|err
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|pipe
comma
id|request
comma
id|requesttype
comma
id|value
comma
id|index
comma
id|buf
comma
id|size
comma
id|timeout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|data
comma
id|buf
comma
id|size
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * entry point for linux usb interface&n; */
r_static
r_int
id|usb_audio_probe
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
suffix:semicolon
r_static
r_void
id|usb_audio_disconnect
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
suffix:semicolon
DECL|variable|usb_audio_ids
r_static
r_struct
id|usb_device_id
id|usb_audio_ids
(braket
)braket
op_assign
(brace
macro_line|#include &quot;usbquirks.h&quot;
(brace
dot
id|match_flags
op_assign
(paren
id|USB_DEVICE_ID_MATCH_INT_CLASS
op_or
id|USB_DEVICE_ID_MATCH_INT_SUBCLASS
)paren
comma
dot
id|bInterfaceClass
op_assign
id|USB_CLASS_AUDIO
comma
dot
id|bInterfaceSubClass
op_assign
id|USB_SUBCLASS_AUDIO_CONTROL
)brace
comma
(brace
)brace
multiline_comment|/* Terminating entry */
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|usb
comma
id|usb_audio_ids
)paren
suffix:semicolon
DECL|variable|usb_audio_driver
r_static
r_struct
id|usb_driver
id|usb_audio_driver
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;snd-usb-audio&quot;
comma
dot
id|probe
op_assign
id|usb_audio_probe
comma
dot
id|disconnect
op_assign
id|usb_audio_disconnect
comma
dot
id|id_table
op_assign
id|usb_audio_ids
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * proc interface for list the supported pcm formats&n; */
DECL|function|proc_dump_substream_formats
r_static
r_void
id|proc_dump_substream_formats
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
id|snd_info_buffer_t
op_star
id|buffer
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_static
r_char
op_star
id|sync_types
(braket
l_int|4
)braket
op_assign
(brace
l_string|&quot;NONE&quot;
comma
l_string|&quot;ASYNC&quot;
comma
l_string|&quot;ADAPTIVE&quot;
comma
l_string|&quot;SYNC&quot;
)brace
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|subs-&gt;fmt_list
)paren
(brace
r_struct
id|audioformat
op_star
id|fp
suffix:semicolon
id|fp
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|audioformat
comma
id|list
)paren
suffix:semicolon
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;  Interface %d&bslash;n&quot;
comma
id|fp-&gt;iface
)paren
suffix:semicolon
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;    Altset %d&bslash;n&quot;
comma
id|fp-&gt;altsetting
)paren
suffix:semicolon
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;    Format: %s&bslash;n&quot;
comma
id|snd_pcm_format_name
c_func
(paren
id|fp-&gt;format
)paren
)paren
suffix:semicolon
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;    Channels: %d&bslash;n&quot;
comma
id|fp-&gt;channels
)paren
suffix:semicolon
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;    Endpoint: %d %s (%s)&bslash;n&quot;
comma
id|fp-&gt;endpoint
op_amp
id|USB_ENDPOINT_NUMBER_MASK
comma
id|fp-&gt;endpoint
op_amp
id|USB_DIR_IN
ques
c_cond
l_string|&quot;IN&quot;
suffix:colon
l_string|&quot;OUT&quot;
comma
id|sync_types
(braket
(paren
id|fp-&gt;ep_attr
op_amp
id|EP_ATTR_MASK
)paren
op_rshift
l_int|2
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fp-&gt;rates
op_amp
id|SNDRV_PCM_RATE_CONTINUOUS
)paren
(brace
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;    Rates: %d - %d (continuous)&bslash;n&quot;
comma
id|fp-&gt;rate_min
comma
id|fp-&gt;rate_max
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|i
suffix:semicolon
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;    Rates: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fp-&gt;nr_rates
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;, &quot;
)paren
suffix:semicolon
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%d&quot;
comma
id|fp-&gt;rate_table
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
singleline_comment|// snd_iprintf(buffer, &quot;    Max Packet Size = %d&bslash;n&quot;, fp-&gt;maxpacksize);
singleline_comment|// snd_iprintf(buffer, &quot;    EP Attribute = 0x%x&bslash;n&quot;, fp-&gt;attributes);
)brace
)brace
DECL|function|proc_dump_substream_status
r_static
r_void
id|proc_dump_substream_status
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
comma
id|snd_info_buffer_t
op_star
id|buffer
)paren
(brace
r_if
c_cond
(paren
id|subs-&gt;running
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;  Status: Running&bslash;n&quot;
)paren
suffix:semicolon
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;    Interface = %d&bslash;n&quot;
comma
id|subs-&gt;interface
)paren
suffix:semicolon
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;    Altset = %d&bslash;n&quot;
comma
id|subs-&gt;format
)paren
suffix:semicolon
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;    URBs = %d [ &quot;
comma
id|subs-&gt;nurbs
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|subs-&gt;nurbs
suffix:semicolon
id|i
op_increment
)paren
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%d &quot;
comma
id|subs-&gt;dataurb
(braket
id|i
)braket
dot
id|packets
)paren
suffix:semicolon
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;    Packet Size = %d&bslash;n&quot;
comma
id|subs-&gt;curpacksize
)paren
suffix:semicolon
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;    Momentary freq = %u Hz&bslash;n&quot;
comma
id|snd_usb_get_speed
c_func
(paren
id|subs-&gt;dev
)paren
op_eq
id|USB_SPEED_FULL
ques
c_cond
id|get_full_speed_hz
c_func
(paren
id|subs-&gt;freqm
)paren
suffix:colon
id|get_high_speed_hz
c_func
(paren
id|subs-&gt;freqm
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;  Status: Stop&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|proc_pcm_format_read
r_static
r_void
id|proc_pcm_format_read
c_func
(paren
id|snd_info_entry_t
op_star
id|entry
comma
id|snd_info_buffer_t
op_star
id|buffer
)paren
(brace
id|snd_usb_stream_t
op_star
id|stream
op_assign
id|entry-&gt;private_data
suffix:semicolon
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%s : %s&bslash;n&quot;
comma
id|stream-&gt;chip-&gt;card-&gt;longname
comma
id|stream-&gt;pcm-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stream-&gt;substream
(braket
id|SNDRV_PCM_STREAM_PLAYBACK
)braket
dot
id|num_formats
)paren
(brace
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;&bslash;nPlayback:&bslash;n&quot;
)paren
suffix:semicolon
id|proc_dump_substream_status
c_func
(paren
op_amp
id|stream-&gt;substream
(braket
id|SNDRV_PCM_STREAM_PLAYBACK
)braket
comma
id|buffer
)paren
suffix:semicolon
id|proc_dump_substream_formats
c_func
(paren
op_amp
id|stream-&gt;substream
(braket
id|SNDRV_PCM_STREAM_PLAYBACK
)braket
comma
id|buffer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stream-&gt;substream
(braket
id|SNDRV_PCM_STREAM_CAPTURE
)braket
dot
id|num_formats
)paren
(brace
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;&bslash;nCapture:&bslash;n&quot;
)paren
suffix:semicolon
id|proc_dump_substream_status
c_func
(paren
op_amp
id|stream-&gt;substream
(braket
id|SNDRV_PCM_STREAM_CAPTURE
)braket
comma
id|buffer
)paren
suffix:semicolon
id|proc_dump_substream_formats
c_func
(paren
op_amp
id|stream-&gt;substream
(braket
id|SNDRV_PCM_STREAM_CAPTURE
)braket
comma
id|buffer
)paren
suffix:semicolon
)brace
)brace
DECL|function|proc_pcm_format_add
r_static
r_void
id|proc_pcm_format_add
c_func
(paren
id|snd_usb_stream_t
op_star
id|stream
)paren
(brace
id|snd_info_entry_t
op_star
id|entry
suffix:semicolon
r_char
id|name
(braket
l_int|32
)braket
suffix:semicolon
id|snd_card_t
op_star
id|card
op_assign
id|stream-&gt;chip-&gt;card
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;stream%d&quot;
comma
id|stream-&gt;pcm_index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|snd_card_proc_new
c_func
(paren
id|card
comma
id|name
comma
op_amp
id|entry
)paren
)paren
id|snd_info_set_text_ops
c_func
(paren
id|entry
comma
id|stream
comma
l_int|1024
comma
id|proc_pcm_format_read
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * initialize the substream instance.&n; */
DECL|function|init_substream
r_static
r_void
id|init_substream
c_func
(paren
id|snd_usb_stream_t
op_star
id|as
comma
r_int
id|stream
comma
r_struct
id|audioformat
op_star
id|fp
)paren
(brace
id|snd_usb_substream_t
op_star
id|subs
op_assign
op_amp
id|as-&gt;substream
(braket
id|stream
)braket
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|subs-&gt;fmt_list
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|subs-&gt;lock
)paren
suffix:semicolon
id|subs-&gt;stream
op_assign
id|as
suffix:semicolon
id|subs-&gt;direction
op_assign
id|stream
suffix:semicolon
id|subs-&gt;dev
op_assign
id|as-&gt;chip-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|snd_usb_get_speed
c_func
(paren
id|subs-&gt;dev
)paren
op_eq
id|USB_SPEED_FULL
)paren
id|subs-&gt;ops
op_assign
id|audio_urb_ops
(braket
id|stream
)braket
suffix:semicolon
r_else
id|subs-&gt;ops
op_assign
id|audio_urb_ops_high_speed
(braket
id|stream
)braket
suffix:semicolon
id|snd_pcm_lib_preallocate_pages
c_func
(paren
id|as-&gt;pcm-&gt;streams
(braket
id|stream
)braket
dot
id|substream
comma
id|SNDRV_DMA_TYPE_CONTINUOUS
comma
id|snd_dma_continuous_data
c_func
(paren
id|GFP_KERNEL
)paren
comma
l_int|64
op_star
l_int|1024
comma
l_int|128
op_star
l_int|1024
)paren
suffix:semicolon
id|snd_pcm_set_ops
c_func
(paren
id|as-&gt;pcm
comma
id|stream
comma
id|stream
op_eq
id|SNDRV_PCM_STREAM_PLAYBACK
ques
c_cond
op_amp
id|snd_usb_playback_ops
suffix:colon
op_amp
id|snd_usb_capture_ops
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|fp-&gt;list
comma
op_amp
id|subs-&gt;fmt_list
)paren
suffix:semicolon
id|subs-&gt;formats
op_or_assign
l_int|1ULL
op_lshift
id|fp-&gt;format
suffix:semicolon
id|subs-&gt;endpoint
op_assign
id|fp-&gt;endpoint
suffix:semicolon
id|subs-&gt;num_formats
op_increment
suffix:semicolon
id|subs-&gt;fmt_type
op_assign
id|fp-&gt;fmt_type
suffix:semicolon
)brace
multiline_comment|/*&n; * free a substream&n; */
DECL|function|free_substream
r_static
r_void
id|free_substream
c_func
(paren
id|snd_usb_substream_t
op_star
id|subs
)paren
(brace
r_struct
id|list_head
op_star
id|p
comma
op_star
id|n
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subs-&gt;num_formats
)paren
r_return
suffix:semicolon
multiline_comment|/* not initialized */
id|list_for_each_safe
c_func
(paren
id|p
comma
id|n
comma
op_amp
id|subs-&gt;fmt_list
)paren
(brace
r_struct
id|audioformat
op_star
id|fp
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|audioformat
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fp-&gt;rate_table
)paren
id|kfree
c_func
(paren
id|fp-&gt;rate_table
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * free a usb stream instance&n; */
DECL|function|snd_usb_audio_stream_free
r_static
r_void
id|snd_usb_audio_stream_free
c_func
(paren
id|snd_usb_stream_t
op_star
id|stream
)paren
(brace
id|free_substream
c_func
(paren
op_amp
id|stream-&gt;substream
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|free_substream
c_func
(paren
op_amp
id|stream-&gt;substream
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|stream-&gt;list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|stream
)paren
suffix:semicolon
)brace
DECL|function|snd_usb_audio_pcm_free
r_static
r_void
id|snd_usb_audio_pcm_free
c_func
(paren
id|snd_pcm_t
op_star
id|pcm
)paren
(brace
id|snd_usb_stream_t
op_star
id|stream
op_assign
id|pcm-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|stream
)paren
(brace
id|stream-&gt;pcm
op_assign
l_int|NULL
suffix:semicolon
id|snd_pcm_lib_preallocate_free_for_all
c_func
(paren
id|pcm
)paren
suffix:semicolon
id|snd_usb_audio_stream_free
c_func
(paren
id|stream
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * add this endpoint to the chip instance.&n; * if a stream with the same endpoint already exists, append to it.&n; * if not, create a new pcm stream.&n; */
DECL|function|add_audio_endpoint
r_static
r_int
id|add_audio_endpoint
c_func
(paren
id|snd_usb_audio_t
op_star
id|chip
comma
r_int
id|stream
comma
r_struct
id|audioformat
op_star
id|fp
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|snd_usb_stream_t
op_star
id|as
suffix:semicolon
id|snd_usb_substream_t
op_star
id|subs
suffix:semicolon
id|snd_pcm_t
op_star
id|pcm
suffix:semicolon
r_int
id|err
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|chip-&gt;pcm_list
)paren
(brace
id|as
op_assign
id|list_entry
c_func
(paren
id|p
comma
id|snd_usb_stream_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|as-&gt;fmt_type
op_ne
id|fp-&gt;fmt_type
)paren
r_continue
suffix:semicolon
id|subs
op_assign
op_amp
id|as-&gt;substream
(braket
id|stream
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subs-&gt;endpoint
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|subs-&gt;endpoint
op_eq
id|fp-&gt;endpoint
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|fp-&gt;list
comma
op_amp
id|subs-&gt;fmt_list
)paren
suffix:semicolon
id|subs-&gt;num_formats
op_increment
suffix:semicolon
id|subs-&gt;formats
op_or_assign
l_int|1ULL
op_lshift
id|fp-&gt;format
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* look for an empty stream */
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|chip-&gt;pcm_list
)paren
(brace
id|as
op_assign
id|list_entry
c_func
(paren
id|p
comma
id|snd_usb_stream_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|as-&gt;fmt_type
op_ne
id|fp-&gt;fmt_type
)paren
r_continue
suffix:semicolon
id|subs
op_assign
op_amp
id|as-&gt;substream
(braket
id|stream
)braket
suffix:semicolon
r_if
c_cond
(paren
id|subs-&gt;endpoint
)paren
r_continue
suffix:semicolon
id|err
op_assign
id|snd_pcm_new_stream
c_func
(paren
id|as-&gt;pcm
comma
id|stream
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|init_substream
c_func
(paren
id|as
comma
id|stream
comma
id|fp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* create a new pcm */
id|as
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|as
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|as
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|as
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|as
)paren
)paren
suffix:semicolon
id|as-&gt;pcm_index
op_assign
id|chip-&gt;pcm_devs
suffix:semicolon
id|as-&gt;chip
op_assign
id|chip
suffix:semicolon
id|as-&gt;fmt_type
op_assign
id|fp-&gt;fmt_type
suffix:semicolon
id|err
op_assign
id|snd_pcm_new
c_func
(paren
id|chip-&gt;card
comma
l_string|&quot;USB Audio&quot;
comma
id|chip-&gt;pcm_devs
comma
id|stream
op_eq
id|SNDRV_PCM_STREAM_PLAYBACK
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|stream
op_eq
id|SNDRV_PCM_STREAM_PLAYBACK
ques
c_cond
l_int|0
suffix:colon
l_int|1
comma
op_amp
id|pcm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|as
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|as-&gt;pcm
op_assign
id|pcm
suffix:semicolon
id|pcm-&gt;private_data
op_assign
id|as
suffix:semicolon
id|pcm-&gt;private_free
op_assign
id|snd_usb_audio_pcm_free
suffix:semicolon
id|pcm-&gt;info_flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;pcm_devs
OG
l_int|0
)paren
id|sprintf
c_func
(paren
id|pcm-&gt;name
comma
l_string|&quot;USB Audio #%d&quot;
comma
id|chip-&gt;pcm_devs
)paren
suffix:semicolon
r_else
id|strcpy
c_func
(paren
id|pcm-&gt;name
comma
l_string|&quot;USB Audio&quot;
)paren
suffix:semicolon
id|init_substream
c_func
(paren
id|as
comma
id|stream
comma
id|fp
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|as-&gt;list
comma
op_amp
id|chip-&gt;pcm_list
)paren
suffix:semicolon
id|chip-&gt;pcm_devs
op_increment
suffix:semicolon
id|proc_pcm_format_add
c_func
(paren
id|as
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * check if the device uses big-endian samples&n; */
DECL|function|is_big_endian_format
r_static
r_int
id|is_big_endian_format
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|audioformat
op_star
id|fp
)paren
(brace
multiline_comment|/* M-Audio */
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idVendor
)paren
op_eq
l_int|0x0763
)paren
(brace
multiline_comment|/* Quattro: captured data only */
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idProduct
)paren
op_eq
l_int|0x2001
op_logical_and
id|fp-&gt;endpoint
op_amp
id|USB_DIR_IN
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Audiophile USB */
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idProduct
)paren
op_eq
l_int|0x2003
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * parse the audio format type I descriptor&n; * and returns the corresponding pcm format&n; *&n; * @dev: usb device&n; * @fp: audioformat record&n; * @format: the format tag (wFormatTag)&n; * @fmt: the format type descriptor&n; */
DECL|function|parse_audio_format_i_type
r_static
r_int
id|parse_audio_format_i_type
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|audioformat
op_star
id|fp
comma
r_int
id|format
comma
r_int
r_char
op_star
id|fmt
)paren
(brace
r_int
id|pcm_format
suffix:semicolon
r_int
id|sample_width
comma
id|sample_bytes
suffix:semicolon
multiline_comment|/* FIXME: correct endianess and sign? */
id|pcm_format
op_assign
op_minus
l_int|1
suffix:semicolon
id|sample_width
op_assign
id|fmt
(braket
l_int|6
)braket
suffix:semicolon
id|sample_bytes
op_assign
id|fmt
(braket
l_int|5
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|format
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* some devices don&squot;t define this correctly... */
id|snd_printdd
c_func
(paren
id|KERN_INFO
l_string|&quot;%d:%u:%d : format type 0 is detected, processed as PCM&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|fp-&gt;iface
comma
id|fp-&gt;altsetting
)paren
suffix:semicolon
multiline_comment|/* fall-through */
r_case
id|USB_AUDIO_FORMAT_PCM
suffix:colon
r_if
c_cond
(paren
id|sample_width
OG
id|sample_bytes
op_star
l_int|8
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%d:%u:%d : sample bitwidth %d in over sample bytes %d&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|fp-&gt;iface
comma
id|fp-&gt;altsetting
comma
id|sample_width
comma
id|sample_bytes
)paren
suffix:semicolon
)brace
multiline_comment|/* check the format byte size */
r_switch
c_cond
(paren
id|fmt
(braket
l_int|5
)braket
)paren
(brace
r_case
l_int|1
suffix:colon
id|pcm_format
op_assign
id|SNDRV_PCM_FORMAT_S8
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|is_big_endian_format
c_func
(paren
id|dev
comma
id|fp
)paren
)paren
id|pcm_format
op_assign
id|SNDRV_PCM_FORMAT_S16_BE
suffix:semicolon
multiline_comment|/* grrr, big endian!! */
r_else
id|pcm_format
op_assign
id|SNDRV_PCM_FORMAT_S16_LE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|is_big_endian_format
c_func
(paren
id|dev
comma
id|fp
)paren
)paren
id|pcm_format
op_assign
id|SNDRV_PCM_FORMAT_S24_3BE
suffix:semicolon
multiline_comment|/* grrr, big endian!! */
r_else
id|pcm_format
op_assign
id|SNDRV_PCM_FORMAT_S24_3LE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|pcm_format
op_assign
id|SNDRV_PCM_FORMAT_S32_LE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|snd_printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%d:%u:%d : unsupported sample bitwidth %d in %d bytes&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|fp-&gt;iface
comma
id|fp-&gt;altsetting
comma
id|sample_width
comma
id|sample_bytes
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|USB_AUDIO_FORMAT_PCM8
suffix:colon
multiline_comment|/* Dallas DS4201 workaround */
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idVendor
)paren
op_eq
l_int|0x04fa
op_logical_and
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idProduct
)paren
op_eq
l_int|0x4201
)paren
id|pcm_format
op_assign
id|SNDRV_PCM_FORMAT_S8
suffix:semicolon
r_else
id|pcm_format
op_assign
id|SNDRV_PCM_FORMAT_U8
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_AUDIO_FORMAT_IEEE_FLOAT
suffix:colon
id|pcm_format
op_assign
id|SNDRV_PCM_FORMAT_FLOAT_LE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_AUDIO_FORMAT_ALAW
suffix:colon
id|pcm_format
op_assign
id|SNDRV_PCM_FORMAT_A_LAW
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_AUDIO_FORMAT_MU_LAW
suffix:colon
id|pcm_format
op_assign
id|SNDRV_PCM_FORMAT_MU_LAW
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|snd_printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%d:%u:%d : unsupported format type %d&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|fp-&gt;iface
comma
id|fp-&gt;altsetting
comma
id|format
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|pcm_format
suffix:semicolon
)brace
multiline_comment|/*&n; * parse the format descriptor and stores the possible sample rates&n; * on the audioformat table.&n; *&n; * @dev: usb device&n; * @fp: audioformat record&n; * @fmt: the format descriptor&n; * @offset: the start offset of descriptor pointing the rate type&n; *          (7 for type I and II, 8 for type II)&n; */
DECL|function|parse_audio_format_rates
r_static
r_int
id|parse_audio_format_rates
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|audioformat
op_star
id|fp
comma
r_int
r_char
op_star
id|fmt
comma
r_int
id|offset
)paren
(brace
r_int
id|nr_rates
op_assign
id|fmt
(braket
id|offset
)braket
suffix:semicolon
r_if
c_cond
(paren
id|fmt
(braket
l_int|0
)braket
OL
id|offset
op_plus
l_int|1
op_plus
l_int|3
op_star
(paren
id|nr_rates
ques
c_cond
id|nr_rates
suffix:colon
l_int|2
)paren
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%d:%u:%d : invalid FORMAT_TYPE desc&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|fp-&gt;iface
comma
id|fp-&gt;altsetting
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nr_rates
)paren
(brace
multiline_comment|/*&n;&t;&t; * build the rate table and bitmap flags&n;&t;&t; */
r_int
id|r
comma
id|idx
comma
id|c
suffix:semicolon
multiline_comment|/* this table corresponds to the SNDRV_PCM_RATE_XXX bit */
r_static
r_int
r_int
id|conv_rates
(braket
)braket
op_assign
(brace
l_int|5512
comma
l_int|8000
comma
l_int|11025
comma
l_int|16000
comma
l_int|22050
comma
l_int|32000
comma
l_int|44100
comma
l_int|48000
comma
l_int|64000
comma
l_int|88200
comma
l_int|96000
comma
l_int|176400
comma
l_int|192000
)brace
suffix:semicolon
id|fp-&gt;rate_table
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_int
)paren
op_star
id|nr_rates
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fp-&gt;rate_table
op_eq
l_int|NULL
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cannot malloc&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|fp-&gt;nr_rates
op_assign
id|nr_rates
suffix:semicolon
id|fp-&gt;rate_min
op_assign
id|fp-&gt;rate_max
op_assign
id|combine_triple
c_func
(paren
op_amp
id|fmt
(braket
l_int|8
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|r
op_assign
l_int|0
comma
id|idx
op_assign
id|offset
op_plus
l_int|1
suffix:semicolon
id|r
OL
id|nr_rates
suffix:semicolon
id|r
op_increment
comma
id|idx
op_add_assign
l_int|3
)paren
(brace
r_int
r_int
id|rate
op_assign
id|fp-&gt;rate_table
(braket
id|r
)braket
op_assign
id|combine_triple
c_func
(paren
op_amp
id|fmt
(braket
id|idx
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rate
OL
id|fp-&gt;rate_min
)paren
id|fp-&gt;rate_min
op_assign
id|rate
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rate
OG
id|fp-&gt;rate_max
)paren
id|fp-&gt;rate_max
op_assign
id|rate
suffix:semicolon
r_for
c_loop
(paren
id|c
op_assign
l_int|0
suffix:semicolon
id|c
OL
(paren
r_int
)paren
id|ARRAY_SIZE
c_func
(paren
id|conv_rates
)paren
suffix:semicolon
id|c
op_increment
)paren
(brace
r_if
c_cond
(paren
id|rate
op_eq
id|conv_rates
(braket
id|c
)braket
)paren
(brace
id|fp-&gt;rates
op_or_assign
(paren
l_int|1
op_lshift
id|c
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* continuous rates */
id|fp-&gt;rates
op_assign
id|SNDRV_PCM_RATE_CONTINUOUS
suffix:semicolon
id|fp-&gt;rate_min
op_assign
id|combine_triple
c_func
(paren
op_amp
id|fmt
(braket
id|offset
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|fp-&gt;rate_max
op_assign
id|combine_triple
c_func
(paren
op_amp
id|fmt
(braket
id|offset
op_plus
l_int|4
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * parse the format type I and III descriptors&n; */
DECL|function|parse_audio_format_i
r_static
r_int
id|parse_audio_format_i
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|audioformat
op_star
id|fp
comma
r_int
id|format
comma
r_int
r_char
op_star
id|fmt
)paren
(brace
r_int
id|pcm_format
suffix:semicolon
r_if
c_cond
(paren
id|fmt
(braket
l_int|3
)braket
op_eq
id|USB_FORMAT_TYPE_III
)paren
(brace
multiline_comment|/* FIXME: the format type is really IECxxx&n;&t;&t; *        but we give normal PCM format to get the existing&n;&t;&t; *        apps working...&n;&t;&t; */
id|pcm_format
op_assign
id|SNDRV_PCM_FORMAT_S16_LE
suffix:semicolon
)brace
r_else
(brace
id|pcm_format
op_assign
id|parse_audio_format_i_type
c_func
(paren
id|dev
comma
id|fp
comma
id|format
comma
id|fmt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcm_format
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|fp-&gt;format
op_assign
id|pcm_format
suffix:semicolon
id|fp-&gt;channels
op_assign
id|fmt
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
id|fp-&gt;channels
OL
l_int|1
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%d:%u:%d : invalid channels %d&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|fp-&gt;iface
comma
id|fp-&gt;altsetting
comma
id|fp-&gt;channels
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|parse_audio_format_rates
c_func
(paren
id|dev
comma
id|fp
comma
id|fmt
comma
l_int|7
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * prase the format type II descriptor&n; */
DECL|function|parse_audio_format_ii
r_static
r_int
id|parse_audio_format_ii
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|audioformat
op_star
id|fp
comma
r_int
id|format
comma
r_int
r_char
op_star
id|fmt
)paren
(brace
r_int
id|brate
comma
id|framesize
suffix:semicolon
r_switch
c_cond
(paren
id|format
)paren
(brace
r_case
id|USB_AUDIO_FORMAT_AC3
suffix:colon
multiline_comment|/* FIXME: there is no AC3 format defined yet */
singleline_comment|// fp-&gt;format = SNDRV_PCM_FORMAT_AC3;
id|fp-&gt;format
op_assign
id|SNDRV_PCM_FORMAT_U8
suffix:semicolon
multiline_comment|/* temporarily hack to receive byte streams */
r_break
suffix:semicolon
r_case
id|USB_AUDIO_FORMAT_MPEG
suffix:colon
id|fp-&gt;format
op_assign
id|SNDRV_PCM_FORMAT_MPEG
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|snd_printd
c_func
(paren
id|KERN_INFO
l_string|&quot;%d:%u:%d : unknown format tag 0x%x is detected.  processed as MPEG.&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|fp-&gt;iface
comma
id|fp-&gt;altsetting
comma
id|format
)paren
suffix:semicolon
id|fp-&gt;format
op_assign
id|SNDRV_PCM_FORMAT_MPEG
suffix:semicolon
r_break
suffix:semicolon
)brace
id|fp-&gt;channels
op_assign
l_int|1
suffix:semicolon
id|brate
op_assign
id|combine_word
c_func
(paren
op_amp
id|fmt
(braket
l_int|4
)braket
)paren
suffix:semicolon
multiline_comment|/* fmt[4,5] : wMaxBitRate (in kbps) */
id|framesize
op_assign
id|combine_word
c_func
(paren
op_amp
id|fmt
(braket
l_int|6
)braket
)paren
suffix:semicolon
multiline_comment|/* fmt[6,7]: wSamplesPerFrame */
id|snd_printd
c_func
(paren
id|KERN_INFO
l_string|&quot;found format II with max.bitrate = %d, frame size=%d&bslash;n&quot;
comma
id|brate
comma
id|framesize
)paren
suffix:semicolon
id|fp-&gt;frame_size
op_assign
id|framesize
suffix:semicolon
r_return
id|parse_audio_format_rates
c_func
(paren
id|dev
comma
id|fp
comma
id|fmt
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/* fmt[8..] sample rates */
)brace
DECL|function|parse_audio_format
r_static
r_int
id|parse_audio_format
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|audioformat
op_star
id|fp
comma
r_int
id|format
comma
r_int
r_char
op_star
id|fmt
comma
r_int
id|stream
)paren
(brace
r_int
id|err
suffix:semicolon
r_switch
c_cond
(paren
id|fmt
(braket
l_int|3
)braket
)paren
(brace
r_case
id|USB_FORMAT_TYPE_I
suffix:colon
r_case
id|USB_FORMAT_TYPE_III
suffix:colon
id|err
op_assign
id|parse_audio_format_i
c_func
(paren
id|dev
comma
id|fp
comma
id|format
comma
id|fmt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_FORMAT_TYPE_II
suffix:colon
id|err
op_assign
id|parse_audio_format_ii
c_func
(paren
id|dev
comma
id|fp
comma
id|format
comma
id|fmt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|snd_printd
c_func
(paren
id|KERN_INFO
l_string|&quot;%d:%u:%d : format type %d is not supported yet&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|fp-&gt;iface
comma
id|fp-&gt;altsetting
comma
id|fmt
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|fp-&gt;fmt_type
op_assign
id|fmt
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
macro_line|#if 1
multiline_comment|/* FIXME: temporary hack for extigy */
multiline_comment|/* extigy apparently supports sample rates other than 48k&n;&t; * but not in ordinary way.  so we enable only 48k atm.&n;&t; */
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idVendor
)paren
op_eq
l_int|0x041e
op_logical_and
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idProduct
)paren
op_eq
l_int|0x3000
)paren
(brace
r_if
c_cond
(paren
id|fmt
(braket
l_int|3
)braket
op_eq
id|USB_FORMAT_TYPE_I
op_logical_and
id|stream
op_eq
id|SNDRV_PCM_STREAM_PLAYBACK
op_logical_and
id|fp-&gt;rates
op_ne
id|SNDRV_PCM_RATE_48000
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* use 48k only */
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parse_audio_endpoints
r_static
r_int
id|parse_audio_endpoints
c_func
(paren
id|snd_usb_audio_t
op_star
id|chip
comma
r_int
id|iface_no
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
r_struct
id|usb_interface
op_star
id|iface
suffix:semicolon
r_struct
id|usb_host_interface
op_star
id|alts
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|altsd
suffix:semicolon
r_int
id|i
comma
id|altno
comma
id|err
comma
id|stream
suffix:semicolon
r_int
id|format
suffix:semicolon
r_struct
id|audioformat
op_star
id|fp
suffix:semicolon
r_int
r_char
op_star
id|fmt
comma
op_star
id|csep
suffix:semicolon
id|dev
op_assign
id|chip-&gt;dev
suffix:semicolon
multiline_comment|/* parse the interface&squot;s altsettings */
id|iface
op_assign
id|usb_ifnum_to_if
c_func
(paren
id|dev
comma
id|iface_no
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|iface-&gt;num_altsetting
suffix:semicolon
id|i
op_increment
)paren
(brace
id|alts
op_assign
op_amp
id|iface-&gt;altsetting
(braket
id|i
)braket
suffix:semicolon
id|altsd
op_assign
id|get_iface_desc
c_func
(paren
id|alts
)paren
suffix:semicolon
multiline_comment|/* skip invalid one */
r_if
c_cond
(paren
(paren
id|altsd-&gt;bInterfaceClass
op_ne
id|USB_CLASS_AUDIO
op_logical_and
id|altsd-&gt;bInterfaceClass
op_ne
id|USB_CLASS_VENDOR_SPEC
)paren
op_logical_or
(paren
id|altsd-&gt;bInterfaceSubClass
op_ne
id|USB_SUBCLASS_AUDIO_STREAMING
op_logical_and
id|altsd-&gt;bInterfaceSubClass
op_ne
id|USB_SUBCLASS_VENDOR_SPEC
)paren
op_logical_or
id|altsd-&gt;bNumEndpoints
OL
l_int|1
op_logical_or
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|0
)paren
op_member_access_from_pointer
id|wMaxPacketSize
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* must be isochronous */
r_if
c_cond
(paren
(paren
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|0
)paren
op_member_access_from_pointer
id|bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_ne
id|USB_ENDPOINT_XFER_ISOC
)paren
r_continue
suffix:semicolon
multiline_comment|/* check direction */
id|stream
op_assign
(paren
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|0
)paren
op_member_access_from_pointer
id|bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
ques
c_cond
id|SNDRV_PCM_STREAM_CAPTURE
suffix:colon
id|SNDRV_PCM_STREAM_PLAYBACK
suffix:semicolon
id|altno
op_assign
id|altsd-&gt;bAlternateSetting
suffix:semicolon
multiline_comment|/* get audio formats */
id|fmt
op_assign
id|snd_usb_find_csint_desc
c_func
(paren
id|alts-&gt;extra
comma
id|alts-&gt;extralen
comma
l_int|NULL
comma
id|AS_GENERAL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fmt
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%d:%u:%d : AS_GENERAL descriptor not found&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|iface_no
comma
id|altno
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fmt
(braket
l_int|0
)braket
OL
l_int|7
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%d:%u:%d : invalid AS_GENERAL desc&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|iface_no
comma
id|altno
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|format
op_assign
(paren
id|fmt
(braket
l_int|6
)braket
op_lshift
l_int|8
)paren
op_or
id|fmt
(braket
l_int|5
)braket
suffix:semicolon
multiline_comment|/* remember the format value */
multiline_comment|/* get format type */
id|fmt
op_assign
id|snd_usb_find_csint_desc
c_func
(paren
id|alts-&gt;extra
comma
id|alts-&gt;extralen
comma
l_int|NULL
comma
id|FORMAT_TYPE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fmt
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%d:%u:%d : no FORMAT_TYPE desc&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|iface_no
comma
id|altno
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fmt
(braket
l_int|0
)braket
OL
l_int|8
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%d:%u:%d : invalid FORMAT_TYPE desc&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|iface_no
comma
id|altno
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|csep
op_assign
id|snd_usb_find_desc
c_func
(paren
id|alts-&gt;endpoint
(braket
l_int|0
)braket
dot
id|extra
comma
id|alts-&gt;endpoint
(braket
l_int|0
)braket
dot
id|extralen
comma
l_int|NULL
comma
id|USB_DT_CS_ENDPOINT
)paren
suffix:semicolon
multiline_comment|/* Creamware Noah has this descriptor after the 2nd endpoint */
r_if
c_cond
(paren
op_logical_neg
id|csep
op_logical_and
id|altsd-&gt;bNumEndpoints
op_ge
l_int|2
)paren
id|csep
op_assign
id|snd_usb_find_desc
c_func
(paren
id|alts-&gt;endpoint
(braket
l_int|1
)braket
dot
id|extra
comma
id|alts-&gt;endpoint
(braket
l_int|1
)braket
dot
id|extralen
comma
l_int|NULL
comma
id|USB_DT_CS_ENDPOINT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|csep
op_logical_or
id|csep
(braket
l_int|0
)braket
OL
l_int|7
op_logical_or
id|csep
(braket
l_int|2
)braket
op_ne
id|EP_GENERAL
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%d:%u:%d : no or invalid class specific endpoint descriptor&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|iface_no
comma
id|altno
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|fp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|fp
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cannot malloc&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|fp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|fp
)paren
)paren
suffix:semicolon
id|fp-&gt;iface
op_assign
id|iface_no
suffix:semicolon
id|fp-&gt;altsetting
op_assign
id|altno
suffix:semicolon
id|fp-&gt;altset_idx
op_assign
id|i
suffix:semicolon
id|fp-&gt;endpoint
op_assign
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|0
)paren
op_member_access_from_pointer
id|bEndpointAddress
suffix:semicolon
id|fp-&gt;ep_attr
op_assign
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|0
)paren
op_member_access_from_pointer
id|bmAttributes
suffix:semicolon
multiline_comment|/* FIXME: decode wMaxPacketSize of high bandwith endpoints */
id|fp-&gt;maxpacksize
op_assign
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|0
)paren
op_member_access_from_pointer
id|wMaxPacketSize
suffix:semicolon
id|fp-&gt;attributes
op_assign
id|csep
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* some quirks for attributes here */
multiline_comment|/* workaround for AudioTrak Optoplay */
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idVendor
)paren
op_eq
l_int|0x0a92
op_logical_and
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idProduct
)paren
op_eq
l_int|0x0053
)paren
(brace
multiline_comment|/* Optoplay sets the sample rate attribute although&n;&t;&t;&t; * it seems not supporting it in fact.&n;&t;&t;&t; */
id|fp-&gt;attributes
op_and_assign
op_complement
id|EP_CS_ATTR_SAMPLE_RATE
suffix:semicolon
)brace
multiline_comment|/* workaround for M-Audio Audiophile USB */
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idVendor
)paren
op_eq
l_int|0x0763
op_logical_and
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idProduct
)paren
op_eq
l_int|0x2003
)paren
(brace
multiline_comment|/* doesn&squot;t set the sample rate attribute, but supports it */
id|fp-&gt;attributes
op_or_assign
id|EP_CS_ATTR_SAMPLE_RATE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * plantronics headset and Griffin iMic have set adaptive-in&n;&t;&t; * although it&squot;s really not...&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idVendor
)paren
op_eq
l_int|0x047f
op_logical_and
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idProduct
)paren
op_eq
l_int|0x0ca1
)paren
op_logical_or
multiline_comment|/* Griffin iMic (note that there is an older model 77d:223) */
(paren
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idVendor
)paren
op_eq
l_int|0x077d
op_logical_and
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idProduct
)paren
op_eq
l_int|0x07af
)paren
)paren
(brace
id|fp-&gt;ep_attr
op_and_assign
op_complement
id|EP_ATTR_MASK
suffix:semicolon
r_if
c_cond
(paren
id|stream
op_eq
id|SNDRV_PCM_STREAM_PLAYBACK
)paren
id|fp-&gt;ep_attr
op_or_assign
id|EP_ATTR_ADAPTIVE
suffix:semicolon
r_else
id|fp-&gt;ep_attr
op_or_assign
id|EP_ATTR_SYNC
suffix:semicolon
)brace
multiline_comment|/* ok, let&squot;s parse further... */
r_if
c_cond
(paren
id|parse_audio_format
c_func
(paren
id|dev
comma
id|fp
comma
id|format
comma
id|fmt
comma
id|stream
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|fp-&gt;rate_table
)paren
id|kfree
c_func
(paren
id|fp-&gt;rate_table
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fp
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|snd_printdd
c_func
(paren
id|KERN_INFO
l_string|&quot;%d:%u:%d: add audio endpoint 0x%x&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|iface_no
comma
id|i
comma
id|fp-&gt;endpoint
)paren
suffix:semicolon
id|err
op_assign
id|add_audio_endpoint
c_func
(paren
id|chip
comma
id|stream
comma
id|fp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|fp-&gt;rate_table
)paren
id|kfree
c_func
(paren
id|fp-&gt;rate_table
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* try to set the interface... */
id|usb_set_interface
c_func
(paren
id|chip-&gt;dev
comma
id|iface_no
comma
id|altno
)paren
suffix:semicolon
id|init_usb_pitch
c_func
(paren
id|chip-&gt;dev
comma
id|iface_no
comma
id|alts
comma
id|fp
)paren
suffix:semicolon
id|init_usb_sample_rate
c_func
(paren
id|chip-&gt;dev
comma
id|iface_no
comma
id|alts
comma
id|fp
comma
id|fp-&gt;rate_max
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * disconnect streams&n; * called from snd_usb_audio_disconnect()&n; */
DECL|function|snd_usb_stream_disconnect
r_static
r_void
id|snd_usb_stream_disconnect
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_struct
id|usb_driver
op_star
id|driver
)paren
(brace
r_int
id|idx
suffix:semicolon
id|snd_usb_stream_t
op_star
id|as
suffix:semicolon
id|snd_usb_substream_t
op_star
id|subs
suffix:semicolon
id|as
op_assign
id|list_entry
c_func
(paren
id|head
comma
id|snd_usb_stream_t
comma
id|list
)paren
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
l_int|2
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|subs
op_assign
op_amp
id|as-&gt;substream
(braket
id|idx
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subs-&gt;num_formats
)paren
r_return
suffix:semicolon
id|release_substream_urbs
c_func
(paren
id|subs
comma
l_int|1
)paren
suffix:semicolon
id|subs-&gt;interface
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * parse audio control descriptor and create pcm/midi streams&n; */
DECL|function|snd_usb_create_streams
r_static
r_int
id|snd_usb_create_streams
c_func
(paren
id|snd_usb_audio_t
op_star
id|chip
comma
r_int
id|ctrlif
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
op_assign
id|chip-&gt;dev
suffix:semicolon
r_struct
id|usb_host_interface
op_star
id|host_iface
suffix:semicolon
r_struct
id|usb_interface
op_star
id|iface
suffix:semicolon
r_int
r_char
op_star
id|p1
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/* find audiocontrol interface */
id|host_iface
op_assign
op_amp
id|usb_ifnum_to_if
c_func
(paren
id|dev
comma
id|ctrlif
)paren
op_member_access_from_pointer
id|altsetting
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p1
op_assign
id|snd_usb_find_csint_desc
c_func
(paren
id|host_iface-&gt;extra
comma
id|host_iface-&gt;extralen
comma
l_int|NULL
comma
id|HEADER
)paren
)paren
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cannot find HEADER&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|p1
(braket
l_int|7
)braket
op_logical_or
id|p1
(braket
l_int|0
)braket
OL
l_int|8
op_plus
id|p1
(braket
l_int|7
)braket
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;invalid HEADER&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * parse all USB audio streaming interfaces&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|p1
(braket
l_int|7
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_host_interface
op_star
id|alts
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|altsd
suffix:semicolon
id|j
op_assign
id|p1
(braket
l_int|8
op_plus
id|i
)braket
suffix:semicolon
id|iface
op_assign
id|usb_ifnum_to_if
c_func
(paren
id|dev
comma
id|j
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iface
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%d:%u:%d : does not exist&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|ctrlif
comma
id|j
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usb_interface_claimed
c_func
(paren
id|iface
)paren
)paren
(brace
id|snd_printdd
c_func
(paren
id|KERN_INFO
l_string|&quot;%d:%d:%d: skipping, already claimed&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|ctrlif
comma
id|j
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|alts
op_assign
op_amp
id|iface-&gt;altsetting
(braket
l_int|0
)braket
suffix:semicolon
id|altsd
op_assign
id|get_iface_desc
c_func
(paren
id|alts
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|altsd-&gt;bInterfaceClass
op_eq
id|USB_CLASS_AUDIO
op_logical_or
id|altsd-&gt;bInterfaceClass
op_eq
id|USB_CLASS_VENDOR_SPEC
)paren
op_logical_and
id|altsd-&gt;bInterfaceSubClass
op_eq
id|USB_SUBCLASS_MIDI_STREAMING
)paren
(brace
r_if
c_cond
(paren
id|snd_usb_create_midi_interface
c_func
(paren
id|chip
comma
id|iface
comma
l_int|NULL
)paren
OL
l_int|0
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%d:%u:%d: cannot create sequencer device&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|ctrlif
comma
id|j
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|usb_driver_claim_interface
c_func
(paren
op_amp
id|usb_audio_driver
comma
id|iface
comma
(paren
r_void
op_star
)paren
op_minus
l_int|1L
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|altsd-&gt;bInterfaceClass
op_ne
id|USB_CLASS_AUDIO
op_logical_and
id|altsd-&gt;bInterfaceClass
op_ne
id|USB_CLASS_VENDOR_SPEC
)paren
op_logical_or
id|altsd-&gt;bInterfaceSubClass
op_ne
id|USB_SUBCLASS_AUDIO_STREAMING
)paren
(brace
id|snd_printdd
c_func
(paren
id|KERN_ERR
l_string|&quot;%d:%u:%d: skipping non-supported interface %d&bslash;n&quot;
comma
id|dev-&gt;devnum
comma
id|ctrlif
comma
id|j
comma
id|altsd-&gt;bInterfaceClass
)paren
suffix:semicolon
multiline_comment|/* skip non-supported classes */
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|parse_audio_endpoints
c_func
(paren
id|chip
comma
id|j
)paren
)paren
(brace
id|usb_set_interface
c_func
(paren
id|dev
comma
id|j
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* reset the current interface */
id|usb_driver_claim_interface
c_func
(paren
op_amp
id|usb_audio_driver
comma
id|iface
comma
(paren
r_void
op_star
)paren
op_minus
l_int|1L
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * create a stream for an endpoint/altsetting without proper descriptors&n; */
DECL|function|create_fixed_stream_quirk
r_static
r_int
id|create_fixed_stream_quirk
c_func
(paren
id|snd_usb_audio_t
op_star
id|chip
comma
r_struct
id|usb_interface
op_star
id|iface
comma
r_const
id|snd_usb_audio_quirk_t
op_star
id|quirk
)paren
(brace
r_struct
id|audioformat
op_star
id|fp
suffix:semicolon
r_struct
id|usb_host_interface
op_star
id|alts
suffix:semicolon
r_int
id|stream
comma
id|err
suffix:semicolon
r_int
op_star
id|rate_table
op_assign
l_int|NULL
suffix:semicolon
id|fp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|fp
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cannot malloc&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|fp
comma
id|quirk-&gt;data
comma
r_sizeof
(paren
op_star
id|fp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fp-&gt;nr_rates
OG
l_int|0
)paren
(brace
id|rate_table
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_int
)paren
op_star
id|fp-&gt;nr_rates
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rate_table
)paren
(brace
id|kfree
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|rate_table
comma
id|fp-&gt;rate_table
comma
r_sizeof
(paren
r_int
)paren
op_star
id|fp-&gt;nr_rates
)paren
suffix:semicolon
id|fp-&gt;rate_table
op_assign
id|rate_table
suffix:semicolon
)brace
id|stream
op_assign
(paren
id|fp-&gt;endpoint
op_amp
id|USB_DIR_IN
)paren
ques
c_cond
id|SNDRV_PCM_STREAM_CAPTURE
suffix:colon
id|SNDRV_PCM_STREAM_PLAYBACK
suffix:semicolon
id|err
op_assign
id|add_audio_endpoint
c_func
(paren
id|chip
comma
id|stream
comma
id|fp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|fp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rate_table
)paren
id|kfree
c_func
(paren
id|rate_table
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fp-&gt;iface
op_ne
id|get_iface_desc
c_func
(paren
op_amp
id|iface-&gt;altsetting
(braket
l_int|0
)braket
)paren
op_member_access_from_pointer
id|bInterfaceNumber
op_logical_or
id|fp-&gt;altset_idx
op_ge
id|iface-&gt;num_altsetting
)paren
(brace
id|kfree
c_func
(paren
id|fp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rate_table
)paren
id|kfree
c_func
(paren
id|rate_table
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|alts
op_assign
op_amp
id|iface-&gt;altsetting
(braket
id|fp-&gt;altset_idx
)braket
suffix:semicolon
id|usb_set_interface
c_func
(paren
id|chip-&gt;dev
comma
id|fp-&gt;iface
comma
l_int|0
)paren
suffix:semicolon
id|init_usb_pitch
c_func
(paren
id|chip-&gt;dev
comma
id|fp-&gt;iface
comma
id|alts
comma
id|fp
)paren
suffix:semicolon
id|init_usb_sample_rate
c_func
(paren
id|chip-&gt;dev
comma
id|fp-&gt;iface
comma
id|alts
comma
id|fp
comma
id|fp-&gt;rate_max
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * create a stream for an interface with proper descriptors&n; */
DECL|function|create_standard_interface_quirk
r_static
r_int
id|create_standard_interface_quirk
c_func
(paren
id|snd_usb_audio_t
op_star
id|chip
comma
r_struct
id|usb_interface
op_star
id|iface
comma
r_const
id|snd_usb_audio_quirk_t
op_star
id|quirk
)paren
(brace
r_struct
id|usb_host_interface
op_star
id|alts
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|altsd
suffix:semicolon
r_int
id|err
suffix:semicolon
id|alts
op_assign
op_amp
id|iface-&gt;altsetting
(braket
l_int|0
)braket
suffix:semicolon
id|altsd
op_assign
id|get_iface_desc
c_func
(paren
id|alts
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|quirk-&gt;type
)paren
(brace
r_case
id|QUIRK_AUDIO_STANDARD_INTERFACE
suffix:colon
id|err
op_assign
id|parse_audio_endpoints
c_func
(paren
id|chip
comma
id|altsd-&gt;bInterfaceNumber
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|usb_set_interface
c_func
(paren
id|chip-&gt;dev
comma
id|altsd-&gt;bInterfaceNumber
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* reset the current interface */
r_break
suffix:semicolon
r_case
id|QUIRK_MIDI_STANDARD_INTERFACE
suffix:colon
id|err
op_assign
id|snd_usb_create_midi_interface
c_func
(paren
id|chip
comma
id|iface
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|snd_printd
c_func
(paren
id|KERN_ERR
l_string|&quot;invalid quirk type %d&bslash;n&quot;
comma
id|quirk-&gt;type
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cannot setup if %d: error %d&bslash;n&quot;
comma
id|altsd-&gt;bInterfaceNumber
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a stream for an Edirol UA-700/UA-25 interface.  The only way&n; * to detect the sample rate is by looking at wMaxPacketSize.&n; */
DECL|function|create_ua700_ua25_quirk
r_static
r_int
id|create_ua700_ua25_quirk
c_func
(paren
id|snd_usb_audio_t
op_star
id|chip
comma
r_struct
id|usb_interface
op_star
id|iface
)paren
(brace
r_static
r_const
r_struct
id|audioformat
id|ua_format
op_assign
(brace
dot
id|format
op_assign
id|SNDRV_PCM_FORMAT_S24_3LE
comma
dot
id|channels
op_assign
l_int|2
comma
dot
id|fmt_type
op_assign
id|USB_FORMAT_TYPE_I
comma
dot
id|altsetting
op_assign
l_int|1
comma
dot
id|altset_idx
op_assign
l_int|1
comma
dot
id|rates
op_assign
id|SNDRV_PCM_RATE_CONTINUOUS
comma
)brace
suffix:semicolon
r_struct
id|usb_host_interface
op_star
id|alts
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|altsd
suffix:semicolon
r_struct
id|audioformat
op_star
id|fp
suffix:semicolon
r_int
id|stream
comma
id|err
suffix:semicolon
multiline_comment|/* both PCM and MIDI interfaces have 2 altsettings */
r_if
c_cond
(paren
id|iface-&gt;num_altsetting
op_ne
l_int|2
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|alts
op_assign
op_amp
id|iface-&gt;altsetting
(braket
l_int|1
)braket
suffix:semicolon
id|altsd
op_assign
id|get_iface_desc
c_func
(paren
id|alts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|altsd-&gt;bNumEndpoints
op_eq
l_int|2
)paren
(brace
r_static
r_const
id|snd_usb_midi_endpoint_info_t
id|ua700_ep
op_assign
(brace
dot
id|out_cables
op_assign
l_int|0x0003
comma
dot
id|in_cables
op_assign
l_int|0x0003
)brace
suffix:semicolon
r_static
r_const
id|snd_usb_audio_quirk_t
id|ua700_quirk
op_assign
(brace
dot
id|type
op_assign
id|QUIRK_MIDI_FIXED_ENDPOINT
comma
dot
id|data
op_assign
op_amp
id|ua700_ep
)brace
suffix:semicolon
r_static
r_const
id|snd_usb_midi_endpoint_info_t
id|ua25_ep
op_assign
(brace
dot
id|out_cables
op_assign
l_int|0x0001
comma
dot
id|in_cables
op_assign
l_int|0x0001
)brace
suffix:semicolon
r_static
r_const
id|snd_usb_audio_quirk_t
id|ua25_quirk
op_assign
(brace
dot
id|type
op_assign
id|QUIRK_MIDI_FIXED_ENDPOINT
comma
dot
id|data
op_assign
op_amp
id|ua25_ep
)brace
suffix:semicolon
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|chip-&gt;dev-&gt;descriptor.idProduct
)paren
op_eq
l_int|0x002b
)paren
r_return
id|snd_usb_create_midi_interface
c_func
(paren
id|chip
comma
id|iface
comma
op_amp
id|ua700_quirk
)paren
suffix:semicolon
r_else
r_return
id|snd_usb_create_midi_interface
c_func
(paren
id|chip
comma
id|iface
comma
op_amp
id|ua25_quirk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|altsd-&gt;bNumEndpoints
op_ne
l_int|1
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|fp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|fp
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memcpy
c_func
(paren
id|fp
comma
op_amp
id|ua_format
comma
r_sizeof
(paren
op_star
id|fp
)paren
)paren
suffix:semicolon
id|fp-&gt;iface
op_assign
id|altsd-&gt;bInterfaceNumber
suffix:semicolon
id|fp-&gt;endpoint
op_assign
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|0
)paren
op_member_access_from_pointer
id|bEndpointAddress
suffix:semicolon
id|fp-&gt;ep_attr
op_assign
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|0
)paren
op_member_access_from_pointer
id|bmAttributes
suffix:semicolon
id|fp-&gt;maxpacksize
op_assign
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|0
)paren
op_member_access_from_pointer
id|wMaxPacketSize
suffix:semicolon
r_switch
c_cond
(paren
id|fp-&gt;maxpacksize
)paren
(brace
r_case
l_int|0x120
suffix:colon
id|fp-&gt;rate_max
op_assign
id|fp-&gt;rate_min
op_assign
l_int|44100
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x138
suffix:colon
r_case
l_int|0x140
suffix:colon
id|fp-&gt;rate_max
op_assign
id|fp-&gt;rate_min
op_assign
l_int|48000
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x258
suffix:colon
r_case
l_int|0x260
suffix:colon
id|fp-&gt;rate_max
op_assign
id|fp-&gt;rate_min
op_assign
l_int|96000
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;unknown sample rate&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|stream
op_assign
(paren
id|fp-&gt;endpoint
op_amp
id|USB_DIR_IN
)paren
ques
c_cond
id|SNDRV_PCM_STREAM_CAPTURE
suffix:colon
id|SNDRV_PCM_STREAM_PLAYBACK
suffix:semicolon
id|err
op_assign
id|add_audio_endpoint
c_func
(paren
id|chip
comma
id|stream
comma
id|fp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|usb_set_interface
c_func
(paren
id|chip-&gt;dev
comma
id|fp-&gt;iface
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a stream for an Edirol UA-1000 interface.&n; */
DECL|function|create_ua1000_quirk
r_static
r_int
id|create_ua1000_quirk
c_func
(paren
id|snd_usb_audio_t
op_star
id|chip
comma
r_struct
id|usb_interface
op_star
id|iface
)paren
(brace
r_static
r_const
r_struct
id|audioformat
id|ua1000_format
op_assign
(brace
dot
id|format
op_assign
id|SNDRV_PCM_FORMAT_S32_LE
comma
dot
id|fmt_type
op_assign
id|USB_FORMAT_TYPE_I
comma
dot
id|altsetting
op_assign
l_int|1
comma
dot
id|altset_idx
op_assign
l_int|1
comma
dot
id|attributes
op_assign
l_int|0
comma
dot
id|rates
op_assign
id|SNDRV_PCM_RATE_CONTINUOUS
comma
)brace
suffix:semicolon
r_struct
id|usb_host_interface
op_star
id|alts
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|altsd
suffix:semicolon
r_struct
id|audioformat
op_star
id|fp
suffix:semicolon
r_int
id|stream
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
id|iface-&gt;num_altsetting
op_ne
l_int|2
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|alts
op_assign
op_amp
id|iface-&gt;altsetting
(braket
l_int|1
)braket
suffix:semicolon
id|altsd
op_assign
id|get_iface_desc
c_func
(paren
id|alts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|alts-&gt;extralen
op_ne
l_int|11
op_logical_or
id|alts-&gt;extra
(braket
l_int|1
)braket
op_ne
id|CS_AUDIO_INTERFACE
op_logical_or
id|altsd-&gt;bNumEndpoints
op_ne
l_int|1
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|fp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|fp
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memcpy
c_func
(paren
id|fp
comma
op_amp
id|ua1000_format
comma
r_sizeof
(paren
op_star
id|fp
)paren
)paren
suffix:semicolon
id|fp-&gt;channels
op_assign
id|alts-&gt;extra
(braket
l_int|4
)braket
suffix:semicolon
id|fp-&gt;iface
op_assign
id|altsd-&gt;bInterfaceNumber
suffix:semicolon
id|fp-&gt;endpoint
op_assign
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|0
)paren
op_member_access_from_pointer
id|bEndpointAddress
suffix:semicolon
id|fp-&gt;ep_attr
op_assign
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|0
)paren
op_member_access_from_pointer
id|bmAttributes
suffix:semicolon
id|fp-&gt;maxpacksize
op_assign
id|get_endpoint
c_func
(paren
id|alts
comma
l_int|0
)paren
op_member_access_from_pointer
id|wMaxPacketSize
suffix:semicolon
id|fp-&gt;rate_max
op_assign
id|fp-&gt;rate_min
op_assign
id|combine_triple
c_func
(paren
op_amp
id|alts-&gt;extra
(braket
l_int|8
)braket
)paren
suffix:semicolon
id|stream
op_assign
(paren
id|fp-&gt;endpoint
op_amp
id|USB_DIR_IN
)paren
ques
c_cond
id|SNDRV_PCM_STREAM_CAPTURE
suffix:colon
id|SNDRV_PCM_STREAM_PLAYBACK
suffix:semicolon
id|err
op_assign
id|add_audio_endpoint
c_func
(paren
id|chip
comma
id|stream
comma
id|fp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|fp
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* FIXME: playback must be synchronized to capture */
id|usb_set_interface
c_func
(paren
id|chip-&gt;dev
comma
id|fp-&gt;iface
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|snd_usb_create_quirk
c_func
(paren
id|snd_usb_audio_t
op_star
id|chip
comma
r_struct
id|usb_interface
op_star
id|iface
comma
r_const
id|snd_usb_audio_quirk_t
op_star
id|quirk
)paren
suffix:semicolon
multiline_comment|/*&n; * handle the quirks for the contained interfaces&n; */
DECL|function|create_composite_quirk
r_static
r_int
id|create_composite_quirk
c_func
(paren
id|snd_usb_audio_t
op_star
id|chip
comma
r_struct
id|usb_interface
op_star
id|iface
comma
r_const
id|snd_usb_audio_quirk_t
op_star
id|quirk
)paren
(brace
r_int
id|probed_ifnum
op_assign
id|get_iface_desc
c_func
(paren
id|iface-&gt;altsetting
)paren
op_member_access_from_pointer
id|bInterfaceNumber
suffix:semicolon
r_int
id|err
suffix:semicolon
r_for
c_loop
(paren
id|quirk
op_assign
id|quirk-&gt;data
suffix:semicolon
id|quirk-&gt;ifnum
op_ge
l_int|0
suffix:semicolon
op_increment
id|quirk
)paren
(brace
id|iface
op_assign
id|usb_ifnum_to_if
c_func
(paren
id|chip-&gt;dev
comma
id|quirk-&gt;ifnum
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iface
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|quirk-&gt;ifnum
op_ne
id|probed_ifnum
op_logical_and
id|usb_interface_claimed
c_func
(paren
id|iface
)paren
)paren
r_continue
suffix:semicolon
id|err
op_assign
id|snd_usb_create_quirk
c_func
(paren
id|chip
comma
id|iface
comma
id|quirk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|quirk-&gt;ifnum
op_ne
id|probed_ifnum
)paren
id|usb_driver_claim_interface
c_func
(paren
op_amp
id|usb_audio_driver
comma
id|iface
comma
(paren
r_void
op_star
)paren
op_minus
l_int|1L
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * boot quirks&n; */
DECL|macro|EXTIGY_FIRMWARE_SIZE_OLD
mdefine_line|#define EXTIGY_FIRMWARE_SIZE_OLD 794
DECL|macro|EXTIGY_FIRMWARE_SIZE_NEW
mdefine_line|#define EXTIGY_FIRMWARE_SIZE_NEW 483
DECL|function|snd_usb_extigy_boot_quirk
r_static
r_int
id|snd_usb_extigy_boot_quirk
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_struct
id|usb_host_config
op_star
id|config
op_assign
id|dev-&gt;actconfig
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|get_cfg_desc
c_func
(paren
id|config
)paren
op_member_access_from_pointer
id|wTotalLength
op_eq
id|EXTIGY_FIRMWARE_SIZE_OLD
op_logical_or
id|get_cfg_desc
c_func
(paren
id|config
)paren
op_member_access_from_pointer
id|wTotalLength
op_eq
id|EXTIGY_FIRMWARE_SIZE_NEW
)paren
(brace
id|snd_printdd
c_func
(paren
l_string|&quot;sending Extigy boot sequence...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Send message to force it to reconnect with full interface. */
id|err
op_assign
id|snd_usb_ctl_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
l_int|0x10
comma
l_int|0x43
comma
l_int|0x0001
comma
l_int|0x000a
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
id|snd_printdd
c_func
(paren
l_string|&quot;error sending boot message: %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
id|err
op_assign
id|usb_get_descriptor
c_func
(paren
id|dev
comma
id|USB_DT_DEVICE
comma
l_int|0
comma
op_amp
id|dev-&gt;descriptor
comma
r_sizeof
(paren
id|dev-&gt;descriptor
)paren
)paren
suffix:semicolon
id|config
op_assign
id|dev-&gt;actconfig
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
id|snd_printdd
c_func
(paren
l_string|&quot;error usb_get_descriptor: %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
id|err
op_assign
id|usb_reset_configuration
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
id|snd_printdd
c_func
(paren
l_string|&quot;error usb_reset_configuration: %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
id|snd_printdd
c_func
(paren
l_string|&quot;extigy_boot: new boot length = %d&bslash;n&quot;
comma
id|get_cfg_desc
c_func
(paren
id|config
)paren
op_member_access_from_pointer
id|wTotalLength
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* quit this anyway */
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * audio-interface quirks&n; *&n; * returns zero if no standard audio/MIDI parsing is needed.&n; * returns a postive value if standard audio/midi interfaces are parsed&n; * after this.&n; * returns a negative value at error.&n; */
DECL|function|snd_usb_create_quirk
r_static
r_int
id|snd_usb_create_quirk
c_func
(paren
id|snd_usb_audio_t
op_star
id|chip
comma
r_struct
id|usb_interface
op_star
id|iface
comma
r_const
id|snd_usb_audio_quirk_t
op_star
id|quirk
)paren
(brace
r_switch
c_cond
(paren
id|quirk-&gt;type
)paren
(brace
r_case
id|QUIRK_MIDI_FIXED_ENDPOINT
suffix:colon
r_case
id|QUIRK_MIDI_YAMAHA
suffix:colon
r_case
id|QUIRK_MIDI_MIDIMAN
suffix:colon
r_return
id|snd_usb_create_midi_interface
c_func
(paren
id|chip
comma
id|iface
comma
id|quirk
)paren
suffix:semicolon
r_case
id|QUIRK_COMPOSITE
suffix:colon
r_return
id|create_composite_quirk
c_func
(paren
id|chip
comma
id|iface
comma
id|quirk
)paren
suffix:semicolon
r_case
id|QUIRK_AUDIO_FIXED_ENDPOINT
suffix:colon
r_return
id|create_fixed_stream_quirk
c_func
(paren
id|chip
comma
id|iface
comma
id|quirk
)paren
suffix:semicolon
r_case
id|QUIRK_AUDIO_STANDARD_INTERFACE
suffix:colon
r_case
id|QUIRK_MIDI_STANDARD_INTERFACE
suffix:colon
r_return
id|create_standard_interface_quirk
c_func
(paren
id|chip
comma
id|iface
comma
id|quirk
)paren
suffix:semicolon
r_case
id|QUIRK_AUDIO_EDIROL_UA700_UA25
suffix:colon
r_return
id|create_ua700_ua25_quirk
c_func
(paren
id|chip
comma
id|iface
)paren
suffix:semicolon
r_case
id|QUIRK_AUDIO_EDIROL_UA1000
suffix:colon
r_return
id|create_ua1000_quirk
c_func
(paren
id|chip
comma
id|iface
)paren
suffix:semicolon
r_default
suffix:colon
id|snd_printd
c_func
(paren
id|KERN_ERR
l_string|&quot;invalid quirk type %d&bslash;n&quot;
comma
id|quirk-&gt;type
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * common proc files to show the usb device info&n; */
DECL|function|proc_audio_usbbus_read
r_static
r_void
id|proc_audio_usbbus_read
c_func
(paren
id|snd_info_entry_t
op_star
id|entry
comma
id|snd_info_buffer_t
op_star
id|buffer
)paren
(brace
id|snd_usb_audio_t
op_star
id|chip
op_assign
id|entry-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chip-&gt;shutdown
)paren
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%03d/%03d&bslash;n&quot;
comma
id|chip-&gt;dev-&gt;bus-&gt;busnum
comma
id|chip-&gt;dev-&gt;devnum
)paren
suffix:semicolon
)brace
DECL|function|proc_audio_usbid_read
r_static
r_void
id|proc_audio_usbid_read
c_func
(paren
id|snd_info_entry_t
op_star
id|entry
comma
id|snd_info_buffer_t
op_star
id|buffer
)paren
(brace
id|snd_usb_audio_t
op_star
id|chip
op_assign
id|entry-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chip-&gt;shutdown
)paren
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%04x:%04x&bslash;n&quot;
comma
id|le16_to_cpu
c_func
(paren
id|chip-&gt;dev-&gt;descriptor.idVendor
)paren
comma
id|le16_to_cpu
c_func
(paren
id|chip-&gt;dev-&gt;descriptor.idProduct
)paren
)paren
suffix:semicolon
)brace
DECL|function|snd_usb_audio_create_proc
r_static
r_void
id|snd_usb_audio_create_proc
c_func
(paren
id|snd_usb_audio_t
op_star
id|chip
)paren
(brace
id|snd_info_entry_t
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|snd_card_proc_new
c_func
(paren
id|chip-&gt;card
comma
l_string|&quot;usbbus&quot;
comma
op_amp
id|entry
)paren
)paren
id|snd_info_set_text_ops
c_func
(paren
id|entry
comma
id|chip
comma
l_int|1024
comma
id|proc_audio_usbbus_read
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|snd_card_proc_new
c_func
(paren
id|chip-&gt;card
comma
l_string|&quot;usbid&quot;
comma
op_amp
id|entry
)paren
)paren
id|snd_info_set_text_ops
c_func
(paren
id|entry
comma
id|chip
comma
l_int|1024
comma
id|proc_audio_usbid_read
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * free the chip instance&n; *&n; * here we have to do not much, since pcm and controls are already freed&n; *&n; */
DECL|function|snd_usb_audio_free
r_static
r_int
id|snd_usb_audio_free
c_func
(paren
id|snd_usb_audio_t
op_star
id|chip
)paren
(brace
id|kfree
c_func
(paren
id|chip
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|snd_usb_audio_dev_free
r_static
r_int
id|snd_usb_audio_dev_free
c_func
(paren
id|snd_device_t
op_star
id|device
)paren
(brace
id|snd_usb_audio_t
op_star
id|chip
op_assign
id|device-&gt;device_data
suffix:semicolon
r_return
id|snd_usb_audio_free
c_func
(paren
id|chip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * create a chip instance and set its names.&n; */
DECL|function|snd_usb_audio_create
r_static
r_int
id|snd_usb_audio_create
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|idx
comma
r_const
id|snd_usb_audio_quirk_t
op_star
id|quirk
comma
id|snd_usb_audio_t
op_star
op_star
id|rchip
)paren
(brace
id|snd_card_t
op_star
id|card
suffix:semicolon
id|snd_usb_audio_t
op_star
id|chip
suffix:semicolon
r_int
id|err
comma
id|len
suffix:semicolon
r_char
id|component
(braket
l_int|14
)braket
suffix:semicolon
r_static
id|snd_device_ops_t
id|ops
op_assign
(brace
dot
id|dev_free
op_assign
id|snd_usb_audio_dev_free
comma
)brace
suffix:semicolon
op_star
id|rchip
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|snd_usb_get_speed
c_func
(paren
id|dev
)paren
op_ne
id|USB_SPEED_FULL
op_logical_and
id|snd_usb_get_speed
c_func
(paren
id|dev
)paren
op_ne
id|USB_SPEED_HIGH
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;unknown device speed %d&bslash;n&quot;
comma
id|snd_usb_get_speed
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|card
op_assign
id|snd_card_new
c_func
(paren
id|index
(braket
id|idx
)braket
comma
id|id
(braket
id|idx
)braket
comma
id|THIS_MODULE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card
op_eq
l_int|NULL
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cannot create card instance %d&bslash;n&quot;
comma
id|idx
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|chip
op_assign
id|kcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|chip
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chip
)paren
(brace
id|snd_card_free
c_func
(paren
id|card
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|chip-&gt;index
op_assign
id|idx
suffix:semicolon
id|chip-&gt;dev
op_assign
id|dev
suffix:semicolon
id|chip-&gt;card
op_assign
id|card
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|chip-&gt;pcm_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|chip-&gt;midi_list
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_device_new
c_func
(paren
id|card
comma
id|SNDRV_DEV_LOWLEVEL
comma
id|chip
comma
op_amp
id|ops
)paren
)paren
OL
l_int|0
)paren
(brace
id|snd_usb_audio_free
c_func
(paren
id|chip
)paren
suffix:semicolon
id|snd_card_free
c_func
(paren
id|card
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|card-&gt;driver
comma
l_string|&quot;USB-Audio&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|component
comma
l_string|&quot;USB%04x:%04x&quot;
comma
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idVendor
)paren
comma
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idProduct
)paren
)paren
suffix:semicolon
id|snd_component_add
c_func
(paren
id|card
comma
id|component
)paren
suffix:semicolon
multiline_comment|/* retrieve the device string as shortname */
r_if
c_cond
(paren
id|quirk
op_logical_and
id|quirk-&gt;product_name
)paren
(brace
id|strlcpy
c_func
(paren
id|card-&gt;shortname
comma
id|quirk-&gt;product_name
comma
r_sizeof
(paren
id|card-&gt;shortname
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;descriptor.iProduct
op_logical_or
id|usb_string
c_func
(paren
id|dev
comma
id|dev-&gt;descriptor.iProduct
comma
id|card-&gt;shortname
comma
r_sizeof
(paren
id|card-&gt;shortname
)paren
)paren
op_le
l_int|0
)paren
(brace
multiline_comment|/* no name available from anywhere, so use ID */
id|sprintf
c_func
(paren
id|card-&gt;shortname
comma
l_string|&quot;USB Device %#04x:%#04x&quot;
comma
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idVendor
)paren
comma
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idProduct
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* retrieve the vendor and device strings as longname */
r_if
c_cond
(paren
id|quirk
op_logical_and
id|quirk-&gt;vendor_name
)paren
(brace
id|len
op_assign
id|strlcpy
c_func
(paren
id|card-&gt;longname
comma
id|quirk-&gt;vendor_name
comma
r_sizeof
(paren
id|card-&gt;longname
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dev-&gt;descriptor.iManufacturer
)paren
id|len
op_assign
id|usb_string
c_func
(paren
id|dev
comma
id|dev-&gt;descriptor.iManufacturer
comma
id|card-&gt;longname
comma
r_sizeof
(paren
id|card-&gt;longname
)paren
)paren
suffix:semicolon
r_else
id|len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we don&squot;t really care if there isn&squot;t any vendor string */
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
id|strlcat
c_func
(paren
id|card-&gt;longname
comma
l_string|&quot; &quot;
comma
r_sizeof
(paren
id|card-&gt;longname
)paren
)paren
suffix:semicolon
id|strlcat
c_func
(paren
id|card-&gt;longname
comma
id|card-&gt;shortname
comma
r_sizeof
(paren
id|card-&gt;longname
)paren
)paren
suffix:semicolon
id|len
op_assign
id|strlcat
c_func
(paren
id|card-&gt;longname
comma
l_string|&quot; at &quot;
comma
r_sizeof
(paren
id|card-&gt;longname
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
id|card-&gt;longname
)paren
)paren
id|usb_make_path
c_func
(paren
id|dev
comma
id|card-&gt;longname
op_plus
id|len
comma
r_sizeof
(paren
id|card-&gt;longname
)paren
op_minus
id|len
)paren
suffix:semicolon
id|strlcat
c_func
(paren
id|card-&gt;longname
comma
id|snd_usb_get_speed
c_func
(paren
id|dev
)paren
op_eq
id|USB_SPEED_FULL
ques
c_cond
l_string|&quot;, full speed&quot;
suffix:colon
l_string|&quot;, high speed&quot;
comma
r_sizeof
(paren
id|card-&gt;longname
)paren
)paren
suffix:semicolon
id|snd_usb_audio_create_proc
c_func
(paren
id|chip
)paren
suffix:semicolon
id|snd_card_set_dev
c_func
(paren
id|card
comma
op_amp
id|dev-&gt;dev
)paren
suffix:semicolon
op_star
id|rchip
op_assign
id|chip
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * probe the active usb device&n; *&n; * note that this can be called multiple times per a device, when it&n; * includes multiple audio control interfaces.&n; *&n; * thus we check the usb device pointer and creates the card instance&n; * only at the first time.  the successive calls of this function will&n; * append the pcm interface to the corresponding card.&n; */
DECL|function|snd_usb_audio_probe
r_static
r_void
op_star
id|snd_usb_audio_probe
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|usb_interface
op_star
id|intf
comma
r_const
r_struct
id|usb_device_id
op_star
id|usb_id
)paren
(brace
r_struct
id|usb_host_config
op_star
id|config
op_assign
id|dev-&gt;actconfig
suffix:semicolon
r_const
id|snd_usb_audio_quirk_t
op_star
id|quirk
op_assign
(paren
r_const
id|snd_usb_audio_quirk_t
op_star
)paren
id|usb_id-&gt;driver_info
suffix:semicolon
r_int
id|i
comma
id|err
suffix:semicolon
id|snd_usb_audio_t
op_star
id|chip
suffix:semicolon
r_struct
id|usb_host_interface
op_star
id|alts
suffix:semicolon
r_int
id|ifnum
suffix:semicolon
id|alts
op_assign
op_amp
id|intf-&gt;altsetting
(braket
l_int|0
)braket
suffix:semicolon
id|ifnum
op_assign
id|get_iface_desc
c_func
(paren
id|alts
)paren
op_member_access_from_pointer
id|bInterfaceNumber
suffix:semicolon
r_if
c_cond
(paren
id|quirk
op_logical_and
id|quirk-&gt;ifnum
op_ge
l_int|0
op_logical_and
id|ifnum
op_ne
id|quirk-&gt;ifnum
)paren
r_goto
id|__err_val
suffix:semicolon
multiline_comment|/* SB Extigy needs special boot-up sequence */
multiline_comment|/* if more models come, this will go to the quirk list. */
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idVendor
)paren
op_eq
l_int|0x041e
op_logical_and
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idProduct
)paren
op_eq
l_int|0x3000
)paren
(brace
r_if
c_cond
(paren
id|snd_usb_extigy_boot_quirk
c_func
(paren
id|dev
comma
id|intf
)paren
OL
l_int|0
)paren
r_goto
id|__err_val
suffix:semicolon
id|config
op_assign
id|dev-&gt;actconfig
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * found a config.  now register to ALSA&n;&t; */
multiline_comment|/* check whether it&squot;s already registered */
id|chip
op_assign
l_int|NULL
suffix:semicolon
id|down
c_func
(paren
op_amp
id|register_mutex
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SNDRV_CARDS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|usb_chip
(braket
id|i
)braket
op_logical_and
id|usb_chip
(braket
id|i
)braket
op_member_access_from_pointer
id|dev
op_eq
id|dev
)paren
(brace
r_if
c_cond
(paren
id|usb_chip
(braket
id|i
)braket
op_member_access_from_pointer
id|shutdown
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;USB device is in the shutdown state, cannot create a card instance&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|__error
suffix:semicolon
)brace
id|chip
op_assign
id|usb_chip
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|chip
)paren
(brace
multiline_comment|/* it&squot;s a fresh one.&n;&t;&t; * now look for an empty slot and create a new card instance&n;&t;&t; */
multiline_comment|/* first, set the current configuration for this device */
r_if
c_cond
(paren
id|usb_reset_configuration
c_func
(paren
id|dev
)paren
OL
l_int|0
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cannot reset configuration (value 0x%x)&bslash;n&quot;
comma
id|get_cfg_desc
c_func
(paren
id|config
)paren
op_member_access_from_pointer
id|bConfigurationValue
)paren
suffix:semicolon
r_goto
id|__error
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SNDRV_CARDS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|enable
(braket
id|i
)braket
op_logical_and
op_logical_neg
id|usb_chip
(braket
id|i
)braket
op_logical_and
(paren
id|vid
(braket
id|i
)braket
op_eq
op_minus
l_int|1
op_logical_or
id|vid
(braket
id|i
)braket
op_eq
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idVendor
)paren
)paren
op_logical_and
(paren
id|pid
(braket
id|i
)braket
op_eq
op_minus
l_int|1
op_logical_or
id|pid
(braket
id|i
)braket
op_eq
id|le16_to_cpu
c_func
(paren
id|dev-&gt;descriptor.idProduct
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|snd_usb_audio_create
c_func
(paren
id|dev
comma
id|i
comma
id|quirk
comma
op_amp
id|chip
)paren
OL
l_int|0
)paren
(brace
r_goto
id|__error
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|chip
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;no available usb audio device&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|__error
suffix:semicolon
)brace
)brace
id|err
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* continue */
r_if
c_cond
(paren
id|quirk
op_logical_and
id|quirk-&gt;ifnum
op_ne
id|QUIRK_NO_INTERFACE
)paren
(brace
multiline_comment|/* need some special handlings */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_usb_create_quirk
c_func
(paren
id|chip
comma
id|intf
comma
id|quirk
)paren
)paren
OL
l_int|0
)paren
r_goto
id|__error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
OG
l_int|0
)paren
(brace
multiline_comment|/* create normal USB audio interfaces */
r_if
c_cond
(paren
id|snd_usb_create_streams
c_func
(paren
id|chip
comma
id|ifnum
)paren
OL
l_int|0
op_logical_or
id|snd_usb_create_mixer
c_func
(paren
id|chip
comma
id|ifnum
)paren
OL
l_int|0
)paren
(brace
r_goto
id|__error
suffix:semicolon
)brace
)brace
multiline_comment|/* we are allowed to call snd_card_register() many times */
r_if
c_cond
(paren
id|snd_card_register
c_func
(paren
id|chip-&gt;card
)paren
OL
l_int|0
)paren
(brace
r_goto
id|__error
suffix:semicolon
)brace
id|usb_chip
(braket
id|chip-&gt;index
)braket
op_assign
id|chip
suffix:semicolon
id|chip-&gt;num_interfaces
op_increment
suffix:semicolon
id|up
c_func
(paren
op_amp
id|register_mutex
)paren
suffix:semicolon
r_return
id|chip
suffix:semicolon
id|__error
suffix:colon
r_if
c_cond
(paren
id|chip
op_logical_and
op_logical_neg
id|chip-&gt;num_interfaces
)paren
id|snd_card_free
c_func
(paren
id|chip-&gt;card
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|register_mutex
)paren
suffix:semicolon
id|__err_val
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * we need to take care of counter, since disconnection can be called also&n; * many times as well as usb_audio_probe().&n; */
DECL|function|snd_usb_audio_disconnect
r_static
r_void
id|snd_usb_audio_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
(brace
id|snd_usb_audio_t
op_star
id|chip
suffix:semicolon
id|snd_card_t
op_star
id|card
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_eq
(paren
r_void
op_star
)paren
op_minus
l_int|1L
)paren
r_return
suffix:semicolon
id|chip
op_assign
id|ptr
suffix:semicolon
id|card
op_assign
id|chip-&gt;card
suffix:semicolon
id|down
c_func
(paren
op_amp
id|register_mutex
)paren
suffix:semicolon
id|chip-&gt;shutdown
op_assign
l_int|1
suffix:semicolon
id|chip-&gt;num_interfaces
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;num_interfaces
op_le
l_int|0
)paren
(brace
id|snd_card_disconnect
c_func
(paren
id|card
)paren
suffix:semicolon
multiline_comment|/* release the pcm resources */
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|chip-&gt;pcm_list
)paren
(brace
id|snd_usb_stream_disconnect
c_func
(paren
id|p
comma
op_amp
id|usb_audio_driver
)paren
suffix:semicolon
)brace
multiline_comment|/* release the midi resources */
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|chip-&gt;midi_list
)paren
(brace
id|snd_usbmidi_disconnect
c_func
(paren
id|p
comma
op_amp
id|usb_audio_driver
)paren
suffix:semicolon
)brace
id|usb_chip
(braket
id|chip-&gt;index
)braket
op_assign
l_int|NULL
suffix:semicolon
id|up
c_func
(paren
op_amp
id|register_mutex
)paren
suffix:semicolon
id|snd_card_free_in_thread
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
r_else
(brace
id|up
c_func
(paren
op_amp
id|register_mutex
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * new 2.5 USB kernel API&n; */
DECL|function|usb_audio_probe
r_static
r_int
id|usb_audio_probe
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_void
op_star
id|chip
suffix:semicolon
id|chip
op_assign
id|snd_usb_audio_probe
c_func
(paren
id|interface_to_usbdev
c_func
(paren
id|intf
)paren
comma
id|intf
comma
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chip
)paren
(brace
id|dev_set_drvdata
c_func
(paren
op_amp
id|intf-&gt;dev
comma
id|chip
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EIO
suffix:semicolon
)brace
DECL|function|usb_audio_disconnect
r_static
r_void
id|usb_audio_disconnect
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
id|snd_usb_audio_disconnect
c_func
(paren
id|interface_to_usbdev
c_func
(paren
id|intf
)paren
comma
id|dev_get_drvdata
c_func
(paren
op_amp
id|intf-&gt;dev
)paren
)paren
suffix:semicolon
)brace
DECL|function|snd_usb_audio_init
r_static
r_int
id|__init
id|snd_usb_audio_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|nrpacks
template_param
id|MAX_PACKS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;invalid nrpacks value.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|usb_register
c_func
(paren
op_amp
id|usb_audio_driver
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|snd_usb_audio_cleanup
r_static
r_void
id|__exit
id|snd_usb_audio_cleanup
c_func
(paren
r_void
)paren
(brace
id|usb_deregister
c_func
(paren
op_amp
id|usb_audio_driver
)paren
suffix:semicolon
)brace
DECL|variable|snd_usb_audio_init
id|module_init
c_func
(paren
id|snd_usb_audio_init
)paren
suffix:semicolon
DECL|variable|snd_usb_audio_cleanup
id|module_exit
c_func
(paren
id|snd_usb_audio_cleanup
)paren
suffix:semicolon
eof
