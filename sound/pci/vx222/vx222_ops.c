multiline_comment|/*&n; * Driver for Digigram VX222 V2/Mic soundcards&n; *&n; * VX222-specific low-level routines&n; *&n; * Copyright (c) 2002 by Takashi Iwai &lt;tiwai@suse.de&gt;&n; *&n; *   This program is free software; you can redistribute it and/or modify&n; *   it under the terms of the GNU General Public License as published by&n; *   the Free Software Foundation; either version 2 of the License, or&n; *   (at your option) any later version.&n; *&n; *   This program is distributed in the hope that it will be useful,&n; *   but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *   GNU General Public License for more details.&n; *&n; *   You should have received a copy of the GNU General Public License&n; *   along with this program; if not, write to the Free Software&n; *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA&n; */
macro_line|#include &lt;sound/driver.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/firmware.h&gt;
macro_line|#include &lt;sound/core.h&gt;
macro_line|#include &lt;sound/control.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;vx222.h&quot;
DECL|variable|vx2_reg_offset
r_static
r_int
id|vx2_reg_offset
(braket
id|VX_REG_MAX
)braket
op_assign
(brace
(braket
id|VX_ICR
)braket
op_assign
l_int|0x00
comma
(braket
id|VX_CVR
)braket
op_assign
l_int|0x04
comma
(braket
id|VX_ISR
)braket
op_assign
l_int|0x08
comma
(braket
id|VX_IVR
)braket
op_assign
l_int|0x0c
comma
(braket
id|VX_RXH
)braket
op_assign
l_int|0x14
comma
(braket
id|VX_RXM
)braket
op_assign
l_int|0x18
comma
(braket
id|VX_RXL
)braket
op_assign
l_int|0x1c
comma
(braket
id|VX_DMA
)braket
op_assign
l_int|0x10
comma
(braket
id|VX_CDSP
)braket
op_assign
l_int|0x20
comma
(braket
id|VX_CFG
)braket
op_assign
l_int|0x24
comma
(braket
id|VX_RUER
)braket
op_assign
l_int|0x28
comma
(braket
id|VX_DATA
)braket
op_assign
l_int|0x2c
comma
(braket
id|VX_STATUS
)braket
op_assign
l_int|0x30
comma
(braket
id|VX_LOFREQ
)braket
op_assign
l_int|0x34
comma
(braket
id|VX_HIFREQ
)braket
op_assign
l_int|0x38
comma
(braket
id|VX_CSUER
)braket
op_assign
l_int|0x3c
comma
(braket
id|VX_SELMIC
)braket
op_assign
l_int|0x40
comma
(braket
id|VX_COMPOT
)braket
op_assign
l_int|0x44
comma
singleline_comment|// Write: POTENTIOMETER ; Read: COMPRESSION LEVEL activate
(braket
id|VX_SCOMPR
)braket
op_assign
l_int|0x48
comma
singleline_comment|// Read: COMPRESSION THRESHOLD activate
(braket
id|VX_GLIMIT
)braket
op_assign
l_int|0x4c
comma
singleline_comment|// Read: LEVEL LIMITATION activate
(braket
id|VX_INTCSR
)braket
op_assign
l_int|0x4c
comma
singleline_comment|// VX_INTCSR_REGISTER_OFFSET
(braket
id|VX_CNTRL
)braket
op_assign
l_int|0x50
comma
singleline_comment|// VX_CNTRL_REGISTER_OFFSET
(braket
id|VX_GPIOC
)braket
op_assign
l_int|0x54
comma
singleline_comment|// VX_GPIOC (new with PLX9030)
)brace
suffix:semicolon
DECL|variable|vx2_reg_index
r_static
r_int
id|vx2_reg_index
(braket
id|VX_REG_MAX
)braket
op_assign
(brace
(braket
id|VX_ICR
)braket
op_assign
l_int|1
comma
(braket
id|VX_CVR
)braket
op_assign
l_int|1
comma
(braket
id|VX_ISR
)braket
op_assign
l_int|1
comma
(braket
id|VX_IVR
)braket
op_assign
l_int|1
comma
(braket
id|VX_RXH
)braket
op_assign
l_int|1
comma
(braket
id|VX_RXM
)braket
op_assign
l_int|1
comma
(braket
id|VX_RXL
)braket
op_assign
l_int|1
comma
(braket
id|VX_DMA
)braket
op_assign
l_int|1
comma
(braket
id|VX_CDSP
)braket
op_assign
l_int|1
comma
(braket
id|VX_CFG
)braket
op_assign
l_int|1
comma
(braket
id|VX_RUER
)braket
op_assign
l_int|1
comma
(braket
id|VX_DATA
)braket
op_assign
l_int|1
comma
(braket
id|VX_STATUS
)braket
op_assign
l_int|1
comma
(braket
id|VX_LOFREQ
)braket
op_assign
l_int|1
comma
(braket
id|VX_HIFREQ
)braket
op_assign
l_int|1
comma
(braket
id|VX_CSUER
)braket
op_assign
l_int|1
comma
(braket
id|VX_SELMIC
)braket
op_assign
l_int|1
comma
(braket
id|VX_COMPOT
)braket
op_assign
l_int|1
comma
(braket
id|VX_SCOMPR
)braket
op_assign
l_int|1
comma
(braket
id|VX_GLIMIT
)braket
op_assign
l_int|1
comma
(braket
id|VX_INTCSR
)braket
op_assign
l_int|0
comma
multiline_comment|/* on the PLX */
(braket
id|VX_CNTRL
)braket
op_assign
l_int|0
comma
multiline_comment|/* on the PLX */
(braket
id|VX_GPIOC
)braket
op_assign
l_int|0
comma
multiline_comment|/* on the PLX */
)brace
suffix:semicolon
DECL|function|vx2_reg_addr
r_inline
r_static
r_int
r_int
id|vx2_reg_addr
c_func
(paren
id|vx_core_t
op_star
id|_chip
comma
r_int
id|reg
)paren
(brace
r_struct
id|snd_vx222
op_star
id|chip
op_assign
(paren
r_struct
id|snd_vx222
op_star
)paren
id|_chip
suffix:semicolon
r_return
id|chip-&gt;port
(braket
id|vx2_reg_index
(braket
id|reg
)braket
)braket
op_plus
id|vx2_reg_offset
(braket
id|reg
)braket
suffix:semicolon
)brace
multiline_comment|/**&n; * snd_vx_inb - read a byte from the register&n; * @offset: register enum&n; */
DECL|function|vx2_inb
r_static
r_int
r_char
id|vx2_inb
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
r_int
id|offset
)paren
(brace
r_return
id|inb
c_func
(paren
id|vx2_reg_addr
c_func
(paren
id|chip
comma
id|offset
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * snd_vx_outb - write a byte on the register&n; * @offset: the register offset&n; * @val: the value to write&n; */
DECL|function|vx2_outb
r_static
r_void
id|vx2_outb
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
r_int
id|offset
comma
r_int
r_char
id|val
)paren
(brace
id|outb
c_func
(paren
id|val
comma
id|vx2_reg_addr
c_func
(paren
id|chip
comma
id|offset
)paren
)paren
suffix:semicolon
singleline_comment|//printk(&quot;outb: %x -&gt; %x&bslash;n&quot;, val, vx2_reg_addr(chip, offset));
)brace
multiline_comment|/**&n; * snd_vx_inl - read a 32bit word from the register&n; * @offset: register enum&n; */
DECL|function|vx2_inl
r_static
r_int
r_int
id|vx2_inl
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
r_int
id|offset
)paren
(brace
r_return
id|inl
c_func
(paren
id|vx2_reg_addr
c_func
(paren
id|chip
comma
id|offset
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * snd_vx_outl - write a 32bit word on the register&n; * @offset: the register enum&n; * @val: the value to write&n; */
DECL|function|vx2_outl
r_static
r_void
id|vx2_outl
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
r_int
id|offset
comma
r_int
r_int
id|val
)paren
(brace
singleline_comment|// printk(&quot;outl: %x -&gt; %x&bslash;n&quot;, val, vx2_reg_addr(chip, offset));
id|outl
c_func
(paren
id|val
comma
id|vx2_reg_addr
c_func
(paren
id|chip
comma
id|offset
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * redefine macros to call directly&n; */
DECL|macro|vx_inb
macro_line|#undef vx_inb
DECL|macro|vx_inb
mdefine_line|#define vx_inb(chip,reg)&t;vx2_inb((vx_core_t*)(chip), VX_##reg)
DECL|macro|vx_outb
macro_line|#undef vx_outb
DECL|macro|vx_outb
mdefine_line|#define vx_outb(chip,reg,val)&t;vx2_outb((vx_core_t*)(chip), VX_##reg, val)
DECL|macro|vx_inl
macro_line|#undef vx_inl
DECL|macro|vx_inl
mdefine_line|#define vx_inl(chip,reg)&t;vx2_inl((vx_core_t*)(chip), VX_##reg)
DECL|macro|vx_outl
macro_line|#undef vx_outl
DECL|macro|vx_outl
mdefine_line|#define vx_outl(chip,reg,val)&t;vx2_outl((vx_core_t*)(chip), VX_##reg, val)
multiline_comment|/*&n; * vx_reset_dsp - reset the DSP&n; */
DECL|macro|XX_DSP_RESET_WAIT_TIME
mdefine_line|#define XX_DSP_RESET_WAIT_TIME&t;&t;2&t;/* ms */
DECL|function|vx2_reset_dsp
r_static
r_void
id|vx2_reset_dsp
c_func
(paren
id|vx_core_t
op_star
id|_chip
)paren
(brace
r_struct
id|snd_vx222
op_star
id|chip
op_assign
(paren
r_struct
id|snd_vx222
op_star
)paren
id|_chip
suffix:semicolon
multiline_comment|/* set the reset dsp bit to 0 */
id|vx_outl
c_func
(paren
id|chip
comma
id|CDSP
comma
id|chip-&gt;regCDSP
op_amp
op_complement
id|VX_CDSP_DSP_RESET_MASK
)paren
suffix:semicolon
id|snd_vx_delay
c_func
(paren
id|_chip
comma
id|XX_DSP_RESET_WAIT_TIME
)paren
suffix:semicolon
id|chip-&gt;regCDSP
op_or_assign
id|VX_CDSP_DSP_RESET_MASK
suffix:semicolon
multiline_comment|/* set the reset dsp bit to 1 */
id|vx_outl
c_func
(paren
id|chip
comma
id|CDSP
comma
id|chip-&gt;regCDSP
)paren
suffix:semicolon
)brace
DECL|function|vx2_test_xilinx
r_static
r_int
id|vx2_test_xilinx
c_func
(paren
id|vx_core_t
op_star
id|_chip
)paren
(brace
r_struct
id|snd_vx222
op_star
id|chip
op_assign
(paren
r_struct
id|snd_vx222
op_star
)paren
id|_chip
suffix:semicolon
r_int
r_int
id|data
suffix:semicolon
id|snd_printdd
c_func
(paren
l_string|&quot;testing xilinx...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* This test uses several write/read sequences on TEST0 and TEST1 bits&n;&t; * to figure out whever or not the xilinx was correctly loaded&n;&t; */
multiline_comment|/* We write 1 on CDSP.TEST0. We should get 0 on STATUS.TEST0. */
id|vx_outl
c_func
(paren
id|chip
comma
id|CDSP
comma
id|chip-&gt;regCDSP
op_or
id|VX_CDSP_TEST0_MASK
)paren
suffix:semicolon
id|vx_inl
c_func
(paren
id|chip
comma
id|ISR
)paren
suffix:semicolon
id|data
op_assign
id|vx_inl
c_func
(paren
id|chip
comma
id|STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data
op_amp
id|VX_STATUS_VAL_TEST0_MASK
)paren
op_eq
id|VX_STATUS_VAL_TEST0_MASK
)paren
(brace
id|snd_printdd
c_func
(paren
l_string|&quot;bad!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* We write 0 on CDSP.TEST0. We should get 1 on STATUS.TEST0. */
id|vx_outl
c_func
(paren
id|chip
comma
id|CDSP
comma
id|chip-&gt;regCDSP
op_amp
op_complement
id|VX_CDSP_TEST0_MASK
)paren
suffix:semicolon
id|vx_inl
c_func
(paren
id|chip
comma
id|ISR
)paren
suffix:semicolon
id|data
op_assign
id|vx_inl
c_func
(paren
id|chip
comma
id|STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|data
op_amp
id|VX_STATUS_VAL_TEST0_MASK
)paren
)paren
(brace
id|snd_printdd
c_func
(paren
l_string|&quot;bad! #2&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|_chip-&gt;type
op_eq
id|VX_TYPE_BOARD
)paren
(brace
multiline_comment|/* not implemented on VX_2_BOARDS */
multiline_comment|/* We write 1 on CDSP.TEST1. We should get 0 on STATUS.TEST1. */
id|vx_outl
c_func
(paren
id|chip
comma
id|CDSP
comma
id|chip-&gt;regCDSP
op_or
id|VX_CDSP_TEST1_MASK
)paren
suffix:semicolon
id|vx_inl
c_func
(paren
id|chip
comma
id|ISR
)paren
suffix:semicolon
id|data
op_assign
id|vx_inl
c_func
(paren
id|chip
comma
id|STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data
op_amp
id|VX_STATUS_VAL_TEST1_MASK
)paren
op_eq
id|VX_STATUS_VAL_TEST1_MASK
)paren
(brace
id|snd_printdd
c_func
(paren
l_string|&quot;bad! #3&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* We write 0 on CDSP.TEST1. We should get 1 on STATUS.TEST1. */
id|vx_outl
c_func
(paren
id|chip
comma
id|CDSP
comma
id|chip-&gt;regCDSP
op_amp
op_complement
id|VX_CDSP_TEST1_MASK
)paren
suffix:semicolon
id|vx_inl
c_func
(paren
id|chip
comma
id|ISR
)paren
suffix:semicolon
id|data
op_assign
id|vx_inl
c_func
(paren
id|chip
comma
id|STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|data
op_amp
id|VX_STATUS_VAL_TEST1_MASK
)paren
)paren
(brace
id|snd_printdd
c_func
(paren
l_string|&quot;bad! #4&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
id|snd_printdd
c_func
(paren
l_string|&quot;ok, xilinx fine.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * vx_setup_pseudo_dma - set up the pseudo dma read/write mode.&n; * @do_write: 0 = read, 1 = set up for DMA write&n; */
DECL|function|vx2_setup_pseudo_dma
r_static
r_void
id|vx2_setup_pseudo_dma
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
r_int
id|do_write
)paren
(brace
multiline_comment|/* Interrupt mode and HREQ pin enabled for host transmit data transfers&n;&t; * (in case of the use of the pseudo-dma facility).&n;&t; */
id|vx_outl
c_func
(paren
id|chip
comma
id|ICR
comma
id|do_write
ques
c_cond
id|ICR_TREQ
suffix:colon
id|ICR_RREQ
)paren
suffix:semicolon
multiline_comment|/* Reset the pseudo-dma register (in case of the use of the&n;&t; * pseudo-dma facility).&n;&t; */
id|vx_outl
c_func
(paren
id|chip
comma
id|RESET_DMA
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_release_pseudo_dma - disable the pseudo-DMA mode&n; */
DECL|function|vx2_release_pseudo_dma
r_inline
r_static
r_void
id|vx2_release_pseudo_dma
c_func
(paren
id|vx_core_t
op_star
id|chip
)paren
(brace
multiline_comment|/* HREQ pin disabled. */
id|vx_outl
c_func
(paren
id|chip
comma
id|ICR
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* pseudo-dma write */
DECL|function|vx2_dma_write
r_static
r_void
id|vx2_dma_write
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
id|snd_pcm_runtime_t
op_star
id|runtime
comma
id|vx_pipe_t
op_star
id|pipe
comma
r_int
id|count
)paren
(brace
r_int
r_int
id|port
op_assign
id|vx2_reg_addr
c_func
(paren
id|chip
comma
id|VX_DMA
)paren
suffix:semicolon
r_int
id|offset
op_assign
id|pipe-&gt;hw_ptr
suffix:semicolon
id|u32
op_star
id|addr
op_assign
(paren
id|u32
op_star
)paren
(paren
id|runtime-&gt;dma_area
op_plus
id|offset
)paren
suffix:semicolon
id|snd_assert
c_func
(paren
id|count
op_mod
l_int|4
op_eq
l_int|0
comma
r_return
)paren
suffix:semicolon
id|vx2_setup_pseudo_dma
c_func
(paren
id|chip
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Transfer using pseudo-dma.&n;&t; */
r_if
c_cond
(paren
id|offset
op_plus
id|count
OG
id|pipe-&gt;buffer_bytes
)paren
(brace
r_int
id|length
op_assign
id|pipe-&gt;buffer_bytes
op_minus
id|offset
suffix:semicolon
id|count
op_sub_assign
id|length
suffix:semicolon
id|length
op_rshift_assign
l_int|2
suffix:semicolon
multiline_comment|/* in 32bit words */
multiline_comment|/* Transfer using pseudo-dma. */
r_while
c_loop
(paren
id|length
op_decrement
OG
l_int|0
)paren
(brace
id|outl
c_func
(paren
id|cpu_to_le32
c_func
(paren
op_star
id|addr
)paren
comma
id|port
)paren
suffix:semicolon
id|addr
op_increment
suffix:semicolon
)brace
id|addr
op_assign
(paren
id|u32
op_star
)paren
id|runtime-&gt;dma_area
suffix:semicolon
id|pipe-&gt;hw_ptr
op_assign
l_int|0
suffix:semicolon
)brace
id|pipe-&gt;hw_ptr
op_add_assign
id|count
suffix:semicolon
id|count
op_rshift_assign
l_int|2
suffix:semicolon
multiline_comment|/* in 32bit words */
multiline_comment|/* Transfer using pseudo-dma. */
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
(brace
id|outl
c_func
(paren
id|cpu_to_le32
c_func
(paren
op_star
id|addr
)paren
comma
id|port
)paren
suffix:semicolon
id|addr
op_increment
suffix:semicolon
)brace
id|vx2_release_pseudo_dma
c_func
(paren
id|chip
)paren
suffix:semicolon
)brace
multiline_comment|/* pseudo dma read */
DECL|function|vx2_dma_read
r_static
r_void
id|vx2_dma_read
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
id|snd_pcm_runtime_t
op_star
id|runtime
comma
id|vx_pipe_t
op_star
id|pipe
comma
r_int
id|count
)paren
(brace
r_int
id|offset
op_assign
id|pipe-&gt;hw_ptr
suffix:semicolon
id|u32
op_star
id|addr
op_assign
(paren
id|u32
op_star
)paren
(paren
id|runtime-&gt;dma_area
op_plus
id|offset
)paren
suffix:semicolon
r_int
r_int
id|port
op_assign
id|vx2_reg_addr
c_func
(paren
id|chip
comma
id|VX_DMA
)paren
suffix:semicolon
id|snd_assert
c_func
(paren
id|count
op_mod
l_int|4
op_eq
l_int|0
comma
r_return
)paren
suffix:semicolon
id|vx2_setup_pseudo_dma
c_func
(paren
id|chip
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Transfer using pseudo-dma.&n;&t; */
r_if
c_cond
(paren
id|offset
op_plus
id|count
OG
id|pipe-&gt;buffer_bytes
)paren
(brace
r_int
id|length
op_assign
id|pipe-&gt;buffer_bytes
op_minus
id|offset
suffix:semicolon
id|count
op_sub_assign
id|length
suffix:semicolon
id|length
op_rshift_assign
l_int|2
suffix:semicolon
multiline_comment|/* in 32bit words */
multiline_comment|/* Transfer using pseudo-dma. */
r_while
c_loop
(paren
id|length
op_decrement
OG
l_int|0
)paren
op_star
id|addr
op_increment
op_assign
id|le32_to_cpu
c_func
(paren
id|inl
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
id|addr
op_assign
(paren
id|u32
op_star
)paren
id|runtime-&gt;dma_area
suffix:semicolon
id|pipe-&gt;hw_ptr
op_assign
l_int|0
suffix:semicolon
)brace
id|pipe-&gt;hw_ptr
op_add_assign
id|count
suffix:semicolon
id|count
op_rshift_assign
l_int|2
suffix:semicolon
multiline_comment|/* in 32bit words */
multiline_comment|/* Transfer using pseudo-dma. */
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
op_star
id|addr
op_increment
op_assign
id|le32_to_cpu
c_func
(paren
id|inl
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
id|vx2_release_pseudo_dma
c_func
(paren
id|chip
)paren
suffix:semicolon
)brace
DECL|macro|VX_XILINX_RESET_MASK
mdefine_line|#define VX_XILINX_RESET_MASK        0x40000000
DECL|macro|VX_USERBIT0_MASK
mdefine_line|#define VX_USERBIT0_MASK            0x00000004
DECL|macro|VX_USERBIT1_MASK
mdefine_line|#define VX_USERBIT1_MASK            0x00000020
DECL|macro|VX_CNTRL_REGISTER_VALUE
mdefine_line|#define VX_CNTRL_REGISTER_VALUE     0x00172012
multiline_comment|/*&n; * transfer counts bits to PLX&n; */
DECL|function|put_xilinx_data
r_static
r_int
id|put_xilinx_data
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
r_int
r_int
id|port
comma
r_int
r_int
id|counts
comma
r_int
r_char
id|data
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|counts
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
multiline_comment|/* set the clock bit to 0. */
id|val
op_assign
id|VX_CNTRL_REGISTER_VALUE
op_amp
op_complement
id|VX_USERBIT0_MASK
suffix:semicolon
id|vx2_outl
c_func
(paren
id|chip
comma
id|port
comma
id|val
)paren
suffix:semicolon
id|vx2_inl
c_func
(paren
id|chip
comma
id|port
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
id|val
op_or_assign
id|VX_USERBIT1_MASK
suffix:semicolon
r_else
id|val
op_and_assign
op_complement
id|VX_USERBIT1_MASK
suffix:semicolon
id|vx2_outl
c_func
(paren
id|chip
comma
id|port
comma
id|val
)paren
suffix:semicolon
id|vx2_inl
c_func
(paren
id|chip
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* set the clock bit to 1. */
id|val
op_or_assign
id|VX_USERBIT0_MASK
suffix:semicolon
id|vx2_outl
c_func
(paren
id|chip
comma
id|port
comma
id|val
)paren
suffix:semicolon
id|vx2_inl
c_func
(paren
id|chip
comma
id|port
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * load the xilinx image&n; */
DECL|function|vx2_load_xilinx_binary
r_static
r_int
id|vx2_load_xilinx_binary
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
r_const
r_struct
id|firmware
op_star
id|xilinx
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|port
suffix:semicolon
r_int
r_char
op_star
id|image
suffix:semicolon
multiline_comment|/* XILINX reset (wait at least 1 milisecond between reset on and off). */
id|vx_outl
c_func
(paren
id|chip
comma
id|CNTRL
comma
id|VX_CNTRL_REGISTER_VALUE
op_or
id|VX_XILINX_RESET_MASK
)paren
suffix:semicolon
id|vx_inl
c_func
(paren
id|chip
comma
id|CNTRL
)paren
suffix:semicolon
id|snd_vx_delay
c_func
(paren
id|chip
comma
l_int|10
)paren
suffix:semicolon
id|vx_outl
c_func
(paren
id|chip
comma
id|CNTRL
comma
id|VX_CNTRL_REGISTER_VALUE
)paren
suffix:semicolon
id|vx_inl
c_func
(paren
id|chip
comma
id|CNTRL
)paren
suffix:semicolon
id|snd_vx_delay
c_func
(paren
id|chip
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;type
op_eq
id|VX_TYPE_BOARD
)paren
id|port
op_assign
id|VX_CNTRL
suffix:semicolon
r_else
id|port
op_assign
id|VX_GPIOC
suffix:semicolon
multiline_comment|/* VX222 V2 and VX222_MIC_BOARD with new PLX9030 use this register */
id|image
op_assign
id|xilinx-&gt;data
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|xilinx-&gt;size
suffix:semicolon
id|i
op_increment
comma
id|image
op_increment
)paren
(brace
r_if
c_cond
(paren
id|put_xilinx_data
c_func
(paren
id|chip
comma
id|port
comma
l_int|8
comma
op_star
id|image
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* don&squot;t take too much time in this loop... */
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
id|put_xilinx_data
c_func
(paren
id|chip
comma
id|port
comma
l_int|4
comma
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* end signature */
id|snd_vx_delay
c_func
(paren
id|chip
comma
l_int|200
)paren
suffix:semicolon
multiline_comment|/* test after loading (is buggy with VX222) */
r_if
c_cond
(paren
id|chip-&gt;type
op_ne
id|VX_TYPE_BOARD
)paren
(brace
multiline_comment|/* Test if load successful: test bit 8 of register GPIOC (VX222: use CNTRL) ! */
id|i
op_assign
id|vx_inl
c_func
(paren
id|chip
comma
id|GPIOC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
l_int|0x0100
)paren
r_return
l_int|0
suffix:semicolon
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;vx222: xilinx test failed after load, GPIOC=0x%x&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * load the boot/dsp images&n; */
DECL|function|vx2_load_dsp
r_static
r_int
id|vx2_load_dsp
c_func
(paren
id|vx_core_t
op_star
id|vx
comma
r_int
id|index
comma
r_const
r_struct
id|firmware
op_star
id|dsp
)paren
(brace
r_int
id|err
suffix:semicolon
r_switch
c_cond
(paren
id|index
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* xilinx image */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|vx2_load_xilinx_binary
c_func
(paren
id|vx
comma
id|dsp
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|vx2_test_xilinx
c_func
(paren
id|vx
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* DSP boot */
r_return
id|snd_vx_dsp_boot
c_func
(paren
id|vx
comma
id|dsp
)paren
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* DSP image */
r_return
id|snd_vx_dsp_load
c_func
(paren
id|vx
comma
id|dsp
)paren
suffix:semicolon
r_default
suffix:colon
id|snd_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * vx_test_and_ack - test and acknowledge interrupt&n; *&n; * called from irq hander, too&n; *&n; * spinlock held!&n; */
DECL|function|vx2_test_and_ack
r_static
r_int
id|vx2_test_and_ack
c_func
(paren
id|vx_core_t
op_star
id|chip
)paren
(brace
multiline_comment|/* not booted yet? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|chip-&gt;chip_status
op_amp
id|VX_STAT_XILINX_LOADED
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|vx_inl
c_func
(paren
id|chip
comma
id|STATUS
)paren
op_amp
id|VX_STATUS_MEMIRQ_MASK
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* ok, interrupts generated, now ack it */
multiline_comment|/* set ACQUIT bit up and down */
id|vx_outl
c_func
(paren
id|chip
comma
id|STATUS
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* useless read just to spend some time and maintain&n;&t; * the ACQUIT signal up for a while ( a bus cycle )&n;&t; */
id|vx_inl
c_func
(paren
id|chip
comma
id|STATUS
)paren
suffix:semicolon
multiline_comment|/* ack */
id|vx_outl
c_func
(paren
id|chip
comma
id|STATUS
comma
id|VX_STATUS_MEMIRQ_MASK
)paren
suffix:semicolon
multiline_comment|/* useless read just to spend some time and maintain&n;&t; * the ACQUIT signal up for a while ( a bus cycle ) */
id|vx_inl
c_func
(paren
id|chip
comma
id|STATUS
)paren
suffix:semicolon
multiline_comment|/* clear */
id|vx_outl
c_func
(paren
id|chip
comma
id|STATUS
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * vx_validate_irq - enable/disable IRQ&n; */
DECL|function|vx2_validate_irq
r_static
r_void
id|vx2_validate_irq
c_func
(paren
id|vx_core_t
op_star
id|_chip
comma
r_int
id|enable
)paren
(brace
r_struct
id|snd_vx222
op_star
id|chip
op_assign
(paren
r_struct
id|snd_vx222
op_star
)paren
id|_chip
suffix:semicolon
multiline_comment|/* Set the interrupt enable bit to 1 in CDSP register */
r_if
c_cond
(paren
id|enable
)paren
(brace
multiline_comment|/* Set the PCI interrupt enable bit to 1.*/
id|vx_outl
c_func
(paren
id|chip
comma
id|INTCSR
comma
id|VX_INTCSR_VALUE
op_or
id|VX_PCI_INTERRUPT_MASK
)paren
suffix:semicolon
id|chip-&gt;regCDSP
op_or_assign
id|VX_CDSP_VALID_IRQ_MASK
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Set the PCI interrupt enable bit to 0. */
id|vx_outl
c_func
(paren
id|chip
comma
id|INTCSR
comma
id|VX_INTCSR_VALUE
op_amp
op_complement
id|VX_PCI_INTERRUPT_MASK
)paren
suffix:semicolon
id|chip-&gt;regCDSP
op_and_assign
op_complement
id|VX_CDSP_VALID_IRQ_MASK
suffix:semicolon
)brace
id|vx_outl
c_func
(paren
id|chip
comma
id|CDSP
comma
id|chip-&gt;regCDSP
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * write an AKM codec data (24bit)&n; */
DECL|function|vx2_write_codec_reg
r_static
r_void
id|vx2_write_codec_reg
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|vx_inl
c_func
(paren
id|chip
comma
id|HIFREQ
)paren
suffix:semicolon
multiline_comment|/* We have to send 24 bits (3 x 8 bits). Start with most signif. Bit */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|24
suffix:semicolon
id|i
op_increment
comma
id|data
op_lshift_assign
l_int|1
)paren
id|vx_outl
c_func
(paren
id|chip
comma
id|DATA
comma
(paren
(paren
id|data
op_amp
l_int|0x800000
)paren
ques
c_cond
id|VX_DATA_CODEC_MASK
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/* Terminate access to codec registers */
id|vx_inl
c_func
(paren
id|chip
comma
id|RUER
)paren
suffix:semicolon
)brace
DECL|macro|AKM_CODEC_POWER_CONTROL_CMD
mdefine_line|#define AKM_CODEC_POWER_CONTROL_CMD 0xA007
DECL|macro|AKM_CODEC_RESET_ON_CMD
mdefine_line|#define AKM_CODEC_RESET_ON_CMD      0xA100
DECL|macro|AKM_CODEC_RESET_OFF_CMD
mdefine_line|#define AKM_CODEC_RESET_OFF_CMD     0xA103
DECL|macro|AKM_CODEC_CLOCK_FORMAT_CMD
mdefine_line|#define AKM_CODEC_CLOCK_FORMAT_CMD  0xA240
DECL|macro|AKM_CODEC_MUTE_CMD
mdefine_line|#define AKM_CODEC_MUTE_CMD          0xA38D
DECL|macro|AKM_CODEC_UNMUTE_CMD
mdefine_line|#define AKM_CODEC_UNMUTE_CMD        0xA30D
DECL|macro|AKM_CODEC_LEFT_LEVEL_CMD
mdefine_line|#define AKM_CODEC_LEFT_LEVEL_CMD    0xA400
DECL|macro|AKM_CODEC_RIGHT_LEVEL_CMD
mdefine_line|#define AKM_CODEC_RIGHT_LEVEL_CMD   0xA500
DECL|variable|vx2_akm_gains_lut
r_static
r_const
id|u8
id|vx2_akm_gains_lut
(braket
id|VX2_AKM_LEVEL_MAX
op_plus
l_int|1
)braket
op_assign
(brace
l_int|0x7f
comma
singleline_comment|// [000] =  +0.000 dB  -&gt;  AKM(0x7f) =  +0.000 dB  error(+0.000 dB)
l_int|0x7d
comma
singleline_comment|// [001] =  -0.500 dB  -&gt;  AKM(0x7d) =  -0.572 dB  error(-0.072 dB)
l_int|0x7c
comma
singleline_comment|// [002] =  -1.000 dB  -&gt;  AKM(0x7c) =  -0.873 dB  error(+0.127 dB)
l_int|0x7a
comma
singleline_comment|// [003] =  -1.500 dB  -&gt;  AKM(0x7a) =  -1.508 dB  error(-0.008 dB)
l_int|0x79
comma
singleline_comment|// [004] =  -2.000 dB  -&gt;  AKM(0x79) =  -1.844 dB  error(+0.156 dB)
l_int|0x77
comma
singleline_comment|// [005] =  -2.500 dB  -&gt;  AKM(0x77) =  -2.557 dB  error(-0.057 dB)
l_int|0x76
comma
singleline_comment|// [006] =  -3.000 dB  -&gt;  AKM(0x76) =  -2.937 dB  error(+0.063 dB)
l_int|0x75
comma
singleline_comment|// [007] =  -3.500 dB  -&gt;  AKM(0x75) =  -3.334 dB  error(+0.166 dB)
l_int|0x73
comma
singleline_comment|// [008] =  -4.000 dB  -&gt;  AKM(0x73) =  -4.188 dB  error(-0.188 dB)
l_int|0x72
comma
singleline_comment|// [009] =  -4.500 dB  -&gt;  AKM(0x72) =  -4.648 dB  error(-0.148 dB)
l_int|0x71
comma
singleline_comment|// [010] =  -5.000 dB  -&gt;  AKM(0x71) =  -5.134 dB  error(-0.134 dB)
l_int|0x70
comma
singleline_comment|// [011] =  -5.500 dB  -&gt;  AKM(0x70) =  -5.649 dB  error(-0.149 dB)
l_int|0x6f
comma
singleline_comment|// [012] =  -6.000 dB  -&gt;  AKM(0x6f) =  -6.056 dB  error(-0.056 dB)
l_int|0x6d
comma
singleline_comment|// [013] =  -6.500 dB  -&gt;  AKM(0x6d) =  -6.631 dB  error(-0.131 dB)
l_int|0x6c
comma
singleline_comment|// [014] =  -7.000 dB  -&gt;  AKM(0x6c) =  -6.933 dB  error(+0.067 dB)
l_int|0x6a
comma
singleline_comment|// [015] =  -7.500 dB  -&gt;  AKM(0x6a) =  -7.571 dB  error(-0.071 dB)
l_int|0x69
comma
singleline_comment|// [016] =  -8.000 dB  -&gt;  AKM(0x69) =  -7.909 dB  error(+0.091 dB)
l_int|0x67
comma
singleline_comment|// [017] =  -8.500 dB  -&gt;  AKM(0x67) =  -8.626 dB  error(-0.126 dB)
l_int|0x66
comma
singleline_comment|// [018] =  -9.000 dB  -&gt;  AKM(0x66) =  -9.008 dB  error(-0.008 dB)
l_int|0x65
comma
singleline_comment|// [019] =  -9.500 dB  -&gt;  AKM(0x65) =  -9.407 dB  error(+0.093 dB)
l_int|0x64
comma
singleline_comment|// [020] = -10.000 dB  -&gt;  AKM(0x64) =  -9.826 dB  error(+0.174 dB)
l_int|0x62
comma
singleline_comment|// [021] = -10.500 dB  -&gt;  AKM(0x62) = -10.730 dB  error(-0.230 dB)
l_int|0x61
comma
singleline_comment|// [022] = -11.000 dB  -&gt;  AKM(0x61) = -11.219 dB  error(-0.219 dB)
l_int|0x60
comma
singleline_comment|// [023] = -11.500 dB  -&gt;  AKM(0x60) = -11.738 dB  error(-0.238 dB)
l_int|0x5f
comma
singleline_comment|// [024] = -12.000 dB  -&gt;  AKM(0x5f) = -12.149 dB  error(-0.149 dB)
l_int|0x5e
comma
singleline_comment|// [025] = -12.500 dB  -&gt;  AKM(0x5e) = -12.434 dB  error(+0.066 dB)
l_int|0x5c
comma
singleline_comment|// [026] = -13.000 dB  -&gt;  AKM(0x5c) = -13.033 dB  error(-0.033 dB)
l_int|0x5b
comma
singleline_comment|// [027] = -13.500 dB  -&gt;  AKM(0x5b) = -13.350 dB  error(+0.150 dB)
l_int|0x59
comma
singleline_comment|// [028] = -14.000 dB  -&gt;  AKM(0x59) = -14.018 dB  error(-0.018 dB)
l_int|0x58
comma
singleline_comment|// [029] = -14.500 dB  -&gt;  AKM(0x58) = -14.373 dB  error(+0.127 dB)
l_int|0x56
comma
singleline_comment|// [030] = -15.000 dB  -&gt;  AKM(0x56) = -15.130 dB  error(-0.130 dB)
l_int|0x55
comma
singleline_comment|// [031] = -15.500 dB  -&gt;  AKM(0x55) = -15.534 dB  error(-0.034 dB)
l_int|0x54
comma
singleline_comment|// [032] = -16.000 dB  -&gt;  AKM(0x54) = -15.958 dB  error(+0.042 dB)
l_int|0x53
comma
singleline_comment|// [033] = -16.500 dB  -&gt;  AKM(0x53) = -16.404 dB  error(+0.096 dB)
l_int|0x52
comma
singleline_comment|// [034] = -17.000 dB  -&gt;  AKM(0x52) = -16.874 dB  error(+0.126 dB)
l_int|0x51
comma
singleline_comment|// [035] = -17.500 dB  -&gt;  AKM(0x51) = -17.371 dB  error(+0.129 dB)
l_int|0x50
comma
singleline_comment|// [036] = -18.000 dB  -&gt;  AKM(0x50) = -17.898 dB  error(+0.102 dB)
l_int|0x4e
comma
singleline_comment|// [037] = -18.500 dB  -&gt;  AKM(0x4e) = -18.605 dB  error(-0.105 dB)
l_int|0x4d
comma
singleline_comment|// [038] = -19.000 dB  -&gt;  AKM(0x4d) = -18.905 dB  error(+0.095 dB)
l_int|0x4b
comma
singleline_comment|// [039] = -19.500 dB  -&gt;  AKM(0x4b) = -19.538 dB  error(-0.038 dB)
l_int|0x4a
comma
singleline_comment|// [040] = -20.000 dB  -&gt;  AKM(0x4a) = -19.872 dB  error(+0.128 dB)
l_int|0x48
comma
singleline_comment|// [041] = -20.500 dB  -&gt;  AKM(0x48) = -20.583 dB  error(-0.083 dB)
l_int|0x47
comma
singleline_comment|// [042] = -21.000 dB  -&gt;  AKM(0x47) = -20.961 dB  error(+0.039 dB)
l_int|0x46
comma
singleline_comment|// [043] = -21.500 dB  -&gt;  AKM(0x46) = -21.356 dB  error(+0.144 dB)
l_int|0x44
comma
singleline_comment|// [044] = -22.000 dB  -&gt;  AKM(0x44) = -22.206 dB  error(-0.206 dB)
l_int|0x43
comma
singleline_comment|// [045] = -22.500 dB  -&gt;  AKM(0x43) = -22.664 dB  error(-0.164 dB)
l_int|0x42
comma
singleline_comment|// [046] = -23.000 dB  -&gt;  AKM(0x42) = -23.147 dB  error(-0.147 dB)
l_int|0x41
comma
singleline_comment|// [047] = -23.500 dB  -&gt;  AKM(0x41) = -23.659 dB  error(-0.159 dB)
l_int|0x40
comma
singleline_comment|// [048] = -24.000 dB  -&gt;  AKM(0x40) = -24.203 dB  error(-0.203 dB)
l_int|0x3f
comma
singleline_comment|// [049] = -24.500 dB  -&gt;  AKM(0x3f) = -24.635 dB  error(-0.135 dB)
l_int|0x3e
comma
singleline_comment|// [050] = -25.000 dB  -&gt;  AKM(0x3e) = -24.935 dB  error(+0.065 dB)
l_int|0x3c
comma
singleline_comment|// [051] = -25.500 dB  -&gt;  AKM(0x3c) = -25.569 dB  error(-0.069 dB)
l_int|0x3b
comma
singleline_comment|// [052] = -26.000 dB  -&gt;  AKM(0x3b) = -25.904 dB  error(+0.096 dB)
l_int|0x39
comma
singleline_comment|// [053] = -26.500 dB  -&gt;  AKM(0x39) = -26.615 dB  error(-0.115 dB)
l_int|0x38
comma
singleline_comment|// [054] = -27.000 dB  -&gt;  AKM(0x38) = -26.994 dB  error(+0.006 dB)
l_int|0x37
comma
singleline_comment|// [055] = -27.500 dB  -&gt;  AKM(0x37) = -27.390 dB  error(+0.110 dB)
l_int|0x36
comma
singleline_comment|// [056] = -28.000 dB  -&gt;  AKM(0x36) = -27.804 dB  error(+0.196 dB)
l_int|0x34
comma
singleline_comment|// [057] = -28.500 dB  -&gt;  AKM(0x34) = -28.699 dB  error(-0.199 dB)
l_int|0x33
comma
singleline_comment|// [058] = -29.000 dB  -&gt;  AKM(0x33) = -29.183 dB  error(-0.183 dB)
l_int|0x32
comma
singleline_comment|// [059] = -29.500 dB  -&gt;  AKM(0x32) = -29.696 dB  error(-0.196 dB)
l_int|0x31
comma
singleline_comment|// [060] = -30.000 dB  -&gt;  AKM(0x31) = -30.241 dB  error(-0.241 dB)
l_int|0x31
comma
singleline_comment|// [061] = -30.500 dB  -&gt;  AKM(0x31) = -30.241 dB  error(+0.259 dB)
l_int|0x30
comma
singleline_comment|// [062] = -31.000 dB  -&gt;  AKM(0x30) = -30.823 dB  error(+0.177 dB)
l_int|0x2e
comma
singleline_comment|// [063] = -31.500 dB  -&gt;  AKM(0x2e) = -31.610 dB  error(-0.110 dB)
l_int|0x2d
comma
singleline_comment|// [064] = -32.000 dB  -&gt;  AKM(0x2d) = -31.945 dB  error(+0.055 dB)
l_int|0x2b
comma
singleline_comment|// [065] = -32.500 dB  -&gt;  AKM(0x2b) = -32.659 dB  error(-0.159 dB)
l_int|0x2a
comma
singleline_comment|// [066] = -33.000 dB  -&gt;  AKM(0x2a) = -33.038 dB  error(-0.038 dB)
l_int|0x29
comma
singleline_comment|// [067] = -33.500 dB  -&gt;  AKM(0x29) = -33.435 dB  error(+0.065 dB)
l_int|0x28
comma
singleline_comment|// [068] = -34.000 dB  -&gt;  AKM(0x28) = -33.852 dB  error(+0.148 dB)
l_int|0x27
comma
singleline_comment|// [069] = -34.500 dB  -&gt;  AKM(0x27) = -34.289 dB  error(+0.211 dB)
l_int|0x25
comma
singleline_comment|// [070] = -35.000 dB  -&gt;  AKM(0x25) = -35.235 dB  error(-0.235 dB)
l_int|0x24
comma
singleline_comment|// [071] = -35.500 dB  -&gt;  AKM(0x24) = -35.750 dB  error(-0.250 dB)
l_int|0x24
comma
singleline_comment|// [072] = -36.000 dB  -&gt;  AKM(0x24) = -35.750 dB  error(+0.250 dB)
l_int|0x23
comma
singleline_comment|// [073] = -36.500 dB  -&gt;  AKM(0x23) = -36.297 dB  error(+0.203 dB)
l_int|0x22
comma
singleline_comment|// [074] = -37.000 dB  -&gt;  AKM(0x22) = -36.881 dB  error(+0.119 dB)
l_int|0x21
comma
singleline_comment|// [075] = -37.500 dB  -&gt;  AKM(0x21) = -37.508 dB  error(-0.008 dB)
l_int|0x20
comma
singleline_comment|// [076] = -38.000 dB  -&gt;  AKM(0x20) = -38.183 dB  error(-0.183 dB)
l_int|0x1f
comma
singleline_comment|// [077] = -38.500 dB  -&gt;  AKM(0x1f) = -38.726 dB  error(-0.226 dB)
l_int|0x1e
comma
singleline_comment|// [078] = -39.000 dB  -&gt;  AKM(0x1e) = -39.108 dB  error(-0.108 dB)
l_int|0x1d
comma
singleline_comment|// [079] = -39.500 dB  -&gt;  AKM(0x1d) = -39.507 dB  error(-0.007 dB)
l_int|0x1c
comma
singleline_comment|// [080] = -40.000 dB  -&gt;  AKM(0x1c) = -39.926 dB  error(+0.074 dB)
l_int|0x1b
comma
singleline_comment|// [081] = -40.500 dB  -&gt;  AKM(0x1b) = -40.366 dB  error(+0.134 dB)
l_int|0x1a
comma
singleline_comment|// [082] = -41.000 dB  -&gt;  AKM(0x1a) = -40.829 dB  error(+0.171 dB)
l_int|0x19
comma
singleline_comment|// [083] = -41.500 dB  -&gt;  AKM(0x19) = -41.318 dB  error(+0.182 dB)
l_int|0x18
comma
singleline_comment|// [084] = -42.000 dB  -&gt;  AKM(0x18) = -41.837 dB  error(+0.163 dB)
l_int|0x17
comma
singleline_comment|// [085] = -42.500 dB  -&gt;  AKM(0x17) = -42.389 dB  error(+0.111 dB)
l_int|0x16
comma
singleline_comment|// [086] = -43.000 dB  -&gt;  AKM(0x16) = -42.978 dB  error(+0.022 dB)
l_int|0x15
comma
singleline_comment|// [087] = -43.500 dB  -&gt;  AKM(0x15) = -43.610 dB  error(-0.110 dB)
l_int|0x14
comma
singleline_comment|// [088] = -44.000 dB  -&gt;  AKM(0x14) = -44.291 dB  error(-0.291 dB)
l_int|0x14
comma
singleline_comment|// [089] = -44.500 dB  -&gt;  AKM(0x14) = -44.291 dB  error(+0.209 dB)
l_int|0x13
comma
singleline_comment|// [090] = -45.000 dB  -&gt;  AKM(0x13) = -45.031 dB  error(-0.031 dB)
l_int|0x12
comma
singleline_comment|// [091] = -45.500 dB  -&gt;  AKM(0x12) = -45.840 dB  error(-0.340 dB)
l_int|0x12
comma
singleline_comment|// [092] = -46.000 dB  -&gt;  AKM(0x12) = -45.840 dB  error(+0.160 dB)
l_int|0x11
comma
singleline_comment|// [093] = -46.500 dB  -&gt;  AKM(0x11) = -46.731 dB  error(-0.231 dB)
l_int|0x11
comma
singleline_comment|// [094] = -47.000 dB  -&gt;  AKM(0x11) = -46.731 dB  error(+0.269 dB)
l_int|0x10
comma
singleline_comment|// [095] = -47.500 dB  -&gt;  AKM(0x10) = -47.725 dB  error(-0.225 dB)
l_int|0x10
comma
singleline_comment|// [096] = -48.000 dB  -&gt;  AKM(0x10) = -47.725 dB  error(+0.275 dB)
l_int|0x0f
comma
singleline_comment|// [097] = -48.500 dB  -&gt;  AKM(0x0f) = -48.553 dB  error(-0.053 dB)
l_int|0x0e
comma
singleline_comment|// [098] = -49.000 dB  -&gt;  AKM(0x0e) = -49.152 dB  error(-0.152 dB)
l_int|0x0d
comma
singleline_comment|// [099] = -49.500 dB  -&gt;  AKM(0x0d) = -49.796 dB  error(-0.296 dB)
l_int|0x0d
comma
singleline_comment|// [100] = -50.000 dB  -&gt;  AKM(0x0d) = -49.796 dB  error(+0.204 dB)
l_int|0x0c
comma
singleline_comment|// [101] = -50.500 dB  -&gt;  AKM(0x0c) = -50.491 dB  error(+0.009 dB)
l_int|0x0b
comma
singleline_comment|// [102] = -51.000 dB  -&gt;  AKM(0x0b) = -51.247 dB  error(-0.247 dB)
l_int|0x0b
comma
singleline_comment|// [103] = -51.500 dB  -&gt;  AKM(0x0b) = -51.247 dB  error(+0.253 dB)
l_int|0x0a
comma
singleline_comment|// [104] = -52.000 dB  -&gt;  AKM(0x0a) = -52.075 dB  error(-0.075 dB)
l_int|0x0a
comma
singleline_comment|// [105] = -52.500 dB  -&gt;  AKM(0x0a) = -52.075 dB  error(+0.425 dB)
l_int|0x09
comma
singleline_comment|// [106] = -53.000 dB  -&gt;  AKM(0x09) = -52.990 dB  error(+0.010 dB)
l_int|0x09
comma
singleline_comment|// [107] = -53.500 dB  -&gt;  AKM(0x09) = -52.990 dB  error(+0.510 dB)
l_int|0x08
comma
singleline_comment|// [108] = -54.000 dB  -&gt;  AKM(0x08) = -54.013 dB  error(-0.013 dB)
l_int|0x08
comma
singleline_comment|// [109] = -54.500 dB  -&gt;  AKM(0x08) = -54.013 dB  error(+0.487 dB)
l_int|0x07
comma
singleline_comment|// [110] = -55.000 dB  -&gt;  AKM(0x07) = -55.173 dB  error(-0.173 dB)
l_int|0x07
comma
singleline_comment|// [111] = -55.500 dB  -&gt;  AKM(0x07) = -55.173 dB  error(+0.327 dB)
l_int|0x06
comma
singleline_comment|// [112] = -56.000 dB  -&gt;  AKM(0x06) = -56.512 dB  error(-0.512 dB)
l_int|0x06
comma
singleline_comment|// [113] = -56.500 dB  -&gt;  AKM(0x06) = -56.512 dB  error(-0.012 dB)
l_int|0x06
comma
singleline_comment|// [114] = -57.000 dB  -&gt;  AKM(0x06) = -56.512 dB  error(+0.488 dB)
l_int|0x05
comma
singleline_comment|// [115] = -57.500 dB  -&gt;  AKM(0x05) = -58.095 dB  error(-0.595 dB)
l_int|0x05
comma
singleline_comment|// [116] = -58.000 dB  -&gt;  AKM(0x05) = -58.095 dB  error(-0.095 dB)
l_int|0x05
comma
singleline_comment|// [117] = -58.500 dB  -&gt;  AKM(0x05) = -58.095 dB  error(+0.405 dB)
l_int|0x05
comma
singleline_comment|// [118] = -59.000 dB  -&gt;  AKM(0x05) = -58.095 dB  error(+0.905 dB)
l_int|0x04
comma
singleline_comment|// [119] = -59.500 dB  -&gt;  AKM(0x04) = -60.034 dB  error(-0.534 dB)
l_int|0x04
comma
singleline_comment|// [120] = -60.000 dB  -&gt;  AKM(0x04) = -60.034 dB  error(-0.034 dB)
l_int|0x04
comma
singleline_comment|// [121] = -60.500 dB  -&gt;  AKM(0x04) = -60.034 dB  error(+0.466 dB)
l_int|0x04
comma
singleline_comment|// [122] = -61.000 dB  -&gt;  AKM(0x04) = -60.034 dB  error(+0.966 dB)
l_int|0x03
comma
singleline_comment|// [123] = -61.500 dB  -&gt;  AKM(0x03) = -62.532 dB  error(-1.032 dB)
l_int|0x03
comma
singleline_comment|// [124] = -62.000 dB  -&gt;  AKM(0x03) = -62.532 dB  error(-0.532 dB)
l_int|0x03
comma
singleline_comment|// [125] = -62.500 dB  -&gt;  AKM(0x03) = -62.532 dB  error(-0.032 dB)
l_int|0x03
comma
singleline_comment|// [126] = -63.000 dB  -&gt;  AKM(0x03) = -62.532 dB  error(+0.468 dB)
l_int|0x03
comma
singleline_comment|// [127] = -63.500 dB  -&gt;  AKM(0x03) = -62.532 dB  error(+0.968 dB)
l_int|0x03
comma
singleline_comment|// [128] = -64.000 dB  -&gt;  AKM(0x03) = -62.532 dB  error(+1.468 dB)
l_int|0x02
comma
singleline_comment|// [129] = -64.500 dB  -&gt;  AKM(0x02) = -66.054 dB  error(-1.554 dB)
l_int|0x02
comma
singleline_comment|// [130] = -65.000 dB  -&gt;  AKM(0x02) = -66.054 dB  error(-1.054 dB)
l_int|0x02
comma
singleline_comment|// [131] = -65.500 dB  -&gt;  AKM(0x02) = -66.054 dB  error(-0.554 dB)
l_int|0x02
comma
singleline_comment|// [132] = -66.000 dB  -&gt;  AKM(0x02) = -66.054 dB  error(-0.054 dB)
l_int|0x02
comma
singleline_comment|// [133] = -66.500 dB  -&gt;  AKM(0x02) = -66.054 dB  error(+0.446 dB)
l_int|0x02
comma
singleline_comment|// [134] = -67.000 dB  -&gt;  AKM(0x02) = -66.054 dB  error(+0.946 dB)
l_int|0x02
comma
singleline_comment|// [135] = -67.500 dB  -&gt;  AKM(0x02) = -66.054 dB  error(+1.446 dB)
l_int|0x02
comma
singleline_comment|// [136] = -68.000 dB  -&gt;  AKM(0x02) = -66.054 dB  error(+1.946 dB)
l_int|0x02
comma
singleline_comment|// [137] = -68.500 dB  -&gt;  AKM(0x02) = -66.054 dB  error(+2.446 dB)
l_int|0x02
comma
singleline_comment|// [138] = -69.000 dB  -&gt;  AKM(0x02) = -66.054 dB  error(+2.946 dB)
l_int|0x01
comma
singleline_comment|// [139] = -69.500 dB  -&gt;  AKM(0x01) = -72.075 dB  error(-2.575 dB)
l_int|0x01
comma
singleline_comment|// [140] = -70.000 dB  -&gt;  AKM(0x01) = -72.075 dB  error(-2.075 dB)
l_int|0x01
comma
singleline_comment|// [141] = -70.500 dB  -&gt;  AKM(0x01) = -72.075 dB  error(-1.575 dB)
l_int|0x01
comma
singleline_comment|// [142] = -71.000 dB  -&gt;  AKM(0x01) = -72.075 dB  error(-1.075 dB)
l_int|0x01
comma
singleline_comment|// [143] = -71.500 dB  -&gt;  AKM(0x01) = -72.075 dB  error(-0.575 dB)
l_int|0x01
comma
singleline_comment|// [144] = -72.000 dB  -&gt;  AKM(0x01) = -72.075 dB  error(-0.075 dB)
l_int|0x01
comma
singleline_comment|// [145] = -72.500 dB  -&gt;  AKM(0x01) = -72.075 dB  error(+0.425 dB)
l_int|0x01
comma
singleline_comment|// [146] = -73.000 dB  -&gt;  AKM(0x01) = -72.075 dB  error(+0.925 dB)
l_int|0x00
)brace
suffix:semicolon
singleline_comment|// [147] = -73.500 dB  -&gt;  AKM(0x00) =  mute       error(+infini)
multiline_comment|/*&n; * pseudo-codec write entry&n; */
DECL|function|vx2_write_akm
r_static
r_void
id|vx2_write_akm
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
r_int
id|reg
comma
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_eq
id|XX_CODEC_DAC_CONTROL_REGISTER
)paren
(brace
id|vx2_write_codec_reg
c_func
(paren
id|chip
comma
id|data
ques
c_cond
id|AKM_CODEC_MUTE_CMD
suffix:colon
id|AKM_CODEC_UNMUTE_CMD
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* `data&squot; is a value between 0x0 and VX2_AKM_LEVEL_MAX = 0x093, in the case of the AKM codecs, we need&n;&t;   a look up table, as there is no linear matching between the driver codec values&n;&t;   and the real dBu value&n;&t;*/
id|snd_assert
c_func
(paren
id|data
OL
r_sizeof
(paren
id|vx2_akm_gains_lut
)paren
comma
r_return
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|reg
)paren
(brace
r_case
id|XX_CODEC_LEVEL_LEFT_REGISTER
suffix:colon
id|val
op_assign
id|AKM_CODEC_LEFT_LEVEL_CMD
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XX_CODEC_LEVEL_RIGHT_REGISTER
suffix:colon
id|val
op_assign
id|AKM_CODEC_RIGHT_LEVEL_CMD
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|snd_BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|val
op_or_assign
id|vx2_akm_gains_lut
(braket
id|data
)braket
suffix:semicolon
id|vx2_write_codec_reg
c_func
(paren
id|chip
comma
id|val
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * write codec bit for old VX222 board&n; */
DECL|function|vx2_old_write_codec_bit
r_static
r_void
id|vx2_old_write_codec_bit
c_func
(paren
id|vx_core_t
op_star
id|chip
comma
r_int
id|codec
comma
r_int
r_int
id|data
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* activate access to codec registers */
id|vx_inl
c_func
(paren
id|chip
comma
id|HIFREQ
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|24
suffix:semicolon
id|i
op_increment
comma
id|data
op_lshift_assign
l_int|1
)paren
id|vx_outl
c_func
(paren
id|chip
comma
id|DATA
comma
(paren
(paren
id|data
op_amp
l_int|0x800000
)paren
ques
c_cond
id|VX_DATA_CODEC_MASK
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/* Terminate access to codec registers */
id|vx_inl
c_func
(paren
id|chip
comma
id|RUER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * reset codec bit&n; */
DECL|function|vx2_reset_codec
r_static
r_void
id|vx2_reset_codec
c_func
(paren
id|vx_core_t
op_star
id|_chip
)paren
(brace
r_struct
id|snd_vx222
op_star
id|chip
op_assign
(paren
r_struct
id|snd_vx222
op_star
)paren
id|_chip
suffix:semicolon
multiline_comment|/* Set the reset CODEC bit to 0. */
id|vx_outl
c_func
(paren
id|chip
comma
id|CDSP
comma
id|chip-&gt;regCDSP
op_amp
op_complement
id|VX_CDSP_CODEC_RESET_MASK
)paren
suffix:semicolon
id|vx_inl
c_func
(paren
id|chip
comma
id|CDSP
)paren
suffix:semicolon
id|snd_vx_delay
c_func
(paren
id|_chip
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Set the reset CODEC bit to 1. */
id|chip-&gt;regCDSP
op_or_assign
id|VX_CDSP_CODEC_RESET_MASK
suffix:semicolon
id|vx_outl
c_func
(paren
id|chip
comma
id|CDSP
comma
id|chip-&gt;regCDSP
)paren
suffix:semicolon
id|vx_inl
c_func
(paren
id|chip
comma
id|CDSP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_chip-&gt;type
op_eq
id|VX_TYPE_BOARD
)paren
(brace
id|snd_vx_delay
c_func
(paren
id|_chip
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|snd_vx_delay
c_func
(paren
id|_chip
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/* additionnel wait time for AKM&squot;s */
id|vx2_write_codec_reg
c_func
(paren
id|_chip
comma
id|AKM_CODEC_POWER_CONTROL_CMD
)paren
suffix:semicolon
multiline_comment|/* DAC power up, ADC power up, Vref power down */
id|vx2_write_codec_reg
c_func
(paren
id|_chip
comma
id|AKM_CODEC_CLOCK_FORMAT_CMD
)paren
suffix:semicolon
multiline_comment|/* default */
id|vx2_write_codec_reg
c_func
(paren
id|_chip
comma
id|AKM_CODEC_MUTE_CMD
)paren
suffix:semicolon
multiline_comment|/* Mute = ON ,Deemphasis = OFF */
id|vx2_write_codec_reg
c_func
(paren
id|_chip
comma
id|AKM_CODEC_RESET_OFF_CMD
)paren
suffix:semicolon
multiline_comment|/* DAC and ADC normal operation */
r_if
c_cond
(paren
id|_chip-&gt;type
op_eq
id|VX_TYPE_MIC
)paren
(brace
multiline_comment|/* set up the micro input selector */
id|chip-&gt;regSELMIC
op_assign
id|MICRO_SELECT_INPUT_NORM
op_or
id|MICRO_SELECT_PREAMPLI_G_0
op_or
id|MICRO_SELECT_NOISE_T_52DB
suffix:semicolon
multiline_comment|/* reset phantom power supply */
id|chip-&gt;regSELMIC
op_and_assign
op_complement
id|MICRO_SELECT_PHANTOM_ALIM
suffix:semicolon
id|vx_outl
c_func
(paren
id|_chip
comma
id|SELMIC
comma
id|chip-&gt;regSELMIC
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * change the audio source&n; */
DECL|function|vx2_change_audio_source
r_static
r_void
id|vx2_change_audio_source
c_func
(paren
id|vx_core_t
op_star
id|_chip
comma
r_int
id|src
)paren
(brace
r_struct
id|snd_vx222
op_star
id|chip
op_assign
(paren
r_struct
id|snd_vx222
op_star
)paren
id|_chip
suffix:semicolon
r_switch
c_cond
(paren
id|src
)paren
(brace
r_case
id|VX_AUDIO_SRC_DIGITAL
suffix:colon
id|chip-&gt;regCFG
op_or_assign
id|VX_CFG_DATAIN_SEL_MASK
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|chip-&gt;regCFG
op_and_assign
op_complement
id|VX_CFG_DATAIN_SEL_MASK
suffix:semicolon
r_break
suffix:semicolon
)brace
id|vx_outl
c_func
(paren
id|chip
comma
id|CFG
comma
id|chip-&gt;regCFG
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * set the clock source&n; */
DECL|function|vx2_set_clock_source
r_static
r_void
id|vx2_set_clock_source
c_func
(paren
id|vx_core_t
op_star
id|_chip
comma
r_int
id|source
)paren
(brace
r_struct
id|snd_vx222
op_star
id|chip
op_assign
(paren
r_struct
id|snd_vx222
op_star
)paren
id|_chip
suffix:semicolon
r_if
c_cond
(paren
id|source
op_eq
id|INTERNAL_QUARTZ
)paren
id|chip-&gt;regCFG
op_and_assign
op_complement
id|VX_CFG_CLOCKIN_SEL_MASK
suffix:semicolon
r_else
id|chip-&gt;regCFG
op_or_assign
id|VX_CFG_CLOCKIN_SEL_MASK
suffix:semicolon
id|vx_outl
c_func
(paren
id|chip
comma
id|CFG
comma
id|chip-&gt;regCFG
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * reset the board&n; */
DECL|function|vx2_reset_board
r_static
r_void
id|vx2_reset_board
c_func
(paren
id|vx_core_t
op_star
id|_chip
comma
r_int
id|cold_reset
)paren
(brace
r_struct
id|snd_vx222
op_star
id|chip
op_assign
(paren
r_struct
id|snd_vx222
op_star
)paren
id|_chip
suffix:semicolon
multiline_comment|/* initialize the register values */
id|chip-&gt;regCDSP
op_assign
id|VX_CDSP_CODEC_RESET_MASK
op_or
id|VX_CDSP_DSP_RESET_MASK
suffix:semicolon
id|chip-&gt;regCFG
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * input level controls for VX222 Mic&n; */
multiline_comment|/* Micro level is specified to be adjustable from -96dB to 63 dB (board coded 0x00 ... 318),&n; * 318 = 210 + 36 + 36 + 36   (210 = +9dB variable) (3 * 36 = 3 steps of 18dB pre ampli)&n; * as we will mute if less than -110dB, so let&squot;s simply use line input coded levels and add constant offset !&n; */
DECL|macro|V2_MICRO_LEVEL_RANGE
mdefine_line|#define V2_MICRO_LEVEL_RANGE        (318 - 255)
DECL|function|vx2_set_input_level
r_static
r_void
id|vx2_set_input_level
c_func
(paren
r_struct
id|snd_vx222
op_star
id|chip
)paren
(brace
r_int
id|i
comma
id|miclevel
comma
id|preamp
suffix:semicolon
r_int
r_int
id|data
suffix:semicolon
id|miclevel
op_assign
id|chip-&gt;mic_level
suffix:semicolon
id|miclevel
op_add_assign
id|V2_MICRO_LEVEL_RANGE
suffix:semicolon
multiline_comment|/* add 318 - 0xff */
id|preamp
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|miclevel
OG
l_int|210
)paren
(brace
multiline_comment|/* limitation to +9dB of 3310 real gain */
id|preamp
op_increment
suffix:semicolon
multiline_comment|/* raise pre ampli + 18dB */
id|miclevel
op_sub_assign
(paren
l_int|18
op_star
l_int|2
)paren
suffix:semicolon
multiline_comment|/* lower level 18 dB (*2 because of 0.5 dB steps !) */
)brace
id|snd_assert
c_func
(paren
id|preamp
OL
l_int|4
comma
r_return
)paren
suffix:semicolon
multiline_comment|/* set pre-amp level */
id|chip-&gt;regSELMIC
op_and_assign
op_complement
id|MICRO_SELECT_PREAMPLI_MASK
suffix:semicolon
id|chip-&gt;regSELMIC
op_or_assign
(paren
id|preamp
op_lshift
id|MICRO_SELECT_PREAMPLI_OFFSET
)paren
op_amp
id|MICRO_SELECT_PREAMPLI_MASK
suffix:semicolon
id|vx_outl
c_func
(paren
id|chip
comma
id|SELMIC
comma
id|chip-&gt;regSELMIC
)paren
suffix:semicolon
id|data
op_assign
(paren
r_int
r_int
)paren
id|miclevel
op_lshift
l_int|16
op_or
(paren
r_int
r_int
)paren
id|chip-&gt;input_level
(braket
l_int|1
)braket
op_lshift
l_int|8
op_or
(paren
r_int
r_int
)paren
id|chip-&gt;input_level
(braket
l_int|0
)braket
suffix:semicolon
id|vx_inl
c_func
(paren
id|chip
comma
id|DATA
)paren
suffix:semicolon
multiline_comment|/* Activate input level programming */
multiline_comment|/* We have to send 32 bits (4 x 8 bits) */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
comma
id|data
op_lshift_assign
l_int|1
)paren
id|vx_outl
c_func
(paren
id|chip
comma
id|DATA
comma
(paren
(paren
id|data
op_amp
l_int|0x80000000
)paren
ques
c_cond
id|VX_DATA_CODEC_MASK
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|vx_inl
c_func
(paren
id|chip
comma
id|RUER
)paren
suffix:semicolon
multiline_comment|/* Terminate input level programming */
)brace
DECL|macro|MIC_LEVEL_MAX
mdefine_line|#define MIC_LEVEL_MAX&t;0xff
multiline_comment|/*&n; * controls API for input levels&n; */
multiline_comment|/* input levels */
DECL|function|vx_input_level_info
r_static
r_int
id|vx_input_level_info
c_func
(paren
id|snd_kcontrol_t
op_star
id|kcontrol
comma
id|snd_ctl_elem_info_t
op_star
id|uinfo
)paren
(brace
id|uinfo-&gt;type
op_assign
id|SNDRV_CTL_ELEM_TYPE_INTEGER
suffix:semicolon
id|uinfo-&gt;count
op_assign
l_int|2
suffix:semicolon
id|uinfo-&gt;value.integer.min
op_assign
l_int|0
suffix:semicolon
id|uinfo-&gt;value.integer.max
op_assign
id|MIC_LEVEL_MAX
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vx_input_level_get
r_static
r_int
id|vx_input_level_get
c_func
(paren
id|snd_kcontrol_t
op_star
id|kcontrol
comma
id|snd_ctl_elem_value_t
op_star
id|ucontrol
)paren
(brace
id|vx_core_t
op_star
id|_chip
op_assign
id|snd_kcontrol_chip
c_func
(paren
id|kcontrol
)paren
suffix:semicolon
r_struct
id|snd_vx222
op_star
id|chip
op_assign
(paren
r_struct
id|snd_vx222
op_star
)paren
id|_chip
suffix:semicolon
id|down
c_func
(paren
op_amp
id|_chip-&gt;mixer_mutex
)paren
suffix:semicolon
id|ucontrol-&gt;value.integer.value
(braket
l_int|0
)braket
op_assign
id|chip-&gt;input_level
(braket
l_int|0
)braket
suffix:semicolon
id|ucontrol-&gt;value.integer.value
(braket
l_int|1
)braket
op_assign
id|chip-&gt;input_level
(braket
l_int|1
)braket
suffix:semicolon
id|up
c_func
(paren
op_amp
id|_chip-&gt;mixer_mutex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vx_input_level_put
r_static
r_int
id|vx_input_level_put
c_func
(paren
id|snd_kcontrol_t
op_star
id|kcontrol
comma
id|snd_ctl_elem_value_t
op_star
id|ucontrol
)paren
(brace
id|vx_core_t
op_star
id|_chip
op_assign
id|snd_kcontrol_chip
c_func
(paren
id|kcontrol
)paren
suffix:semicolon
r_struct
id|snd_vx222
op_star
id|chip
op_assign
(paren
r_struct
id|snd_vx222
op_star
)paren
id|_chip
suffix:semicolon
id|down
c_func
(paren
op_amp
id|_chip-&gt;mixer_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;input_level
(braket
l_int|0
)braket
op_ne
id|ucontrol-&gt;value.integer.value
(braket
l_int|0
)braket
op_logical_or
id|chip-&gt;input_level
(braket
l_int|1
)braket
op_ne
id|ucontrol-&gt;value.integer.value
(braket
l_int|1
)braket
)paren
(brace
id|chip-&gt;input_level
(braket
l_int|0
)braket
op_assign
id|ucontrol-&gt;value.integer.value
(braket
l_int|0
)braket
suffix:semicolon
id|chip-&gt;input_level
(braket
l_int|1
)braket
op_assign
id|ucontrol-&gt;value.integer.value
(braket
l_int|1
)braket
suffix:semicolon
id|vx2_set_input_level
c_func
(paren
id|chip
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|_chip-&gt;mixer_mutex
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|_chip-&gt;mixer_mutex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* mic level */
DECL|function|vx_mic_level_info
r_static
r_int
id|vx_mic_level_info
c_func
(paren
id|snd_kcontrol_t
op_star
id|kcontrol
comma
id|snd_ctl_elem_info_t
op_star
id|uinfo
)paren
(brace
id|uinfo-&gt;type
op_assign
id|SNDRV_CTL_ELEM_TYPE_INTEGER
suffix:semicolon
id|uinfo-&gt;count
op_assign
l_int|1
suffix:semicolon
id|uinfo-&gt;value.integer.min
op_assign
l_int|0
suffix:semicolon
id|uinfo-&gt;value.integer.max
op_assign
id|MIC_LEVEL_MAX
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vx_mic_level_get
r_static
r_int
id|vx_mic_level_get
c_func
(paren
id|snd_kcontrol_t
op_star
id|kcontrol
comma
id|snd_ctl_elem_value_t
op_star
id|ucontrol
)paren
(brace
id|vx_core_t
op_star
id|_chip
op_assign
id|snd_kcontrol_chip
c_func
(paren
id|kcontrol
)paren
suffix:semicolon
r_struct
id|snd_vx222
op_star
id|chip
op_assign
(paren
r_struct
id|snd_vx222
op_star
)paren
id|_chip
suffix:semicolon
id|ucontrol-&gt;value.integer.value
(braket
l_int|0
)braket
op_assign
id|chip-&gt;mic_level
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vx_mic_level_put
r_static
r_int
id|vx_mic_level_put
c_func
(paren
id|snd_kcontrol_t
op_star
id|kcontrol
comma
id|snd_ctl_elem_value_t
op_star
id|ucontrol
)paren
(brace
id|vx_core_t
op_star
id|_chip
op_assign
id|snd_kcontrol_chip
c_func
(paren
id|kcontrol
)paren
suffix:semicolon
r_struct
id|snd_vx222
op_star
id|chip
op_assign
(paren
r_struct
id|snd_vx222
op_star
)paren
id|_chip
suffix:semicolon
id|down
c_func
(paren
op_amp
id|_chip-&gt;mixer_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;mic_level
op_ne
id|ucontrol-&gt;value.integer.value
(braket
l_int|0
)braket
)paren
(brace
id|chip-&gt;mic_level
op_assign
id|ucontrol-&gt;value.integer.value
(braket
l_int|0
)braket
suffix:semicolon
id|vx2_set_input_level
c_func
(paren
id|chip
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|_chip-&gt;mixer_mutex
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|_chip-&gt;mixer_mutex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|vx_control_input_level
r_static
id|snd_kcontrol_new_t
id|vx_control_input_level
op_assign
(brace
dot
id|iface
op_assign
id|SNDRV_CTL_ELEM_IFACE_MIXER
comma
dot
id|name
op_assign
l_string|&quot;Capture Volume&quot;
comma
dot
id|info
op_assign
id|vx_input_level_info
comma
dot
id|get
op_assign
id|vx_input_level_get
comma
dot
id|put
op_assign
id|vx_input_level_put
comma
)brace
suffix:semicolon
DECL|variable|vx_control_mic_level
r_static
id|snd_kcontrol_new_t
id|vx_control_mic_level
op_assign
(brace
dot
id|iface
op_assign
id|SNDRV_CTL_ELEM_IFACE_MIXER
comma
dot
id|name
op_assign
l_string|&quot;Mic Capture Volume&quot;
comma
dot
id|info
op_assign
id|vx_mic_level_info
comma
dot
id|get
op_assign
id|vx_mic_level_get
comma
dot
id|put
op_assign
id|vx_mic_level_put
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * FIXME: compressor/limiter implementation is missing yet...&n; */
DECL|function|vx2_add_mic_controls
r_static
r_int
id|vx2_add_mic_controls
c_func
(paren
id|vx_core_t
op_star
id|_chip
)paren
(brace
r_struct
id|snd_vx222
op_star
id|chip
op_assign
(paren
r_struct
id|snd_vx222
op_star
)paren
id|_chip
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|_chip-&gt;type
op_ne
id|VX_TYPE_MIC
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* mute input levels */
id|chip-&gt;input_level
(braket
l_int|0
)braket
op_assign
id|chip-&gt;input_level
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|chip-&gt;mic_level
op_assign
l_int|0
suffix:semicolon
id|vx2_set_input_level
c_func
(paren
id|chip
)paren
suffix:semicolon
multiline_comment|/* controls */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_ctl_add
c_func
(paren
id|_chip-&gt;card
comma
id|snd_ctl_new1
c_func
(paren
op_amp
id|vx_control_input_level
comma
id|chip
)paren
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_ctl_add
c_func
(paren
id|_chip-&gt;card
comma
id|snd_ctl_new1
c_func
(paren
op_amp
id|vx_control_mic_level
comma
id|chip
)paren
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * callbacks&n; */
DECL|variable|vx222_ops
r_struct
id|snd_vx_ops
id|vx222_ops
op_assign
(brace
dot
id|in8
op_assign
id|vx2_inb
comma
dot
id|in32
op_assign
id|vx2_inl
comma
dot
id|out8
op_assign
id|vx2_outb
comma
dot
id|out32
op_assign
id|vx2_outl
comma
dot
id|test_and_ack
op_assign
id|vx2_test_and_ack
comma
dot
id|validate_irq
op_assign
id|vx2_validate_irq
comma
dot
id|akm_write
op_assign
id|vx2_write_akm
comma
dot
id|reset_codec
op_assign
id|vx2_reset_codec
comma
dot
id|change_audio_source
op_assign
id|vx2_change_audio_source
comma
dot
id|set_clock_source
op_assign
id|vx2_set_clock_source
comma
dot
id|load_dsp
op_assign
id|vx2_load_dsp
comma
dot
id|reset_dsp
op_assign
id|vx2_reset_dsp
comma
dot
id|reset_board
op_assign
id|vx2_reset_board
comma
dot
id|dma_write
op_assign
id|vx2_dma_write
comma
dot
id|dma_read
op_assign
id|vx2_dma_read
comma
dot
id|add_controls
op_assign
id|vx2_add_mic_controls
comma
)brace
suffix:semicolon
multiline_comment|/* for old VX222 board */
DECL|variable|vx222_old_ops
r_struct
id|snd_vx_ops
id|vx222_old_ops
op_assign
(brace
dot
id|in8
op_assign
id|vx2_inb
comma
dot
id|in32
op_assign
id|vx2_inl
comma
dot
id|out8
op_assign
id|vx2_outb
comma
dot
id|out32
op_assign
id|vx2_outl
comma
dot
id|test_and_ack
op_assign
id|vx2_test_and_ack
comma
dot
id|validate_irq
op_assign
id|vx2_validate_irq
comma
dot
id|write_codec
op_assign
id|vx2_old_write_codec_bit
comma
dot
id|reset_codec
op_assign
id|vx2_reset_codec
comma
dot
id|change_audio_source
op_assign
id|vx2_change_audio_source
comma
dot
id|set_clock_source
op_assign
id|vx2_set_clock_source
comma
dot
id|load_dsp
op_assign
id|vx2_load_dsp
comma
dot
id|reset_dsp
op_assign
id|vx2_reset_dsp
comma
dot
id|reset_board
op_assign
id|vx2_reset_board
comma
dot
id|dma_write
op_assign
id|vx2_dma_write
comma
dot
id|dma_read
op_assign
id|vx2_dma_read
comma
)brace
suffix:semicolon
eof
