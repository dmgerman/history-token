multiline_comment|/* Copyright (C) by Paul Barton-Davis 1998-1999&n; *&n; * Some portions of this file are taken from work that is&n; * copyright (C) by Hannu Savolainen 1993-1996&n; *&n; * This program is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)&n; * Version 2 (June 1991). See the &quot;COPYING&quot; file distributed with this software&n; * for more info.  &n; */
multiline_comment|/*  &n; * An ALSA lowlevel driver for Turtle Beach ICS2115 wavetable synth&n; *                                             (Maui, Tropez, Tropez Plus)&n; *&n; * This driver supports the onboard wavetable synthesizer (an ICS2115),&n; * including patch, sample and program loading and unloading, conversion&n; * of GUS patches during loading, and full user-level access to all&n; * WaveFront commands. It tries to provide semi-intelligent patch and&n; * sample management as well.&n; *&n; */
macro_line|#include &lt;sound/driver.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;sound/core.h&gt;
macro_line|#include &lt;sound/snd_wavefront.h&gt;
macro_line|#include &lt;sound/initval.h&gt;
DECL|variable|wf_raw
r_static
r_int
id|wf_raw
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we normally check for &quot;raw state&quot; to firmware&n;&t;&t;&t;  loading. if non-zero, then during driver loading, the&n;&t;&t;&t;  state of the board is ignored, and we reset the&n;&t;&t;&t;  board and load the firmware anyway.&n;&t;&t;       */
DECL|variable|fx_raw
r_static
r_int
id|fx_raw
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* if this is zero, we&squot;ll leave the FX processor in&n;&t;&t;&t;  whatever state it is when the driver is loaded.&n;&t;&t;&t;  The default is to download the microprogram and&n;&t;&t;&t;  associated coefficients to set it up for &quot;default&quot;&n;&t;&t;&t;  operation, whatever that means.&n;&t;&t;       */
DECL|variable|debug_default
r_static
r_int
id|debug_default
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* you can set this to control debugging&n;&t;&t;&t;&t;  during driver loading. it takes any combination&n;&t;&t;&t;&t;  of the WF_DEBUG_* flags defined in&n;&t;&t;&t;&t;  wavefront.h&n;&t;&t;&t;       */
multiline_comment|/* XXX this needs to be made firmware and hardware version dependent */
DECL|variable|ospath
r_static
r_char
op_star
id|ospath
op_assign
l_string|&quot;/etc/sound/wavefront.os&quot;
suffix:semicolon
multiline_comment|/* where to find a processed&n;&t;&t;&t;&t;&t;&t;    version of the WaveFront OS&n;&t;&t;&t;&t;&t;&t; */
DECL|variable|wait_usecs
r_static
r_int
id|wait_usecs
op_assign
l_int|150
suffix:semicolon
multiline_comment|/* This magic number seems to give pretty optimal&n;&t;&t;&t;&t;throughput based on my limited experimentation.&n;&t;&t;&t;&t;If you want to play around with it and find a better&n;&t;&t;&t;&t;value, be my guest. Remember, the idea is to&n;&t;&t;&t;&t;get a number that causes us to just busy wait&n;&t;&t;&t;&t;for as many WaveFront commands as possible, without&n;&t;&t;&t;&t;coming up with a number so large that we hog the&n;&t;&t;&t;&t;whole CPU.&n;&n;&t;&t;&t;&t;Specifically, with this number, out of about 134,000&n;&t;&t;&t;&t;status waits, only about 250 result in a sleep.&n;&t;&t;&t;    */
DECL|variable|sleep_interval
r_static
r_int
id|sleep_interval
op_assign
l_int|100
suffix:semicolon
multiline_comment|/* HZ/sleep_interval seconds per sleep */
DECL|variable|sleep_tries
r_static
r_int
id|sleep_tries
op_assign
l_int|50
suffix:semicolon
multiline_comment|/* number of times we&squot;ll try to sleep */
DECL|variable|reset_time
r_static
r_int
id|reset_time
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* hundreths of a second we wait after a HW&n;&t;&t;&t;&t;     reset for the expected interrupt.&n;&t;&t;&t;&t;  */
DECL|variable|ramcheck_time
r_static
r_int
id|ramcheck_time
op_assign
l_int|20
suffix:semicolon
multiline_comment|/* time in seconds to wait while ROM code&n;&t;&t;&t;&t;     checks on-board RAM.&n;&t;&t;&t;&t;  */
DECL|variable|osrun_time
r_static
r_int
id|osrun_time
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* time in seconds we wait for the OS to&n;&t;&t;&t;&t;     start running.&n;&t;&t;&t;&t;  */
id|module_param
c_func
(paren
id|wf_raw
comma
r_int
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|wf_raw
comma
l_string|&quot;if non-zero, assume that we need to boot the OS&quot;
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|fx_raw
comma
r_int
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|fx_raw
comma
l_string|&quot;if non-zero, assume that the FX process needs help&quot;
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|debug_default
comma
r_int
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|debug_default
comma
l_string|&quot;debug parameters for card initialization&quot;
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|wait_usecs
comma
r_int
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|wait_usecs
comma
l_string|&quot;how long to wait without sleeping, usecs&quot;
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|sleep_interval
comma
r_int
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|sleep_interval
comma
l_string|&quot;how long to sleep when waiting for reply&quot;
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|sleep_tries
comma
r_int
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|sleep_tries
comma
l_string|&quot;how many times to try sleeping during a wait&quot;
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|ospath
comma
id|charp
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|ospath
comma
l_string|&quot;full pathname to processed ICS2115 OS firmware&quot;
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|reset_time
comma
r_int
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|reset_time
comma
l_string|&quot;how long to wait for a reset to take effect&quot;
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|ramcheck_time
comma
r_int
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|ramcheck_time
comma
l_string|&quot;how many seconds to wait for the RAM test&quot;
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|osrun_time
comma
r_int
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|osrun_time
comma
l_string|&quot;how many seconds to wait for the ICS2115 OS&quot;
)paren
suffix:semicolon
multiline_comment|/* if WF_DEBUG not defined, no run-time debugging messages will&n;   be available via the debug flag setting. Given the current&n;   beta state of the driver, this will remain set until a future &n;   version.&n;*/
DECL|macro|WF_DEBUG
mdefine_line|#define WF_DEBUG 1
macro_line|#ifdef WF_DEBUG
macro_line|#if defined(NEW_MACRO_VARARGS) || __GNUC__ &gt;= 3
DECL|macro|DPRINT
mdefine_line|#define DPRINT(cond, ...) &bslash;&n;       if ((dev-&gt;debug &amp; (cond)) == (cond)) { &bslash;&n;&t;     snd_printk (__VA_ARGS__); &bslash;&n;       }
macro_line|#else
DECL|macro|DPRINT
mdefine_line|#define DPRINT(cond, args...) &bslash;&n;       if ((dev-&gt;debug &amp; (cond)) == (cond)) { &bslash;&n;&t;     snd_printk (args); &bslash;&n;       }
macro_line|#endif
macro_line|#else
DECL|macro|DPRINT
mdefine_line|#define DPRINT(cond, args...)
macro_line|#endif /* WF_DEBUG */
DECL|macro|LOGNAME
mdefine_line|#define LOGNAME &quot;WaveFront: &quot;
multiline_comment|/* bitmasks for WaveFront status port value */
DECL|macro|STAT_RINTR_ENABLED
mdefine_line|#define STAT_RINTR_ENABLED&t;0x01
DECL|macro|STAT_CAN_READ
mdefine_line|#define STAT_CAN_READ&t;&t;0x02
DECL|macro|STAT_INTR_READ
mdefine_line|#define STAT_INTR_READ&t;&t;0x04
DECL|macro|STAT_WINTR_ENABLED
mdefine_line|#define STAT_WINTR_ENABLED&t;0x10
DECL|macro|STAT_CAN_WRITE
mdefine_line|#define STAT_CAN_WRITE&t;&t;0x20
DECL|macro|STAT_INTR_WRITE
mdefine_line|#define STAT_INTR_WRITE&t;&t;0x40
r_static
r_int
id|wavefront_delete_sample
(paren
id|snd_wavefront_t
op_star
comma
r_int
id|sampnum
)paren
suffix:semicolon
r_static
r_int
id|wavefront_find_free_sample
(paren
id|snd_wavefront_t
op_star
)paren
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|cmd
r_int
id|cmd
suffix:semicolon
DECL|member|action
r_char
op_star
id|action
suffix:semicolon
DECL|member|read_cnt
r_int
r_int
id|read_cnt
suffix:semicolon
DECL|member|write_cnt
r_int
r_int
id|write_cnt
suffix:semicolon
DECL|member|need_ack
r_int
id|need_ack
suffix:semicolon
DECL|typedef|wavefront_command
)brace
id|wavefront_command
suffix:semicolon
r_static
r_struct
(brace
DECL|member|errno
r_int
id|errno
suffix:semicolon
DECL|member|errstr
r_const
r_char
op_star
id|errstr
suffix:semicolon
DECL|variable|wavefront_errors
)brace
id|wavefront_errors
(braket
)braket
op_assign
(brace
(brace
l_int|0x01
comma
l_string|&quot;Bad sample number&quot;
)brace
comma
(brace
l_int|0x02
comma
l_string|&quot;Out of sample memory&quot;
)brace
comma
(brace
l_int|0x03
comma
l_string|&quot;Bad patch number&quot;
)brace
comma
(brace
l_int|0x04
comma
l_string|&quot;Error in number of voices&quot;
)brace
comma
(brace
l_int|0x06
comma
l_string|&quot;Sample load already in progress&quot;
)brace
comma
(brace
l_int|0x0B
comma
l_string|&quot;No sample load request pending&quot;
)brace
comma
(brace
l_int|0x0E
comma
l_string|&quot;Bad MIDI channel number&quot;
)brace
comma
(brace
l_int|0x10
comma
l_string|&quot;Download Record Error&quot;
)brace
comma
(brace
l_int|0x80
comma
l_string|&quot;Success&quot;
)brace
comma
(brace
l_int|0x0
)brace
)brace
suffix:semicolon
DECL|macro|NEEDS_ACK
mdefine_line|#define NEEDS_ACK 1
DECL|variable|wavefront_commands
r_static
id|wavefront_command
id|wavefront_commands
(braket
)braket
op_assign
(brace
(brace
id|WFC_SET_SYNTHVOL
comma
l_string|&quot;set synthesizer volume&quot;
comma
l_int|0
comma
l_int|1
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_GET_SYNTHVOL
comma
l_string|&quot;get synthesizer volume&quot;
comma
l_int|1
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_SET_NVOICES
comma
l_string|&quot;set number of voices&quot;
comma
l_int|0
comma
l_int|1
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_GET_NVOICES
comma
l_string|&quot;get number of voices&quot;
comma
l_int|1
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_SET_TUNING
comma
l_string|&quot;set synthesizer tuning&quot;
comma
l_int|0
comma
l_int|2
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_GET_TUNING
comma
l_string|&quot;get synthesizer tuning&quot;
comma
l_int|2
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_DISABLE_CHANNEL
comma
l_string|&quot;disable synth channel&quot;
comma
l_int|0
comma
l_int|1
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_ENABLE_CHANNEL
comma
l_string|&quot;enable synth channel&quot;
comma
l_int|0
comma
l_int|1
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_GET_CHANNEL_STATUS
comma
l_string|&quot;get synth channel status&quot;
comma
l_int|3
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_MISYNTH_OFF
comma
l_string|&quot;disable midi-in to synth&quot;
comma
l_int|0
comma
l_int|0
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_MISYNTH_ON
comma
l_string|&quot;enable midi-in to synth&quot;
comma
l_int|0
comma
l_int|0
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_VMIDI_ON
comma
l_string|&quot;enable virtual midi mode&quot;
comma
l_int|0
comma
l_int|0
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_VMIDI_OFF
comma
l_string|&quot;disable virtual midi mode&quot;
comma
l_int|0
comma
l_int|0
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_MIDI_STATUS
comma
l_string|&quot;report midi status&quot;
comma
l_int|1
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_FIRMWARE_VERSION
comma
l_string|&quot;report firmware version&quot;
comma
l_int|2
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_HARDWARE_VERSION
comma
l_string|&quot;report hardware version&quot;
comma
l_int|2
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_GET_NSAMPLES
comma
l_string|&quot;report number of samples&quot;
comma
l_int|2
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_INSTOUT_LEVELS
comma
l_string|&quot;report instantaneous output levels&quot;
comma
l_int|7
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_PEAKOUT_LEVELS
comma
l_string|&quot;report peak output levels&quot;
comma
l_int|7
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_DOWNLOAD_SAMPLE
comma
l_string|&quot;download sample&quot;
comma
l_int|0
comma
id|WF_SAMPLE_BYTES
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_DOWNLOAD_BLOCK
comma
l_string|&quot;download block&quot;
comma
l_int|0
comma
l_int|0
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_DOWNLOAD_SAMPLE_HEADER
comma
l_string|&quot;download sample header&quot;
comma
l_int|0
comma
id|WF_SAMPLE_HDR_BYTES
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_UPLOAD_SAMPLE_HEADER
comma
l_string|&quot;upload sample header&quot;
comma
l_int|13
comma
l_int|2
comma
l_int|0
)brace
comma
multiline_comment|/* This command requires a variable number of bytes to be written.&n;&t;   There is a hack in snd_wavefront_cmd() to support this. The actual&n;&t;   count is passed in as the read buffer ptr, cast appropriately.&n;&t;   Ugh.&n;&t;*/
(brace
id|WFC_DOWNLOAD_MULTISAMPLE
comma
l_string|&quot;download multisample&quot;
comma
l_int|0
comma
l_int|0
comma
id|NEEDS_ACK
)brace
comma
multiline_comment|/* This one is a hack as well. We just read the first byte of the&n;&t;   response, don&squot;t fetch an ACK, and leave the rest to the &n;&t;   calling function. Ugly, ugly, ugly.&n;&t;*/
(brace
id|WFC_UPLOAD_MULTISAMPLE
comma
l_string|&quot;upload multisample&quot;
comma
l_int|2
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
id|WFC_DOWNLOAD_SAMPLE_ALIAS
comma
l_string|&quot;download sample alias&quot;
comma
l_int|0
comma
id|WF_ALIAS_BYTES
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_UPLOAD_SAMPLE_ALIAS
comma
l_string|&quot;upload sample alias&quot;
comma
id|WF_ALIAS_BYTES
comma
l_int|2
comma
l_int|0
)brace
comma
(brace
id|WFC_DELETE_SAMPLE
comma
l_string|&quot;delete sample&quot;
comma
l_int|0
comma
l_int|2
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_IDENTIFY_SAMPLE_TYPE
comma
l_string|&quot;identify sample type&quot;
comma
l_int|5
comma
l_int|2
comma
l_int|0
)brace
comma
(brace
id|WFC_UPLOAD_SAMPLE_PARAMS
comma
l_string|&quot;upload sample parameters&quot;
)brace
comma
(brace
id|WFC_REPORT_FREE_MEMORY
comma
l_string|&quot;report free memory&quot;
comma
l_int|4
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_DOWNLOAD_PATCH
comma
l_string|&quot;download patch&quot;
comma
l_int|0
comma
l_int|134
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_UPLOAD_PATCH
comma
l_string|&quot;upload patch&quot;
comma
l_int|132
comma
l_int|2
comma
l_int|0
)brace
comma
(brace
id|WFC_DOWNLOAD_PROGRAM
comma
l_string|&quot;download program&quot;
comma
l_int|0
comma
l_int|33
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_UPLOAD_PROGRAM
comma
l_string|&quot;upload program&quot;
comma
l_int|32
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
id|WFC_DOWNLOAD_EDRUM_PROGRAM
comma
l_string|&quot;download enhanced drum program&quot;
comma
l_int|0
comma
l_int|9
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_UPLOAD_EDRUM_PROGRAM
comma
l_string|&quot;upload enhanced drum program&quot;
comma
l_int|8
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
id|WFC_SET_EDRUM_CHANNEL
comma
l_string|&quot;set enhanced drum program channel&quot;
comma
l_int|0
comma
l_int|1
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_DISABLE_DRUM_PROGRAM
comma
l_string|&quot;disable drum program&quot;
comma
l_int|0
comma
l_int|1
comma
id|NEEDS_ACK
)brace
comma
(brace
id|WFC_REPORT_CHANNEL_PROGRAMS
comma
l_string|&quot;report channel program numbers&quot;
comma
l_int|32
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|WFC_NOOP
comma
l_string|&quot;the no-op command&quot;
comma
l_int|0
comma
l_int|0
comma
id|NEEDS_ACK
)brace
comma
(brace
l_int|0x00
)brace
)brace
suffix:semicolon
r_static
r_const
r_char
op_star
DECL|function|wavefront_errorstr
id|wavefront_errorstr
(paren
r_int
id|errnum
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|wavefront_errors
(braket
id|i
)braket
dot
id|errstr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|wavefront_errors
(braket
id|i
)braket
dot
id|errno
op_eq
id|errnum
)paren
(brace
r_return
id|wavefront_errors
(braket
id|i
)braket
dot
id|errstr
suffix:semicolon
)brace
)brace
r_return
l_string|&quot;Unknown WaveFront error&quot;
suffix:semicolon
)brace
r_static
id|wavefront_command
op_star
DECL|function|wavefront_get_command
id|wavefront_get_command
(paren
r_int
id|cmd
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|wavefront_commands
(braket
id|i
)braket
dot
id|cmd
op_ne
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_eq
id|wavefront_commands
(braket
id|i
)braket
dot
id|cmd
)paren
(brace
r_return
op_amp
id|wavefront_commands
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
r_return
(paren
id|wavefront_command
op_star
)paren
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|wavefront_status
id|wavefront_status
(paren
id|snd_wavefront_t
op_star
id|dev
)paren
(brace
r_return
id|inb
(paren
id|dev-&gt;status_port
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_sleep
id|wavefront_sleep
(paren
r_int
id|limit
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|limit
)paren
suffix:semicolon
r_return
id|signal_pending
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_wait
id|wavefront_wait
(paren
id|snd_wavefront_t
op_star
id|dev
comma
r_int
id|mask
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Spin for a short period of time, because &gt;99% of all&n;&t;   requests to the WaveFront can be serviced inline like this.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|wait_usecs
suffix:semicolon
id|i
op_add_assign
l_int|5
)paren
(brace
r_if
c_cond
(paren
id|wavefront_status
(paren
id|dev
)paren
op_amp
id|mask
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sleep_tries
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|wavefront_status
(paren
id|dev
)paren
op_amp
id|mask
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wavefront_sleep
(paren
id|HZ
op_div
id|sleep_interval
)paren
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_read
id|wavefront_read
(paren
id|snd_wavefront_t
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|wavefront_wait
(paren
id|dev
comma
id|STAT_CAN_READ
)paren
)paren
r_return
id|inb
(paren
id|dev-&gt;data_port
)paren
suffix:semicolon
id|DPRINT
(paren
id|WF_DEBUG_DATA
comma
l_string|&quot;read timeout.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_write
id|wavefront_write
(paren
id|snd_wavefront_t
op_star
id|dev
comma
r_int
r_char
id|data
)paren
(brace
r_if
c_cond
(paren
id|wavefront_wait
(paren
id|dev
comma
id|STAT_CAN_WRITE
)paren
)paren
(brace
id|outb
(paren
id|data
comma
id|dev-&gt;data_port
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DPRINT
(paren
id|WF_DEBUG_DATA
comma
l_string|&quot;write timeout.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|snd_wavefront_cmd
id|snd_wavefront_cmd
(paren
id|snd_wavefront_t
op_star
id|dev
comma
r_int
id|cmd
comma
r_int
r_char
op_star
id|rbuf
comma
r_int
r_char
op_star
id|wbuf
)paren
(brace
r_int
id|ack
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_int
id|c
suffix:semicolon
id|wavefront_command
op_star
id|wfcmd
suffix:semicolon
r_if
c_cond
(paren
(paren
id|wfcmd
op_assign
id|wavefront_get_command
(paren
id|cmd
)paren
)paren
op_eq
(paren
id|wavefront_command
op_star
)paren
l_int|0
)paren
(brace
id|snd_printk
(paren
l_string|&quot;command 0x%x not supported.&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Hack to handle the one variable-size write command. See&n;&t;   wavefront_send_multisample() for the other half of this&n;&t;   gross and ugly strategy.&n;&t;*/
r_if
c_cond
(paren
id|cmd
op_eq
id|WFC_DOWNLOAD_MULTISAMPLE
)paren
(brace
id|wfcmd-&gt;write_cnt
op_assign
(paren
r_int
r_int
)paren
id|rbuf
suffix:semicolon
id|rbuf
op_assign
l_int|NULL
suffix:semicolon
)brace
id|DPRINT
(paren
id|WF_DEBUG_CMD
comma
l_string|&quot;0x%x [%s] (%d,%d,%d)&bslash;n&quot;
comma
id|cmd
comma
id|wfcmd-&gt;action
comma
id|wfcmd-&gt;read_cnt
comma
id|wfcmd-&gt;write_cnt
comma
id|wfcmd-&gt;need_ack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_write
(paren
id|dev
comma
id|cmd
)paren
)paren
(brace
id|DPRINT
(paren
(paren
id|WF_DEBUG_IO
op_or
id|WF_DEBUG_CMD
)paren
comma
l_string|&quot;cannot request &quot;
l_string|&quot;0x%x [%s].&bslash;n&quot;
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wfcmd-&gt;write_cnt
OG
l_int|0
)paren
(brace
id|DPRINT
(paren
id|WF_DEBUG_DATA
comma
l_string|&quot;writing %d bytes &quot;
l_string|&quot;for 0x%x&bslash;n&quot;
comma
id|wfcmd-&gt;write_cnt
comma
id|cmd
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|wfcmd-&gt;write_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|wavefront_write
(paren
id|dev
comma
id|wbuf
(braket
id|i
)braket
)paren
)paren
(brace
id|DPRINT
(paren
id|WF_DEBUG_IO
comma
l_string|&quot;bad write for byte &quot;
l_string|&quot;%d of 0x%x [%s].&bslash;n&quot;
comma
id|i
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|DPRINT
(paren
id|WF_DEBUG_DATA
comma
l_string|&quot;write[%d] = 0x%x&bslash;n&quot;
comma
id|i
comma
id|wbuf
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|wfcmd-&gt;read_cnt
OG
l_int|0
)paren
(brace
id|DPRINT
(paren
id|WF_DEBUG_DATA
comma
l_string|&quot;reading %d ints &quot;
l_string|&quot;for 0x%x&bslash;n&quot;
comma
id|wfcmd-&gt;read_cnt
comma
id|cmd
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|wfcmd-&gt;read_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|c
op_assign
id|wavefront_read
(paren
id|dev
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|DPRINT
(paren
id|WF_DEBUG_IO
comma
l_string|&quot;bad read for byte &quot;
l_string|&quot;%d of 0x%x [%s].&bslash;n&quot;
comma
id|i
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Now handle errors. Lots of special cases here */
r_if
c_cond
(paren
id|c
op_eq
l_int|0xff
)paren
(brace
r_if
c_cond
(paren
(paren
id|c
op_assign
id|wavefront_read
(paren
id|dev
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|DPRINT
(paren
id|WF_DEBUG_IO
comma
l_string|&quot;bad read for &quot;
l_string|&quot;error byte at &quot;
l_string|&quot;read byte %d &quot;
l_string|&quot;of 0x%x [%s].&bslash;n&quot;
comma
id|i
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Can you believe this madness ? */
r_if
c_cond
(paren
id|c
op_eq
l_int|1
op_logical_and
id|wfcmd-&gt;cmd
op_eq
id|WFC_IDENTIFY_SAMPLE_TYPE
)paren
(brace
id|rbuf
(braket
l_int|0
)braket
op_assign
id|WF_ST_EMPTY
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_int|3
op_logical_and
id|wfcmd-&gt;cmd
op_eq
id|WFC_UPLOAD_PATCH
)paren
(brace
r_return
l_int|3
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_int|1
op_logical_and
id|wfcmd-&gt;cmd
op_eq
id|WFC_UPLOAD_PROGRAM
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|DPRINT
(paren
id|WF_DEBUG_IO
comma
l_string|&quot;error %d (%s) &quot;
l_string|&quot;during &quot;
l_string|&quot;read for byte &quot;
l_string|&quot;%d of 0x%x &quot;
l_string|&quot;[%s].&bslash;n&quot;
comma
id|c
comma
id|wavefront_errorstr
(paren
id|c
)paren
comma
id|i
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|rbuf
(braket
id|i
)braket
op_assign
id|c
suffix:semicolon
)brace
id|DPRINT
(paren
id|WF_DEBUG_DATA
comma
l_string|&quot;read[%d] = 0x%x&bslash;n&quot;
comma
id|i
comma
id|rbuf
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|wfcmd-&gt;read_cnt
op_eq
l_int|0
op_logical_and
id|wfcmd-&gt;write_cnt
op_eq
l_int|0
)paren
op_logical_or
id|wfcmd-&gt;need_ack
)paren
(brace
id|DPRINT
(paren
id|WF_DEBUG_CMD
comma
l_string|&quot;reading ACK for 0x%x&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/* Some commands need an ACK, but return zero instead&n;&t;&t;   of the standard value.&n;&t;&t;*/
r_if
c_cond
(paren
(paren
id|ack
op_assign
id|wavefront_read
(paren
id|dev
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|ack
op_assign
id|WF_ACK
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ack
op_ne
id|WF_ACK
)paren
(brace
r_if
c_cond
(paren
id|ack
op_eq
op_minus
l_int|1
)paren
(brace
id|DPRINT
(paren
id|WF_DEBUG_IO
comma
l_string|&quot;cannot read ack for &quot;
l_string|&quot;0x%x [%s].&bslash;n&quot;
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_int
id|err
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* something unknown */
r_if
c_cond
(paren
id|ack
op_eq
l_int|0xff
)paren
(brace
multiline_comment|/* explicit error */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|wavefront_read
(paren
id|dev
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|DPRINT
(paren
id|WF_DEBUG_DATA
comma
l_string|&quot;cannot read err &quot;
l_string|&quot;for 0x%x [%s].&bslash;n&quot;
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
)brace
)brace
id|DPRINT
(paren
id|WF_DEBUG_IO
comma
l_string|&quot;0x%x [%s] &quot;
l_string|&quot;failed (0x%x, 0x%x, %s)&bslash;n&quot;
comma
id|cmd
comma
id|wfcmd-&gt;action
comma
id|ack
comma
id|err
comma
id|wavefront_errorstr
(paren
id|err
)paren
)paren
suffix:semicolon
r_return
op_minus
id|err
suffix:semicolon
)brace
)brace
id|DPRINT
(paren
id|WF_DEBUG_DATA
comma
l_string|&quot;ack received &quot;
l_string|&quot;for 0x%x [%s]&bslash;n&quot;
comma
id|cmd
comma
id|wfcmd-&gt;action
)paren
suffix:semicolon
)brace
r_else
(brace
id|DPRINT
(paren
id|WF_DEBUG_CMD
comma
l_string|&quot;0x%x [%s] does not need &quot;
l_string|&quot;ACK (%d,%d,%d)&bslash;n&quot;
comma
id|cmd
comma
id|wfcmd-&gt;action
comma
id|wfcmd-&gt;read_cnt
comma
id|wfcmd-&gt;write_cnt
comma
id|wfcmd-&gt;need_ack
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/***********************************************************************&n;WaveFront data munging   &n;&n;Things here are weird. All data written to the board cannot &n;have its most significant bit set. Any data item with values &n;potentially &gt; 0x7F (127) must be split across multiple bytes.&n;&n;Sometimes, we need to munge numeric values that are represented on&n;the x86 side as 8-32 bit values. Sometimes, we need to munge data&n;that is represented on the x86 side as an array of bytes. The most&n;efficient approach to handling both cases seems to be to use 2&n;different functions for munging and 2 for de-munging. This avoids&n;weird casting and worrying about bit-level offsets.&n;&n;**********************************************************************/
r_static
r_int
r_char
op_star
DECL|function|munge_int32
id|munge_int32
(paren
r_int
r_int
id|src
comma
r_int
r_char
op_star
id|dst
comma
r_int
r_int
id|dst_size
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dst_size
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|dst
op_assign
id|src
op_amp
l_int|0x7F
suffix:semicolon
multiline_comment|/* Mask high bit of LSB */
id|src
op_assign
id|src
op_rshift
l_int|7
suffix:semicolon
multiline_comment|/* Rotate Right 7 bits  */
multiline_comment|/* Note: we leave the upper bits in place */
id|dst
op_increment
suffix:semicolon
)brace
suffix:semicolon
r_return
id|dst
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
DECL|function|demunge_int32
id|demunge_int32
(paren
r_int
r_char
op_star
id|src
comma
r_int
id|src_size
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|outval
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|src_size
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|outval
op_assign
(paren
id|outval
op_lshift
l_int|7
)paren
op_plus
id|src
(braket
id|i
)braket
suffix:semicolon
)brace
r_return
id|outval
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
r_char
op_star
DECL|function|munge_buf
id|munge_buf
(paren
r_int
r_char
op_star
id|src
comma
r_int
r_char
op_star
id|dst
comma
r_int
r_int
id|dst_size
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|last
op_assign
id|dst_size
op_div
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|last
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|dst
op_increment
op_assign
id|src
(braket
id|i
)braket
op_amp
l_int|0x7f
suffix:semicolon
op_star
id|dst
op_increment
op_assign
id|src
(braket
id|i
)braket
op_rshift
l_int|7
suffix:semicolon
)brace
r_return
id|dst
suffix:semicolon
)brace
r_static
r_int
r_char
op_star
DECL|function|demunge_buf
id|demunge_buf
(paren
r_int
r_char
op_star
id|src
comma
r_int
r_char
op_star
id|dst
comma
r_int
r_int
id|src_bytes
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
op_star
id|end
op_assign
id|src
op_plus
id|src_bytes
suffix:semicolon
id|end
op_assign
id|src
op_plus
id|src_bytes
suffix:semicolon
multiline_comment|/* NOTE: src and dst *CAN* point to the same address */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|src
op_ne
id|end
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dst
(braket
id|i
)braket
op_assign
op_star
id|src
op_increment
suffix:semicolon
id|dst
(braket
id|i
)braket
op_or_assign
(paren
op_star
id|src
op_increment
)paren
op_lshift
l_int|7
suffix:semicolon
)brace
r_return
id|dst
suffix:semicolon
)brace
"&f;"
multiline_comment|/***********************************************************************&n;WaveFront: sample, patch and program management.&n;***********************************************************************/
r_static
r_int
DECL|function|wavefront_delete_sample
id|wavefront_delete_sample
(paren
id|snd_wavefront_t
op_star
id|dev
comma
r_int
id|sample_num
)paren
(brace
r_int
r_char
id|wbuf
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|x
suffix:semicolon
id|wbuf
(braket
l_int|0
)braket
op_assign
id|sample_num
op_amp
l_int|0x7f
suffix:semicolon
id|wbuf
(braket
l_int|1
)braket
op_assign
id|sample_num
op_rshift
l_int|7
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
op_assign
id|snd_wavefront_cmd
(paren
id|dev
comma
id|WFC_DELETE_SAMPLE
comma
l_int|NULL
comma
id|wbuf
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|dev-&gt;sample_status
(braket
id|sample_num
)braket
op_assign
id|WF_ST_EMPTY
suffix:semicolon
)brace
r_return
id|x
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_get_sample_status
id|wavefront_get_sample_status
(paren
id|snd_wavefront_t
op_star
id|dev
comma
r_int
id|assume_rom
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|rbuf
(braket
l_int|32
)braket
comma
id|wbuf
(braket
l_int|32
)braket
suffix:semicolon
r_int
r_int
id|sc_real
comma
id|sc_alias
comma
id|sc_multi
suffix:semicolon
multiline_comment|/* check sample status */
r_if
c_cond
(paren
id|snd_wavefront_cmd
(paren
id|dev
comma
id|WFC_GET_NSAMPLES
comma
id|rbuf
comma
id|wbuf
)paren
)paren
(brace
id|snd_printk
(paren
l_string|&quot;cannot request sample count.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|sc_real
op_assign
id|sc_alias
op_assign
id|sc_multi
op_assign
id|dev-&gt;samples_used
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_MAX_SAMPLE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|wbuf
(braket
l_int|0
)braket
op_assign
id|i
op_amp
l_int|0x7f
suffix:semicolon
id|wbuf
(braket
l_int|1
)braket
op_assign
id|i
op_rshift
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|snd_wavefront_cmd
(paren
id|dev
comma
id|WFC_IDENTIFY_SAMPLE_TYPE
comma
id|rbuf
comma
id|wbuf
)paren
)paren
(brace
id|snd_printk
c_func
(paren
l_string|&quot;cannot identify sample &quot;
l_string|&quot;type of slot %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|dev-&gt;sample_status
(braket
id|i
)braket
op_assign
id|WF_ST_EMPTY
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|dev-&gt;sample_status
(braket
id|i
)braket
op_assign
(paren
id|WF_SLOT_FILLED
op_or
id|rbuf
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|assume_rom
)paren
(brace
id|dev-&gt;sample_status
(braket
id|i
)braket
op_or_assign
id|WF_SLOT_ROM
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|rbuf
(braket
l_int|0
)braket
op_amp
id|WF_ST_MASK
)paren
(brace
r_case
id|WF_ST_SAMPLE
suffix:colon
id|sc_real
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WF_ST_MULTISAMPLE
suffix:colon
id|sc_multi
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WF_ST_ALIAS
suffix:colon
id|sc_alias
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WF_ST_EMPTY
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|snd_printk
(paren
l_string|&quot;unknown sample type for &quot;
l_string|&quot;slot %d (0x%x)&bslash;n&quot;
comma
id|i
comma
id|rbuf
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rbuf
(braket
l_int|0
)braket
op_ne
id|WF_ST_EMPTY
)paren
(brace
id|dev-&gt;samples_used
op_increment
suffix:semicolon
)brace
)brace
id|snd_printk
(paren
l_string|&quot;%d samples used (%d real, %d aliases, %d multi), &quot;
l_string|&quot;%d empty&bslash;n&quot;
comma
id|dev-&gt;samples_used
comma
id|sc_real
comma
id|sc_alias
comma
id|sc_multi
comma
id|WF_MAX_SAMPLE
op_minus
id|dev-&gt;samples_used
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_get_patch_status
id|wavefront_get_patch_status
(paren
id|snd_wavefront_t
op_star
id|dev
)paren
(brace
r_int
r_char
id|patchbuf
(braket
id|WF_PATCH_BYTES
)braket
suffix:semicolon
r_int
r_char
id|patchnum
(braket
l_int|2
)braket
suffix:semicolon
id|wavefront_patch
op_star
id|p
suffix:semicolon
r_int
id|i
comma
id|x
comma
id|cnt
comma
id|cnt2
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_MAX_PATCH
suffix:semicolon
id|i
op_increment
)paren
(brace
id|patchnum
(braket
l_int|0
)braket
op_assign
id|i
op_amp
l_int|0x7f
suffix:semicolon
id|patchnum
(braket
l_int|1
)braket
op_assign
id|i
op_rshift
l_int|7
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
op_assign
id|snd_wavefront_cmd
(paren
id|dev
comma
id|WFC_UPLOAD_PATCH
comma
id|patchbuf
comma
id|patchnum
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|dev-&gt;patch_status
(braket
id|i
)braket
op_or_assign
id|WF_SLOT_FILLED
suffix:semicolon
id|p
op_assign
(paren
id|wavefront_patch
op_star
)paren
id|patchbuf
suffix:semicolon
id|dev-&gt;sample_status
(braket
id|p-&gt;sample_number
op_or
(paren
id|p-&gt;sample_msb
op_lshift
l_int|7
)paren
)braket
op_or_assign
id|WF_SLOT_USED
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|x
op_eq
l_int|3
)paren
(brace
multiline_comment|/* Bad patch number */
id|dev-&gt;patch_status
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|snd_printk
(paren
l_string|&quot;upload patch &quot;
l_string|&quot;error 0x%x&bslash;n&quot;
comma
id|x
)paren
suffix:semicolon
id|dev-&gt;patch_status
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* program status has already filled in slot_used bits */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cnt
op_assign
l_int|0
comma
id|cnt2
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_MAX_PATCH
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;patch_status
(braket
id|i
)braket
op_amp
id|WF_SLOT_FILLED
)paren
(brace
id|cnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;patch_status
(braket
id|i
)braket
op_amp
id|WF_SLOT_USED
)paren
(brace
id|cnt2
op_increment
suffix:semicolon
)brace
)brace
id|snd_printk
(paren
l_string|&quot;%d patch slots filled, %d in use&bslash;n&quot;
comma
id|cnt
comma
id|cnt2
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_get_program_status
id|wavefront_get_program_status
(paren
id|snd_wavefront_t
op_star
id|dev
)paren
(brace
r_int
r_char
id|progbuf
(braket
id|WF_PROGRAM_BYTES
)braket
suffix:semicolon
id|wavefront_program
id|prog
suffix:semicolon
r_int
r_char
id|prognum
suffix:semicolon
r_int
id|i
comma
id|x
comma
id|l
comma
id|cnt
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_MAX_PROGRAM
suffix:semicolon
id|i
op_increment
)paren
(brace
id|prognum
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
op_assign
id|snd_wavefront_cmd
(paren
id|dev
comma
id|WFC_UPLOAD_PROGRAM
comma
id|progbuf
comma
op_amp
id|prognum
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|dev-&gt;prog_status
(braket
id|i
)braket
op_or_assign
id|WF_SLOT_USED
suffix:semicolon
id|demunge_buf
(paren
id|progbuf
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|prog
comma
id|WF_PROGRAM_BYTES
)paren
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|WF_NUM_LAYERS
suffix:semicolon
id|l
op_increment
)paren
(brace
r_if
c_cond
(paren
id|prog.layer
(braket
id|l
)braket
dot
id|mute
)paren
(brace
id|dev-&gt;patch_status
(braket
id|prog.layer
(braket
id|l
)braket
dot
id|patch_number
)braket
op_or_assign
id|WF_SLOT_USED
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|x
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Bad program number */
id|dev-&gt;prog_status
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|snd_printk
(paren
l_string|&quot;upload program &quot;
l_string|&quot;error 0x%x&bslash;n&quot;
comma
id|x
)paren
suffix:semicolon
id|dev-&gt;prog_status
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cnt
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_MAX_PROGRAM
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;prog_status
(braket
id|i
)braket
)paren
(brace
id|cnt
op_increment
suffix:semicolon
)brace
)brace
id|snd_printk
(paren
l_string|&quot;%d programs slots in use&bslash;n&quot;
comma
id|cnt
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_send_patch
id|wavefront_send_patch
(paren
id|snd_wavefront_t
op_star
id|dev
comma
id|wavefront_patch_info
op_star
id|header
)paren
(brace
r_int
r_char
id|buf
(braket
id|WF_PATCH_BYTES
op_plus
l_int|2
)braket
suffix:semicolon
r_int
r_char
op_star
id|bptr
suffix:semicolon
id|DPRINT
(paren
id|WF_DEBUG_LOAD_PATCH
comma
l_string|&quot;downloading patch %d&bslash;n&quot;
comma
id|header-&gt;number
)paren
suffix:semicolon
id|dev-&gt;patch_status
(braket
id|header-&gt;number
)braket
op_or_assign
id|WF_SLOT_FILLED
suffix:semicolon
id|bptr
op_assign
id|buf
suffix:semicolon
id|bptr
op_assign
id|munge_int32
(paren
id|header-&gt;number
comma
id|buf
comma
l_int|2
)paren
suffix:semicolon
id|munge_buf
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|header-&gt;hdr.p
comma
id|bptr
comma
id|WF_PATCH_BYTES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|snd_wavefront_cmd
(paren
id|dev
comma
id|WFC_DOWNLOAD_PATCH
comma
l_int|NULL
comma
id|buf
)paren
)paren
(brace
id|snd_printk
(paren
l_string|&quot;download patch failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_send_program
id|wavefront_send_program
(paren
id|snd_wavefront_t
op_star
id|dev
comma
id|wavefront_patch_info
op_star
id|header
)paren
(brace
r_int
r_char
id|buf
(braket
id|WF_PROGRAM_BYTES
op_plus
l_int|1
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DPRINT
(paren
id|WF_DEBUG_LOAD_PATCH
comma
l_string|&quot;downloading program %d&bslash;n&quot;
comma
id|header-&gt;number
)paren
suffix:semicolon
id|dev-&gt;prog_status
(braket
id|header-&gt;number
)braket
op_assign
id|WF_SLOT_USED
suffix:semicolon
multiline_comment|/* XXX need to zero existing SLOT_USED bit for program_status[i]&n;&t;   where `i&squot; is the program that&squot;s being (potentially) overwritten.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_NUM_LAYERS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|header-&gt;hdr.pr.layer
(braket
id|i
)braket
dot
id|mute
)paren
(brace
id|dev-&gt;patch_status
(braket
id|header-&gt;hdr.pr.layer
(braket
id|i
)braket
dot
id|patch_number
)braket
op_or_assign
id|WF_SLOT_USED
suffix:semicolon
multiline_comment|/* XXX need to mark SLOT_USED for sample used by&n;&t;&t;&t;   patch_number, but this means we have to load it. Ick.&n;&t;&t;&t;*/
)brace
)brace
id|buf
(braket
l_int|0
)braket
op_assign
id|header-&gt;number
suffix:semicolon
id|munge_buf
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|header-&gt;hdr.pr
comma
op_amp
id|buf
(braket
l_int|1
)braket
comma
id|WF_PROGRAM_BYTES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|snd_wavefront_cmd
(paren
id|dev
comma
id|WFC_DOWNLOAD_PROGRAM
comma
l_int|NULL
comma
id|buf
)paren
)paren
(brace
id|snd_printk
(paren
l_string|&quot;download patch failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_freemem
id|wavefront_freemem
(paren
id|snd_wavefront_t
op_star
id|dev
)paren
(brace
r_char
id|rbuf
(braket
l_int|8
)braket
suffix:semicolon
r_if
c_cond
(paren
id|snd_wavefront_cmd
(paren
id|dev
comma
id|WFC_REPORT_FREE_MEMORY
comma
id|rbuf
comma
l_int|NULL
)paren
)paren
(brace
id|snd_printk
(paren
l_string|&quot;can&squot;t get memory stats.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
id|demunge_int32
(paren
id|rbuf
comma
l_int|4
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|wavefront_send_sample
id|wavefront_send_sample
(paren
id|snd_wavefront_t
op_star
id|dev
comma
id|wavefront_patch_info
op_star
id|header
comma
id|u16
id|__user
op_star
id|dataptr
comma
r_int
id|data_is_unsigned
)paren
(brace
multiline_comment|/* samples are downloaded via a 16-bit wide i/o port&n;&t;   (you could think of it as 2 adjacent 8-bit wide ports&n;&t;   but its less efficient that way). therefore, all&n;&t;   the blocksizes and so forth listed in the documentation,&n;&t;   and used conventionally to refer to sample sizes,&n;&t;   which are given in 8-bit units (bytes), need to be&n;&t;   divided by 2.&n;        */
id|u16
id|sample_short
suffix:semicolon
id|u32
id|length
suffix:semicolon
id|u16
id|__user
op_star
id|data_end
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_const
r_int
r_int
id|max_blksize
op_assign
l_int|4096
op_div
l_int|2
suffix:semicolon
r_int
r_int
id|written
suffix:semicolon
r_int
r_int
id|blocksize
suffix:semicolon
r_int
id|dma_ack
suffix:semicolon
r_int
id|blocknum
suffix:semicolon
r_int
r_char
id|sample_hdr
(braket
id|WF_SAMPLE_HDR_BYTES
)braket
suffix:semicolon
r_int
r_char
op_star
id|shptr
suffix:semicolon
r_int
id|skip
op_assign
l_int|0
suffix:semicolon
r_int
id|initial_skip
op_assign
l_int|0
suffix:semicolon
id|DPRINT
(paren
id|WF_DEBUG_LOAD_PATCH
comma
l_string|&quot;sample %sdownload for slot %d, &quot;
l_string|&quot;type %d, %d bytes from 0x%lx&bslash;n&quot;
comma
id|header-&gt;size
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;header &quot;
comma
id|header-&gt;number
comma
id|header-&gt;subkey
comma
id|header-&gt;size
comma
(paren
r_int
r_int
)paren
id|header-&gt;dataptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|header-&gt;number
op_eq
id|WAVEFRONT_FIND_FREE_SAMPLE_SLOT
)paren
(brace
r_int
id|x
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
op_assign
id|wavefront_find_free_sample
(paren
id|dev
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|snd_printk
(paren
l_string|&quot;unspecified sample =&gt; %d&bslash;n&quot;
comma
id|x
)paren
suffix:semicolon
id|header-&gt;number
op_assign
id|x
suffix:semicolon
)brace
r_if
c_cond
(paren
id|header-&gt;size
)paren
(brace
multiline_comment|/* XXX it&squot;s a debatable point whether or not RDONLY semantics&n;&t;&t;   on the ROM samples should cover just the sample data or&n;&t;&t;   the sample header. For now, it only covers the sample data,&n;&t;&t;   so anyone is free at all times to rewrite sample headers.&n;&n;&t;&t;   My reason for this is that we have the sample headers&n;&t;&t;   available in the WFB file for General MIDI, and so these&n;&t;&t;   can always be reset if needed. The sample data, however,&n;&t;&t;   cannot be recovered without a complete reset and firmware&n;&t;&t;   reload of the ICS2115, which is a very expensive operation.&n;&n;&t;&t;   So, doing things this way allows us to honor the notion of&n;&t;&t;   &quot;RESETSAMPLES&quot; reasonably cheaply. Note however, that this&n;&t;&t;   is done purely at user level: there is no WFB parser in&n;&t;&t;   this driver, and so a complete reset (back to General MIDI,&n;&t;&t;   or theoretically some other configuration) is the&n;&t;&t;   responsibility of the user level library. &n;&n;&t;&t;   To try to do this in the kernel would be a little&n;&t;&t;   crazy: we&squot;d need 158K of kernel space just to hold&n;&t;&t;   a copy of the patch/program/sample header data.&n;&t;&t;*/
r_if
c_cond
(paren
id|dev-&gt;rom_samples_rdonly
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;sample_status
(braket
id|header-&gt;number
)braket
op_amp
id|WF_SLOT_ROM
)paren
(brace
id|snd_printk
(paren
l_string|&quot;sample slot %d &quot;
l_string|&quot;write protected&bslash;n&quot;
comma
id|header-&gt;number
)paren
suffix:semicolon
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
)brace
id|wavefront_delete_sample
(paren
id|dev
comma
id|header-&gt;number
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|header-&gt;size
)paren
(brace
id|dev-&gt;freemem
op_assign
id|wavefront_freemem
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;freemem
OL
(paren
r_int
)paren
id|header-&gt;size
)paren
(brace
id|snd_printk
(paren
l_string|&quot;insufficient memory to &quot;
l_string|&quot;load %d byte sample.&bslash;n&quot;
comma
id|header-&gt;size
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
id|skip
op_assign
id|WF_GET_CHANNEL
c_func
(paren
op_amp
id|header-&gt;hdr.s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skip
OG
l_int|0
op_logical_and
id|header-&gt;hdr.s.SampleResolution
op_ne
id|LINEAR_16BIT
)paren
(brace
id|snd_printk
(paren
l_string|&quot;channel selection only &quot;
l_string|&quot;possible on 16-bit samples&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|skip
)paren
(brace
r_case
l_int|0
suffix:colon
id|initial_skip
op_assign
l_int|0
suffix:semicolon
id|skip
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|initial_skip
op_assign
l_int|0
suffix:semicolon
id|skip
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|initial_skip
op_assign
l_int|1
suffix:semicolon
id|skip
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|initial_skip
op_assign
l_int|2
suffix:semicolon
id|skip
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|initial_skip
op_assign
l_int|3
suffix:semicolon
id|skip
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|initial_skip
op_assign
l_int|4
suffix:semicolon
id|skip
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|initial_skip
op_assign
l_int|5
suffix:semicolon
id|skip
op_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
)brace
id|DPRINT
(paren
id|WF_DEBUG_LOAD_PATCH
comma
l_string|&quot;channel selection: %d =&gt; &quot;
l_string|&quot;initial skip = %d, skip = %d&bslash;n&quot;
comma
id|WF_GET_CHANNEL
(paren
op_amp
id|header-&gt;hdr.s
)paren
comma
id|initial_skip
comma
id|skip
)paren
suffix:semicolon
multiline_comment|/* Be safe, and zero the &quot;Unused&quot; bits ... */
id|WF_SET_CHANNEL
c_func
(paren
op_amp
id|header-&gt;hdr.s
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* adjust size for 16 bit samples by dividing by two.  We always&n;&t;   send 16 bits per write, even for 8 bit samples, so the length&n;&t;   is always half the size of the sample data in bytes.&n;&t;*/
id|length
op_assign
id|header-&gt;size
op_div
l_int|2
suffix:semicolon
multiline_comment|/* the data we&squot;re sent has not been munged, and in fact, the&n;&t;   header we have to send isn&squot;t just a munged copy either.&n;&t;   so, build the sample header right here.&n;&t;*/
id|shptr
op_assign
op_amp
id|sample_hdr
(braket
l_int|0
)braket
suffix:semicolon
id|shptr
op_assign
id|munge_int32
(paren
id|header-&gt;number
comma
id|shptr
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|header-&gt;size
)paren
(brace
id|shptr
op_assign
id|munge_int32
(paren
id|length
comma
id|shptr
comma
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/* Yes, a 4 byte result doesn&squot;t contain all of the offset bits,&n;&t;   but the offset only uses 24 bits.&n;&t;*/
id|shptr
op_assign
id|munge_int32
(paren
op_star
(paren
(paren
id|u32
op_star
)paren
op_amp
id|header-&gt;hdr.s.sampleStartOffset
)paren
comma
id|shptr
comma
l_int|4
)paren
suffix:semicolon
id|shptr
op_assign
id|munge_int32
(paren
op_star
(paren
(paren
id|u32
op_star
)paren
op_amp
id|header-&gt;hdr.s.loopStartOffset
)paren
comma
id|shptr
comma
l_int|4
)paren
suffix:semicolon
id|shptr
op_assign
id|munge_int32
(paren
op_star
(paren
(paren
id|u32
op_star
)paren
op_amp
id|header-&gt;hdr.s.loopEndOffset
)paren
comma
id|shptr
comma
l_int|4
)paren
suffix:semicolon
id|shptr
op_assign
id|munge_int32
(paren
op_star
(paren
(paren
id|u32
op_star
)paren
op_amp
id|header-&gt;hdr.s.sampleEndOffset
)paren
comma
id|shptr
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* This one is truly weird. What kind of weirdo decided that in&n;&t;   a system dominated by 16 and 32 bit integers, they would use&n;&t;   a just 12 bits ?&n;&t;*/
id|shptr
op_assign
id|munge_int32
(paren
id|header-&gt;hdr.s.FrequencyBias
comma
id|shptr
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Why is this nybblified, when the MSB is *always* zero ? &n;&t;   Anyway, we can&squot;t take address of bitfield, so make a&n;&t;   good-faith guess at where it starts.&n;&t;*/
id|shptr
op_assign
id|munge_int32
(paren
op_star
(paren
op_amp
id|header-&gt;hdr.s.FrequencyBias
op_plus
l_int|1
)paren
comma
id|shptr
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|snd_wavefront_cmd
(paren
id|dev
comma
id|header-&gt;size
ques
c_cond
id|WFC_DOWNLOAD_SAMPLE
suffix:colon
id|WFC_DOWNLOAD_SAMPLE_HEADER
comma
l_int|NULL
comma
id|sample_hdr
)paren
)paren
(brace
id|snd_printk
(paren
l_string|&quot;sample %sdownload refused.&bslash;n&quot;
comma
id|header-&gt;size
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;header &quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|header-&gt;size
op_eq
l_int|0
)paren
(brace
r_goto
id|sent
suffix:semicolon
multiline_comment|/* Sorry. Just had to have one somewhere */
)brace
id|data_end
op_assign
id|dataptr
op_plus
id|length
suffix:semicolon
multiline_comment|/* Do any initial skip over an unused channel&squot;s data */
id|dataptr
op_add_assign
id|initial_skip
suffix:semicolon
r_for
c_loop
(paren
id|written
op_assign
l_int|0
comma
id|blocknum
op_assign
l_int|0
suffix:semicolon
id|written
OL
id|length
suffix:semicolon
id|written
op_add_assign
id|max_blksize
comma
id|blocknum
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|length
op_minus
id|written
)paren
OG
id|max_blksize
)paren
(brace
id|blocksize
op_assign
id|max_blksize
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* round to nearest 16-byte value */
id|blocksize
op_assign
(paren
(paren
id|length
op_minus
id|written
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|0x7
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|snd_wavefront_cmd
(paren
id|dev
comma
id|WFC_DOWNLOAD_BLOCK
comma
l_int|NULL
comma
l_int|NULL
)paren
)paren
(brace
id|snd_printk
(paren
l_string|&quot;download block &quot;
l_string|&quot;request refused.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|blocksize
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dataptr
OL
id|data_end
)paren
(brace
id|__get_user
(paren
id|sample_short
comma
id|dataptr
)paren
suffix:semicolon
id|dataptr
op_add_assign
id|skip
suffix:semicolon
r_if
c_cond
(paren
id|data_is_unsigned
)paren
(brace
multiline_comment|/* GUS ? */
r_if
c_cond
(paren
id|WF_SAMPLE_IS_8BIT
c_func
(paren
op_amp
id|header-&gt;hdr.s
)paren
)paren
(brace
multiline_comment|/* 8 bit sample&n;&t;&t;&t;&t;&t;&t; resolution, sign&n;&t;&t;&t;&t;&t;&t; extend both bytes.&n;&t;&t;&t;&t;&t;&t;*/
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|sample_short
)paren
(braket
l_int|0
)braket
op_add_assign
l_int|0x7f
suffix:semicolon
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|sample_short
)paren
(braket
l_int|1
)braket
op_add_assign
l_int|0x7f
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* 16 bit sample&n;&t;&t;&t;&t;&t;&t; resolution, sign&n;&t;&t;&t;&t;&t;&t; extend the MSB.&n;&t;&t;&t;&t;&t;&t;*/
id|sample_short
op_add_assign
l_int|0x7fff
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* In padding section of final block:&n;&n;&t;&t;&t;&t;   Don&squot;t fetch unsupplied data from&n;&t;&t;&t;&t;   user space, just continue with&n;&t;&t;&t;&t;   whatever the final value was.&n;&t;&t;&t;&t;*/
)brace
r_if
c_cond
(paren
id|i
OL
id|blocksize
op_minus
l_int|1
)paren
(brace
id|outw
(paren
id|sample_short
comma
id|dev-&gt;block_port
)paren
suffix:semicolon
)brace
r_else
(brace
id|outw
(paren
id|sample_short
comma
id|dev-&gt;last_block_port
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Get &quot;DMA page acknowledge&quot;, even though its really&n;&t;&t;   nothing to do with DMA at all.&n;&t;&t;*/
r_if
c_cond
(paren
(paren
id|dma_ack
op_assign
id|wavefront_read
(paren
id|dev
)paren
)paren
op_ne
id|WF_DMA_ACK
)paren
(brace
r_if
c_cond
(paren
id|dma_ack
op_eq
op_minus
l_int|1
)paren
(brace
id|snd_printk
(paren
l_string|&quot;upload sample &quot;
l_string|&quot;DMA ack timeout&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_else
(brace
id|snd_printk
(paren
l_string|&quot;upload sample &quot;
l_string|&quot;DMA ack error 0x%x&bslash;n&quot;
comma
id|dma_ack
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
)brace
)brace
id|dev-&gt;sample_status
(braket
id|header-&gt;number
)braket
op_assign
(paren
id|WF_SLOT_FILLED
op_or
id|WF_ST_SAMPLE
)paren
suffix:semicolon
multiline_comment|/* Note, label is here because sending the sample header shouldn&squot;t&n;&t;   alter the sample_status info at all.&n;&t;*/
id|sent
suffix:colon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_send_alias
id|wavefront_send_alias
(paren
id|snd_wavefront_t
op_star
id|dev
comma
id|wavefront_patch_info
op_star
id|header
)paren
(brace
r_int
r_char
id|alias_hdr
(braket
id|WF_ALIAS_BYTES
)braket
suffix:semicolon
id|DPRINT
(paren
id|WF_DEBUG_LOAD_PATCH
comma
l_string|&quot;download alias, %d is &quot;
l_string|&quot;alias for %d&bslash;n&quot;
comma
id|header-&gt;number
comma
id|header-&gt;hdr.a.OriginalSample
)paren
suffix:semicolon
id|munge_int32
(paren
id|header-&gt;number
comma
op_amp
id|alias_hdr
(braket
l_int|0
)braket
comma
l_int|2
)paren
suffix:semicolon
id|munge_int32
(paren
id|header-&gt;hdr.a.OriginalSample
comma
op_amp
id|alias_hdr
(braket
l_int|2
)braket
comma
l_int|2
)paren
suffix:semicolon
id|munge_int32
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|header-&gt;hdr.a.sampleStartOffset
)paren
comma
op_amp
id|alias_hdr
(braket
l_int|4
)braket
comma
l_int|4
)paren
suffix:semicolon
id|munge_int32
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|header-&gt;hdr.a.loopStartOffset
)paren
comma
op_amp
id|alias_hdr
(braket
l_int|8
)braket
comma
l_int|4
)paren
suffix:semicolon
id|munge_int32
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|header-&gt;hdr.a.loopEndOffset
)paren
comma
op_amp
id|alias_hdr
(braket
l_int|12
)braket
comma
l_int|4
)paren
suffix:semicolon
id|munge_int32
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|header-&gt;hdr.a.sampleEndOffset
)paren
comma
op_amp
id|alias_hdr
(braket
l_int|16
)braket
comma
l_int|4
)paren
suffix:semicolon
id|munge_int32
(paren
id|header-&gt;hdr.a.FrequencyBias
comma
op_amp
id|alias_hdr
(braket
l_int|20
)braket
comma
l_int|3
)paren
suffix:semicolon
id|munge_int32
(paren
op_star
(paren
op_amp
id|header-&gt;hdr.a.FrequencyBias
op_plus
l_int|1
)paren
comma
op_amp
id|alias_hdr
(braket
l_int|23
)braket
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|snd_wavefront_cmd
(paren
id|dev
comma
id|WFC_DOWNLOAD_SAMPLE_ALIAS
comma
l_int|NULL
comma
id|alias_hdr
)paren
)paren
(brace
id|snd_printk
(paren
l_string|&quot;download alias failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|dev-&gt;sample_status
(braket
id|header-&gt;number
)braket
op_assign
(paren
id|WF_SLOT_FILLED
op_or
id|WF_ST_ALIAS
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_send_multisample
id|wavefront_send_multisample
(paren
id|snd_wavefront_t
op_star
id|dev
comma
id|wavefront_patch_info
op_star
id|header
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|num_samples
suffix:semicolon
r_int
r_char
id|msample_hdr
(braket
id|WF_MSAMPLE_BYTES
)braket
suffix:semicolon
id|munge_int32
(paren
id|header-&gt;number
comma
op_amp
id|msample_hdr
(braket
l_int|0
)braket
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* You&squot;ll recall at this point that the &quot;number of samples&quot; value&n;&t;   in a wavefront_multisample struct is actually the log2 of the&n;&t;   real number of samples.&n;&t;*/
id|num_samples
op_assign
(paren
l_int|1
op_lshift
(paren
id|header-&gt;hdr.ms.NumberOfSamples
op_amp
l_int|7
)paren
)paren
suffix:semicolon
id|msample_hdr
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_char
)paren
id|header-&gt;hdr.ms.NumberOfSamples
suffix:semicolon
id|DPRINT
(paren
id|WF_DEBUG_LOAD_PATCH
comma
l_string|&quot;multi %d with %d=%d samples&bslash;n&quot;
comma
id|header-&gt;number
comma
id|header-&gt;hdr.ms.NumberOfSamples
comma
id|num_samples
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_samples
suffix:semicolon
id|i
op_increment
)paren
(brace
id|DPRINT
c_func
(paren
id|WF_DEBUG_LOAD_PATCH
op_or
id|WF_DEBUG_DATA
comma
l_string|&quot;sample[%d] = %d&bslash;n&quot;
comma
id|i
comma
id|header-&gt;hdr.ms.SampleNumber
(braket
id|i
)braket
)paren
suffix:semicolon
id|munge_int32
(paren
id|header-&gt;hdr.ms.SampleNumber
(braket
id|i
)braket
comma
op_amp
id|msample_hdr
(braket
l_int|3
op_plus
(paren
id|i
op_star
l_int|2
)paren
)braket
comma
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* Need a hack here to pass in the number of bytes&n;&t;   to be written to the synth. This is ugly, and perhaps&n;&t;   one day, I&squot;ll fix it.&n;&t;*/
r_if
c_cond
(paren
id|snd_wavefront_cmd
(paren
id|dev
comma
id|WFC_DOWNLOAD_MULTISAMPLE
comma
(paren
r_int
r_char
op_star
)paren
(paren
r_int
)paren
(paren
(paren
id|num_samples
op_star
l_int|2
)paren
op_plus
l_int|3
)paren
comma
id|msample_hdr
)paren
)paren
(brace
id|snd_printk
(paren
l_string|&quot;download of multisample failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|dev-&gt;sample_status
(braket
id|header-&gt;number
)braket
op_assign
(paren
id|WF_SLOT_FILLED
op_or
id|WF_ST_MULTISAMPLE
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_fetch_multisample
id|wavefront_fetch_multisample
(paren
id|snd_wavefront_t
op_star
id|dev
comma
id|wavefront_patch_info
op_star
id|header
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|log_ns
(braket
l_int|1
)braket
suffix:semicolon
r_int
r_char
id|number
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|num_samples
suffix:semicolon
id|munge_int32
(paren
id|header-&gt;number
comma
id|number
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|snd_wavefront_cmd
(paren
id|dev
comma
id|WFC_UPLOAD_MULTISAMPLE
comma
id|log_ns
comma
id|number
)paren
)paren
(brace
id|snd_printk
(paren
l_string|&quot;upload multisample failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|DPRINT
(paren
id|WF_DEBUG_DATA
comma
l_string|&quot;msample %d has %d samples&bslash;n&quot;
comma
id|header-&gt;number
comma
id|log_ns
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|header-&gt;hdr.ms.NumberOfSamples
op_assign
id|log_ns
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* get the number of samples ... */
id|num_samples
op_assign
(paren
l_int|1
op_lshift
id|log_ns
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_samples
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
id|d
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
op_assign
id|wavefront_read
(paren
id|dev
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|snd_printk
(paren
l_string|&quot;upload multisample failed &quot;
l_string|&quot;during sample loop.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|d
(braket
l_int|0
)braket
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
op_assign
id|wavefront_read
(paren
id|dev
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|snd_printk
(paren
l_string|&quot;upload multisample failed &quot;
l_string|&quot;during sample loop.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|d
(braket
l_int|1
)braket
op_assign
id|val
suffix:semicolon
id|header-&gt;hdr.ms.SampleNumber
(braket
id|i
)braket
op_assign
id|demunge_int32
(paren
(paren
r_int
r_char
op_star
)paren
id|d
comma
l_int|2
)paren
suffix:semicolon
id|DPRINT
(paren
id|WF_DEBUG_DATA
comma
l_string|&quot;msample sample[%d] = %d&bslash;n&quot;
comma
id|i
comma
id|header-&gt;hdr.ms.SampleNumber
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_send_drum
id|wavefront_send_drum
(paren
id|snd_wavefront_t
op_star
id|dev
comma
id|wavefront_patch_info
op_star
id|header
)paren
(brace
r_int
r_char
id|drumbuf
(braket
id|WF_DRUM_BYTES
)braket
suffix:semicolon
id|wavefront_drum
op_star
id|drum
op_assign
op_amp
id|header-&gt;hdr.d
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DPRINT
(paren
id|WF_DEBUG_LOAD_PATCH
comma
l_string|&quot;downloading edrum for MIDI &quot;
l_string|&quot;note %d, patch = %d&bslash;n&quot;
comma
id|header-&gt;number
comma
id|drum-&gt;PatchNumber
)paren
suffix:semicolon
id|drumbuf
(braket
l_int|0
)braket
op_assign
id|header-&gt;number
op_amp
l_int|0x7f
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|munge_int32
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|drum
)paren
(braket
id|i
)braket
comma
op_amp
id|drumbuf
(braket
l_int|1
op_plus
(paren
id|i
op_star
l_int|2
)paren
)braket
comma
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|snd_wavefront_cmd
(paren
id|dev
comma
id|WFC_DOWNLOAD_EDRUM_PROGRAM
comma
l_int|NULL
comma
id|drumbuf
)paren
)paren
(brace
id|snd_printk
(paren
l_string|&quot;download drum failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_find_free_sample
id|wavefront_find_free_sample
(paren
id|snd_wavefront_t
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_MAX_SAMPLE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;sample_status
(braket
id|i
)braket
op_amp
id|WF_SLOT_FILLED
)paren
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
)brace
id|snd_printk
(paren
l_string|&quot;no free sample slots!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_int
id|wavefront_find_free_patch
(paren
id|snd_wavefront_t
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|WF_MAX_PATCH
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;patch_status
(braket
id|i
)braket
op_amp
id|WF_SLOT_FILLED
)paren
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
)brace
id|snd_printk
(paren
l_string|&quot;no free patch slots!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
r_static
r_int
DECL|function|wavefront_load_patch
id|wavefront_load_patch
(paren
id|snd_wavefront_t
op_star
id|dev
comma
r_const
r_char
id|__user
op_star
id|addr
)paren
(brace
id|wavefront_patch_info
id|header
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|header
comma
id|addr
comma
r_sizeof
(paren
id|wavefront_patch_info
)paren
op_minus
r_sizeof
(paren
id|wavefront_any
)paren
)paren
)paren
(brace
id|snd_printk
(paren
l_string|&quot;bad address for load patch.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EFAULT
)paren
suffix:semicolon
)brace
id|DPRINT
(paren
id|WF_DEBUG_LOAD_PATCH
comma
l_string|&quot;download &quot;
l_string|&quot;Sample type: %d &quot;
l_string|&quot;Sample number: %d &quot;
l_string|&quot;Sample size: %d&bslash;n&quot;
comma
id|header.subkey
comma
id|header.number
comma
id|header.size
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|header.subkey
)paren
(brace
r_case
id|WF_ST_SAMPLE
suffix:colon
multiline_comment|/* sample or sample_header, based on patch-&gt;size */
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|header.hdr.s
comma
id|header.hdrptr
comma
r_sizeof
(paren
id|wavefront_sample
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|wavefront_send_sample
(paren
id|dev
comma
op_amp
id|header
comma
id|header.dataptr
comma
l_int|0
)paren
suffix:semicolon
r_case
id|WF_ST_MULTISAMPLE
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|header.hdr.s
comma
id|header.hdrptr
comma
r_sizeof
(paren
id|wavefront_multisample
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|wavefront_send_multisample
(paren
id|dev
comma
op_amp
id|header
)paren
suffix:semicolon
r_case
id|WF_ST_ALIAS
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|header.hdr.a
comma
id|header.hdrptr
comma
r_sizeof
(paren
id|wavefront_alias
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|wavefront_send_alias
(paren
id|dev
comma
op_amp
id|header
)paren
suffix:semicolon
r_case
id|WF_ST_DRUM
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|header.hdr.d
comma
id|header.hdrptr
comma
r_sizeof
(paren
id|wavefront_drum
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|wavefront_send_drum
(paren
id|dev
comma
op_amp
id|header
)paren
suffix:semicolon
r_case
id|WF_ST_PATCH
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|header.hdr.p
comma
id|header.hdrptr
comma
r_sizeof
(paren
id|wavefront_patch
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|wavefront_send_patch
(paren
id|dev
comma
op_amp
id|header
)paren
suffix:semicolon
r_case
id|WF_ST_PROGRAM
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|header.hdr.pr
comma
id|header.hdrptr
comma
r_sizeof
(paren
id|wavefront_program
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|wavefront_send_program
(paren
id|dev
comma
op_amp
id|header
)paren
suffix:semicolon
r_default
suffix:colon
id|snd_printk
(paren
l_string|&quot;unknown patch type %d.&bslash;n&quot;
comma
id|header.subkey
)paren
suffix:semicolon
r_return
op_minus
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/***********************************************************************&n;WaveFront: hardware-dependent interface&n;***********************************************************************/
r_static
r_void
DECL|function|process_sample_hdr
id|process_sample_hdr
(paren
id|u8
op_star
id|buf
)paren
(brace
id|wavefront_sample
id|s
suffix:semicolon
id|u8
op_star
id|ptr
suffix:semicolon
id|ptr
op_assign
id|buf
suffix:semicolon
multiline_comment|/* The board doesn&squot;t send us an exact copy of a &quot;wavefront_sample&quot;&n;&t;   in response to an Upload Sample Header command. Instead, we &n;&t;   have to convert the data format back into our data structure,&n;&t;   just as in the Download Sample command, where we have to do&n;&t;   something very similar in the reverse direction.&n;&t;*/
op_star
(paren
(paren
id|u32
op_star
)paren
op_amp
id|s.sampleStartOffset
)paren
op_assign
id|demunge_int32
(paren
id|ptr
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|4
suffix:semicolon
op_star
(paren
(paren
id|u32
op_star
)paren
op_amp
id|s.loopStartOffset
)paren
op_assign
id|demunge_int32
(paren
id|ptr
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|4
suffix:semicolon
op_star
(paren
(paren
id|u32
op_star
)paren
op_amp
id|s.loopEndOffset
)paren
op_assign
id|demunge_int32
(paren
id|ptr
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|4
suffix:semicolon
op_star
(paren
(paren
id|u32
op_star
)paren
op_amp
id|s.sampleEndOffset
)paren
op_assign
id|demunge_int32
(paren
id|ptr
comma
l_int|4
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|4
suffix:semicolon
op_star
(paren
(paren
id|u32
op_star
)paren
op_amp
id|s.FrequencyBias
)paren
op_assign
id|demunge_int32
(paren
id|ptr
comma
l_int|3
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|3
suffix:semicolon
id|s.SampleResolution
op_assign
op_star
id|ptr
op_amp
l_int|0x3
suffix:semicolon
id|s.Loop
op_assign
op_star
id|ptr
op_amp
l_int|0x8
suffix:semicolon
id|s.Bidirectional
op_assign
op_star
id|ptr
op_amp
l_int|0x10
suffix:semicolon
id|s.Reverse
op_assign
op_star
id|ptr
op_amp
l_int|0x40
suffix:semicolon
multiline_comment|/* Now copy it back to where it came from */
id|memcpy
(paren
id|buf
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|s
comma
r_sizeof
(paren
id|wavefront_sample
)paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|wavefront_synth_control
id|wavefront_synth_control
(paren
id|snd_wavefront_card_t
op_star
id|acard
comma
id|wavefront_control
op_star
id|wc
)paren
(brace
id|snd_wavefront_t
op_star
id|dev
op_assign
op_amp
id|acard-&gt;wavefront
suffix:semicolon
r_int
r_char
id|patchnumbuf
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DPRINT
(paren
id|WF_DEBUG_CMD
comma
l_string|&quot;synth control with &quot;
l_string|&quot;cmd 0x%x&bslash;n&quot;
comma
id|wc-&gt;cmd
)paren
suffix:semicolon
multiline_comment|/* Pre-handling of or for various commands */
r_switch
c_cond
(paren
id|wc-&gt;cmd
)paren
(brace
r_case
id|WFC_DISABLE_INTERRUPTS
suffix:colon
id|snd_printk
(paren
l_string|&quot;interrupts disabled.&bslash;n&quot;
)paren
suffix:semicolon
id|outb
(paren
l_int|0x80
op_or
l_int|0x20
comma
id|dev-&gt;control_port
)paren
suffix:semicolon
id|dev-&gt;interrupts_are_midi
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_ENABLE_INTERRUPTS
suffix:colon
id|snd_printk
(paren
l_string|&quot;interrupts enabled.&bslash;n&quot;
)paren
suffix:semicolon
id|outb
(paren
l_int|0x80
op_or
l_int|0x40
op_or
l_int|0x20
comma
id|dev-&gt;control_port
)paren
suffix:semicolon
id|dev-&gt;interrupts_are_midi
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_INTERRUPT_STATUS
suffix:colon
id|wc-&gt;rbuf
(braket
l_int|0
)braket
op_assign
id|dev-&gt;interrupts_are_midi
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_ROMSAMPLES_RDONLY
suffix:colon
id|dev-&gt;rom_samples_rdonly
op_assign
id|wc-&gt;wbuf
(braket
l_int|0
)braket
suffix:semicolon
id|wc-&gt;status
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_IDENTIFY_SLOT_TYPE
suffix:colon
id|i
op_assign
id|wc-&gt;wbuf
(braket
l_int|0
)braket
op_or
(paren
id|wc-&gt;wbuf
(braket
l_int|1
)braket
op_lshift
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
op_logical_or
id|i
op_ge
id|WF_MAX_SAMPLE
)paren
(brace
id|snd_printk
(paren
l_string|&quot;invalid slot ID %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|wc-&gt;status
op_assign
id|EINVAL
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|wc-&gt;rbuf
(braket
l_int|0
)braket
op_assign
id|dev-&gt;sample_status
(braket
id|i
)braket
suffix:semicolon
id|wc-&gt;status
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_DEBUG_DRIVER
suffix:colon
id|dev-&gt;debug
op_assign
id|wc-&gt;wbuf
(braket
l_int|0
)braket
suffix:semicolon
id|snd_printk
(paren
l_string|&quot;debug = 0x%x&bslash;n&quot;
comma
id|dev-&gt;debug
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_UPLOAD_PATCH
suffix:colon
id|munge_int32
(paren
op_star
(paren
(paren
id|u32
op_star
)paren
id|wc-&gt;wbuf
)paren
comma
id|patchnumbuf
comma
l_int|2
)paren
suffix:semicolon
id|memcpy
(paren
id|wc-&gt;wbuf
comma
id|patchnumbuf
comma
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_UPLOAD_MULTISAMPLE
suffix:colon
multiline_comment|/* multisamples have to be handled differently, and&n;&t;&t;   cannot be dealt with properly by snd_wavefront_cmd() alone.&n;&t;&t;*/
id|wc-&gt;status
op_assign
id|wavefront_fetch_multisample
(paren
id|dev
comma
(paren
id|wavefront_patch_info
op_star
)paren
id|wc-&gt;rbuf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|WFC_UPLOAD_SAMPLE_ALIAS
suffix:colon
id|snd_printk
(paren
l_string|&quot;support for sample alias upload &quot;
l_string|&quot;being considered.&bslash;n&quot;
)paren
suffix:semicolon
id|wc-&gt;status
op_assign
id|EINVAL
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|wc-&gt;status
op_assign
id|snd_wavefront_cmd
(paren
id|dev
comma
id|wc-&gt;cmd
comma
id|wc-&gt;rbuf
comma
id|wc-&gt;wbuf
)paren
suffix:semicolon
multiline_comment|/* Post-handling of certain commands.&n;&n;&t;   In particular, if the command was an upload, demunge the data&n;&t;   so that the user-level doesn&squot;t have to think about it.&n;&t;*/
r_if
c_cond
(paren
id|wc-&gt;status
op_eq
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|wc-&gt;cmd
)paren
(brace
multiline_comment|/* intercept any freemem requests so that we know&n;&t;&t;&t;   we are always current with the user-level view&n;&t;&t;&t;   of things.&n;&t;&t;&t;*/
r_case
id|WFC_REPORT_FREE_MEMORY
suffix:colon
id|dev-&gt;freemem
op_assign
id|demunge_int32
(paren
id|wc-&gt;rbuf
comma
l_int|4
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_UPLOAD_PATCH
suffix:colon
id|demunge_buf
(paren
id|wc-&gt;rbuf
comma
id|wc-&gt;rbuf
comma
id|WF_PATCH_BYTES
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_UPLOAD_PROGRAM
suffix:colon
id|demunge_buf
(paren
id|wc-&gt;rbuf
comma
id|wc-&gt;rbuf
comma
id|WF_PROGRAM_BYTES
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_UPLOAD_EDRUM_PROGRAM
suffix:colon
id|demunge_buf
(paren
id|wc-&gt;rbuf
comma
id|wc-&gt;rbuf
comma
id|WF_DRUM_BYTES
op_minus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_UPLOAD_SAMPLE_HEADER
suffix:colon
id|process_sample_hdr
(paren
id|wc-&gt;rbuf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_UPLOAD_SAMPLE_ALIAS
suffix:colon
id|snd_printk
(paren
l_string|&quot;support for &quot;
l_string|&quot;sample aliases still &quot;
l_string|&quot;being considered.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_VMIDI_OFF
suffix:colon
id|snd_wavefront_midi_disable_virtual
(paren
id|acard
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WFC_VMIDI_ON
suffix:colon
id|snd_wavefront_midi_enable_virtual
(paren
id|acard
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|snd_wavefront_synth_open
id|snd_wavefront_synth_open
(paren
id|snd_hwdep_t
op_star
id|hw
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|try_module_get
c_func
(paren
id|hw-&gt;card-&gt;module
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|file-&gt;private_data
op_assign
id|hw
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|snd_wavefront_synth_release
id|snd_wavefront_synth_release
(paren
id|snd_hwdep_t
op_star
id|hw
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|module_put
c_func
(paren
id|hw-&gt;card-&gt;module
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|snd_wavefront_synth_ioctl
id|snd_wavefront_synth_ioctl
(paren
id|snd_hwdep_t
op_star
id|hw
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|snd_card_t
op_star
id|card
suffix:semicolon
id|snd_wavefront_t
op_star
id|dev
suffix:semicolon
id|snd_wavefront_card_t
op_star
id|acard
suffix:semicolon
id|wavefront_control
id|wc
suffix:semicolon
r_void
id|__user
op_star
id|argp
op_assign
(paren
r_void
id|__user
op_star
)paren
id|arg
suffix:semicolon
id|card
op_assign
(paren
id|snd_card_t
op_star
)paren
id|hw-&gt;card
suffix:semicolon
id|snd_assert
c_func
(paren
id|card
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENODEV
)paren
suffix:semicolon
id|snd_assert
c_func
(paren
id|card-&gt;private_data
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENODEV
)paren
suffix:semicolon
id|acard
op_assign
id|card-&gt;private_data
suffix:semicolon
id|dev
op_assign
op_amp
id|acard-&gt;wavefront
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|WFCTL_LOAD_SPP
suffix:colon
r_if
c_cond
(paren
id|wavefront_load_patch
(paren
id|dev
comma
id|argp
)paren
op_ne
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|WFCTL_WFCMD
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|wc
comma
id|argp
comma
r_sizeof
(paren
id|wc
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_synth_control
(paren
id|acard
comma
op_amp
id|wc
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
(paren
id|argp
comma
op_amp
id|wc
comma
r_sizeof
(paren
id|wc
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/***********************************************************************/
multiline_comment|/*  WaveFront: interface for card-level wavefront module               */
multiline_comment|/***********************************************************************/
r_void
DECL|function|snd_wavefront_internal_interrupt
id|snd_wavefront_internal_interrupt
(paren
id|snd_wavefront_card_t
op_star
id|card
)paren
(brace
id|snd_wavefront_t
op_star
id|dev
op_assign
op_amp
id|card-&gt;wavefront
suffix:semicolon
multiline_comment|/*&n;&t;   Some comments on interrupts. I attempted a version of this&n;&t;   driver that used interrupts throughout the code instead of&n;&t;   doing busy and/or sleep-waiting. Alas, it appears that once&n;&t;   the Motorola firmware is downloaded, the card *never*&n;&t;   generates an RX interrupt. These are successfully generated&n;&t;   during firmware loading, and after that wavefront_status()&n;&t;   reports that an interrupt is pending on the card from time&n;&t;   to time, but it never seems to be delivered to this&n;&t;   driver. Note also that wavefront_status() continues to&n;&t;   report that RX interrupts are enabled, suggesting that I&n;&t;   didn&squot;t goof up and disable them by mistake.&n;&n;&t;   Thus, I stepped back to a prior version of&n;&t;   wavefront_wait(), the only place where this really&n;&t;   matters. Its sad, but I&squot;ve looked through the code to check&n;&t;   on things, and I really feel certain that the Motorola&n;&t;   firmware prevents RX-ready interrupts.&n;&t;*/
r_if
c_cond
(paren
(paren
id|wavefront_status
c_func
(paren
id|dev
)paren
op_amp
(paren
id|STAT_INTR_READ
op_or
id|STAT_INTR_WRITE
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|dev-&gt;irq_lock
)paren
suffix:semicolon
id|dev-&gt;irq_ok
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;irq_cnt
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dev-&gt;irq_lock
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|dev-&gt;interrupt_sleeper
)paren
suffix:semicolon
)brace
multiline_comment|/* STATUS REGISTER &n;&n;0 Host Rx Interrupt Enable (1=Enabled)&n;1 Host Rx Register Full (1=Full)&n;2 Host Rx Interrupt Pending (1=Interrupt)&n;3 Unused&n;4 Host Tx Interrupt (1=Enabled)&n;5 Host Tx Register empty (1=Empty)&n;6 Host Tx Interrupt Pending (1=Interrupt)&n;7 Unused&n;*/
r_static
r_int
id|__init
DECL|function|snd_wavefront_interrupt_bits
id|snd_wavefront_interrupt_bits
(paren
r_int
id|irq
)paren
(brace
r_int
id|bits
suffix:semicolon
r_switch
c_cond
(paren
id|irq
)paren
(brace
r_case
l_int|9
suffix:colon
id|bits
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|bits
op_assign
l_int|0x08
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
suffix:colon
id|bits
op_assign
l_int|0x10
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|15
suffix:colon
id|bits
op_assign
l_int|0x18
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|snd_printk
(paren
l_string|&quot;invalid IRQ %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
id|bits
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|bits
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|wavefront_should_cause_interrupt
id|wavefront_should_cause_interrupt
(paren
id|snd_wavefront_t
op_star
id|dev
comma
r_int
id|val
comma
r_int
id|port
comma
r_int
id|timeout
)paren
(brace
id|wait_queue_t
id|wait
suffix:semicolon
id|init_waitqueue_entry
c_func
(paren
op_amp
id|wait
comma
id|current
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|dev-&gt;irq_lock
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|dev-&gt;interrupt_sleeper
comma
op_amp
id|wait
)paren
suffix:semicolon
id|dev-&gt;irq_ok
op_assign
l_int|0
suffix:semicolon
id|outb
(paren
id|val
comma
id|port
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|dev-&gt;irq_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|timeout
op_assign
id|schedule_timeout
c_func
(paren
id|timeout
)paren
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq_ok
)paren
r_return
suffix:semicolon
)brace
)brace
r_static
r_int
id|__init
DECL|function|wavefront_reset_to_cleanliness
id|wavefront_reset_to_cleanliness
(paren
id|snd_wavefront_t
op_star
id|dev
)paren
(brace
r_int
id|bits
suffix:semicolon
r_int
id|hwv
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* IRQ already checked */
id|bits
op_assign
id|snd_wavefront_interrupt_bits
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
multiline_comment|/* try reset of port */
id|outb
(paren
l_int|0x0
comma
id|dev-&gt;control_port
)paren
suffix:semicolon
multiline_comment|/* At this point, the board is in reset, and the H/W initialization&n;&t;   register is accessed at the same address as the data port.&n;     &n;&t;   Bit 7 - Enable IRQ Driver&t;&n;&t;   0 - Tri-state the Wave-Board drivers for the PC Bus IRQs&n;&t;   1 - Enable IRQ selected by bits 5:3 to be driven onto the PC Bus.&n;     &n;&t;   Bit 6 - MIDI Interface Select&n;&n;&t;   0 - Use the MIDI Input from the 26-pin WaveBlaster&n;&t;   compatible header as the serial MIDI source&n;&t;   1 - Use the MIDI Input from the 9-pin D connector as the&n;&t;   serial MIDI source.&n;     &n;&t;   Bits 5:3 - IRQ Selection&n;&t;   0 0 0 - IRQ 2/9&n;&t;   0 0 1 - IRQ 5&n;&t;   0 1 0 - IRQ 12&n;&t;   0 1 1 - IRQ 15&n;&t;   1 0 0 - Reserved&n;&t;   1 0 1 - Reserved&n;&t;   1 1 0 - Reserved&n;&t;   1 1 1 - Reserved&n;     &n;&t;   Bits 2:1 - Reserved&n;&t;   Bit 0 - Disable Boot ROM&n;&t;   0 - memory accesses to 03FC30-03FFFFH utilize the internal Boot ROM&n;&t;   1 - memory accesses to 03FC30-03FFFFH are directed to external &n;&t;   storage.&n;     &n;&t;*/
multiline_comment|/* configure hardware: IRQ, enable interrupts, &n;&t;   plus external 9-pin MIDI interface selected&n;&t;*/
id|outb
(paren
l_int|0x80
op_or
l_int|0x40
op_or
id|bits
comma
id|dev-&gt;data_port
)paren
suffix:semicolon
multiline_comment|/* CONTROL REGISTER&n;&n;&t;   0 Host Rx Interrupt Enable (1=Enabled)      0x1&n;&t;   1 Unused                                    0x2&n;&t;   2 Unused                                    0x4&n;&t;   3 Unused                                    0x8&n;&t;   4 Host Tx Interrupt Enable                 0x10&n;&t;   5 Mute (0=Mute; 1=Play)                    0x20&n;&t;   6 Master Interrupt Enable (1=Enabled)      0x40&n;&t;   7 Master Reset (0=Reset; 1=Run)            0x80&n;&n;&t;   Take us out of reset, mute output, master + TX + RX interrupts on.&n;&t;   &n;&t;   We&squot;ll get an interrupt presumably to tell us that the TX&n;&t;   register is clear.&n;&t;*/
id|wavefront_should_cause_interrupt
c_func
(paren
id|dev
comma
l_int|0x80
op_or
l_int|0x40
op_or
l_int|0x10
op_or
l_int|0x1
comma
id|dev-&gt;control_port
comma
(paren
id|reset_time
op_star
id|HZ
)paren
op_div
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Note: data port is now the data port, not the h/w initialization&n;&t;   port.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;irq_ok
)paren
(brace
id|snd_printk
(paren
l_string|&quot;intr not received after h/w un-reset.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
multiline_comment|/* Note: data port is now the data port, not the h/w initialization&n;&t;   port.&n;&n;&t;   At this point, only &quot;HW VERSION&quot; or &quot;DOWNLOAD OS&quot; commands&n;&t;   will work. So, issue one of them, and wait for TX&n;&t;   interrupt. This can take a *long* time after a cold boot,&n;&t;   while the ISC ROM does its RAM test. The SDK says up to 4&n;&t;   seconds - with 12MB of RAM on a Tropez+, it takes a lot&n;&t;   longer than that (~16secs). Note that the card understands&n;&t;   the difference between a warm and a cold boot, so&n;&t;   subsequent ISC2115 reboots (say, caused by module&n;&t;   reloading) will get through this much faster.&n;&n;&t;   XXX Interesting question: why is no RX interrupt received first ?&n;&t;*/
id|wavefront_should_cause_interrupt
c_func
(paren
id|dev
comma
id|WFC_HARDWARE_VERSION
comma
id|dev-&gt;data_port
comma
id|ramcheck_time
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;irq_ok
)paren
(brace
id|snd_printk
(paren
l_string|&quot;post-RAM-check interrupt not received.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|wavefront_wait
(paren
id|dev
comma
id|STAT_CAN_READ
)paren
)paren
(brace
id|snd_printk
(paren
l_string|&quot;no response to HW version cmd.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|hwv
(braket
l_int|0
)braket
op_assign
id|wavefront_read
(paren
id|dev
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|snd_printk
(paren
l_string|&quot;board not responding correctly.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwv
(braket
l_int|0
)braket
op_eq
l_int|0xFF
)paren
(brace
multiline_comment|/* NAK */
multiline_comment|/* Board&squot;s RAM test failed. Try to read error code,&n;&t;&t;   and tell us about it either way.&n;&t;&t;*/
r_if
c_cond
(paren
(paren
id|hwv
(braket
l_int|0
)braket
op_assign
id|wavefront_read
(paren
id|dev
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|snd_printk
(paren
l_string|&quot;on-board RAM test failed &quot;
l_string|&quot;(bad error code).&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|snd_printk
(paren
l_string|&quot;on-board RAM test failed &quot;
l_string|&quot;(error code: 0x%x).&bslash;n&quot;
comma
id|hwv
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_goto
id|gone_bad
suffix:semicolon
)brace
multiline_comment|/* We&squot;re OK, just get the next byte of the HW version response */
r_if
c_cond
(paren
(paren
id|hwv
(braket
l_int|1
)braket
op_assign
id|wavefront_read
(paren
id|dev
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|snd_printk
(paren
l_string|&quot;incorrect h/w response.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
id|snd_printk
(paren
l_string|&quot;hardware version %d.%d&bslash;n&quot;
comma
id|hwv
(braket
l_int|0
)braket
comma
id|hwv
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|gone_bad
suffix:colon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/syscalls.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
r_static
r_int
id|__init
DECL|function|wavefront_download_firmware
id|wavefront_download_firmware
(paren
id|snd_wavefront_t
op_star
id|dev
comma
r_char
op_star
id|path
)paren
(brace
r_int
r_char
id|section
(braket
id|WF_SECTION_MAX
)braket
suffix:semicolon
r_int
r_char
id|section_length
suffix:semicolon
multiline_comment|/* yes, just a char; max value is WF_SECTION_MAX */
r_int
id|section_cnt_downloaded
op_assign
l_int|0
suffix:semicolon
r_int
id|fd
suffix:semicolon
r_int
id|c
suffix:semicolon
r_int
id|i
suffix:semicolon
id|mm_segment_t
id|fs
suffix:semicolon
multiline_comment|/* This tries to be a bit cleverer than the stuff Alan Cox did for&n;&t;   the generic sound firmware, in that it actually knows&n;&t;   something about the structure of the Motorola firmware. In&n;&t;   particular, it uses a version that has been stripped of the&n;&t;   20K of useless header information, and had section lengths&n;&t;   added, making it possible to load the entire OS without any&n;&t;   [kv]malloc() activity, since the longest entity we ever read is&n;&t;   42 bytes (well, WF_SECTION_MAX) long.&n;&t;*/
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
(paren
id|get_ds
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fd
op_assign
id|sys_open
(paren
id|path
comma
l_int|0
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
(brace
id|snd_printk
(paren
l_string|&quot;Unable to load &bslash;&quot;%s&bslash;&quot;.&bslash;n&quot;
comma
id|path
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
id|x
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
op_assign
id|sys_read
(paren
id|fd
comma
op_amp
id|section_length
comma
r_sizeof
(paren
id|section_length
)paren
)paren
)paren
op_ne
r_sizeof
(paren
id|section_length
)paren
)paren
(brace
id|snd_printk
(paren
l_string|&quot;firmware read error.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
r_if
c_cond
(paren
id|section_length
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|section_length
template_param
id|WF_SECTION_MAX
)paren
(brace
id|snd_printk
(paren
l_string|&quot;invalid firmware section length %d&bslash;n&quot;
comma
id|section_length
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sys_read
(paren
id|fd
comma
id|section
comma
id|section_length
)paren
op_ne
id|section_length
)paren
(brace
id|snd_printk
(paren
l_string|&quot;firmware section &quot;
l_string|&quot;read error.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
multiline_comment|/* Send command */
r_if
c_cond
(paren
id|wavefront_write
(paren
id|dev
comma
id|WFC_DOWNLOAD_OS
)paren
)paren
(brace
r_goto
id|failure
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|section_length
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|wavefront_write
(paren
id|dev
comma
id|section
(braket
id|i
)braket
)paren
)paren
(brace
r_goto
id|failure
suffix:semicolon
)brace
)brace
multiline_comment|/* get ACK */
r_if
c_cond
(paren
id|wavefront_wait
(paren
id|dev
comma
id|STAT_CAN_READ
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|c
op_assign
id|inb
(paren
id|dev-&gt;data_port
)paren
)paren
op_ne
id|WF_ACK
)paren
(brace
id|snd_printk
(paren
l_string|&quot;download &quot;
l_string|&quot;of section #%d not &quot;
l_string|&quot;acknowledged, ack = 0x%x&bslash;n&quot;
comma
id|section_cnt_downloaded
op_plus
l_int|1
comma
id|c
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
)brace
r_else
(brace
id|snd_printk
(paren
l_string|&quot;time out for firmware ACK.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
)brace
id|sys_close
(paren
id|fd
)paren
suffix:semicolon
id|set_fs
(paren
id|fs
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|failure
suffix:colon
id|sys_close
(paren
id|fd
)paren
suffix:semicolon
id|set_fs
(paren
id|fs
)paren
suffix:semicolon
id|snd_printk
(paren
l_string|&quot;firmware download failed!!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|wavefront_do_reset
id|wavefront_do_reset
(paren
id|snd_wavefront_t
op_star
id|dev
)paren
(brace
r_char
id|voices
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_reset_to_cleanliness
(paren
id|dev
)paren
)paren
(brace
id|snd_printk
(paren
l_string|&quot;hw reset failed.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;israw
)paren
(brace
r_if
c_cond
(paren
id|wavefront_download_firmware
(paren
id|dev
comma
id|ospath
)paren
)paren
(brace
r_goto
id|gone_bad
suffix:semicolon
)brace
id|dev-&gt;israw
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Wait for the OS to get running. The protocol for&n;&t;&t;   this is non-obvious, and was determined by&n;&t;&t;   using port-IO tracing in DOSemu and some&n;&t;&t;   experimentation here.&n;&t;&t;   &n;&t;&t;   Rather than using timed waits, use interrupts creatively.&n;&t;&t;*/
id|wavefront_should_cause_interrupt
(paren
id|dev
comma
id|WFC_NOOP
comma
id|dev-&gt;data_port
comma
(paren
id|osrun_time
op_star
id|HZ
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;irq_ok
)paren
(brace
id|snd_printk
(paren
l_string|&quot;no post-OS interrupt.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
multiline_comment|/* Now, do it again ! */
id|wavefront_should_cause_interrupt
(paren
id|dev
comma
id|WFC_NOOP
comma
id|dev-&gt;data_port
comma
(paren
l_int|10
op_star
id|HZ
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;irq_ok
)paren
(brace
id|snd_printk
(paren
l_string|&quot;no post-OS interrupt(2).&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
multiline_comment|/* OK, no (RX/TX) interrupts any more, but leave mute&n;&t;&t;   in effect. &n;&t;&t;*/
id|outb
(paren
l_int|0x80
op_or
l_int|0x40
comma
id|dev-&gt;control_port
)paren
suffix:semicolon
)brace
multiline_comment|/* SETUPSND.EXE asks for sample memory config here, but since i&n;&t;   have no idea how to interpret the result, we&squot;ll forget&n;&t;   about it.&n;&t;*/
r_if
c_cond
(paren
(paren
id|dev-&gt;freemem
op_assign
id|wavefront_freemem
(paren
id|dev
)paren
)paren
OL
l_int|0
)paren
(brace
r_goto
id|gone_bad
suffix:semicolon
)brace
id|snd_printk
(paren
l_string|&quot;available DRAM %dk&bslash;n&quot;
comma
id|dev-&gt;freemem
op_div
l_int|1024
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wavefront_write
(paren
id|dev
comma
l_int|0xf0
)paren
op_logical_or
id|wavefront_write
(paren
id|dev
comma
l_int|1
)paren
op_logical_or
(paren
id|wavefront_read
(paren
id|dev
)paren
OL
l_int|0
)paren
)paren
(brace
id|dev-&gt;debug
op_assign
l_int|0
suffix:semicolon
id|snd_printk
(paren
l_string|&quot;MPU emulation mode not set.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
id|voices
(braket
l_int|0
)braket
op_assign
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|snd_wavefront_cmd
(paren
id|dev
comma
id|WFC_SET_NVOICES
comma
l_int|NULL
comma
id|voices
)paren
)paren
(brace
id|snd_printk
(paren
l_string|&quot;cannot set number of voices to 32.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gone_bad
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|gone_bad
suffix:colon
multiline_comment|/* reset that sucker so that it doesn&squot;t bother us. */
id|outb
(paren
l_int|0x0
comma
id|dev-&gt;control_port
)paren
suffix:semicolon
id|dev-&gt;interrupts_are_midi
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_int
id|__init
DECL|function|snd_wavefront_start
id|snd_wavefront_start
(paren
id|snd_wavefront_t
op_star
id|dev
)paren
(brace
r_int
id|samples_are_from_rom
suffix:semicolon
multiline_comment|/* IMPORTANT: assumes that snd_wavefront_detect() and/or&n;&t;   wavefront_reset_to_cleanliness() has already been called &n;&t;*/
r_if
c_cond
(paren
id|dev-&gt;israw
)paren
(brace
id|samples_are_from_rom
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* XXX is this always true ? */
id|samples_are_from_rom
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;israw
op_logical_or
id|fx_raw
)paren
(brace
r_if
c_cond
(paren
id|wavefront_do_reset
(paren
id|dev
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Check for FX device, present only on Tropez+ */
id|dev-&gt;has_fx
op_assign
(paren
id|snd_wavefront_fx_detect
(paren
id|dev
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;has_fx
op_logical_and
id|fx_raw
)paren
(brace
id|snd_wavefront_fx_start
(paren
id|dev
)paren
suffix:semicolon
)brace
id|wavefront_get_sample_status
(paren
id|dev
comma
id|samples_are_from_rom
)paren
suffix:semicolon
id|wavefront_get_program_status
(paren
id|dev
)paren
suffix:semicolon
id|wavefront_get_patch_status
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Start normal operation: unreset, master interrupt enabled, no mute&n;&t;*/
id|outb
(paren
l_int|0x80
op_or
l_int|0x40
op_or
l_int|0x20
comma
id|dev-&gt;control_port
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_int
id|__init
DECL|function|snd_wavefront_detect
id|snd_wavefront_detect
(paren
id|snd_wavefront_card_t
op_star
id|card
)paren
(brace
r_int
r_char
id|rbuf
(braket
l_int|4
)braket
comma
id|wbuf
(braket
l_int|4
)braket
suffix:semicolon
id|snd_wavefront_t
op_star
id|dev
op_assign
op_amp
id|card-&gt;wavefront
suffix:semicolon
multiline_comment|/* returns zero if a WaveFront card is successfully detected.&n;&t;   negative otherwise.&n;&t;*/
id|dev-&gt;israw
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;has_fx
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;debug
op_assign
id|debug_default
suffix:semicolon
id|dev-&gt;interrupts_are_midi
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;irq_cnt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;rom_samples_rdonly
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|snd_wavefront_cmd
(paren
id|dev
comma
id|WFC_FIRMWARE_VERSION
comma
id|rbuf
comma
id|wbuf
)paren
op_eq
l_int|0
)paren
(brace
id|dev-&gt;fw_version
(braket
l_int|0
)braket
op_assign
id|rbuf
(braket
l_int|0
)braket
suffix:semicolon
id|dev-&gt;fw_version
(braket
l_int|1
)braket
op_assign
id|rbuf
(braket
l_int|1
)braket
suffix:semicolon
id|snd_printk
(paren
l_string|&quot;firmware %d.%d already loaded.&bslash;n&quot;
comma
id|rbuf
(braket
l_int|0
)braket
comma
id|rbuf
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* check that a command actually works */
r_if
c_cond
(paren
id|snd_wavefront_cmd
(paren
id|dev
comma
id|WFC_HARDWARE_VERSION
comma
id|rbuf
comma
id|wbuf
)paren
op_eq
l_int|0
)paren
(brace
id|dev-&gt;hw_version
(braket
l_int|0
)braket
op_assign
id|rbuf
(braket
l_int|0
)braket
suffix:semicolon
id|dev-&gt;hw_version
(braket
l_int|1
)braket
op_assign
id|rbuf
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_else
(brace
id|snd_printk
(paren
l_string|&quot;not raw, but no &quot;
l_string|&quot;hardware version!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|wf_raw
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|snd_printk
(paren
l_string|&quot;reloading firmware as you requested.&bslash;n&quot;
)paren
suffix:semicolon
id|dev-&gt;israw
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|dev-&gt;israw
op_assign
l_int|1
suffix:semicolon
id|snd_printk
(paren
l_string|&quot;no response to firmware probe, assume raw.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
