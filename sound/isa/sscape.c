multiline_comment|/*&n; *   Low-level ALSA driver for the ENSONIQ SoundScape PnP&n; *   Copyright (c) by Chris Rankin&n; *&n; *   This driver was written in part using information obtained from&n; *   the OSS/Free SoundScape driver, written by Hannu Savolainen.&n; *&n; *&n; *   This program is free software; you can redistribute it and/or modify&n; *   it under the terms of the GNU General Public License as published by&n; *   the Free Software Foundation; either version 2 of the License, or&n; *   (at your option) any later version.&n; *&n; *   This program is distributed in the hope that it will be useful,&n; *   but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *   GNU General Public License for more details.&n; *&n; *   You should have received a copy of the GNU General Public License&n; *   along with this program; if not, write to the Free Software&n; *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA&n; */
macro_line|#include &lt;sound/driver.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/pnp.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;sound/core.h&gt;
macro_line|#include &lt;sound/hwdep.h&gt;
macro_line|#include &lt;sound/cs4231.h&gt;
macro_line|#include &lt;sound/mpu401.h&gt;
macro_line|#include &lt;sound/initval.h&gt;
macro_line|#include &lt;sound/sscape_ioctl.h&gt;
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Chris Rankin&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;ENSONIQ SoundScape PnP driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|__devinitdata
r_static
r_int
id|index
(braket
id|SNDRV_CARDS
)braket
id|__devinitdata
op_assign
id|SNDRV_DEFAULT_IDX
suffix:semicolon
DECL|variable|__devinitdata
r_static
r_char
op_star
id|id
(braket
id|SNDRV_CARDS
)braket
id|__devinitdata
op_assign
id|SNDRV_DEFAULT_STR
suffix:semicolon
DECL|variable|__devinitdata
r_static
r_int
id|port
(braket
id|SNDRV_CARDS
)braket
id|__devinitdata
op_assign
(brace
(braket
l_int|0
dot
dot
dot
(paren
id|SNDRV_CARDS
op_minus
l_int|1
)paren
)braket
op_assign
id|SNDRV_AUTO_PORT
)brace
suffix:semicolon
DECL|variable|__devinitdata
r_static
r_int
id|irq
(braket
id|SNDRV_CARDS
)braket
id|__devinitdata
op_assign
id|SNDRV_DEFAULT_IRQ
suffix:semicolon
DECL|variable|__devinitdata
r_static
r_int
id|mpu_irq
(braket
id|SNDRV_CARDS
)braket
id|__devinitdata
op_assign
id|SNDRV_DEFAULT_IRQ
suffix:semicolon
DECL|variable|__devinitdata
r_static
r_int
id|dma
(braket
id|SNDRV_CARDS
)braket
id|__devinitdata
op_assign
id|SNDRV_DEFAULT_DMA
suffix:semicolon
id|module_param_array
c_func
(paren
id|index
comma
r_int
comma
l_int|NULL
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|index
comma
l_string|&quot;Index number for SoundScape soundcard&quot;
)paren
suffix:semicolon
id|module_param_array
c_func
(paren
id|id
comma
id|charp
comma
l_int|NULL
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|id
comma
l_string|&quot;Description for SoundScape card&quot;
)paren
suffix:semicolon
id|module_param_array
c_func
(paren
id|port
comma
r_int
comma
l_int|NULL
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|port
comma
l_string|&quot;Port # for SoundScape driver.&quot;
)paren
suffix:semicolon
id|module_param_array
c_func
(paren
id|irq
comma
r_int
comma
l_int|NULL
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|irq
comma
l_string|&quot;IRQ # for SoundScape driver.&quot;
)paren
suffix:semicolon
id|module_param_array
c_func
(paren
id|mpu_irq
comma
r_int
comma
l_int|NULL
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|mpu_irq
comma
l_string|&quot;MPU401 IRQ # for SoundScape driver.&quot;
)paren
suffix:semicolon
id|module_param_array
c_func
(paren
id|dma
comma
r_int
comma
l_int|NULL
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|dma
comma
l_string|&quot;DMA # for SoundScape driver.&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PNP
DECL|variable|sscape_pnpids
r_static
r_struct
id|pnp_card_device_id
id|sscape_pnpids
(braket
)braket
op_assign
(brace
(brace
dot
id|id
op_assign
l_string|&quot;ENS3081&quot;
comma
dot
id|devs
op_assign
(brace
(brace
l_string|&quot;ENS0000&quot;
)brace
)brace
)brace
comma
(brace
dot
id|id
op_assign
l_string|&quot;&quot;
)brace
multiline_comment|/* end */
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pnp_card
comma
id|sscape_pnpids
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|sscape_card
r_static
id|snd_card_t
op_star
id|sscape_card
(braket
id|SNDRV_CARDS
)braket
suffix:semicolon
DECL|macro|MPU401_IO
mdefine_line|#define MPU401_IO(i)     ((i) + 0)
DECL|macro|MIDI_DATA_IO
mdefine_line|#define MIDI_DATA_IO(i)  ((i) + 0)
DECL|macro|MIDI_CTRL_IO
mdefine_line|#define MIDI_CTRL_IO(i)  ((i) + 1)
DECL|macro|HOST_CTRL_IO
mdefine_line|#define HOST_CTRL_IO(i)  ((i) + 2)
DECL|macro|HOST_DATA_IO
mdefine_line|#define HOST_DATA_IO(i)  ((i) + 3)
DECL|macro|ODIE_ADDR_IO
mdefine_line|#define ODIE_ADDR_IO(i)  ((i) + 4)
DECL|macro|ODIE_DATA_IO
mdefine_line|#define ODIE_DATA_IO(i)  ((i) + 5)
DECL|macro|CODEC_IO
mdefine_line|#define CODEC_IO(i)      ((i) + 8)
DECL|macro|IC_ODIE
mdefine_line|#define IC_ODIE  1
DECL|macro|IC_OPUS
mdefine_line|#define IC_OPUS  2
DECL|macro|RX_READY
mdefine_line|#define RX_READY 0x01
DECL|macro|TX_READY
mdefine_line|#define TX_READY 0x02
DECL|macro|CMD_ACK
mdefine_line|#define CMD_ACK           0x80
DECL|macro|CMD_SET_MIDI_VOL
mdefine_line|#define CMD_SET_MIDI_VOL  0x84
DECL|macro|CMD_GET_MIDI_VOL
mdefine_line|#define CMD_GET_MIDI_VOL  0x85
DECL|macro|CMD_XXX_MIDI_VOL
mdefine_line|#define CMD_XXX_MIDI_VOL  0x86
DECL|macro|CMD_SET_EXTMIDI
mdefine_line|#define CMD_SET_EXTMIDI   0x8a
DECL|macro|CMD_GET_EXTMIDI
mdefine_line|#define CMD_GET_EXTMIDI   0x8b
DECL|macro|CMD_SET_MT32
mdefine_line|#define CMD_SET_MT32      0x8c
DECL|macro|CMD_GET_MT32
mdefine_line|#define CMD_GET_MT32      0x8d
DECL|enum|GA_REG
r_enum
id|GA_REG
(brace
DECL|enumerator|GA_INTSTAT_REG
id|GA_INTSTAT_REG
op_assign
l_int|0
comma
DECL|enumerator|GA_INTENA_REG
id|GA_INTENA_REG
comma
DECL|enumerator|GA_DMAA_REG
id|GA_DMAA_REG
comma
DECL|enumerator|GA_DMAB_REG
id|GA_DMAB_REG
comma
DECL|enumerator|GA_INTCFG_REG
id|GA_INTCFG_REG
comma
DECL|enumerator|GA_DMACFG_REG
id|GA_DMACFG_REG
comma
DECL|enumerator|GA_CDCFG_REG
id|GA_CDCFG_REG
comma
DECL|enumerator|GA_SMCFGA_REG
id|GA_SMCFGA_REG
comma
DECL|enumerator|GA_SMCFGB_REG
id|GA_SMCFGB_REG
comma
DECL|enumerator|GA_HMCTL_REG
id|GA_HMCTL_REG
)brace
suffix:semicolon
DECL|macro|DMA_8BIT
mdefine_line|#define DMA_8BIT  0x80
DECL|macro|AD1845_FREQ_SEL_MSB
mdefine_line|#define AD1845_FREQ_SEL_MSB    0x16
DECL|macro|AD1845_FREQ_SEL_LSB
mdefine_line|#define AD1845_FREQ_SEL_LSB    0x17
DECL|struct|soundscape
r_struct
id|soundscape
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|io_base
r_int
id|io_base
suffix:semicolon
DECL|member|codec_type
r_int
id|codec_type
suffix:semicolon
DECL|member|ic_type
r_int
id|ic_type
suffix:semicolon
DECL|member|io_res
r_struct
id|resource
op_star
id|io_res
suffix:semicolon
DECL|member|chip
id|cs4231_t
op_star
id|chip
suffix:semicolon
DECL|member|mpu
id|mpu401_t
op_star
id|mpu
suffix:semicolon
DECL|member|hw
id|snd_hwdep_t
op_star
id|hw
suffix:semicolon
multiline_comment|/*&n;&t; * The MIDI device won&squot;t work until we&squot;ve loaded&n;&t; * its firmware via a hardware-dependent device IOCTL&n;&t; */
DECL|member|fwlock
id|spinlock_t
id|fwlock
suffix:semicolon
DECL|member|hw_in_use
r_int
id|hw_in_use
suffix:semicolon
DECL|member|midi_usage
r_int
r_int
id|midi_usage
suffix:semicolon
DECL|member|midi_vol
r_int
r_char
id|midi_vol
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|INVALID_IRQ
mdefine_line|#define INVALID_IRQ  ((unsigned)-1)
DECL|function|get_card_soundscape
r_static
r_inline
r_struct
id|soundscape
op_star
id|get_card_soundscape
c_func
(paren
id|snd_card_t
op_star
id|c
)paren
(brace
r_return
(paren
r_struct
id|soundscape
op_star
)paren
(paren
id|c-&gt;private_data
)paren
suffix:semicolon
)brace
DECL|function|get_mpu401_soundscape
r_static
r_inline
r_struct
id|soundscape
op_star
id|get_mpu401_soundscape
c_func
(paren
id|mpu401_t
op_star
id|mpu
)paren
(brace
r_return
(paren
r_struct
id|soundscape
op_star
)paren
(paren
id|mpu-&gt;private_data
)paren
suffix:semicolon
)brace
DECL|function|get_hwdep_soundscape
r_static
r_inline
r_struct
id|soundscape
op_star
id|get_hwdep_soundscape
c_func
(paren
id|snd_hwdep_t
op_star
id|hw
)paren
(brace
r_return
(paren
r_struct
id|soundscape
op_star
)paren
(paren
id|hw-&gt;private_data
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocates some kernel memory that we can use for DMA.&n; * I think this means that the memory has to map to&n; * contiguous pages of physical memory.&n; */
DECL|function|get_dmabuf
r_static
r_struct
id|snd_dma_buffer
op_star
id|get_dmabuf
c_func
(paren
r_struct
id|snd_dma_buffer
op_star
id|buf
comma
r_int
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
id|buf
)paren
(brace
r_if
c_cond
(paren
id|snd_dma_alloc_pages_fallback
c_func
(paren
id|SNDRV_DMA_TYPE_DEV
comma
id|snd_dma_isa_data
c_func
(paren
)paren
comma
id|size
comma
id|buf
)paren
OL
l_int|0
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sscape: Failed to allocate %lu bytes for DMA&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|buf
suffix:semicolon
)brace
multiline_comment|/*&n; * Release the DMA-able kernel memory ...&n; */
DECL|function|free_dmabuf
r_static
r_void
id|free_dmabuf
c_func
(paren
r_struct
id|snd_dma_buffer
op_star
id|buf
)paren
(brace
r_if
c_cond
(paren
id|buf
op_logical_and
id|buf-&gt;area
)paren
id|snd_dma_free_pages
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function writes to the SoundScape&squot;s control registers,&n; * but doesn&squot;t do any locking. It&squot;s up to the caller to do that.&n; * This is why this function is &quot;unsafe&quot; ...&n; */
DECL|function|sscape_write_unsafe
r_static
r_inline
r_void
id|sscape_write_unsafe
c_func
(paren
r_int
id|io_base
comma
r_enum
id|GA_REG
id|reg
comma
r_int
r_char
id|val
)paren
(brace
id|outb
c_func
(paren
id|reg
comma
id|ODIE_ADDR_IO
c_func
(paren
id|io_base
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|val
comma
id|ODIE_DATA_IO
c_func
(paren
id|io_base
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Write to the SoundScape&squot;s control registers, and do the&n; * necessary locking ...&n; */
DECL|function|sscape_write
r_static
r_void
id|sscape_write
c_func
(paren
r_struct
id|soundscape
op_star
id|s
comma
r_enum
id|GA_REG
id|reg
comma
r_int
r_char
id|val
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|sscape_write_unsafe
c_func
(paren
id|s-&gt;io_base
comma
id|reg
comma
id|val
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read from the SoundScape&squot;s control registers, but leave any&n; * locking to the caller. This is why the function is &quot;unsafe&quot; ...&n; */
DECL|function|sscape_read_unsafe
r_static
r_inline
r_int
r_char
id|sscape_read_unsafe
c_func
(paren
r_int
id|io_base
comma
r_enum
id|GA_REG
id|reg
)paren
(brace
id|outb
c_func
(paren
id|reg
comma
id|ODIE_ADDR_IO
c_func
(paren
id|io_base
)paren
)paren
suffix:semicolon
r_return
id|inb
c_func
(paren
id|ODIE_DATA_IO
c_func
(paren
id|io_base
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Puts the SoundScape into &quot;host&quot; mode, as compared to &quot;MIDI&quot; mode&n; */
DECL|function|set_host_mode_unsafe
r_static
r_inline
r_void
id|set_host_mode_unsafe
c_func
(paren
r_int
id|io_base
)paren
(brace
id|outb
c_func
(paren
l_int|0x0
comma
id|HOST_CTRL_IO
c_func
(paren
id|io_base
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Puts the SoundScape into &quot;MIDI&quot; mode, as compared to &quot;host&quot; mode&n; */
DECL|function|set_midi_mode_unsafe
r_static
r_inline
r_void
id|set_midi_mode_unsafe
c_func
(paren
r_int
id|io_base
)paren
(brace
id|outb
c_func
(paren
l_int|0x3
comma
id|HOST_CTRL_IO
c_func
(paren
id|io_base
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the SoundScape&squot;s host-mode control register, but leave&n; * any locking issues to the caller ...&n; */
DECL|function|host_read_unsafe
r_static
r_inline
r_int
id|host_read_unsafe
c_func
(paren
r_int
id|io_base
)paren
(brace
r_int
id|data
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|HOST_CTRL_IO
c_func
(paren
id|io_base
)paren
)paren
op_amp
id|RX_READY
)paren
op_ne
l_int|0
)paren
(brace
id|data
op_assign
id|inb
c_func
(paren
id|HOST_DATA_IO
c_func
(paren
id|io_base
)paren
)paren
suffix:semicolon
)brace
r_return
id|data
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the SoundScape&squot;s host-mode control register, performing&n; * a limited amount of busy-waiting if the register isn&squot;t ready.&n; * Also leaves all locking-issues to the caller ...&n; */
DECL|function|host_read_ctrl_unsafe
r_static
r_int
id|host_read_ctrl_unsafe
c_func
(paren
r_int
id|io_base
comma
r_int
id|timeout
)paren
(brace
r_int
id|data
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|data
op_assign
id|host_read_unsafe
c_func
(paren
id|io_base
)paren
)paren
OL
l_int|0
)paren
op_logical_and
(paren
id|timeout
op_ne
l_int|0
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
op_decrement
id|timeout
suffix:semicolon
)brace
multiline_comment|/* while */
r_return
id|data
suffix:semicolon
)brace
multiline_comment|/*&n; * Write to the SoundScape&squot;s host-mode control registers, but&n; * leave any locking issues to the caller ...&n; */
DECL|function|host_write_unsafe
r_static
r_inline
r_int
id|host_write_unsafe
c_func
(paren
r_int
id|io_base
comma
r_int
r_char
id|data
)paren
(brace
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|HOST_CTRL_IO
c_func
(paren
id|io_base
)paren
)paren
op_amp
id|TX_READY
)paren
op_ne
l_int|0
)paren
(brace
id|outb
c_func
(paren
id|data
comma
id|HOST_DATA_IO
c_func
(paren
id|io_base
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Write to the SoundScape&squot;s host-mode control registers, performing&n; * a limited amount of busy-waiting if the register isn&squot;t ready.&n; * Also leaves all locking-issues to the caller ...&n; */
DECL|function|host_write_ctrl_unsafe
r_static
r_int
id|host_write_ctrl_unsafe
c_func
(paren
r_int
id|io_base
comma
r_int
r_char
id|data
comma
r_int
id|timeout
)paren
(brace
r_int
id|err
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|err
op_assign
id|host_write_unsafe
c_func
(paren
id|io_base
comma
id|data
)paren
)paren
op_logical_and
(paren
id|timeout
op_ne
l_int|0
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
op_decrement
id|timeout
suffix:semicolon
)brace
multiline_comment|/* while */
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Check that the MIDI subsystem is operational. If it isn&squot;t,&n; * then we will hang the computer if we try to use it ...&n; *&n; * NOTE: This check is based upon observation, not documentation.&n; */
DECL|function|verify_mpu401
r_static
r_inline
r_int
id|verify_mpu401
c_func
(paren
r_const
id|mpu401_t
op_star
id|mpu
)paren
(brace
r_return
(paren
(paren
id|inb
c_func
(paren
id|MIDI_CTRL_IO
c_func
(paren
id|mpu-&gt;port
)paren
)paren
op_amp
l_int|0xc0
)paren
op_eq
l_int|0x80
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is apparently the standard way to initailise an MPU-401&n; */
DECL|function|initialise_mpu401
r_static
r_inline
r_void
id|initialise_mpu401
c_func
(paren
r_const
id|mpu401_t
op_star
id|mpu
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|MIDI_DATA_IO
c_func
(paren
id|mpu-&gt;port
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Tell the SoundScape to activate the AD1845 chip (I think).&n; * The AD1845 detection fails if we *don&squot;t* do this, so I&n; * think that this is a good idea ...&n; */
DECL|function|activate_ad1845_unsafe
r_static
r_inline
r_void
id|activate_ad1845_unsafe
c_func
(paren
r_int
id|io_base
)paren
(brace
id|sscape_write_unsafe
c_func
(paren
id|io_base
comma
id|GA_HMCTL_REG
comma
(paren
id|sscape_read_unsafe
c_func
(paren
id|io_base
comma
id|GA_HMCTL_REG
)paren
op_amp
l_int|0xcf
)paren
op_or
l_int|0x10
)paren
suffix:semicolon
id|sscape_write_unsafe
c_func
(paren
id|io_base
comma
id|GA_CDCFG_REG
comma
l_int|0x80
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Do the necessary ALSA-level cleanup to deallocate our driver ...&n; */
DECL|function|soundscape_free
r_static
r_void
id|soundscape_free
c_func
(paren
id|snd_card_t
op_star
id|c
)paren
(brace
r_register
r_struct
id|soundscape
op_star
id|sscape
op_assign
id|get_card_soundscape
c_func
(paren
id|c
)paren
suffix:semicolon
id|release_resource
c_func
(paren
id|sscape-&gt;io_res
)paren
suffix:semicolon
id|kfree_nocheck
c_func
(paren
id|sscape-&gt;io_res
)paren
suffix:semicolon
id|free_dma
c_func
(paren
id|sscape-&gt;chip-&gt;dma1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Put this process into an idle wait-state for a certain number&n; * of &quot;jiffies&quot;. The process can almost certainly be rescheduled&n; * while we&squot;re waiting, and so we must NOT be holding any spinlocks&n; * when we call this function. If we are then we risk DEADLOCK in&n; * SMP (Ha!) or pre-emptible kernels.&n; */
DECL|function|sleep
r_static
r_inline
r_void
id|sleep
c_func
(paren
r_int
id|jiffs
comma
r_int
id|state
)paren
(brace
id|set_current_state
c_func
(paren
id|state
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|jiffs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Tell the SoundScape to begin a DMA tranfer using the given channel.&n; * All locking issues are left to the caller.&n; */
DECL|function|sscape_start_dma_unsafe
r_static
r_inline
r_void
id|sscape_start_dma_unsafe
c_func
(paren
r_int
id|io_base
comma
r_enum
id|GA_REG
id|reg
)paren
(brace
id|sscape_write_unsafe
c_func
(paren
id|io_base
comma
id|reg
comma
id|sscape_read_unsafe
c_func
(paren
id|io_base
comma
id|reg
)paren
op_or
l_int|0x01
)paren
suffix:semicolon
id|sscape_write_unsafe
c_func
(paren
id|io_base
comma
id|reg
comma
id|sscape_read_unsafe
c_func
(paren
id|io_base
comma
id|reg
)paren
op_amp
l_int|0xfe
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for a DMA transfer to complete. This is a &quot;limited busy-wait&quot;,&n; * and all locking issues are left to the caller.&n; */
DECL|function|sscape_wait_dma_unsafe
r_static
r_int
id|sscape_wait_dma_unsafe
c_func
(paren
r_int
id|io_base
comma
r_enum
id|GA_REG
id|reg
comma
r_int
id|timeout
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|sscape_read_unsafe
c_func
(paren
id|io_base
comma
id|reg
)paren
op_amp
l_int|0x01
)paren
op_logical_and
(paren
id|timeout
op_ne
l_int|0
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
op_decrement
id|timeout
suffix:semicolon
)brace
multiline_comment|/* while */
r_return
(paren
id|sscape_read_unsafe
c_func
(paren
id|io_base
comma
id|reg
)paren
op_amp
l_int|0x01
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for the On-Board Processor to return its start-up&n; * acknowledgement sequence. This wait is too long for&n; * us to perform &quot;busy-waiting&quot;, and so we must sleep.&n; * This in turn means that we must not be holding any&n; * spinlocks when we call this function.&n; */
DECL|function|obp_startup_ack
r_static
r_int
id|obp_startup_ack
c_func
(paren
r_struct
id|soundscape
op_star
id|s
comma
r_int
id|timeout
)paren
(brace
r_while
c_loop
(paren
id|timeout
op_ne
l_int|0
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|x
suffix:semicolon
id|sleep
c_func
(paren
l_int|1
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|x
op_assign
id|inb
c_func
(paren
id|HOST_DATA_IO
c_func
(paren
id|s-&gt;io_base
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
op_amp
l_int|0xfe
)paren
op_eq
l_int|0xfe
)paren
r_return
l_int|1
suffix:semicolon
op_decrement
id|timeout
suffix:semicolon
)brace
multiline_comment|/* while */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for the host to return its start-up acknowledgement&n; * sequence. This wait is too long for us to perform&n; * &quot;busy-waiting&quot;, and so we must sleep. This in turn means&n; * that we must not be holding any spinlocks when we call&n; * this function.&n; */
DECL|function|host_startup_ack
r_static
r_int
id|host_startup_ack
c_func
(paren
r_struct
id|soundscape
op_star
id|s
comma
r_int
id|timeout
)paren
(brace
r_while
c_loop
(paren
id|timeout
op_ne
l_int|0
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|x
suffix:semicolon
id|sleep
c_func
(paren
l_int|1
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|x
op_assign
id|inb
c_func
(paren
id|HOST_DATA_IO
c_func
(paren
id|s-&gt;io_base
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
op_eq
l_int|0xfe
)paren
r_return
l_int|1
suffix:semicolon
op_decrement
id|timeout
suffix:semicolon
)brace
multiline_comment|/* while */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Upload a byte-stream into the SoundScape using DMA channel A.&n; */
DECL|function|upload_dma_data
r_static
r_int
id|upload_dma_data
c_func
(paren
r_struct
id|soundscape
op_star
id|s
comma
r_const
r_int
r_char
id|__user
op_star
id|data
comma
r_int
id|size
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|snd_dma_buffer
id|dma
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_dmabuf
c_func
(paren
op_amp
id|dma
comma
id|PAGE_ALIGN
c_func
(paren
id|size
)paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reset the board ...&n;&t; */
id|sscape_write_unsafe
c_func
(paren
id|s-&gt;io_base
comma
id|GA_HMCTL_REG
comma
id|sscape_read_unsafe
c_func
(paren
id|s-&gt;io_base
comma
id|GA_HMCTL_REG
)paren
op_amp
l_int|0x3f
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Enable the DMA channels and configure them ...&n;&t; */
id|sscape_write_unsafe
c_func
(paren
id|s-&gt;io_base
comma
id|GA_DMACFG_REG
comma
l_int|0x50
)paren
suffix:semicolon
id|sscape_write_unsafe
c_func
(paren
id|s-&gt;io_base
comma
id|GA_DMAA_REG
comma
(paren
id|s-&gt;chip-&gt;dma1
op_lshift
l_int|4
)paren
op_or
id|DMA_8BIT
)paren
suffix:semicolon
id|sscape_write_unsafe
c_func
(paren
id|s-&gt;io_base
comma
id|GA_DMAB_REG
comma
l_int|0x20
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Take the board out of reset ...&n;&t; */
id|sscape_write_unsafe
c_func
(paren
id|s-&gt;io_base
comma
id|GA_HMCTL_REG
comma
id|sscape_read_unsafe
c_func
(paren
id|s-&gt;io_base
comma
id|GA_HMCTL_REG
)paren
op_or
l_int|0x80
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Upload the user&squot;s data (firmware?) to the SoundScape&n;&t; * board through the DMA channel ...&n;&t; */
r_while
c_loop
(paren
id|size
op_ne
l_int|0
)paren
(brace
r_int
r_int
id|len
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Apparently, copying to/from userspace can sleep.&n;&t;&t; * We are therefore forbidden from holding any&n;&t;&t; * spinlocks while we copy ...&n;&t;&t; */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Remember that the data that we want to DMA&n;&t;&t; * comes from USERSPACE. We have already verified&n;&t;&t; * the userspace pointer ...&n;&t;&t; */
id|len
op_assign
id|min
c_func
(paren
id|size
comma
id|dma.bytes
)paren
suffix:semicolon
id|len
op_sub_assign
id|__copy_from_user
c_func
(paren
id|dma.area
comma
id|data
comma
id|len
)paren
suffix:semicolon
id|data
op_add_assign
id|len
suffix:semicolon
id|size
op_sub_assign
id|len
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Grab that spinlock again, now that we&squot;ve&n;&t;&t; * finished copying!&n;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|snd_dma_program
c_func
(paren
id|s-&gt;chip-&gt;dma1
comma
id|dma.addr
comma
id|len
comma
id|DMA_MODE_WRITE
)paren
suffix:semicolon
id|sscape_start_dma_unsafe
c_func
(paren
id|s-&gt;io_base
comma
id|GA_DMAA_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sscape_wait_dma_unsafe
c_func
(paren
id|s-&gt;io_base
comma
id|GA_DMAA_REG
comma
l_int|5000
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Don&squot;t forget to release this spinlock we&squot;re holding ...&n;&t;&t;&t; */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sscape: DMA upload has timed out&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|_release_dma
suffix:semicolon
)brace
)brace
multiline_comment|/* while */
id|set_host_mode_unsafe
c_func
(paren
id|s-&gt;io_base
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Boot the board ... (I think)&n;&t; */
id|sscape_write_unsafe
c_func
(paren
id|s-&gt;io_base
comma
id|GA_HMCTL_REG
comma
id|sscape_read_unsafe
c_func
(paren
id|s-&gt;io_base
comma
id|GA_HMCTL_REG
)paren
op_or
l_int|0x40
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If all has gone well, then the board should acknowledge&n;&t; * the new upload and tell us that it has rebooted OK. We&n;&t; * give it 5 seconds (max) ...&n;&t; */
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obp_startup_ack
c_func
(paren
id|s
comma
l_int|5
)paren
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sscape: No response from on-board processor after upload&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|host_startup_ack
c_func
(paren
id|s
comma
l_int|5
)paren
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sscape: SoundScape failed to initialise&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|_release_dma
suffix:colon
multiline_comment|/*&n;&t; * NOTE!!! We are NOT holding any spinlocks at this point !!!&n;&t; */
id|sscape_write
c_func
(paren
id|s
comma
id|GA_DMAA_REG
comma
(paren
id|s-&gt;ic_type
op_eq
id|IC_ODIE
ques
c_cond
l_int|0x70
suffix:colon
l_int|0x40
)paren
)paren
suffix:semicolon
id|free_dmabuf
c_func
(paren
op_amp
id|dma
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Upload the bootblock(?) into the SoundScape. The only&n; * purpose of this block of code seems to be to tell&n; * us which version of the microcode we should be using.&n; *&n; * NOTE: The boot-block data resides in USER-SPACE!!!&n; *       However, we have already verified its memory&n; *       addresses by the time we get here.&n; */
DECL|function|sscape_upload_bootblock
r_static
r_int
id|sscape_upload_bootblock
c_func
(paren
r_struct
id|soundscape
op_star
id|sscape
comma
r_struct
id|sscape_bootblock
id|__user
op_star
id|bb
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|data
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|upload_dma_data
c_func
(paren
id|sscape
comma
id|bb-&gt;code
comma
r_sizeof
(paren
id|bb-&gt;code
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sscape-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|data
op_assign
id|host_read_ctrl_unsafe
c_func
(paren
id|sscape-&gt;io_base
comma
l_int|100
)paren
suffix:semicolon
)brace
id|set_midi_mode_unsafe
c_func
(paren
id|sscape-&gt;io_base
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sscape-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|data
OL
l_int|0
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sscape: timeout reading firmware version&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|__copy_to_user
c_func
(paren
op_amp
id|bb-&gt;version
comma
op_amp
id|data
comma
r_sizeof
(paren
id|bb-&gt;version
)paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Upload the microcode into the SoundScape. The&n; * microcode is 64K of data, and if we try to copy&n; * it into a local variable then we will SMASH THE&n; * KERNEL&squot;S STACK! We therefore leave it in USER&n; * SPACE, and save ourselves from copying it at all.&n; */
DECL|function|sscape_upload_microcode
r_static
r_int
id|sscape_upload_microcode
c_func
(paren
r_struct
id|soundscape
op_star
id|sscape
comma
r_const
r_struct
id|sscape_microcode
id|__user
op_star
id|mc
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_char
id|__user
op_star
id|code
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/*&n;&t; * We are going to have to copy this data into a special&n;&t; * DMA-able buffer before we can upload it. We shall therefore&n;&t; * just check that the data pointer is valid for now.&n;&t; *&n;&t; * NOTE: This buffer is 64K long! That&squot;s WAY too big to&n;&t; *       copy into a stack-temporary anyway.&n;&t; */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|code
comma
op_amp
id|mc-&gt;code
)paren
op_logical_or
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|code
comma
id|SSCAPE_MICROCODE_SIZE
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|upload_dma_data
c_func
(paren
id|sscape
comma
id|code
comma
id|SSCAPE_MICROCODE_SIZE
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_INFO
l_string|&quot;sscape: MIDI firmware loaded&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sscape-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|set_midi_mode_unsafe
c_func
(paren
id|sscape-&gt;io_base
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sscape-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|initialise_mpu401
c_func
(paren
id|sscape-&gt;mpu
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Hardware-specific device functions, to implement special&n; * IOCTLs for the SoundScape card. This is how we upload&n; * the microcode into the card, for example, and so we&n; * must ensure that no two processes can open this device&n; * simultaneously, and that we can&squot;t open it at all if&n; * someone is using the MIDI device.&n; */
DECL|function|sscape_hw_open
r_static
r_int
id|sscape_hw_open
c_func
(paren
id|snd_hwdep_t
op_star
id|hw
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_register
r_struct
id|soundscape
op_star
id|sscape
op_assign
id|get_hwdep_soundscape
c_func
(paren
id|hw
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|err
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sscape-&gt;fwlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sscape-&gt;midi_usage
op_ne
l_int|0
)paren
op_logical_or
id|sscape-&gt;hw_in_use
)paren
(brace
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
(brace
id|sscape-&gt;hw_in_use
op_assign
l_int|1
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sscape-&gt;fwlock
comma
id|flags
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sscape_hw_release
r_static
r_int
id|sscape_hw_release
c_func
(paren
id|snd_hwdep_t
op_star
id|hw
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_register
r_struct
id|soundscape
op_star
id|sscape
op_assign
id|get_hwdep_soundscape
c_func
(paren
id|hw
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sscape-&gt;fwlock
comma
id|flags
)paren
suffix:semicolon
id|sscape-&gt;hw_in_use
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sscape-&gt;fwlock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sscape_hw_ioctl
r_static
r_int
id|sscape_hw_ioctl
c_func
(paren
id|snd_hwdep_t
op_star
id|hw
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|soundscape
op_star
id|sscape
op_assign
id|get_hwdep_soundscape
c_func
(paren
id|hw
)paren
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SND_SSCAPE_LOAD_BOOTB
suffix:colon
(brace
r_register
r_struct
id|sscape_bootblock
id|__user
op_star
id|bb
op_assign
(paren
r_struct
id|sscape_bootblock
id|__user
op_star
)paren
id|arg
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We are going to have to copy this data into a special&n;&t;&t;&t; * DMA-able buffer before we can upload it. We shall therefore&n;&t;&t;&t; * just check that the data pointer is valid for now ...&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|bb-&gt;code
comma
r_sizeof
(paren
id|bb-&gt;code
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Now check that we can write the firmware version number too...&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
op_amp
id|bb-&gt;version
comma
r_sizeof
(paren
id|bb-&gt;version
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|sscape_upload_bootblock
c_func
(paren
id|sscape
comma
id|bb
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SND_SSCAPE_LOAD_MCODE
suffix:colon
(brace
r_register
r_const
r_struct
id|sscape_microcode
id|__user
op_star
id|mc
op_assign
(paren
r_const
r_struct
id|sscape_microcode
id|__user
op_star
)paren
id|arg
suffix:semicolon
id|err
op_assign
id|sscape_upload_microcode
c_func
(paren
id|sscape
comma
id|mc
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* switch */
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Mixer control for the SoundScape&squot;s MIDI device.&n; */
DECL|function|sscape_midi_info
r_static
r_int
id|sscape_midi_info
c_func
(paren
id|snd_kcontrol_t
op_star
id|ctl
comma
id|snd_ctl_elem_info_t
op_star
id|uinfo
)paren
(brace
id|uinfo-&gt;type
op_assign
id|SNDRV_CTL_ELEM_TYPE_INTEGER
suffix:semicolon
id|uinfo-&gt;count
op_assign
l_int|1
suffix:semicolon
id|uinfo-&gt;value.integer.min
op_assign
l_int|0
suffix:semicolon
id|uinfo-&gt;value.integer.max
op_assign
l_int|127
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sscape_midi_get
r_static
r_int
id|sscape_midi_get
c_func
(paren
id|snd_kcontrol_t
op_star
id|kctl
comma
id|snd_ctl_elem_value_t
op_star
id|uctl
)paren
(brace
id|cs4231_t
op_star
id|chip
op_assign
id|snd_kcontrol_chip
c_func
(paren
id|kctl
)paren
suffix:semicolon
id|snd_card_t
op_star
id|card
op_assign
id|chip-&gt;card
suffix:semicolon
r_register
r_struct
id|soundscape
op_star
id|s
op_assign
id|get_card_soundscape
c_func
(paren
id|card
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|set_host_mode_unsafe
c_func
(paren
id|s-&gt;io_base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host_write_ctrl_unsafe
c_func
(paren
id|s-&gt;io_base
comma
id|CMD_GET_MIDI_VOL
comma
l_int|100
)paren
)paren
(brace
id|uctl-&gt;value.integer.value
(braket
l_int|0
)braket
op_assign
id|host_read_ctrl_unsafe
c_func
(paren
id|s-&gt;io_base
comma
l_int|100
)paren
suffix:semicolon
)brace
id|set_midi_mode_unsafe
c_func
(paren
id|s-&gt;io_base
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sscape_midi_put
r_static
r_int
id|sscape_midi_put
c_func
(paren
id|snd_kcontrol_t
op_star
id|kctl
comma
id|snd_ctl_elem_value_t
op_star
id|uctl
)paren
(brace
id|cs4231_t
op_star
id|chip
op_assign
id|snd_kcontrol_chip
c_func
(paren
id|kctl
)paren
suffix:semicolon
id|snd_card_t
op_star
id|card
op_assign
id|chip-&gt;card
suffix:semicolon
r_register
r_struct
id|soundscape
op_star
id|s
op_assign
id|get_card_soundscape
c_func
(paren
id|card
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|change
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We need to put the board into HOST mode before we&n;&t; * can send any volume-changing HOST commands ...&n;&t; */
id|set_host_mode_unsafe
c_func
(paren
id|s-&gt;io_base
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * To successfully change the MIDI volume setting, you seem to&n;&t; * have to write a volume command, write the new volume value,&n;&t; * and then perform another volume-related command. Perhaps the&n;&t; * first command is an &quot;open&quot; and the second command is a &quot;close&quot;?&n;&t; */
r_if
c_cond
(paren
id|s-&gt;midi_vol
op_eq
(paren
(paren
r_int
r_char
)paren
id|uctl-&gt;value.integer
dot
id|value
(braket
l_int|0
)braket
op_amp
l_int|127
)paren
)paren
(brace
id|change
op_assign
l_int|0
suffix:semicolon
r_goto
id|__skip_change
suffix:semicolon
)brace
id|change
op_assign
(paren
id|host_write_ctrl_unsafe
c_func
(paren
id|s-&gt;io_base
comma
id|CMD_SET_MIDI_VOL
comma
l_int|100
)paren
op_logical_and
id|host_write_ctrl_unsafe
c_func
(paren
id|s-&gt;io_base
comma
(paren
(paren
r_int
r_char
)paren
id|uctl-&gt;value.integer
dot
id|value
(braket
l_int|0
)braket
)paren
op_amp
l_int|127
comma
l_int|100
)paren
op_logical_and
id|host_write_ctrl_unsafe
c_func
(paren
id|s-&gt;io_base
comma
id|CMD_XXX_MIDI_VOL
comma
l_int|100
)paren
)paren
suffix:semicolon
id|__skip_change
suffix:colon
multiline_comment|/*&n;&t; * Take the board out of HOST mode and back into MIDI mode ...&n;&t; */
id|set_midi_mode_unsafe
c_func
(paren
id|s-&gt;io_base
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|change
suffix:semicolon
)brace
DECL|variable|midi_mixer_ctl
r_static
id|snd_kcontrol_new_t
id|midi_mixer_ctl
op_assign
(brace
dot
id|iface
op_assign
id|SNDRV_CTL_ELEM_IFACE_MIXER
comma
dot
id|name
op_assign
l_string|&quot;MIDI&quot;
comma
dot
id|info
op_assign
id|sscape_midi_info
comma
dot
id|get
op_assign
id|sscape_midi_get
comma
dot
id|put
op_assign
id|sscape_midi_put
)brace
suffix:semicolon
multiline_comment|/*&n; * The SoundScape can use two IRQs from a possible set of four.&n; * These IRQs are encoded as bit patterns so that they can be&n; * written to the control registers.&n; */
DECL|function|get_irq_config
r_static
r_int
id|__devinit
id|get_irq_config
c_func
(paren
r_int
id|irq
)paren
(brace
r_static
r_const
r_int
id|valid_irq
(braket
)braket
op_assign
(brace
l_int|9
comma
l_int|5
comma
l_int|7
comma
l_int|10
)brace
suffix:semicolon
r_int
id|cfg
suffix:semicolon
r_for
c_loop
(paren
id|cfg
op_assign
l_int|0
suffix:semicolon
id|cfg
OL
id|ARRAY_SIZE
c_func
(paren
id|valid_irq
)paren
suffix:semicolon
op_increment
id|cfg
)paren
(brace
r_if
c_cond
(paren
id|irq
op_eq
id|valid_irq
(braket
id|cfg
)braket
)paren
r_return
id|cfg
suffix:semicolon
)brace
multiline_comment|/* for */
r_return
id|INVALID_IRQ
suffix:semicolon
)brace
multiline_comment|/*&n; * Perform certain arcane port-checks to see whether there&n; * is a SoundScape board lurking behind the given ports.&n; */
DECL|function|detect_sscape
r_static
r_int
id|__devinit
id|detect_sscape
c_func
(paren
r_struct
id|soundscape
op_star
id|s
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|d
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The following code is lifted from the original OSS driver,&n;&t; * and as I don&squot;t have a datasheet I cannot really comment&n;&t; * on what it is doing...&n;&t; */
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|HOST_CTRL_IO
c_func
(paren
id|s-&gt;io_base
)paren
)paren
op_amp
l_int|0x78
)paren
op_ne
l_int|0
)paren
r_goto
id|_done
suffix:semicolon
id|d
op_assign
id|inb
c_func
(paren
id|ODIE_ADDR_IO
c_func
(paren
id|s-&gt;io_base
)paren
)paren
op_amp
l_int|0xf0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|d
op_amp
l_int|0x80
)paren
op_ne
l_int|0
)paren
r_goto
id|_done
suffix:semicolon
r_if
c_cond
(paren
id|d
op_eq
l_int|0
)paren
(brace
id|s-&gt;codec_type
op_assign
l_int|1
suffix:semicolon
id|s-&gt;ic_type
op_assign
id|IC_ODIE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|d
op_amp
l_int|0x60
)paren
op_ne
l_int|0
)paren
(brace
id|s-&gt;codec_type
op_assign
l_int|2
suffix:semicolon
id|s-&gt;ic_type
op_assign
id|IC_OPUS
suffix:semicolon
)brace
r_else
r_goto
id|_done
suffix:semicolon
id|outb
c_func
(paren
l_int|0xfa
comma
id|ODIE_ADDR_IO
c_func
(paren
id|s-&gt;io_base
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|ODIE_ADDR_IO
c_func
(paren
id|s-&gt;io_base
)paren
)paren
op_amp
l_int|0x9f
)paren
op_ne
l_int|0x0a
)paren
r_goto
id|_done
suffix:semicolon
id|outb
c_func
(paren
l_int|0xfe
comma
id|ODIE_ADDR_IO
c_func
(paren
id|s-&gt;io_base
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|ODIE_ADDR_IO
c_func
(paren
id|s-&gt;io_base
)paren
)paren
op_amp
l_int|0x9f
)paren
op_ne
l_int|0x0e
)paren
r_goto
id|_done
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|ODIE_DATA_IO
c_func
(paren
id|s-&gt;io_base
)paren
)paren
op_amp
l_int|0x9f
)paren
op_ne
l_int|0x0e
)paren
r_goto
id|_done
suffix:semicolon
multiline_comment|/*&n;&t; * SoundScape successfully detected!&n;&t; */
id|retval
op_assign
l_int|1
suffix:semicolon
id|_done
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * ALSA callback function, called when attempting to open the MIDI device.&n; * Check that the MIDI firmware has been loaded, because we don&squot;t want&n; * to crash the machine. Also check that someone isn&squot;t using the hardware&n; * IOCTL device.&n; */
DECL|function|mpu401_open
r_static
r_int
id|mpu401_open
c_func
(paren
id|mpu401_t
op_star
id|mpu
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|verify_mpu401
c_func
(paren
id|mpu
)paren
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sscape: MIDI disabled, please load firmware&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
(brace
r_register
r_struct
id|soundscape
op_star
id|sscape
op_assign
id|get_mpu401_soundscape
c_func
(paren
id|mpu
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sscape-&gt;fwlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sscape-&gt;hw_in_use
op_logical_or
(paren
id|sscape-&gt;midi_usage
op_eq
id|ULONG_MAX
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
(brace
op_increment
(paren
id|sscape-&gt;midi_usage
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sscape-&gt;fwlock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|function|mpu401_close
r_static
r_void
id|mpu401_close
c_func
(paren
id|mpu401_t
op_star
id|mpu
)paren
(brace
r_register
r_struct
id|soundscape
op_star
id|sscape
op_assign
id|get_mpu401_soundscape
c_func
(paren
id|mpu
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sscape-&gt;fwlock
comma
id|flags
)paren
suffix:semicolon
op_decrement
(paren
id|sscape-&gt;midi_usage
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sscape-&gt;fwlock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialse an MPU-401 subdevice for MIDI support on the SoundScape.&n; */
DECL|function|create_mpu401
r_static
r_int
id|__devinit
id|create_mpu401
c_func
(paren
id|snd_card_t
op_star
id|card
comma
r_int
id|devnum
comma
r_int
r_int
id|port
comma
r_int
id|irq
)paren
(brace
r_struct
id|soundscape
op_star
id|sscape
op_assign
id|get_card_soundscape
c_func
(paren
id|card
)paren
suffix:semicolon
id|snd_rawmidi_t
op_star
id|rawmidi
suffix:semicolon
r_int
id|err
suffix:semicolon
DECL|macro|MPU401_SHARE_HARDWARE
mdefine_line|#define MPU401_SHARE_HARDWARE  1
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_mpu401_uart_new
c_func
(paren
id|card
comma
id|devnum
comma
id|MPU401_HW_MPU401
comma
id|port
comma
id|MPU401_SHARE_HARDWARE
comma
id|irq
comma
id|SA_INTERRUPT
comma
op_amp
id|rawmidi
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|mpu401_t
op_star
id|mpu
op_assign
(paren
id|mpu401_t
op_star
)paren
id|rawmidi-&gt;private_data
suffix:semicolon
id|mpu-&gt;open_input
op_assign
id|mpu401_open
suffix:semicolon
id|mpu-&gt;open_output
op_assign
id|mpu401_open
suffix:semicolon
id|mpu-&gt;close_input
op_assign
id|mpu401_close
suffix:semicolon
id|mpu-&gt;close_output
op_assign
id|mpu401_close
suffix:semicolon
id|mpu-&gt;private_data
op_assign
id|sscape
suffix:semicolon
id|sscape-&gt;mpu
op_assign
id|mpu
suffix:semicolon
id|initialise_mpu401
c_func
(paren
id|mpu
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Override for the CS4231 playback format function.&n; * The AD1845 has much simpler format and rate selection.&n; */
DECL|function|ad1845_playback_format
r_static
r_void
id|ad1845_playback_format
c_func
(paren
id|cs4231_t
op_star
id|chip
comma
id|snd_pcm_hw_params_t
op_star
id|params
comma
r_int
r_char
id|format
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rate
op_assign
id|params_rate
c_func
(paren
id|params
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The AD1845 can&squot;t handle sample frequencies&n;&t; * outside of 4 kHZ to 50 kHZ&n;&t; */
r_if
c_cond
(paren
id|rate
OG
l_int|50000
)paren
id|rate
op_assign
l_int|50000
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rate
OL
l_int|4000
)paren
id|rate
op_assign
l_int|4000
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|chip-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Program the AD1845 correctly for the playback stream.&n;&t; * Note that we do NOT need to toggle the MCE bit because&n;&t; * the PLAYBACK_ENABLE bit of the Interface Configuration&n;&t; * register is set.&n;&t; * &n;&t; * NOTE: We seem to need to write to the MSB before the LSB&n;&t; *       to get the correct sample frequency.&n;&t; */
id|snd_cs4231_out
c_func
(paren
id|chip
comma
id|CS4231_PLAYBK_FORMAT
comma
(paren
id|format
op_amp
l_int|0xf0
)paren
)paren
suffix:semicolon
id|snd_cs4231_out
c_func
(paren
id|chip
comma
id|AD1845_FREQ_SEL_MSB
comma
(paren
r_int
r_char
)paren
(paren
id|rate
op_rshift
l_int|8
)paren
)paren
suffix:semicolon
id|snd_cs4231_out
c_func
(paren
id|chip
comma
id|AD1845_FREQ_SEL_LSB
comma
(paren
r_int
r_char
)paren
id|rate
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|chip-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Override for the CS4231 capture format function. &n; * The AD1845 has much simpler format and rate selection.&n; */
DECL|function|ad1845_capture_format
r_static
r_void
id|ad1845_capture_format
c_func
(paren
id|cs4231_t
op_star
id|chip
comma
id|snd_pcm_hw_params_t
op_star
id|params
comma
r_int
r_char
id|format
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rate
op_assign
id|params_rate
c_func
(paren
id|params
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The AD1845 can&squot;t handle sample frequencies &n;&t; * outside of 4 kHZ to 50 kHZ&n;&t; */
r_if
c_cond
(paren
id|rate
OG
l_int|50000
)paren
id|rate
op_assign
l_int|50000
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rate
OL
l_int|4000
)paren
id|rate
op_assign
l_int|4000
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|chip-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Program the AD1845 correctly for the playback stream.&n;&t; * Note that we do NOT need to toggle the MCE bit because&n;&t; * the CAPTURE_ENABLE bit of the Interface Configuration&n;&t; * register is set.&n;&t; *&n;&t; * NOTE: We seem to need to write to the MSB before the LSB&n;&t; *       to get the correct sample frequency.&n;&t; */
id|snd_cs4231_out
c_func
(paren
id|chip
comma
id|CS4231_REC_FORMAT
comma
(paren
id|format
op_amp
l_int|0xf0
)paren
)paren
suffix:semicolon
id|snd_cs4231_out
c_func
(paren
id|chip
comma
id|AD1845_FREQ_SEL_MSB
comma
(paren
r_int
r_char
)paren
(paren
id|rate
op_rshift
l_int|8
)paren
)paren
suffix:semicolon
id|snd_cs4231_out
c_func
(paren
id|chip
comma
id|AD1845_FREQ_SEL_LSB
comma
(paren
r_int
r_char
)paren
id|rate
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|chip-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create an AD1845 PCM subdevice on the SoundScape. The AD1845&n; * is very much like a CS4231, with a few extra bits. We will&n; * try to support at least some of the extra bits by overriding&n; * some of the CS4231 callback.&n; */
DECL|function|create_ad1845
r_static
r_int
id|__devinit
id|create_ad1845
c_func
(paren
id|snd_card_t
op_star
id|card
comma
r_int
id|port
comma
r_int
id|irq
comma
r_int
id|dma1
)paren
(brace
r_register
r_struct
id|soundscape
op_star
id|sscape
op_assign
id|get_card_soundscape
c_func
(paren
id|card
)paren
suffix:semicolon
id|cs4231_t
op_star
id|chip
suffix:semicolon
r_int
id|err
suffix:semicolon
DECL|macro|CS4231_SHARE_HARDWARE
mdefine_line|#define CS4231_SHARE_HARDWARE  (CS4231_HWSHARE_DMA1 | CS4231_HWSHARE_DMA2)
multiline_comment|/*&n;&t; * The AD1845 PCM device is only half-duplex, and so&n;&t; * we only give it one DMA channel ...&n;&t; */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_cs4231_create
c_func
(paren
id|card
comma
id|port
comma
op_minus
l_int|1
comma
id|irq
comma
id|dma1
comma
id|dma1
comma
id|CS4231_HW_DETECT
comma
id|CS4231_HWSHARE_DMA1
comma
op_amp
id|chip
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|snd_pcm_t
op_star
id|pcm
suffix:semicolon
DECL|macro|AD1845_FREQ_SEL_ENABLE
mdefine_line|#define AD1845_FREQ_SEL_ENABLE  0x08
DECL|macro|AD1845_PWR_DOWN_CTRL
mdefine_line|#define AD1845_PWR_DOWN_CTRL   0x1b
DECL|macro|AD1845_CRYS_CLOCK_SEL
mdefine_line|#define AD1845_CRYS_CLOCK_SEL  0x1d
multiline_comment|/*&n; * It turns out that the PLAYBACK_ENABLE bit is set&n; * by the lowlevel driver ...&n; *&n;#define AD1845_IFACE_CONFIG  &bslash;&n;           (CS4231_AUTOCALIB | CS4231_RECORD_ENABLE | CS4231_PLAYBACK_ENABLE)&n;    snd_cs4231_mce_up(chip);&n;    spin_lock_irqsave(&amp;chip-&gt;reg_lock, flags);&n;    snd_cs4231_out(chip, CS4231_IFACE_CTRL, AD1845_IFACE_CONFIG);&n;    spin_unlock_irqrestore(&amp;chip-&gt;reg_lock, flags);&n;    snd_cs4231_mce_down(chip);&n; */
multiline_comment|/*&n;&t;&t; * The input clock frequency on the SoundScape must&n;&t;&t; * be 14.31818 MHz, because we must set this register&n;&t;&t; * to get the playback to sound correct ...&n;&t;&t; */
id|snd_cs4231_mce_up
c_func
(paren
id|chip
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|chip-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
id|snd_cs4231_out
c_func
(paren
id|chip
comma
id|AD1845_CRYS_CLOCK_SEL
comma
l_int|0x20
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|chip-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
id|snd_cs4231_mce_down
c_func
(paren
id|chip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * More custom configuration:&n;&t;&t; * a) select &quot;mode 2&quot;, and provide a current drive of 8 mA&n;&t;&t; * b) enable frequency selection (for capture/playback)&n;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|chip-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
id|snd_cs4231_out
c_func
(paren
id|chip
comma
id|CS4231_MISC_INFO
comma
(paren
id|CS4231_MODE2
op_or
l_int|0x10
)paren
)paren
suffix:semicolon
id|snd_cs4231_out
c_func
(paren
id|chip
comma
id|AD1845_PWR_DOWN_CTRL
comma
id|snd_cs4231_in
c_func
(paren
id|chip
comma
id|AD1845_PWR_DOWN_CTRL
)paren
op_or
id|AD1845_FREQ_SEL_ENABLE
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|chip-&gt;reg_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_cs4231_pcm
c_func
(paren
id|chip
comma
l_int|0
comma
op_amp
id|pcm
)paren
)paren
OL
l_int|0
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sscape: No PCM device for AD1845 chip&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|_error
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_cs4231_mixer
c_func
(paren
id|chip
)paren
)paren
OL
l_int|0
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sscape: No mixer device for AD1845 chip&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|_error
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_ctl_add
c_func
(paren
id|card
comma
id|snd_ctl_new1
c_func
(paren
op_amp
id|midi_mixer_ctl
comma
id|chip
)paren
)paren
)paren
OL
l_int|0
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sscape: Could not create MIDI mixer control&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|_error
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|card-&gt;driver
comma
l_string|&quot;SoundScape&quot;
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|card-&gt;shortname
comma
id|pcm-&gt;name
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|card-&gt;longname
comma
r_sizeof
(paren
id|card-&gt;longname
)paren
comma
l_string|&quot;%s at 0x%lx, IRQ %d, DMA %d&bslash;n&quot;
comma
id|pcm-&gt;name
comma
id|chip-&gt;port
comma
id|chip-&gt;irq
comma
id|chip-&gt;dma1
)paren
suffix:semicolon
id|chip-&gt;set_playback_format
op_assign
id|ad1845_playback_format
suffix:semicolon
id|chip-&gt;set_capture_format
op_assign
id|ad1845_capture_format
suffix:semicolon
id|sscape-&gt;chip
op_assign
id|chip
suffix:semicolon
)brace
id|_error
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|struct|params
r_struct
id|params
(brace
DECL|member|index
r_int
id|index
suffix:semicolon
DECL|member|id
r_const
r_char
op_star
id|id
suffix:semicolon
DECL|member|port
r_int
id|port
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|member|mpu_irq
r_int
id|mpu_irq
suffix:semicolon
DECL|member|dma1
r_int
id|dma1
suffix:semicolon
)brace
suffix:semicolon
r_static
r_inline
r_struct
id|params
op_star
DECL|function|init_params
id|init_params
c_func
(paren
r_struct
id|params
op_star
id|params
comma
r_int
id|index
comma
r_const
r_char
op_star
id|id
comma
r_int
id|port
comma
r_int
id|irq
comma
r_int
id|mpu_irq
comma
r_int
id|dma1
)paren
(brace
id|params-&gt;index
op_assign
id|index
suffix:semicolon
id|params-&gt;id
op_assign
id|id
suffix:semicolon
id|params-&gt;port
op_assign
id|port
suffix:semicolon
id|params-&gt;irq
op_assign
id|irq
suffix:semicolon
id|params-&gt;mpu_irq
op_assign
id|mpu_irq
suffix:semicolon
id|params-&gt;dma1
op_assign
(paren
id|dma1
op_amp
l_int|0x03
)paren
suffix:semicolon
r_return
id|params
suffix:semicolon
)brace
multiline_comment|/*&n; * Create an ALSA soundcard entry for the SoundScape, using&n; * the given list of port, IRQ and DMA resources.&n; */
DECL|function|create_sscape
r_static
r_int
id|__devinit
id|create_sscape
c_func
(paren
r_const
r_struct
id|params
op_star
id|params
comma
id|snd_card_t
op_star
op_star
id|rcardp
)paren
(brace
id|snd_card_t
op_star
id|card
suffix:semicolon
r_register
r_struct
id|soundscape
op_star
id|sscape
suffix:semicolon
r_register
r_int
id|dma_cfg
suffix:semicolon
r_int
id|irq_cfg
suffix:semicolon
r_int
id|mpu_irq_cfg
suffix:semicolon
r_struct
id|resource
op_star
id|io_res
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/*&n;&t; * Check that the user didn&squot;t pass us garbage data ...&n;&t; */
id|irq_cfg
op_assign
id|get_irq_config
c_func
(paren
id|params-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_cfg
op_eq
id|INVALID_IRQ
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sscape: Invalid IRQ %d&bslash;n&quot;
comma
id|params-&gt;irq
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|mpu_irq_cfg
op_assign
id|get_irq_config
c_func
(paren
id|params-&gt;mpu_irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mpu_irq_cfg
op_eq
id|INVALID_IRQ
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sscape: Invalid IRQ %d&bslash;n&quot;
comma
id|params-&gt;mpu_irq
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Grab IO ports that we will need to probe so that we&n;&t; * can detect and control this hardware ...&n;&t; */
r_if
c_cond
(paren
(paren
id|io_res
op_assign
id|request_region
c_func
(paren
id|params-&gt;port
comma
l_int|8
comma
l_string|&quot;SoundScape&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sscape: can&squot;t grab port 0x%x&bslash;n&quot;
comma
id|params-&gt;port
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Grab both DMA channels (OK, only one for now) ...&n;&t; */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|request_dma
c_func
(paren
id|params-&gt;dma1
comma
l_string|&quot;SoundScape&quot;
)paren
)paren
OL
l_int|0
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sscape: can&squot;t grab DMA %d&bslash;n&quot;
comma
id|params-&gt;dma1
)paren
suffix:semicolon
r_goto
id|_release_region
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Create a new ALSA sound card entry, in anticipation&n;&t; * of detecting our hardware ...&n;&t; */
r_if
c_cond
(paren
(paren
id|card
op_assign
id|snd_card_new
c_func
(paren
id|params-&gt;index
comma
id|params-&gt;id
comma
id|THIS_MODULE
comma
r_sizeof
(paren
r_struct
id|soundscape
)paren
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|_release_dma
suffix:semicolon
)brace
id|sscape
op_assign
id|get_card_soundscape
c_func
(paren
id|card
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|sscape-&gt;lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|sscape-&gt;fwlock
)paren
suffix:semicolon
id|sscape-&gt;io_res
op_assign
id|io_res
suffix:semicolon
id|sscape-&gt;io_base
op_assign
id|params-&gt;port
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|detect_sscape
c_func
(paren
id|sscape
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sscape: hardware not detected at 0x%x&bslash;n&quot;
comma
id|sscape-&gt;io_base
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|_release_card
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;sscape: hardware detected at 0x%x, using IRQ %d, DMA %d&bslash;n&quot;
comma
id|sscape-&gt;io_base
comma
id|params-&gt;irq
comma
id|params-&gt;dma1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now create the hardware-specific device so that we can&n;&t; * load the microcode into the on-board processor.&n;&t; * We cannot use the MPU-401 MIDI system until this firmware&n;&t; * has been loaded into the card.&n;&t; */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_hwdep_new
c_func
(paren
id|card
comma
l_string|&quot;MC68EC000&quot;
comma
l_int|0
comma
op_amp
(paren
id|sscape-&gt;hw
)paren
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sscape: Failed to create firmware device&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|_release_card
suffix:semicolon
)brace
id|strlcpy
c_func
(paren
id|sscape-&gt;hw-&gt;name
comma
l_string|&quot;SoundScape M68K&quot;
comma
r_sizeof
(paren
id|sscape-&gt;hw-&gt;name
)paren
)paren
suffix:semicolon
id|sscape-&gt;hw-&gt;name
(braket
r_sizeof
(paren
id|sscape-&gt;hw-&gt;name
)paren
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|sscape-&gt;hw-&gt;iface
op_assign
id|SNDRV_HWDEP_IFACE_SSCAPE
suffix:semicolon
id|sscape-&gt;hw-&gt;ops.open
op_assign
id|sscape_hw_open
suffix:semicolon
id|sscape-&gt;hw-&gt;ops.release
op_assign
id|sscape_hw_release
suffix:semicolon
id|sscape-&gt;hw-&gt;ops.ioctl
op_assign
id|sscape_hw_ioctl
suffix:semicolon
id|sscape-&gt;hw-&gt;private_data
op_assign
id|sscape
suffix:semicolon
multiline_comment|/*&n;&t; * Tell the on-board devices where their resources are (I think -&n;&t; * I can&squot;t be sure without a datasheet ... So many magic values!)&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sscape-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|activate_ad1845_unsafe
c_func
(paren
id|sscape-&gt;io_base
)paren
suffix:semicolon
id|sscape_write_unsafe
c_func
(paren
id|sscape-&gt;io_base
comma
id|GA_INTENA_REG
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* disable */
id|sscape_write_unsafe
c_func
(paren
id|sscape-&gt;io_base
comma
id|GA_SMCFGA_REG
comma
l_int|0x2e
)paren
suffix:semicolon
id|sscape_write_unsafe
c_func
(paren
id|sscape-&gt;io_base
comma
id|GA_SMCFGB_REG
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Enable and configure the DMA channels ...&n;&t; */
id|sscape_write_unsafe
c_func
(paren
id|sscape-&gt;io_base
comma
id|GA_DMACFG_REG
comma
l_int|0x50
)paren
suffix:semicolon
id|dma_cfg
op_assign
(paren
id|sscape-&gt;ic_type
op_eq
id|IC_ODIE
ques
c_cond
l_int|0x70
suffix:colon
l_int|0x40
)paren
suffix:semicolon
id|sscape_write_unsafe
c_func
(paren
id|sscape-&gt;io_base
comma
id|GA_DMAA_REG
comma
id|dma_cfg
)paren
suffix:semicolon
id|sscape_write_unsafe
c_func
(paren
id|sscape-&gt;io_base
comma
id|GA_DMAB_REG
comma
l_int|0x20
)paren
suffix:semicolon
id|sscape_write_unsafe
c_func
(paren
id|sscape-&gt;io_base
comma
id|GA_INTCFG_REG
comma
l_int|0xf0
op_or
(paren
id|mpu_irq_cfg
op_lshift
l_int|2
)paren
op_or
id|mpu_irq_cfg
)paren
suffix:semicolon
id|sscape_write_unsafe
c_func
(paren
id|sscape-&gt;io_base
comma
id|GA_CDCFG_REG
comma
l_int|0x09
op_or
id|DMA_8BIT
op_or
(paren
id|params-&gt;dma1
op_lshift
l_int|4
)paren
op_or
(paren
id|irq_cfg
op_lshift
l_int|1
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sscape-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have now enabled the codec chip, and so we should&n;&t; * detect the AD1845 device ...&n;&t; */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|create_ad1845
c_func
(paren
id|card
comma
id|CODEC_IO
c_func
(paren
id|params-&gt;port
)paren
comma
id|params-&gt;irq
comma
id|params-&gt;dma1
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sscape: No AD1845 device at 0x%x, IRQ %d&bslash;n&quot;
comma
id|CODEC_IO
c_func
(paren
id|params-&gt;port
)paren
comma
id|params-&gt;irq
)paren
suffix:semicolon
r_goto
id|_release_card
suffix:semicolon
)brace
DECL|macro|MIDI_DEVNUM
mdefine_line|#define MIDI_DEVNUM  0
r_if
c_cond
(paren
(paren
id|err
op_assign
id|create_mpu401
c_func
(paren
id|card
comma
id|MIDI_DEVNUM
comma
id|MPU401_IO
c_func
(paren
id|params-&gt;port
)paren
comma
id|params-&gt;mpu_irq
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sscape: Failed to create MPU-401 device at 0x%x&bslash;n&quot;
comma
id|MPU401_IO
c_func
(paren
id|params-&gt;port
)paren
)paren
suffix:semicolon
r_goto
id|_release_card
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Enable the master IRQ ...&n;&t; */
id|sscape_write
c_func
(paren
id|sscape
comma
id|GA_INTENA_REG
comma
l_int|0x80
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_card_register
c_func
(paren
id|card
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sscape: Failed to register sound card&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|_release_card
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Initialize mixer&n;&t; */
id|sscape-&gt;midi_vol
op_assign
l_int|0
suffix:semicolon
id|host_write_ctrl_unsafe
c_func
(paren
id|sscape-&gt;io_base
comma
id|CMD_SET_MIDI_VOL
comma
l_int|100
)paren
suffix:semicolon
id|host_write_ctrl_unsafe
c_func
(paren
id|sscape-&gt;io_base
comma
l_int|0
comma
l_int|100
)paren
suffix:semicolon
id|host_write_ctrl_unsafe
c_func
(paren
id|sscape-&gt;io_base
comma
id|CMD_XXX_MIDI_VOL
comma
l_int|100
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now that we have successfully created this sound card,&n;&t; * it is safe to store the pointer.&n;&t; * NOTE: we only register the sound card&squot;s &quot;destructor&quot;&n;&t; *       function now that our &quot;constructor&quot; has completed.&n;&t; */
id|card-&gt;private_free
op_assign
id|soundscape_free
suffix:semicolon
op_star
id|rcardp
op_assign
id|card
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|_release_card
suffix:colon
id|snd_card_free
c_func
(paren
id|card
)paren
suffix:semicolon
id|_release_dma
suffix:colon
id|free_dma
c_func
(paren
id|params-&gt;dma1
)paren
suffix:semicolon
id|_release_region
suffix:colon
id|release_resource
c_func
(paren
id|io_res
)paren
suffix:semicolon
id|kfree_nocheck
c_func
(paren
id|io_res
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|__devinitdata
r_static
r_int
id|sscape_cards
id|__devinitdata
suffix:semicolon
DECL|variable|__devinitdata
r_static
r_struct
id|params
id|sscape_params
(braket
id|SNDRV_CARDS
)braket
id|__devinitdata
suffix:semicolon
macro_line|#ifdef CONFIG_PNP
DECL|function|get_next_autoindex
r_static
r_inline
r_int
id|__devinit
id|get_next_autoindex
c_func
(paren
r_int
id|i
)paren
(brace
r_while
c_loop
(paren
(paren
id|i
OL
id|SNDRV_CARDS
)paren
op_logical_and
(paren
id|port
(braket
id|i
)braket
op_ne
id|SNDRV_AUTO_PORT
)paren
)paren
(brace
op_increment
id|i
suffix:semicolon
)brace
multiline_comment|/* while */
r_return
id|i
suffix:semicolon
)brace
DECL|function|is_port_known
r_static
r_inline
r_int
id|__devinit
id|is_port_known
c_func
(paren
r_int
id|io
comma
r_struct
id|params
op_star
id|params
comma
r_int
id|cards
)paren
(brace
r_while
c_loop
(paren
op_decrement
id|cards
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|params
(braket
id|cards
)braket
dot
id|port
op_eq
id|io
)paren
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* while */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sscape_pnp_detect
r_static
r_int
id|__devinit
id|sscape_pnp_detect
c_func
(paren
r_struct
id|pnp_card_link
op_star
id|pcard
comma
r_const
r_struct
id|pnp_card_device_id
op_star
id|pid
)paren
(brace
r_struct
id|pnp_dev
op_star
id|dev
suffix:semicolon
r_static
r_int
id|idx
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; * Allow this function to fail *quietly* if all the ISA PnP&n;&t; * devices were configured using module parameters instead.&n;&t; */
r_if
c_cond
(paren
(paren
id|idx
op_assign
id|get_next_autoindex
c_func
(paren
id|idx
)paren
)paren
op_ge
id|SNDRV_CARDS
)paren
(brace
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We have found a candidate ISA PnP card. Now we&n;&t; * have to check that it has the devices that we&n;&t; * expect it to have.&n;&t; *&n;&t; * We will NOT try and autoconfigure all of the resources&n;&t; * needed and then activate the card as we are assuming that&n;&t; * has already been done at boot-time using /proc/isapnp.&n;&t; * We shall simply try to give each active card the resources&n;&t; * that it wants. This is a sensible strategy for a modular&n;&t; * system where unused modules are unloaded regularly.&n;&t; *&n;&t; * This strategy is utterly useless if we compile the driver&n;&t; * into the kernel, of course.&n;&t; */
singleline_comment|// printk(KERN_INFO &quot;sscape: %s&bslash;n&quot;, card-&gt;name);
multiline_comment|/*&n;&t; * Check that we still have room for another sound card ...&n;&t; */
r_if
c_cond
(paren
id|sscape_cards
op_ge
id|SNDRV_CARDS
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sscape: No room for another ALSA device&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|dev
op_assign
id|pnp_request_card_device
c_func
(paren
id|pcard
comma
id|pid-&gt;devs
(braket
l_int|0
)braket
dot
id|id
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
(brace
r_struct
id|params
op_star
id|this
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pnp_is_active
c_func
(paren
id|dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|pnp_activate_dev
c_func
(paren
id|dev
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;sscape: device is inactive&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Read the correct parameters off the ISA PnP bus ...&n;&t;&t; */
id|this
op_assign
id|init_params
c_func
(paren
op_amp
id|sscape_params
(braket
id|sscape_cards
)braket
comma
id|index
(braket
id|idx
)braket
comma
id|id
(braket
id|idx
)braket
comma
id|pnp_port_start
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|pnp_irq
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|pnp_irq
c_func
(paren
id|dev
comma
l_int|1
)paren
comma
id|pnp_dma
c_func
(paren
id|dev
comma
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Do we know about this sound card already?&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|is_port_known
c_func
(paren
id|this-&gt;port
comma
id|sscape_params
comma
id|sscape_cards
)paren
)paren
(brace
id|snd_card_t
op_star
id|card
suffix:semicolon
id|ret
op_assign
id|create_sscape
c_func
(paren
id|this
comma
op_amp
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|snd_card_set_dev
c_func
(paren
id|card
comma
op_amp
id|pcard-&gt;card-&gt;dev
)paren
suffix:semicolon
id|pnp_set_card_drvdata
c_func
(paren
id|pcard
comma
id|card
)paren
suffix:semicolon
op_increment
id|sscape_cards
suffix:semicolon
op_increment
id|idx
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sscape_pnp_remove
r_static
r_void
id|__devexit
id|sscape_pnp_remove
c_func
(paren
r_struct
id|pnp_card_link
op_star
id|pcard
)paren
(brace
id|snd_card_t
op_star
id|card
op_assign
(paren
id|snd_card_t
op_star
)paren
id|pnp_get_card_drvdata
c_func
(paren
id|pcard
)paren
suffix:semicolon
id|pnp_set_card_drvdata
c_func
(paren
id|pcard
comma
l_int|NULL
)paren
suffix:semicolon
id|snd_card_disconnect
c_func
(paren
id|card
)paren
suffix:semicolon
id|snd_card_free_in_thread
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
DECL|variable|sscape_pnpc_driver
r_static
r_struct
id|pnp_card_driver
id|sscape_pnpc_driver
op_assign
(brace
dot
id|flags
op_assign
id|PNP_DRIVER_RES_DO_NOT_CHANGE
comma
dot
id|name
op_assign
l_string|&quot;sscape&quot;
comma
dot
id|id_table
op_assign
id|sscape_pnpids
comma
dot
id|probe
op_assign
id|sscape_pnp_detect
comma
dot
id|remove
op_assign
id|__devexit_p
c_func
(paren
id|sscape_pnp_remove
)paren
comma
)brace
suffix:semicolon
macro_line|#endif /* CONFIG_PNP */
DECL|function|sscape_manual_probe
r_static
r_int
id|__init
id|sscape_manual_probe
c_func
(paren
r_struct
id|params
op_star
id|params
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|i
suffix:semicolon
id|snd_card_t
op_star
id|card
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SNDRV_CARDS
suffix:semicolon
op_increment
id|i
)paren
(brace
multiline_comment|/*&n;&t;&t; * We do NOT probe for ports.&n;&t;&t; * If we&squot;re not given a port number for this&n;&t;&t; * card then we completely ignore this line&n;&t;&t; * of parameters.&n;&t;&t; */
r_if
c_cond
(paren
id|port
(braket
id|i
)braket
op_eq
id|SNDRV_AUTO_PORT
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure we were given ALL of the other parameters.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|irq
(braket
id|i
)braket
op_eq
id|SNDRV_AUTO_IRQ
)paren
op_logical_or
(paren
id|mpu_irq
(braket
id|i
)braket
op_eq
id|SNDRV_AUTO_IRQ
)paren
op_logical_or
(paren
id|dma
(braket
id|i
)braket
op_eq
id|SNDRV_AUTO_DMA
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;sscape: insufficient parameters, need IO, IRQ, MPU-IRQ and DMA&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * This cards looks OK ...&n;&t;&t; */
id|init_params
c_func
(paren
id|params
comma
id|index
(braket
id|i
)braket
comma
id|id
(braket
id|i
)braket
comma
id|port
(braket
id|i
)braket
comma
id|irq
(braket
id|i
)braket
comma
id|mpu_irq
(braket
id|i
)braket
comma
id|dma
(braket
id|i
)braket
)paren
suffix:semicolon
id|ret
op_assign
id|create_sscape
c_func
(paren
id|params
comma
op_amp
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|sscape_card
(braket
id|sscape_cards
)braket
op_assign
id|card
suffix:semicolon
id|params
op_increment
suffix:semicolon
id|sscape_cards
op_increment
suffix:semicolon
)brace
multiline_comment|/* for */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sscape_exit
r_static
r_void
id|sscape_exit
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
macro_line|#ifdef CONFIG_PNP
id|pnp_unregister_card_driver
c_func
(paren
op_amp
id|sscape_pnpc_driver
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|sscape_card
)paren
suffix:semicolon
op_increment
id|i
)paren
(brace
id|snd_card_free
c_func
(paren
id|sscape_card
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* for */
)brace
DECL|function|sscape_init
r_static
r_int
id|__init
id|sscape_init
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; * First check whether we were passed any parameters.&n;&t; * These MUST take precedence over ANY automatic way&n;&t; * of allocating cards, because the operator is&n;&t; * S-P-E-L-L-I-N-G it out for us...&n;&t; */
id|ret
op_assign
id|sscape_manual_probe
c_func
(paren
id|sscape_params
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sscape_cards
suffix:semicolon
op_increment
id|i
)paren
id|snd_card_free
c_func
(paren
id|sscape_card
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PNP
r_if
c_cond
(paren
id|sscape_cards
OL
id|SNDRV_CARDS
)paren
(brace
id|ret
op_assign
id|pnp_register_card_driver
c_func
(paren
op_amp
id|sscape_pnpc_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|sscape_exit
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|sscape_init
id|module_init
c_func
(paren
id|sscape_init
)paren
suffix:semicolon
DECL|variable|sscape_exit
id|module_exit
c_func
(paren
id|sscape_exit
)paren
suffix:semicolon
eof
