multiline_comment|/*&n; *  Information interface for ALSA driver&n; *  Copyright (c) by Jaroslav Kysela &lt;perex@suse.cz&gt;&n; *&n; *&n; *   This program is free software; you can redistribute it and/or modify&n; *   it under the terms of the GNU General Public License as published by&n; *   the Free Software Foundation; either version 2 of the License, or&n; *   (at your option) any later version.&n; *&n; *   This program is distributed in the hope that it will be useful,&n; *   but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *   GNU General Public License for more details.&n; *&n; *   You should have received a copy of the GNU General Public License&n; *   along with this program; if not, write to the Free Software&n; *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA&n; *&n; */
macro_line|#include &lt;sound/driver.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;sound/core.h&gt;
macro_line|#include &lt;sound/minors.h&gt;
macro_line|#include &lt;sound/info.h&gt;
macro_line|#include &lt;sound/version.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;stdarg.h&gt;
multiline_comment|/*&n; *&n; */
DECL|function|snd_info_check_reserved_words
r_int
id|snd_info_check_reserved_words
c_func
(paren
r_const
r_char
op_star
id|str
)paren
(brace
r_static
r_char
op_star
id|reserved
(braket
)braket
op_assign
(brace
l_string|&quot;version&quot;
comma
l_string|&quot;meminfo&quot;
comma
l_string|&quot;memdebug&quot;
comma
l_string|&quot;detect&quot;
comma
l_string|&quot;devices&quot;
comma
l_string|&quot;oss&quot;
comma
l_string|&quot;cards&quot;
comma
l_string|&quot;timers&quot;
comma
l_string|&quot;synth&quot;
comma
l_string|&quot;pcm&quot;
comma
l_string|&quot;seq&quot;
comma
l_int|NULL
)brace
suffix:semicolon
r_char
op_star
op_star
id|xstr
op_assign
id|reserved
suffix:semicolon
r_while
c_loop
(paren
op_star
id|xstr
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
op_star
id|xstr
comma
id|str
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|xstr
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|str
comma
l_string|&quot;card&quot;
comma
l_int|4
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
r_static
id|DECLARE_MUTEX
c_func
(paren
id|info_mutex
)paren
suffix:semicolon
DECL|struct|_snd_info_private_data
r_typedef
r_struct
id|_snd_info_private_data
(brace
DECL|member|rbuffer
id|snd_info_buffer_t
op_star
id|rbuffer
suffix:semicolon
DECL|member|wbuffer
id|snd_info_buffer_t
op_star
id|wbuffer
suffix:semicolon
DECL|member|entry
id|snd_info_entry_t
op_star
id|entry
suffix:semicolon
DECL|member|file_private_data
r_void
op_star
id|file_private_data
suffix:semicolon
DECL|typedef|snd_info_private_data_t
)brace
id|snd_info_private_data_t
suffix:semicolon
r_static
r_int
id|snd_info_version_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|snd_info_version_done
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/**&n; * snd_iprintf - printf on the procfs buffer&n; * @buffer: the procfs buffer&n; * @fmt: the printf format&n; *&n; * Outputs the string on the procfs buffer just like printf().&n; *&n; * Returns the size of output string.&n; */
DECL|function|snd_iprintf
r_int
id|snd_iprintf
c_func
(paren
id|snd_info_buffer_t
op_star
id|buffer
comma
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_int
id|res
suffix:semicolon
r_char
id|sbuffer
(braket
l_int|512
)braket
suffix:semicolon
r_if
c_cond
(paren
id|buffer-&gt;stop
op_logical_or
id|buffer-&gt;error
)paren
r_return
l_int|0
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|res
op_assign
id|vscnprintf
c_func
(paren
id|sbuffer
comma
r_sizeof
(paren
id|sbuffer
)paren
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer-&gt;size
op_plus
id|res
op_ge
id|buffer-&gt;len
)paren
(brace
id|buffer-&gt;stop
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|buffer-&gt;curr
comma
id|sbuffer
)paren
suffix:semicolon
id|buffer-&gt;curr
op_add_assign
id|res
suffix:semicolon
id|buffer-&gt;size
op_add_assign
id|res
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/*&n;&n; */
DECL|variable|snd_proc_root
r_static
r_struct
id|proc_dir_entry
op_star
id|snd_proc_root
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|snd_seq_root
id|snd_info_entry_t
op_star
id|snd_seq_root
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef CONFIG_SND_OSSEMUL
DECL|variable|snd_oss_root
id|snd_info_entry_t
op_star
id|snd_oss_root
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
DECL|function|snd_info_entry_prepare
r_static
r_inline
r_void
id|snd_info_entry_prepare
c_func
(paren
r_struct
id|proc_dir_entry
op_star
id|de
)paren
(brace
id|de-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
)brace
DECL|function|snd_remove_proc_entry
r_void
id|snd_remove_proc_entry
c_func
(paren
r_struct
id|proc_dir_entry
op_star
id|parent
comma
r_struct
id|proc_dir_entry
op_star
id|de
)paren
(brace
r_if
c_cond
(paren
id|de
)paren
id|remove_proc_entry
c_func
(paren
id|de-&gt;name
comma
id|parent
)paren
suffix:semicolon
)brace
DECL|function|snd_info_entry_llseek
r_static
id|loff_t
id|snd_info_entry_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|orig
)paren
(brace
id|snd_info_private_data_t
op_star
id|data
suffix:semicolon
r_struct
id|snd_info_entry
op_star
id|entry
suffix:semicolon
id|loff_t
id|ret
suffix:semicolon
id|data
op_assign
id|file-&gt;private_data
suffix:semicolon
id|entry
op_assign
id|data-&gt;entry
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|entry-&gt;content
)paren
(brace
r_case
id|SNDRV_INFO_CONTENT_TEXT
suffix:colon
r_switch
c_cond
(paren
id|orig
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* SEEK_SET */
id|file-&gt;f_pos
op_assign
id|offset
suffix:semicolon
id|ret
op_assign
id|file-&gt;f_pos
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* SEEK_CUR */
id|file-&gt;f_pos
op_add_assign
id|offset
suffix:semicolon
id|ret
op_assign
id|file-&gt;f_pos
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* SEEK_END */
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SNDRV_INFO_CONTENT_DATA
suffix:colon
r_if
c_cond
(paren
id|entry-&gt;c.ops-&gt;llseek
)paren
(brace
id|ret
op_assign
id|entry-&gt;c.ops
op_member_access_from_pointer
id|llseek
c_func
(paren
id|entry
comma
id|data-&gt;file_private_data
comma
id|file
comma
id|offset
comma
id|orig
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|snd_info_entry_read
r_static
id|ssize_t
id|snd_info_entry_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
id|__user
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|offset
)paren
(brace
id|snd_info_private_data_t
op_star
id|data
suffix:semicolon
r_struct
id|snd_info_entry
op_star
id|entry
suffix:semicolon
id|snd_info_buffer_t
op_star
id|buf
suffix:semicolon
r_int
id|size
op_assign
l_int|0
suffix:semicolon
id|loff_t
id|pos
suffix:semicolon
id|data
op_assign
id|file-&gt;private_data
suffix:semicolon
id|snd_assert
c_func
(paren
id|data
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENXIO
)paren
suffix:semicolon
id|pos
op_assign
op_star
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
op_logical_or
(paren
r_int
)paren
id|pos
op_ne
id|pos
op_logical_or
(paren
id|ssize_t
)paren
id|count
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|pos
op_plus
(paren
r_int
r_int
)paren
id|count
OL
(paren
r_int
r_int
)paren
id|pos
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|entry
op_assign
id|data-&gt;entry
suffix:semicolon
r_switch
c_cond
(paren
id|entry-&gt;content
)paren
(brace
r_case
id|SNDRV_INFO_CONTENT_TEXT
suffix:colon
id|buf
op_assign
id|data-&gt;rbuffer
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|buf-&gt;size
)paren
r_return
l_int|0
suffix:semicolon
id|size
op_assign
id|buf-&gt;size
op_minus
id|pos
suffix:semicolon
id|size
op_assign
id|min
c_func
(paren
id|count
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
id|buf-&gt;buffer
op_plus
id|pos
comma
id|size
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDRV_INFO_CONTENT_DATA
suffix:colon
r_if
c_cond
(paren
id|entry-&gt;c.ops-&gt;read
)paren
id|size
op_assign
id|entry-&gt;c.ops
op_member_access_from_pointer
id|read
c_func
(paren
id|entry
comma
id|data-&gt;file_private_data
comma
id|file
comma
id|buffer
comma
id|count
comma
id|pos
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ssize_t
)paren
id|size
OG
l_int|0
)paren
op_star
id|offset
op_assign
id|pos
op_plus
id|size
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
DECL|function|snd_info_entry_write
r_static
id|ssize_t
id|snd_info_entry_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
id|__user
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|offset
)paren
(brace
id|snd_info_private_data_t
op_star
id|data
suffix:semicolon
r_struct
id|snd_info_entry
op_star
id|entry
suffix:semicolon
id|snd_info_buffer_t
op_star
id|buf
suffix:semicolon
r_int
id|size
op_assign
l_int|0
suffix:semicolon
id|loff_t
id|pos
suffix:semicolon
id|data
op_assign
id|file-&gt;private_data
suffix:semicolon
id|snd_assert
c_func
(paren
id|data
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENXIO
)paren
suffix:semicolon
id|entry
op_assign
id|data-&gt;entry
suffix:semicolon
id|pos
op_assign
op_star
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
op_logical_or
(paren
r_int
)paren
id|pos
op_ne
id|pos
op_logical_or
(paren
id|ssize_t
)paren
id|count
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|pos
op_plus
(paren
r_int
r_int
)paren
id|count
OL
(paren
r_int
r_int
)paren
id|pos
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_switch
c_cond
(paren
id|entry-&gt;content
)paren
(brace
r_case
id|SNDRV_INFO_CONTENT_TEXT
suffix:colon
id|buf
op_assign
id|data-&gt;wbuffer
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|buf-&gt;len
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|size
op_assign
id|buf-&gt;len
op_minus
id|pos
suffix:semicolon
id|size
op_assign
id|min
c_func
(paren
id|count
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|buf-&gt;buffer
op_plus
id|pos
comma
id|buffer
comma
id|size
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|buf-&gt;size
OL
id|pos
op_plus
id|size
)paren
id|buf-&gt;size
op_assign
id|pos
op_plus
id|size
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDRV_INFO_CONTENT_DATA
suffix:colon
r_if
c_cond
(paren
id|entry-&gt;c.ops-&gt;write
)paren
id|size
op_assign
id|entry-&gt;c.ops
op_member_access_from_pointer
id|write
c_func
(paren
id|entry
comma
id|data-&gt;file_private_data
comma
id|file
comma
id|buffer
comma
id|count
comma
id|pos
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ssize_t
)paren
id|size
OG
l_int|0
)paren
op_star
id|offset
op_assign
id|pos
op_plus
id|size
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
DECL|function|snd_info_entry_open
r_static
r_int
id|snd_info_entry_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|snd_info_entry_t
op_star
id|entry
suffix:semicolon
id|snd_info_private_data_t
op_star
id|data
suffix:semicolon
id|snd_info_buffer_t
op_star
id|buffer
suffix:semicolon
r_struct
id|proc_dir_entry
op_star
id|p
suffix:semicolon
r_int
id|mode
comma
id|err
suffix:semicolon
id|down
c_func
(paren
op_amp
id|info_mutex
)paren
suffix:semicolon
id|p
op_assign
id|PDE
c_func
(paren
id|inode
)paren
suffix:semicolon
id|entry
op_assign
id|p
op_eq
l_int|NULL
ques
c_cond
l_int|NULL
suffix:colon
(paren
id|snd_info_entry_t
op_star
)paren
id|p-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
op_logical_or
id|entry-&gt;disconnected
)paren
(brace
id|up
c_func
(paren
op_amp
id|info_mutex
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|try_module_get
c_func
(paren
id|entry-&gt;module
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|__error1
suffix:semicolon
)brace
id|mode
op_assign
id|file-&gt;f_flags
op_amp
id|O_ACCMODE
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|O_RDONLY
op_logical_or
id|mode
op_eq
id|O_RDWR
)paren
(brace
r_if
c_cond
(paren
(paren
id|entry-&gt;content
op_eq
id|SNDRV_INFO_CONTENT_TEXT
op_logical_and
op_logical_neg
id|entry-&gt;c.text.read_size
)paren
op_logical_or
(paren
id|entry-&gt;content
op_eq
id|SNDRV_INFO_CONTENT_DATA
op_logical_and
id|entry-&gt;c.ops-&gt;read
op_eq
l_int|NULL
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|__error
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|mode
op_eq
id|O_WRONLY
op_logical_or
id|mode
op_eq
id|O_RDWR
)paren
(brace
r_if
c_cond
(paren
(paren
id|entry-&gt;content
op_eq
id|SNDRV_INFO_CONTENT_TEXT
op_logical_and
op_logical_neg
id|entry-&gt;c.text.write_size
)paren
op_logical_or
(paren
id|entry-&gt;content
op_eq
id|SNDRV_INFO_CONTENT_DATA
op_logical_and
id|entry-&gt;c.ops-&gt;write
op_eq
l_int|NULL
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|__error
suffix:semicolon
)brace
)brace
id|data
op_assign
id|kcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|data
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|__error
suffix:semicolon
)brace
id|data-&gt;entry
op_assign
id|entry
suffix:semicolon
r_switch
c_cond
(paren
id|entry-&gt;content
)paren
(brace
r_case
id|SNDRV_INFO_CONTENT_TEXT
suffix:colon
r_if
c_cond
(paren
id|mode
op_eq
id|O_RDONLY
op_logical_or
id|mode
op_eq
id|O_RDWR
)paren
(brace
id|buffer
op_assign
id|kcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|buffer
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|data
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|__error
suffix:semicolon
)brace
id|buffer-&gt;len
op_assign
(paren
id|entry-&gt;c.text.read_size
op_plus
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
op_amp
op_complement
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|buffer-&gt;buffer
op_assign
id|vmalloc
c_func
(paren
id|buffer-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer-&gt;buffer
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|data
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|__error
suffix:semicolon
)brace
id|buffer-&gt;curr
op_assign
id|buffer-&gt;buffer
suffix:semicolon
id|data-&gt;rbuffer
op_assign
id|buffer
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode
op_eq
id|O_WRONLY
op_logical_or
id|mode
op_eq
id|O_RDWR
)paren
(brace
id|buffer
op_assign
id|kcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|buffer
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|mode
op_eq
id|O_RDWR
)paren
(brace
id|vfree
c_func
(paren
id|data-&gt;rbuffer-&gt;buffer
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|data-&gt;rbuffer
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|data
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|__error
suffix:semicolon
)brace
id|buffer-&gt;len
op_assign
(paren
id|entry-&gt;c.text.write_size
op_plus
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
op_amp
op_complement
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|buffer-&gt;buffer
op_assign
id|vmalloc
c_func
(paren
id|buffer-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer-&gt;buffer
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|mode
op_eq
id|O_RDWR
)paren
(brace
id|vfree
c_func
(paren
id|data-&gt;rbuffer-&gt;buffer
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|data-&gt;rbuffer
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|data
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|__error
suffix:semicolon
)brace
id|buffer-&gt;curr
op_assign
id|buffer-&gt;buffer
suffix:semicolon
id|data-&gt;wbuffer
op_assign
id|buffer
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SNDRV_INFO_CONTENT_DATA
suffix:colon
multiline_comment|/* data */
r_if
c_cond
(paren
id|entry-&gt;c.ops-&gt;open
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|entry-&gt;c.ops
op_member_access_from_pointer
id|open
c_func
(paren
id|entry
comma
id|mode
comma
op_amp
id|data-&gt;file_private_data
)paren
)paren
OL
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|data
)paren
suffix:semicolon
r_goto
id|__error
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
id|file-&gt;private_data
op_assign
id|data
suffix:semicolon
id|up
c_func
(paren
op_amp
id|info_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;content
op_eq
id|SNDRV_INFO_CONTENT_TEXT
op_logical_and
(paren
id|mode
op_eq
id|O_RDONLY
op_logical_or
id|mode
op_eq
id|O_RDWR
)paren
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;c.text.read
)paren
(brace
id|down
c_func
(paren
op_amp
id|entry-&gt;access
)paren
suffix:semicolon
id|entry-&gt;c.text
dot
id|read
c_func
(paren
id|entry
comma
id|data-&gt;rbuffer
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|entry-&gt;access
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
id|__error
suffix:colon
id|module_put
c_func
(paren
id|entry-&gt;module
)paren
suffix:semicolon
id|__error1
suffix:colon
id|up
c_func
(paren
op_amp
id|info_mutex
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|snd_info_entry_release
r_static
r_int
id|snd_info_entry_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|snd_info_entry_t
op_star
id|entry
suffix:semicolon
id|snd_info_private_data_t
op_star
id|data
suffix:semicolon
r_int
id|mode
suffix:semicolon
id|mode
op_assign
id|file-&gt;f_flags
op_amp
id|O_ACCMODE
suffix:semicolon
id|data
op_assign
id|file-&gt;private_data
suffix:semicolon
id|entry
op_assign
id|data-&gt;entry
suffix:semicolon
r_switch
c_cond
(paren
id|entry-&gt;content
)paren
(brace
r_case
id|SNDRV_INFO_CONTENT_TEXT
suffix:colon
r_if
c_cond
(paren
id|mode
op_eq
id|O_RDONLY
op_logical_or
id|mode
op_eq
id|O_RDWR
)paren
(brace
id|vfree
c_func
(paren
id|data-&gt;rbuffer-&gt;buffer
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|data-&gt;rbuffer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode
op_eq
id|O_WRONLY
op_logical_or
id|mode
op_eq
id|O_RDWR
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;c.text.write
)paren
(brace
id|entry-&gt;c.text
dot
id|write
c_func
(paren
id|entry
comma
id|data-&gt;wbuffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;wbuffer-&gt;error
)paren
(brace
id|snd_printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;data write error to %s (%i)&bslash;n&quot;
comma
id|entry-&gt;name
comma
id|data-&gt;wbuffer-&gt;error
)paren
suffix:semicolon
)brace
)brace
id|vfree
c_func
(paren
id|data-&gt;wbuffer-&gt;buffer
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|data-&gt;wbuffer
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SNDRV_INFO_CONTENT_DATA
suffix:colon
r_if
c_cond
(paren
id|entry-&gt;c.ops-&gt;release
)paren
id|entry-&gt;c.ops
op_member_access_from_pointer
id|release
c_func
(paren
id|entry
comma
id|mode
comma
id|data-&gt;file_private_data
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|module_put
c_func
(paren
id|entry-&gt;module
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|snd_info_entry_poll
r_static
r_int
r_int
id|snd_info_entry_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
id|snd_info_private_data_t
op_star
id|data
suffix:semicolon
r_struct
id|snd_info_entry
op_star
id|entry
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
id|data
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|entry
op_assign
id|data-&gt;entry
suffix:semicolon
id|mask
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|entry-&gt;content
)paren
(brace
r_case
id|SNDRV_INFO_CONTENT_DATA
suffix:colon
r_if
c_cond
(paren
id|entry-&gt;c.ops-&gt;poll
)paren
r_return
id|entry-&gt;c.ops
op_member_access_from_pointer
id|poll
c_func
(paren
id|entry
comma
id|data-&gt;file_private_data
comma
id|file
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;c.ops-&gt;read
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;c.ops-&gt;write
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|mask
suffix:semicolon
)brace
DECL|function|_snd_info_entry_ioctl
r_static
r_inline
r_int
id|_snd_info_entry_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|snd_info_private_data_t
op_star
id|data
suffix:semicolon
r_struct
id|snd_info_entry
op_star
id|entry
suffix:semicolon
id|data
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|entry
op_assign
id|data-&gt;entry
suffix:semicolon
r_switch
c_cond
(paren
id|entry-&gt;content
)paren
(brace
r_case
id|SNDRV_INFO_CONTENT_DATA
suffix:colon
r_if
c_cond
(paren
id|entry-&gt;c.ops-&gt;ioctl
)paren
r_return
id|entry-&gt;c.ops
op_member_access_from_pointer
id|ioctl
c_func
(paren
id|entry
comma
id|data-&gt;file_private_data
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
op_minus
id|ENOTTY
suffix:semicolon
)brace
multiline_comment|/* FIXME: need to unlock BKL to allow preemption */
DECL|function|snd_info_entry_ioctl
r_static
r_int
id|snd_info_entry_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
id|_snd_info_entry_ioctl
c_func
(paren
id|inode
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|snd_info_entry_mmap
r_static
r_int
id|snd_info_entry_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|snd_info_private_data_t
op_star
id|data
suffix:semicolon
r_struct
id|snd_info_entry
op_star
id|entry
suffix:semicolon
id|data
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|entry
op_assign
id|data-&gt;entry
suffix:semicolon
r_switch
c_cond
(paren
id|entry-&gt;content
)paren
(brace
r_case
id|SNDRV_INFO_CONTENT_DATA
suffix:colon
r_if
c_cond
(paren
id|entry-&gt;c.ops-&gt;mmap
)paren
r_return
id|entry-&gt;c.ops
op_member_access_from_pointer
id|mmap
c_func
(paren
id|entry
comma
id|data-&gt;file_private_data
comma
id|inode
comma
id|file
comma
id|vma
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
DECL|variable|snd_info_entry_operations
r_static
r_struct
id|file_operations
id|snd_info_entry_operations
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|llseek
op_assign
id|snd_info_entry_llseek
comma
dot
id|read
op_assign
id|snd_info_entry_read
comma
dot
id|write
op_assign
id|snd_info_entry_write
comma
dot
id|poll
op_assign
id|snd_info_entry_poll
comma
dot
id|ioctl
op_assign
id|snd_info_entry_ioctl
comma
dot
id|mmap
op_assign
id|snd_info_entry_mmap
comma
dot
id|open
op_assign
id|snd_info_entry_open
comma
dot
id|release
op_assign
id|snd_info_entry_release
comma
)brace
suffix:semicolon
multiline_comment|/**&n; * snd_create_proc_entry - create a procfs entry&n; * @name: the name of the proc file&n; * @mode: the file permission bits, S_Ixxx&n; * @parent: the parent proc-directory entry&n; *&n; * Creates a new proc file entry with the given name and permission&n; * on the given directory.&n; *&n; * Returns the pointer of new instance or NULL on failure.&n; */
DECL|function|snd_create_proc_entry
r_struct
id|proc_dir_entry
op_star
id|snd_create_proc_entry
c_func
(paren
r_const
r_char
op_star
id|name
comma
id|mode_t
id|mode
comma
r_struct
id|proc_dir_entry
op_star
id|parent
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|p
suffix:semicolon
id|p
op_assign
id|create_proc_entry
c_func
(paren
id|name
comma
id|mode
comma
id|parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|snd_info_entry_prepare
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|function|snd_info_init
r_int
id|__init
id|snd_info_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|p
suffix:semicolon
id|p
op_assign
id|snd_create_proc_entry
c_func
(paren
l_string|&quot;asound&quot;
comma
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
comma
op_amp
id|proc_root
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|snd_proc_root
op_assign
id|p
suffix:semicolon
macro_line|#ifdef CONFIG_SND_OSSEMUL
(brace
id|snd_info_entry_t
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
(paren
id|entry
op_assign
id|snd_info_create_module_entry
c_func
(paren
id|THIS_MODULE
comma
l_string|&quot;oss&quot;
comma
l_int|NULL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|entry-&gt;mode
op_assign
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
suffix:semicolon
r_if
c_cond
(paren
id|snd_info_register
c_func
(paren
id|entry
)paren
OL
l_int|0
)paren
(brace
id|snd_info_free_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|snd_oss_root
op_assign
id|entry
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if defined(CONFIG_SND_SEQUENCER) || defined(CONFIG_SND_SEQUENCER_MODULE)
(brace
id|snd_info_entry_t
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
(paren
id|entry
op_assign
id|snd_info_create_module_entry
c_func
(paren
id|THIS_MODULE
comma
l_string|&quot;seq&quot;
comma
l_int|NULL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|entry-&gt;mode
op_assign
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
suffix:semicolon
r_if
c_cond
(paren
id|snd_info_register
c_func
(paren
id|entry
)paren
OL
l_int|0
)paren
(brace
id|snd_info_free_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|snd_seq_root
op_assign
id|entry
suffix:semicolon
)brace
macro_line|#endif
id|snd_info_version_init
c_func
(paren
)paren
suffix:semicolon
id|snd_memory_info_init
c_func
(paren
)paren
suffix:semicolon
id|snd_minor_info_init
c_func
(paren
)paren
suffix:semicolon
id|snd_minor_info_oss_init
c_func
(paren
)paren
suffix:semicolon
id|snd_card_info_init
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|snd_info_done
r_int
id|__exit
id|snd_info_done
c_func
(paren
r_void
)paren
(brace
id|snd_card_info_done
c_func
(paren
)paren
suffix:semicolon
id|snd_minor_info_oss_done
c_func
(paren
)paren
suffix:semicolon
id|snd_minor_info_done
c_func
(paren
)paren
suffix:semicolon
id|snd_memory_info_done
c_func
(paren
)paren
suffix:semicolon
id|snd_info_version_done
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|snd_proc_root
)paren
(brace
macro_line|#if defined(CONFIG_SND_SEQUENCER) || defined(CONFIG_SND_SEQUENCER_MODULE)
r_if
c_cond
(paren
id|snd_seq_root
)paren
id|snd_info_unregister
c_func
(paren
id|snd_seq_root
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SND_OSSEMUL
r_if
c_cond
(paren
id|snd_oss_root
)paren
id|snd_info_unregister
c_func
(paren
id|snd_oss_root
)paren
suffix:semicolon
macro_line|#endif
id|snd_remove_proc_entry
c_func
(paren
op_amp
id|proc_root
comma
id|snd_proc_root
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&n; */
multiline_comment|/*&n; * create a card proc file&n; * called from init.c&n; */
DECL|function|snd_info_card_create
r_int
id|snd_info_card_create
c_func
(paren
id|snd_card_t
op_star
id|card
)paren
(brace
r_char
id|str
(braket
l_int|8
)braket
suffix:semicolon
id|snd_info_entry_t
op_star
id|entry
suffix:semicolon
id|snd_assert
c_func
(paren
id|card
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENXIO
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|str
comma
l_string|&quot;card%i&quot;
comma
id|card-&gt;number
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|entry
op_assign
id|snd_info_create_module_entry
c_func
(paren
id|card-&gt;module
comma
id|str
comma
l_int|NULL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|entry-&gt;mode
op_assign
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
suffix:semicolon
r_if
c_cond
(paren
id|snd_info_register
c_func
(paren
id|entry
)paren
OL
l_int|0
)paren
(brace
id|snd_info_free_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|card-&gt;proc_root
op_assign
id|entry
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * register the card proc file&n; * called from init.c&n; */
DECL|function|snd_info_card_register
r_int
id|snd_info_card_register
c_func
(paren
id|snd_card_t
op_star
id|card
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|p
suffix:semicolon
id|snd_assert
c_func
(paren
id|card
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENXIO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|card-&gt;id
comma
id|card-&gt;proc_root-&gt;name
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|p
op_assign
id|proc_symlink
c_func
(paren
id|card-&gt;id
comma
id|snd_proc_root
comma
id|card-&gt;proc_root-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|card-&gt;proc_root_link
op_assign
id|p
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * de-register the card proc file&n; * called from init.c&n; */
DECL|function|snd_info_card_free
r_int
id|snd_info_card_free
c_func
(paren
id|snd_card_t
op_star
id|card
)paren
(brace
id|snd_assert
c_func
(paren
id|card
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENXIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|card-&gt;proc_root_link
)paren
(brace
id|snd_remove_proc_entry
c_func
(paren
id|snd_proc_root
comma
id|card-&gt;proc_root_link
)paren
suffix:semicolon
id|card-&gt;proc_root_link
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|card-&gt;proc_root
)paren
(brace
id|snd_info_unregister
c_func
(paren
id|card-&gt;proc_root
)paren
suffix:semicolon
id|card-&gt;proc_root
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * snd_info_get_line - read one line from the procfs buffer&n; * @buffer: the procfs buffer&n; * @line: the buffer to store&n; * @len: the max. buffer size - 1&n; *&n; * Reads one line from the buffer and stores the string.&n; *&n; * Returns zero if successful, or 1 if error or EOF.&n; */
DECL|function|snd_info_get_line
r_int
id|snd_info_get_line
c_func
(paren
id|snd_info_buffer_t
op_star
id|buffer
comma
r_char
op_star
id|line
comma
r_int
id|len
)paren
(brace
r_int
id|c
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
l_int|0
op_logical_or
id|buffer-&gt;stop
op_logical_or
id|buffer-&gt;error
)paren
r_return
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|len
OG
l_int|0
)paren
(brace
id|c
op_assign
op_star
id|buffer-&gt;curr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_if
c_cond
(paren
(paren
id|buffer-&gt;curr
op_minus
id|buffer-&gt;buffer
)paren
op_ge
(paren
r_int
)paren
id|buffer-&gt;size
)paren
(brace
id|buffer-&gt;stop
op_assign
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
op_star
id|line
op_increment
op_assign
id|c
suffix:semicolon
r_if
c_cond
(paren
(paren
id|buffer-&gt;curr
op_minus
id|buffer-&gt;buffer
)paren
op_ge
(paren
r_int
)paren
id|buffer-&gt;size
)paren
(brace
id|buffer-&gt;stop
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|c
op_ne
l_char|&squot;&bslash;n&squot;
op_logical_and
op_logical_neg
id|buffer-&gt;stop
)paren
(brace
id|c
op_assign
op_star
id|buffer-&gt;curr
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|buffer-&gt;curr
op_minus
id|buffer-&gt;buffer
)paren
op_ge
(paren
r_int
)paren
id|buffer-&gt;size
)paren
(brace
id|buffer-&gt;stop
op_assign
l_int|1
suffix:semicolon
)brace
)brace
op_star
id|line
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * snd_info_get_line - parse a string token&n; * @dest: the buffer to store the string token&n; * @src: the original string&n; * @len: the max. length of token - 1&n; *&n; * Parses the original string and copy a token to the given&n; * string buffer.&n; *&n; * Returns the updated pointer of the original string so that&n; * it can be used for the next call.&n; */
DECL|function|snd_info_get_str
r_char
op_star
id|snd_info_get_str
c_func
(paren
r_char
op_star
id|dest
comma
r_char
op_star
id|src
comma
r_int
id|len
)paren
(brace
r_int
id|c
suffix:semicolon
r_while
c_loop
(paren
op_star
id|src
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|src
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|src
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|src
op_eq
l_char|&squot;&quot;&squot;
op_logical_or
op_star
id|src
op_eq
l_char|&squot;&bslash;&squot;&squot;
)paren
(brace
id|c
op_assign
op_star
id|src
op_increment
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|len
OG
l_int|0
op_logical_and
op_star
id|src
op_logical_and
op_star
id|src
op_ne
id|c
)paren
(brace
op_star
id|dest
op_increment
op_assign
op_star
id|src
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|src
op_eq
id|c
)paren
id|src
op_increment
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
op_decrement
id|len
OG
l_int|0
op_logical_and
op_star
id|src
op_logical_and
op_star
id|src
op_ne
l_char|&squot; &squot;
op_logical_and
op_star
id|src
op_ne
l_char|&squot;&bslash;t&squot;
)paren
(brace
op_star
id|dest
op_increment
op_assign
op_star
id|src
op_increment
suffix:semicolon
)brace
)brace
op_star
id|dest
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|src
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|src
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|src
op_increment
suffix:semicolon
r_return
id|src
suffix:semicolon
)brace
multiline_comment|/**&n; * snd_info_create_entry - create an info entry&n; * @name: the proc file name&n; *&n; * Creates an info entry with the given file name and initializes as&n; * the default state.&n; *&n; * Usually called from other functions such as&n; * snd_info_create_card_entry().&n; *&n; * Returns the pointer of the new instance, or NULL on failure.&n; */
DECL|function|snd_info_create_entry
r_static
id|snd_info_entry_t
op_star
id|snd_info_create_entry
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
id|snd_info_entry_t
op_star
id|entry
suffix:semicolon
id|entry
op_assign
id|kcalloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
op_star
id|entry
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|entry-&gt;name
op_assign
id|snd_kmalloc_strdup
c_func
(paren
id|name
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;name
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|entry-&gt;mode
op_assign
id|S_IFREG
op_or
id|S_IRUGO
suffix:semicolon
id|entry-&gt;content
op_assign
id|SNDRV_INFO_CONTENT_TEXT
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|entry-&gt;access
)paren
suffix:semicolon
r_return
id|entry
suffix:semicolon
)brace
multiline_comment|/**&n; * snd_info_create_module_entry - create an info entry for the given module&n; * @module: the module pointer&n; * @name: the file name&n; * @parent: the parent directory&n; *&n; * Creates a new info entry and assigns it to the given module.&n; *&n; * Returns the pointer of the new instance, or NULL on failure.&n; */
DECL|function|snd_info_create_module_entry
id|snd_info_entry_t
op_star
id|snd_info_create_module_entry
c_func
(paren
r_struct
id|module
op_star
id|module
comma
r_const
r_char
op_star
id|name
comma
id|snd_info_entry_t
op_star
id|parent
)paren
(brace
id|snd_info_entry_t
op_star
id|entry
op_assign
id|snd_info_create_entry
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
(brace
id|entry-&gt;module
op_assign
id|module
suffix:semicolon
id|entry-&gt;parent
op_assign
id|parent
suffix:semicolon
)brace
r_return
id|entry
suffix:semicolon
)brace
multiline_comment|/**&n; * snd_info_create_card_entry - create an info entry for the given card&n; * @card: the card instance&n; * @name: the file name&n; * @parent: the parent directory&n; *&n; * Creates a new info entry and assigns it to the given card.&n; *&n; * Returns the pointer of the new instance, or NULL on failure.&n; */
DECL|function|snd_info_create_card_entry
id|snd_info_entry_t
op_star
id|snd_info_create_card_entry
c_func
(paren
id|snd_card_t
op_star
id|card
comma
r_const
r_char
op_star
id|name
comma
id|snd_info_entry_t
op_star
id|parent
)paren
(brace
id|snd_info_entry_t
op_star
id|entry
op_assign
id|snd_info_create_entry
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
(brace
id|entry-&gt;module
op_assign
id|card-&gt;module
suffix:semicolon
id|entry-&gt;card
op_assign
id|card
suffix:semicolon
id|entry-&gt;parent
op_assign
id|parent
suffix:semicolon
)brace
r_return
id|entry
suffix:semicolon
)brace
DECL|function|snd_info_dev_free_entry
r_static
r_int
id|snd_info_dev_free_entry
c_func
(paren
id|snd_device_t
op_star
id|device
)paren
(brace
id|snd_info_entry_t
op_star
id|entry
op_assign
id|device-&gt;device_data
suffix:semicolon
id|snd_info_free_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|snd_info_dev_register_entry
r_static
r_int
id|snd_info_dev_register_entry
c_func
(paren
id|snd_device_t
op_star
id|device
)paren
(brace
id|snd_info_entry_t
op_star
id|entry
op_assign
id|device-&gt;device_data
suffix:semicolon
r_return
id|snd_info_register
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
DECL|function|snd_info_dev_disconnect_entry
r_static
r_int
id|snd_info_dev_disconnect_entry
c_func
(paren
id|snd_device_t
op_star
id|device
)paren
(brace
id|snd_info_entry_t
op_star
id|entry
op_assign
id|device-&gt;device_data
suffix:semicolon
id|entry-&gt;disconnected
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|snd_info_dev_unregister_entry
r_static
r_int
id|snd_info_dev_unregister_entry
c_func
(paren
id|snd_device_t
op_star
id|device
)paren
(brace
id|snd_info_entry_t
op_star
id|entry
op_assign
id|device-&gt;device_data
suffix:semicolon
r_return
id|snd_info_unregister
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * snd_card_proc_new - create an info entry for the given card&n; * @card: the card instance&n; * @name: the file name&n; * @entryp: the pointer to store the new info entry&n; *&n; * Creates a new info entry and assigns it to the given card.&n; * Unlike snd_info_create_card_entry(), this function registers the&n; * info entry as an ALSA device component, so that it can be&n; * unregistered/released without explicit call.&n; * Also, you don&squot;t have to register this entry via snd_info_register(),&n; * since this will be registered by snd_card_register() automatically.&n; *&n; * The parent is assumed as card-&gt;proc_root.&n; *&n; * For releasing this entry, use snd_device_free() instead of&n; * snd_info_free_entry(). &n; *&n; * Returns zero if successful, or a negative error code on failure.&n; */
DECL|function|snd_card_proc_new
r_int
id|snd_card_proc_new
c_func
(paren
id|snd_card_t
op_star
id|card
comma
r_const
r_char
op_star
id|name
comma
id|snd_info_entry_t
op_star
op_star
id|entryp
)paren
(brace
r_static
id|snd_device_ops_t
id|ops
op_assign
(brace
dot
id|dev_free
op_assign
id|snd_info_dev_free_entry
comma
dot
id|dev_register
op_assign
id|snd_info_dev_register_entry
comma
dot
id|dev_disconnect
op_assign
id|snd_info_dev_disconnect_entry
comma
dot
id|dev_unregister
op_assign
id|snd_info_dev_unregister_entry
)brace
suffix:semicolon
id|snd_info_entry_t
op_star
id|entry
suffix:semicolon
r_int
id|err
suffix:semicolon
id|entry
op_assign
id|snd_info_create_card_entry
c_func
(paren
id|card
comma
id|name
comma
id|card-&gt;proc_root
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_device_new
c_func
(paren
id|card
comma
id|SNDRV_DEV_INFO
comma
id|entry
comma
op_amp
id|ops
)paren
)paren
OL
l_int|0
)paren
(brace
id|snd_info_free_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entryp
)paren
op_star
id|entryp
op_assign
id|entry
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * snd_info_free_entry - release the info entry&n; * @entry: the info entry&n; *&n; * Releases the info entry.  Don&squot;t call this after registered.&n; */
DECL|function|snd_info_free_entry
r_void
id|snd_info_free_entry
c_func
(paren
id|snd_info_entry_t
op_star
id|entry
)paren
(brace
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;name
)paren
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|entry-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;private_free
)paren
id|entry
op_member_access_from_pointer
id|private_free
c_func
(paren
id|entry
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * snd_info_register - register the info entry&n; * @entry: the info entry&n; *&n; * Registers the proc info entry.&n; *&n; * Returns zero if successful, or a negative error code on failure.&n; */
DECL|function|snd_info_register
r_int
id|snd_info_register
c_func
(paren
id|snd_info_entry_t
op_star
id|entry
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|root
comma
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
id|snd_assert
c_func
(paren
id|entry
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENXIO
)paren
suffix:semicolon
id|root
op_assign
id|entry-&gt;parent
op_eq
l_int|NULL
ques
c_cond
id|snd_proc_root
suffix:colon
id|entry-&gt;parent-&gt;p
suffix:semicolon
id|down
c_func
(paren
op_amp
id|info_mutex
)paren
suffix:semicolon
id|p
op_assign
id|snd_create_proc_entry
c_func
(paren
id|entry-&gt;name
comma
id|entry-&gt;mode
comma
id|root
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|up
c_func
(paren
op_amp
id|info_mutex
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|p-&gt;owner
op_assign
id|entry-&gt;module
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|entry-&gt;mode
)paren
)paren
id|p-&gt;proc_fops
op_assign
op_amp
id|snd_info_entry_operations
suffix:semicolon
id|p-&gt;size
op_assign
id|entry-&gt;size
suffix:semicolon
id|p-&gt;data
op_assign
id|entry
suffix:semicolon
id|entry-&gt;p
op_assign
id|p
suffix:semicolon
id|up
c_func
(paren
op_amp
id|info_mutex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * snd_info_unregister - de-register the info entry&n; * @entry: the info entry&n; *&n; * De-registers the info entry and releases the instance.&n; *&n; * Returns zero if successful, or a negative error code on failure.&n; */
DECL|function|snd_info_unregister
r_int
id|snd_info_unregister
c_func
(paren
id|snd_info_entry_t
op_star
id|entry
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|root
suffix:semicolon
id|snd_assert
c_func
(paren
id|entry
op_ne
l_int|NULL
op_logical_and
id|entry-&gt;p
op_ne
l_int|NULL
comma
r_return
op_minus
id|ENXIO
)paren
suffix:semicolon
id|root
op_assign
id|entry-&gt;parent
op_eq
l_int|NULL
ques
c_cond
id|snd_proc_root
suffix:colon
id|entry-&gt;parent-&gt;p
suffix:semicolon
id|snd_assert
c_func
(paren
id|root
comma
r_return
op_minus
id|ENXIO
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|info_mutex
)paren
suffix:semicolon
id|snd_remove_proc_entry
c_func
(paren
id|root
comma
id|entry-&gt;p
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|info_mutex
)paren
suffix:semicolon
id|snd_info_free_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&n; */
DECL|variable|snd_info_version_entry
r_static
id|snd_info_entry_t
op_star
id|snd_info_version_entry
op_assign
l_int|NULL
suffix:semicolon
DECL|function|snd_info_version_read
r_static
r_void
id|snd_info_version_read
c_func
(paren
id|snd_info_entry_t
op_star
id|entry
comma
id|snd_info_buffer_t
op_star
id|buffer
)paren
(brace
r_static
r_char
op_star
id|kernel_version
op_assign
id|UTS_RELEASE
suffix:semicolon
id|snd_iprintf
c_func
(paren
id|buffer
comma
l_string|&quot;Advanced Linux Sound Architecture Driver Version &quot;
id|CONFIG_SND_VERSION
id|CONFIG_SND_DATE
l_string|&quot;.&bslash;n&quot;
l_string|&quot;Compiled on &quot;
id|__DATE__
l_string|&quot; for kernel %s&quot;
macro_line|#ifdef CONFIG_SMP
l_string|&quot; (SMP)&quot;
macro_line|#endif
macro_line|#ifdef MODVERSIONS
l_string|&quot; with versioned symbols&quot;
macro_line|#endif
l_string|&quot;.&bslash;n&quot;
comma
id|kernel_version
)paren
suffix:semicolon
)brace
DECL|function|snd_info_version_init
r_static
r_int
id|__init
id|snd_info_version_init
c_func
(paren
r_void
)paren
(brace
id|snd_info_entry_t
op_star
id|entry
suffix:semicolon
id|entry
op_assign
id|snd_info_create_module_entry
c_func
(paren
id|THIS_MODULE
comma
l_string|&quot;version&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|entry-&gt;c.text.read_size
op_assign
l_int|256
suffix:semicolon
id|entry-&gt;c.text.read
op_assign
id|snd_info_version_read
suffix:semicolon
r_if
c_cond
(paren
id|snd_info_register
c_func
(paren
id|entry
)paren
OL
l_int|0
)paren
(brace
id|snd_info_free_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|snd_info_version_entry
op_assign
id|entry
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|snd_info_version_done
r_static
r_int
id|__exit
id|snd_info_version_done
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|snd_info_version_entry
)paren
id|snd_info_unregister
c_func
(paren
id|snd_info_version_entry
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PROC_FS */
eof
