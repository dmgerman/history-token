multiline_comment|/*&n; *  linux/kernel/sys.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/utsname.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/prctl.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/highuid.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/key.h&gt;
macro_line|#include &lt;linux/times.h&gt;
macro_line|#include &lt;linux/security.h&gt;
macro_line|#include &lt;linux/dcookies.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;linux/compat.h&gt;
macro_line|#include &lt;linux/syscalls.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/unistd.h&gt;
macro_line|#ifndef SET_UNALIGN_CTL
DECL|macro|SET_UNALIGN_CTL
macro_line|# define SET_UNALIGN_CTL(a,b)&t;(-EINVAL)
macro_line|#endif
macro_line|#ifndef GET_UNALIGN_CTL
DECL|macro|GET_UNALIGN_CTL
macro_line|# define GET_UNALIGN_CTL(a,b)&t;(-EINVAL)
macro_line|#endif
macro_line|#ifndef SET_FPEMU_CTL
DECL|macro|SET_FPEMU_CTL
macro_line|# define SET_FPEMU_CTL(a,b)&t;(-EINVAL)
macro_line|#endif
macro_line|#ifndef GET_FPEMU_CTL
DECL|macro|GET_FPEMU_CTL
macro_line|# define GET_FPEMU_CTL(a,b)&t;(-EINVAL)
macro_line|#endif
macro_line|#ifndef SET_FPEXC_CTL
DECL|macro|SET_FPEXC_CTL
macro_line|# define SET_FPEXC_CTL(a,b)&t;(-EINVAL)
macro_line|#endif
macro_line|#ifndef GET_FPEXC_CTL
DECL|macro|GET_FPEXC_CTL
macro_line|# define GET_FPEXC_CTL(a,b)&t;(-EINVAL)
macro_line|#endif
multiline_comment|/*&n; * this is where the system-wide overflow UID and GID are defined, for&n; * architectures that now have 32-bit UID/GID but didn&squot;t in the past&n; */
DECL|variable|overflowuid
r_int
id|overflowuid
op_assign
id|DEFAULT_OVERFLOWUID
suffix:semicolon
DECL|variable|overflowgid
r_int
id|overflowgid
op_assign
id|DEFAULT_OVERFLOWGID
suffix:semicolon
macro_line|#ifdef CONFIG_UID16
DECL|variable|overflowuid
id|EXPORT_SYMBOL
c_func
(paren
id|overflowuid
)paren
suffix:semicolon
DECL|variable|overflowgid
id|EXPORT_SYMBOL
c_func
(paren
id|overflowgid
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * the same as above, but for filesystems which can only store a 16-bit&n; * UID and GID. as such, this is needed on all architectures&n; */
DECL|variable|fs_overflowuid
r_int
id|fs_overflowuid
op_assign
id|DEFAULT_FS_OVERFLOWUID
suffix:semicolon
DECL|variable|fs_overflowgid
r_int
id|fs_overflowgid
op_assign
id|DEFAULT_FS_OVERFLOWUID
suffix:semicolon
DECL|variable|fs_overflowuid
id|EXPORT_SYMBOL
c_func
(paren
id|fs_overflowuid
)paren
suffix:semicolon
DECL|variable|fs_overflowgid
id|EXPORT_SYMBOL
c_func
(paren
id|fs_overflowgid
)paren
suffix:semicolon
multiline_comment|/*&n; * this indicates whether you can reboot with ctrl-alt-del: the default is yes&n; */
DECL|variable|C_A_D
r_int
id|C_A_D
op_assign
l_int|1
suffix:semicolon
DECL|variable|cad_pid
r_int
id|cad_pid
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n; *&t;Notifier list for kernel code which wants to be called&n; *&t;at shutdown. This is used to stop any idling DMA operations&n; *&t;and the like. &n; */
DECL|variable|reboot_notifier_list
r_static
r_struct
id|notifier_block
op_star
id|reboot_notifier_list
suffix:semicolon
DECL|variable|notifier_lock
id|rwlock_t
id|notifier_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/**&n; *&t;notifier_chain_register&t;- Add notifier to a notifier chain&n; *&t;@list: Pointer to root list pointer&n; *&t;@n: New entry in notifier chain&n; *&n; *&t;Adds a notifier to a notifier chain.&n; *&n; *&t;Currently always returns zero.&n; */
DECL|function|notifier_chain_register
r_int
id|notifier_chain_register
c_func
(paren
r_struct
id|notifier_block
op_star
op_star
id|list
comma
r_struct
id|notifier_block
op_star
id|n
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|notifier_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|list
)paren
(brace
r_if
c_cond
(paren
id|n-&gt;priority
OG
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|priority
)paren
(brace
r_break
suffix:semicolon
)brace
id|list
op_assign
op_amp
(paren
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
)brace
id|n-&gt;next
op_assign
op_star
id|list
suffix:semicolon
op_star
id|list
op_assign
id|n
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|notifier_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|notifier_chain_register
id|EXPORT_SYMBOL
c_func
(paren
id|notifier_chain_register
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;notifier_chain_unregister - Remove notifier from a notifier chain&n; *&t;@nl: Pointer to root list pointer&n; *&t;@n: New entry in notifier chain&n; *&n; *&t;Removes a notifier from a notifier chain.&n; *&n; *&t;Returns zero on success, or %-ENOENT on failure.&n; */
DECL|function|notifier_chain_unregister
r_int
id|notifier_chain_unregister
c_func
(paren
r_struct
id|notifier_block
op_star
op_star
id|nl
comma
r_struct
id|notifier_block
op_star
id|n
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|notifier_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|nl
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|nl
)paren
op_eq
id|n
)paren
(brace
op_star
id|nl
op_assign
id|n-&gt;next
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|notifier_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|nl
op_assign
op_amp
(paren
(paren
op_star
id|nl
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|notifier_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
DECL|variable|notifier_chain_unregister
id|EXPORT_SYMBOL
c_func
(paren
id|notifier_chain_unregister
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;notifier_call_chain - Call functions in a notifier chain&n; *&t;@n: Pointer to root pointer of notifier chain&n; *&t;@val: Value passed unmodified to notifier function&n; *&t;@v: Pointer passed unmodified to notifier function&n; *&n; *&t;Calls each function in a notifier chain in turn.&n; *&n; *&t;If the return value of the notifier can be and&squot;d&n; *&t;with %NOTIFY_STOP_MASK, then notifier_call_chain&n; *&t;will return immediately, with the return value of&n; *&t;the notifier function which halted execution.&n; *&t;Otherwise, the return value is the return value&n; *&t;of the last notifier function called.&n; */
DECL|function|notifier_call_chain
r_int
id|notifier_call_chain
c_func
(paren
r_struct
id|notifier_block
op_star
op_star
id|n
comma
r_int
r_int
id|val
comma
r_void
op_star
id|v
)paren
(brace
r_int
id|ret
op_assign
id|NOTIFY_DONE
suffix:semicolon
r_struct
id|notifier_block
op_star
id|nb
op_assign
op_star
id|n
suffix:semicolon
r_while
c_loop
(paren
id|nb
)paren
(brace
id|ret
op_assign
id|nb
op_member_access_from_pointer
id|notifier_call
c_func
(paren
id|nb
comma
id|val
comma
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_amp
id|NOTIFY_STOP_MASK
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
id|nb
op_assign
id|nb-&gt;next
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|notifier_call_chain
id|EXPORT_SYMBOL
c_func
(paren
id|notifier_call_chain
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;register_reboot_notifier - Register function to be called at reboot time&n; *&t;@nb: Info about notifier function to be called&n; *&n; *&t;Registers a function with the list of functions&n; *&t;to be called at reboot time.&n; *&n; *&t;Currently always returns zero, as notifier_chain_register&n; *&t;always returns zero.&n; */
DECL|function|register_reboot_notifier
r_int
id|register_reboot_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
)paren
(brace
r_return
id|notifier_chain_register
c_func
(paren
op_amp
id|reboot_notifier_list
comma
id|nb
)paren
suffix:semicolon
)brace
DECL|variable|register_reboot_notifier
id|EXPORT_SYMBOL
c_func
(paren
id|register_reboot_notifier
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;unregister_reboot_notifier - Unregister previously registered reboot notifier&n; *&t;@nb: Hook to be unregistered&n; *&n; *&t;Unregisters a previously registered reboot&n; *&t;notifier function.&n; *&n; *&t;Returns zero on success, or %-ENOENT on failure.&n; */
DECL|function|unregister_reboot_notifier
r_int
id|unregister_reboot_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
)paren
(brace
r_return
id|notifier_chain_unregister
c_func
(paren
op_amp
id|reboot_notifier_list
comma
id|nb
)paren
suffix:semicolon
)brace
DECL|variable|unregister_reboot_notifier
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_reboot_notifier
)paren
suffix:semicolon
DECL|function|set_one_prio
r_static
r_int
id|set_one_prio
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
id|niceval
comma
r_int
id|error
)paren
(brace
r_int
id|no_nice
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;uid
op_ne
id|current-&gt;euid
op_logical_and
id|p-&gt;uid
op_ne
id|current-&gt;uid
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_NICE
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|niceval
OL
id|task_nice
c_func
(paren
id|p
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_NICE
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EACCES
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|no_nice
op_assign
id|security_task_setnice
c_func
(paren
id|p
comma
id|niceval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|no_nice
)paren
(brace
id|error
op_assign
id|no_nice
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|ESRCH
)paren
id|error
op_assign
l_int|0
suffix:semicolon
id|set_user_nice
c_func
(paren
id|p
comma
id|niceval
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_setpriority
id|asmlinkage
r_int
id|sys_setpriority
c_func
(paren
r_int
id|which
comma
r_int
id|who
comma
r_int
id|niceval
)paren
(brace
r_struct
id|task_struct
op_star
id|g
comma
op_star
id|p
suffix:semicolon
r_struct
id|user_struct
op_star
id|user
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|which
OG
l_int|2
op_logical_or
id|which
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* normalize: avoid signed division (rounding problems) */
id|error
op_assign
op_minus
id|ESRCH
suffix:semicolon
r_if
c_cond
(paren
id|niceval
OL
op_minus
l_int|20
)paren
id|niceval
op_assign
op_minus
l_int|20
suffix:semicolon
r_if
c_cond
(paren
id|niceval
OG
l_int|19
)paren
id|niceval
op_assign
l_int|19
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|which
)paren
(brace
r_case
id|PRIO_PROCESS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|who
)paren
id|who
op_assign
id|current-&gt;pid
suffix:semicolon
id|p
op_assign
id|find_task_by_pid
c_func
(paren
id|who
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|error
op_assign
id|set_one_prio
c_func
(paren
id|p
comma
id|niceval
comma
id|error
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PRIO_PGRP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|who
)paren
id|who
op_assign
id|process_group
c_func
(paren
id|current
)paren
suffix:semicolon
id|do_each_task_pid
c_func
(paren
id|who
comma
id|PIDTYPE_PGID
comma
id|p
)paren
(brace
id|error
op_assign
id|set_one_prio
c_func
(paren
id|p
comma
id|niceval
comma
id|error
)paren
suffix:semicolon
)brace
id|while_each_task_pid
c_func
(paren
id|who
comma
id|PIDTYPE_PGID
comma
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PRIO_USER
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|who
)paren
id|user
op_assign
id|current-&gt;user
suffix:semicolon
r_else
id|user
op_assign
id|find_user
c_func
(paren
id|who
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|user
)paren
r_goto
id|out_unlock
suffix:semicolon
id|do_each_thread
c_func
(paren
id|g
comma
id|p
)paren
r_if
c_cond
(paren
id|p-&gt;uid
op_eq
id|who
)paren
id|error
op_assign
id|set_one_prio
c_func
(paren
id|p
comma
id|niceval
comma
id|error
)paren
suffix:semicolon
id|while_each_thread
c_func
(paren
id|g
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|who
)paren
id|free_uid
c_func
(paren
id|user
)paren
suffix:semicolon
multiline_comment|/* For find_user() */
r_break
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Ugh. To avoid negative return values, &quot;getpriority()&quot; will&n; * not return the normal nice-value, but a negated value that&n; * has been offset by 20 (ie it returns 40..1 instead of -20..19)&n; * to stay compatible.&n; */
DECL|function|sys_getpriority
id|asmlinkage
r_int
id|sys_getpriority
c_func
(paren
r_int
id|which
comma
r_int
id|who
)paren
(brace
r_struct
id|task_struct
op_star
id|g
comma
op_star
id|p
suffix:semicolon
r_struct
id|user_struct
op_star
id|user
suffix:semicolon
r_int
id|niceval
comma
id|retval
op_assign
op_minus
id|ESRCH
suffix:semicolon
r_if
c_cond
(paren
id|which
OG
l_int|2
op_logical_or
id|which
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|which
)paren
(brace
r_case
id|PRIO_PROCESS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|who
)paren
id|who
op_assign
id|current-&gt;pid
suffix:semicolon
id|p
op_assign
id|find_task_by_pid
c_func
(paren
id|who
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
id|niceval
op_assign
l_int|20
op_minus
id|task_nice
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|niceval
OG
id|retval
)paren
id|retval
op_assign
id|niceval
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PRIO_PGRP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|who
)paren
id|who
op_assign
id|process_group
c_func
(paren
id|current
)paren
suffix:semicolon
id|do_each_task_pid
c_func
(paren
id|who
comma
id|PIDTYPE_PGID
comma
id|p
)paren
(brace
id|niceval
op_assign
l_int|20
op_minus
id|task_nice
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|niceval
OG
id|retval
)paren
id|retval
op_assign
id|niceval
suffix:semicolon
)brace
id|while_each_task_pid
c_func
(paren
id|who
comma
id|PIDTYPE_PGID
comma
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PRIO_USER
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|who
)paren
id|user
op_assign
id|current-&gt;user
suffix:semicolon
r_else
id|user
op_assign
id|find_user
c_func
(paren
id|who
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|user
)paren
r_goto
id|out_unlock
suffix:semicolon
id|do_each_thread
c_func
(paren
id|g
comma
id|p
)paren
r_if
c_cond
(paren
id|p-&gt;uid
op_eq
id|who
)paren
(brace
id|niceval
op_assign
l_int|20
op_minus
id|task_nice
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|niceval
OG
id|retval
)paren
id|retval
op_assign
id|niceval
suffix:semicolon
)brace
id|while_each_thread
c_func
(paren
id|g
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|who
)paren
id|free_uid
c_func
(paren
id|user
)paren
suffix:semicolon
multiline_comment|/* for find_user() */
r_break
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Reboot system call: for obvious reasons only root may call it,&n; * and even root needs to set up some magic numbers in the registers&n; * so that some mistake won&squot;t make this reboot the whole machine.&n; * You can also set the meaning of the ctrl-alt-del-key here.&n; *&n; * reboot doesn&squot;t sync: do that yourself before calling this.&n; */
DECL|function|sys_reboot
id|asmlinkage
r_int
id|sys_reboot
c_func
(paren
r_int
id|magic1
comma
r_int
id|magic2
comma
r_int
r_int
id|cmd
comma
r_void
id|__user
op_star
id|arg
)paren
(brace
r_char
id|buffer
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/* We only trust the superuser with rebooting the system. */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_BOOT
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* For safety, we require &quot;magic&quot; arguments. */
r_if
c_cond
(paren
id|magic1
op_ne
id|LINUX_REBOOT_MAGIC1
op_logical_or
(paren
id|magic2
op_ne
id|LINUX_REBOOT_MAGIC2
op_logical_and
id|magic2
op_ne
id|LINUX_REBOOT_MAGIC2A
op_logical_and
id|magic2
op_ne
id|LINUX_REBOOT_MAGIC2B
op_logical_and
id|magic2
op_ne
id|LINUX_REBOOT_MAGIC2C
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|LINUX_REBOOT_CMD_RESTART
suffix:colon
id|notifier_call_chain
c_func
(paren
op_amp
id|reboot_notifier_list
comma
id|SYS_RESTART
comma
l_int|NULL
)paren
suffix:semicolon
id|system_state
op_assign
id|SYSTEM_RESTART
suffix:semicolon
id|device_shutdown
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;Restarting system.&bslash;n&quot;
)paren
suffix:semicolon
id|machine_restart
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LINUX_REBOOT_CMD_CAD_ON
suffix:colon
id|C_A_D
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LINUX_REBOOT_CMD_CAD_OFF
suffix:colon
id|C_A_D
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LINUX_REBOOT_CMD_HALT
suffix:colon
id|notifier_call_chain
c_func
(paren
op_amp
id|reboot_notifier_list
comma
id|SYS_HALT
comma
l_int|NULL
)paren
suffix:semicolon
id|system_state
op_assign
id|SYSTEM_HALT
suffix:semicolon
id|device_shutdown
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;System halted.&bslash;n&quot;
)paren
suffix:semicolon
id|machine_halt
c_func
(paren
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|do_exit
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LINUX_REBOOT_CMD_POWER_OFF
suffix:colon
id|notifier_call_chain
c_func
(paren
op_amp
id|reboot_notifier_list
comma
id|SYS_POWER_OFF
comma
l_int|NULL
)paren
suffix:semicolon
id|system_state
op_assign
id|SYSTEM_POWER_OFF
suffix:semicolon
id|device_shutdown
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;Power down.&bslash;n&quot;
)paren
suffix:semicolon
id|machine_power_off
c_func
(paren
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|do_exit
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LINUX_REBOOT_CMD_RESTART2
suffix:colon
r_if
c_cond
(paren
id|strncpy_from_user
c_func
(paren
op_amp
id|buffer
(braket
l_int|0
)braket
comma
id|arg
comma
r_sizeof
(paren
id|buffer
)paren
op_minus
l_int|1
)paren
OL
l_int|0
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|buffer
(braket
r_sizeof
(paren
id|buffer
)paren
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|notifier_call_chain
c_func
(paren
op_amp
id|reboot_notifier_list
comma
id|SYS_RESTART
comma
id|buffer
)paren
suffix:semicolon
id|system_state
op_assign
id|SYSTEM_RESTART
suffix:semicolon
id|device_shutdown
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;Restarting system with command &squot;%s&squot;.&bslash;n&quot;
comma
id|buffer
)paren
suffix:semicolon
id|machine_restart
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_SOFTWARE_SUSPEND
r_case
id|LINUX_REBOOT_CMD_SW_SUSPEND
suffix:colon
(brace
r_int
id|ret
op_assign
id|software_suspend
c_func
(paren
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif
r_default
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|deferred_cad
r_static
r_void
id|deferred_cad
c_func
(paren
r_void
op_star
id|dummy
)paren
(brace
id|notifier_call_chain
c_func
(paren
op_amp
id|reboot_notifier_list
comma
id|SYS_RESTART
comma
l_int|NULL
)paren
suffix:semicolon
id|machine_restart
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function gets called by ctrl-alt-del - ie the keyboard interrupt.&n; * As it&squot;s called within an interrupt, it may NOT sync: the only choice&n; * is whether to reboot at once, or just ignore the ctrl-alt-del.&n; */
DECL|function|ctrl_alt_del
r_void
id|ctrl_alt_del
c_func
(paren
r_void
)paren
(brace
r_static
id|DECLARE_WORK
c_func
(paren
id|cad_work
comma
id|deferred_cad
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|C_A_D
)paren
id|schedule_work
c_func
(paren
op_amp
id|cad_work
)paren
suffix:semicolon
r_else
id|kill_proc
c_func
(paren
id|cad_pid
comma
id|SIGINT
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Unprivileged users may change the real gid to the effective gid&n; * or vice versa.  (BSD-style)&n; *&n; * If you set the real gid at all, or set the effective gid to a value not&n; * equal to the real gid, then the saved gid is set to the new effective gid.&n; *&n; * This makes it possible for a setgid program to completely drop its&n; * privileges, which is often a useful assertion to make when you are doing&n; * a security audit over a program.&n; *&n; * The general idea is that a program which uses just setregid() will be&n; * 100% compatible with BSD.  A program which uses just setgid() will be&n; * 100% compatible with POSIX with saved IDs. &n; *&n; * SMP: There are not races, the GIDs are checked only by filesystem&n; *      operations (as far as semantic preservation is concerned).&n; */
DECL|function|sys_setregid
id|asmlinkage
r_int
id|sys_setregid
c_func
(paren
id|gid_t
id|rgid
comma
id|gid_t
id|egid
)paren
(brace
r_int
id|old_rgid
op_assign
id|current-&gt;gid
suffix:semicolon
r_int
id|old_egid
op_assign
id|current-&gt;egid
suffix:semicolon
r_int
id|new_rgid
op_assign
id|old_rgid
suffix:semicolon
r_int
id|new_egid
op_assign
id|old_egid
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|retval
op_assign
id|security_task_setgid
c_func
(paren
id|rgid
comma
id|egid
comma
(paren
id|gid_t
)paren
op_minus
l_int|1
comma
id|LSM_SETID_RE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|rgid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|old_rgid
op_eq
id|rgid
)paren
op_logical_or
(paren
id|current-&gt;egid
op_eq
id|rgid
)paren
op_logical_or
id|capable
c_func
(paren
id|CAP_SETGID
)paren
)paren
id|new_rgid
op_assign
id|rgid
suffix:semicolon
r_else
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|egid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|old_rgid
op_eq
id|egid
)paren
op_logical_or
(paren
id|current-&gt;egid
op_eq
id|egid
)paren
op_logical_or
(paren
id|current-&gt;sgid
op_eq
id|egid
)paren
op_logical_or
id|capable
c_func
(paren
id|CAP_SETGID
)paren
)paren
id|new_egid
op_assign
id|egid
suffix:semicolon
r_else
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|new_egid
op_ne
id|old_egid
)paren
(brace
id|current-&gt;mm-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rgid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
op_logical_or
(paren
id|egid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
op_logical_and
id|egid
op_ne
id|old_rgid
)paren
)paren
id|current-&gt;sgid
op_assign
id|new_egid
suffix:semicolon
id|current-&gt;fsgid
op_assign
id|new_egid
suffix:semicolon
id|current-&gt;egid
op_assign
id|new_egid
suffix:semicolon
id|current-&gt;gid
op_assign
id|new_rgid
suffix:semicolon
id|key_fsgid_changed
c_func
(paren
id|current
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * setgid() is implemented like SysV w/ SAVED_IDS &n; *&n; * SMP: Same implicit races as above.&n; */
DECL|function|sys_setgid
id|asmlinkage
r_int
id|sys_setgid
c_func
(paren
id|gid_t
id|gid
)paren
(brace
r_int
id|old_egid
op_assign
id|current-&gt;egid
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|retval
op_assign
id|security_task_setgid
c_func
(paren
id|gid
comma
(paren
id|gid_t
)paren
op_minus
l_int|1
comma
(paren
id|gid_t
)paren
op_minus
l_int|1
comma
id|LSM_SETID_ID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_SETGID
)paren
)paren
(brace
r_if
c_cond
(paren
id|old_egid
op_ne
id|gid
)paren
(brace
id|current-&gt;mm-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;gid
op_assign
id|current-&gt;egid
op_assign
id|current-&gt;sgid
op_assign
id|current-&gt;fsgid
op_assign
id|gid
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|gid
op_eq
id|current-&gt;gid
)paren
op_logical_or
(paren
id|gid
op_eq
id|current-&gt;sgid
)paren
)paren
(brace
r_if
c_cond
(paren
id|old_egid
op_ne
id|gid
)paren
(brace
id|current-&gt;mm-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;egid
op_assign
id|current-&gt;fsgid
op_assign
id|gid
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EPERM
suffix:semicolon
id|key_fsgid_changed
c_func
(paren
id|current
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|set_user
r_static
r_int
id|set_user
c_func
(paren
id|uid_t
id|new_ruid
comma
r_int
id|dumpclear
)paren
(brace
r_struct
id|user_struct
op_star
id|new_user
suffix:semicolon
id|new_user
op_assign
id|alloc_uid
c_func
(paren
id|new_ruid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_user
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|new_user-&gt;processes
)paren
op_ge
id|current-&gt;signal-&gt;rlim
(braket
id|RLIMIT_NPROC
)braket
dot
id|rlim_cur
op_logical_and
id|new_user
op_ne
op_amp
id|root_user
)paren
(brace
id|free_uid
c_func
(paren
id|new_user
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|switch_uid
c_func
(paren
id|new_user
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dumpclear
)paren
(brace
id|current-&gt;mm-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;uid
op_assign
id|new_ruid
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Unprivileged users may change the real uid to the effective uid&n; * or vice versa.  (BSD-style)&n; *&n; * If you set the real uid at all, or set the effective uid to a value not&n; * equal to the real uid, then the saved uid is set to the new effective uid.&n; *&n; * This makes it possible for a setuid program to completely drop its&n; * privileges, which is often a useful assertion to make when you are doing&n; * a security audit over a program.&n; *&n; * The general idea is that a program which uses just setreuid() will be&n; * 100% compatible with BSD.  A program which uses just setuid() will be&n; * 100% compatible with POSIX with saved IDs. &n; */
DECL|function|sys_setreuid
id|asmlinkage
r_int
id|sys_setreuid
c_func
(paren
id|uid_t
id|ruid
comma
id|uid_t
id|euid
)paren
(brace
r_int
id|old_ruid
comma
id|old_euid
comma
id|old_suid
comma
id|new_ruid
comma
id|new_euid
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|retval
op_assign
id|security_task_setuid
c_func
(paren
id|ruid
comma
id|euid
comma
(paren
id|uid_t
)paren
op_minus
l_int|1
comma
id|LSM_SETID_RE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|new_ruid
op_assign
id|old_ruid
op_assign
id|current-&gt;uid
suffix:semicolon
id|new_euid
op_assign
id|old_euid
op_assign
id|current-&gt;euid
suffix:semicolon
id|old_suid
op_assign
id|current-&gt;suid
suffix:semicolon
r_if
c_cond
(paren
id|ruid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
(brace
id|new_ruid
op_assign
id|ruid
suffix:semicolon
r_if
c_cond
(paren
(paren
id|old_ruid
op_ne
id|ruid
)paren
op_logical_and
(paren
id|current-&gt;euid
op_ne
id|ruid
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SETUID
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|euid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
(brace
id|new_euid
op_assign
id|euid
suffix:semicolon
r_if
c_cond
(paren
(paren
id|old_ruid
op_ne
id|euid
)paren
op_logical_and
(paren
id|current-&gt;euid
op_ne
id|euid
)paren
op_logical_and
(paren
id|current-&gt;suid
op_ne
id|euid
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SETUID
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_ruid
op_ne
id|old_ruid
op_logical_and
id|set_user
c_func
(paren
id|new_ruid
comma
id|new_euid
op_ne
id|old_euid
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|new_euid
op_ne
id|old_euid
)paren
(brace
id|current-&gt;mm-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;fsuid
op_assign
id|current-&gt;euid
op_assign
id|new_euid
suffix:semicolon
r_if
c_cond
(paren
id|ruid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
op_logical_or
(paren
id|euid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
op_logical_and
id|euid
op_ne
id|old_ruid
)paren
)paren
id|current-&gt;suid
op_assign
id|current-&gt;euid
suffix:semicolon
id|current-&gt;fsuid
op_assign
id|current-&gt;euid
suffix:semicolon
id|key_fsuid_changed
c_func
(paren
id|current
)paren
suffix:semicolon
r_return
id|security_task_post_setuid
c_func
(paren
id|old_ruid
comma
id|old_euid
comma
id|old_suid
comma
id|LSM_SETID_RE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * setuid() is implemented like SysV with SAVED_IDS &n; * &n; * Note that SAVED_ID&squot;s is deficient in that a setuid root program&n; * like sendmail, for example, cannot set its uid to be a normal &n; * user and then switch back, because if you&squot;re root, setuid() sets&n; * the saved uid too.  If you don&squot;t like this, blame the bright people&n; * in the POSIX committee and/or USG.  Note that the BSD-style setreuid()&n; * will allow a root program to temporarily drop privileges and be able to&n; * regain them by swapping the real and effective uid.  &n; */
DECL|function|sys_setuid
id|asmlinkage
r_int
id|sys_setuid
c_func
(paren
id|uid_t
id|uid
)paren
(brace
r_int
id|old_euid
op_assign
id|current-&gt;euid
suffix:semicolon
r_int
id|old_ruid
comma
id|old_suid
comma
id|new_ruid
comma
id|new_suid
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|retval
op_assign
id|security_task_setuid
c_func
(paren
id|uid
comma
(paren
id|uid_t
)paren
op_minus
l_int|1
comma
(paren
id|uid_t
)paren
op_minus
l_int|1
comma
id|LSM_SETID_ID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|old_ruid
op_assign
id|new_ruid
op_assign
id|current-&gt;uid
suffix:semicolon
id|old_suid
op_assign
id|current-&gt;suid
suffix:semicolon
id|new_suid
op_assign
id|old_suid
suffix:semicolon
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_SETUID
)paren
)paren
(brace
r_if
c_cond
(paren
id|uid
op_ne
id|old_ruid
op_logical_and
id|set_user
c_func
(paren
id|uid
comma
id|old_euid
op_ne
id|uid
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|new_suid
op_assign
id|uid
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|uid
op_ne
id|current-&gt;uid
)paren
op_logical_and
(paren
id|uid
op_ne
id|new_suid
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|old_euid
op_ne
id|uid
)paren
(brace
id|current-&gt;mm-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;fsuid
op_assign
id|current-&gt;euid
op_assign
id|uid
suffix:semicolon
id|current-&gt;suid
op_assign
id|new_suid
suffix:semicolon
id|key_fsuid_changed
c_func
(paren
id|current
)paren
suffix:semicolon
r_return
id|security_task_post_setuid
c_func
(paren
id|old_ruid
comma
id|old_euid
comma
id|old_suid
comma
id|LSM_SETID_ID
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function implements a generic ability to update ruid, euid,&n; * and suid.  This allows you to implement the 4.4 compatible seteuid().&n; */
DECL|function|sys_setresuid
id|asmlinkage
r_int
id|sys_setresuid
c_func
(paren
id|uid_t
id|ruid
comma
id|uid_t
id|euid
comma
id|uid_t
id|suid
)paren
(brace
r_int
id|old_ruid
op_assign
id|current-&gt;uid
suffix:semicolon
r_int
id|old_euid
op_assign
id|current-&gt;euid
suffix:semicolon
r_int
id|old_suid
op_assign
id|current-&gt;suid
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|retval
op_assign
id|security_task_setuid
c_func
(paren
id|ruid
comma
id|euid
comma
id|suid
comma
id|LSM_SETID_RES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SETUID
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|ruid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
op_logical_and
(paren
id|ruid
op_ne
id|current-&gt;uid
)paren
op_logical_and
(paren
id|ruid
op_ne
id|current-&gt;euid
)paren
op_logical_and
(paren
id|ruid
op_ne
id|current-&gt;suid
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|euid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
op_logical_and
(paren
id|euid
op_ne
id|current-&gt;uid
)paren
op_logical_and
(paren
id|euid
op_ne
id|current-&gt;euid
)paren
op_logical_and
(paren
id|euid
op_ne
id|current-&gt;suid
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|suid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
op_logical_and
(paren
id|suid
op_ne
id|current-&gt;uid
)paren
op_logical_and
(paren
id|suid
op_ne
id|current-&gt;euid
)paren
op_logical_and
(paren
id|suid
op_ne
id|current-&gt;suid
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ruid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|ruid
op_ne
id|current-&gt;uid
op_logical_and
id|set_user
c_func
(paren
id|ruid
comma
id|euid
op_ne
id|current-&gt;euid
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|euid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|euid
op_ne
id|current-&gt;euid
)paren
(brace
id|current-&gt;mm-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;euid
op_assign
id|euid
suffix:semicolon
)brace
id|current-&gt;fsuid
op_assign
id|current-&gt;euid
suffix:semicolon
r_if
c_cond
(paren
id|suid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
id|current-&gt;suid
op_assign
id|suid
suffix:semicolon
id|key_fsuid_changed
c_func
(paren
id|current
)paren
suffix:semicolon
r_return
id|security_task_post_setuid
c_func
(paren
id|old_ruid
comma
id|old_euid
comma
id|old_suid
comma
id|LSM_SETID_RES
)paren
suffix:semicolon
)brace
DECL|function|sys_getresuid
id|asmlinkage
r_int
id|sys_getresuid
c_func
(paren
id|uid_t
id|__user
op_star
id|ruid
comma
id|uid_t
id|__user
op_star
id|euid
comma
id|uid_t
id|__user
op_star
id|suid
)paren
(brace
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|retval
op_assign
id|put_user
c_func
(paren
id|current-&gt;uid
comma
id|ruid
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|retval
op_assign
id|put_user
c_func
(paren
id|current-&gt;euid
comma
id|euid
)paren
)paren
)paren
id|retval
op_assign
id|put_user
c_func
(paren
id|current-&gt;suid
comma
id|suid
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Same as above, but for rgid, egid, sgid.&n; */
DECL|function|sys_setresgid
id|asmlinkage
r_int
id|sys_setresgid
c_func
(paren
id|gid_t
id|rgid
comma
id|gid_t
id|egid
comma
id|gid_t
id|sgid
)paren
(brace
r_int
id|retval
suffix:semicolon
id|retval
op_assign
id|security_task_setgid
c_func
(paren
id|rgid
comma
id|egid
comma
id|sgid
comma
id|LSM_SETID_RES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SETGID
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|rgid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
op_logical_and
(paren
id|rgid
op_ne
id|current-&gt;gid
)paren
op_logical_and
(paren
id|rgid
op_ne
id|current-&gt;egid
)paren
op_logical_and
(paren
id|rgid
op_ne
id|current-&gt;sgid
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|egid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
op_logical_and
(paren
id|egid
op_ne
id|current-&gt;gid
)paren
op_logical_and
(paren
id|egid
op_ne
id|current-&gt;egid
)paren
op_logical_and
(paren
id|egid
op_ne
id|current-&gt;sgid
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sgid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
op_logical_and
(paren
id|sgid
op_ne
id|current-&gt;gid
)paren
op_logical_and
(paren
id|sgid
op_ne
id|current-&gt;egid
)paren
op_logical_and
(paren
id|sgid
op_ne
id|current-&gt;sgid
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|egid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|egid
op_ne
id|current-&gt;egid
)paren
(brace
id|current-&gt;mm-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;egid
op_assign
id|egid
suffix:semicolon
)brace
id|current-&gt;fsgid
op_assign
id|current-&gt;egid
suffix:semicolon
r_if
c_cond
(paren
id|rgid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
id|current-&gt;gid
op_assign
id|rgid
suffix:semicolon
r_if
c_cond
(paren
id|sgid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
id|current-&gt;sgid
op_assign
id|sgid
suffix:semicolon
id|key_fsgid_changed
c_func
(paren
id|current
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_getresgid
id|asmlinkage
r_int
id|sys_getresgid
c_func
(paren
id|gid_t
id|__user
op_star
id|rgid
comma
id|gid_t
id|__user
op_star
id|egid
comma
id|gid_t
id|__user
op_star
id|sgid
)paren
(brace
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|retval
op_assign
id|put_user
c_func
(paren
id|current-&gt;gid
comma
id|rgid
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|retval
op_assign
id|put_user
c_func
(paren
id|current-&gt;egid
comma
id|egid
)paren
)paren
)paren
id|retval
op_assign
id|put_user
c_func
(paren
id|current-&gt;sgid
comma
id|sgid
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * &quot;setfsuid()&quot; sets the fsuid - the uid used for filesystem checks. This&n; * is used for &quot;access()&quot; and for the NFS daemon (letting nfsd stay at&n; * whatever uid it wants to). It normally shadows &quot;euid&quot;, except when&n; * explicitly set by setfsuid() or for access..&n; */
DECL|function|sys_setfsuid
id|asmlinkage
r_int
id|sys_setfsuid
c_func
(paren
id|uid_t
id|uid
)paren
(brace
r_int
id|old_fsuid
suffix:semicolon
id|old_fsuid
op_assign
id|current-&gt;fsuid
suffix:semicolon
r_if
c_cond
(paren
id|security_task_setuid
c_func
(paren
id|uid
comma
(paren
id|uid_t
)paren
op_minus
l_int|1
comma
(paren
id|uid_t
)paren
op_minus
l_int|1
comma
id|LSM_SETID_FS
)paren
)paren
r_return
id|old_fsuid
suffix:semicolon
r_if
c_cond
(paren
id|uid
op_eq
id|current-&gt;uid
op_logical_or
id|uid
op_eq
id|current-&gt;euid
op_logical_or
id|uid
op_eq
id|current-&gt;suid
op_logical_or
id|uid
op_eq
id|current-&gt;fsuid
op_logical_or
id|capable
c_func
(paren
id|CAP_SETUID
)paren
)paren
(brace
r_if
c_cond
(paren
id|uid
op_ne
id|old_fsuid
)paren
(brace
id|current-&gt;mm-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;fsuid
op_assign
id|uid
suffix:semicolon
)brace
id|key_fsuid_changed
c_func
(paren
id|current
)paren
suffix:semicolon
id|security_task_post_setuid
c_func
(paren
id|old_fsuid
comma
(paren
id|uid_t
)paren
op_minus
l_int|1
comma
(paren
id|uid_t
)paren
op_minus
l_int|1
comma
id|LSM_SETID_FS
)paren
suffix:semicolon
r_return
id|old_fsuid
suffix:semicolon
)brace
multiline_comment|/*&n; * Samma p&#xfffd; svenska..&n; */
DECL|function|sys_setfsgid
id|asmlinkage
r_int
id|sys_setfsgid
c_func
(paren
id|gid_t
id|gid
)paren
(brace
r_int
id|old_fsgid
suffix:semicolon
id|old_fsgid
op_assign
id|current-&gt;fsgid
suffix:semicolon
r_if
c_cond
(paren
id|security_task_setgid
c_func
(paren
id|gid
comma
(paren
id|gid_t
)paren
op_minus
l_int|1
comma
(paren
id|gid_t
)paren
op_minus
l_int|1
comma
id|LSM_SETID_FS
)paren
)paren
r_return
id|old_fsgid
suffix:semicolon
r_if
c_cond
(paren
id|gid
op_eq
id|current-&gt;gid
op_logical_or
id|gid
op_eq
id|current-&gt;egid
op_logical_or
id|gid
op_eq
id|current-&gt;sgid
op_logical_or
id|gid
op_eq
id|current-&gt;fsgid
op_logical_or
id|capable
c_func
(paren
id|CAP_SETGID
)paren
)paren
(brace
r_if
c_cond
(paren
id|gid
op_ne
id|old_fsgid
)paren
(brace
id|current-&gt;mm-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;fsgid
op_assign
id|gid
suffix:semicolon
id|key_fsgid_changed
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
r_return
id|old_fsgid
suffix:semicolon
)brace
DECL|function|sys_times
id|asmlinkage
r_int
id|sys_times
c_func
(paren
r_struct
id|tms
id|__user
op_star
id|tbuf
)paren
(brace
multiline_comment|/*&n;&t; *&t;In the SMP world we might just be unlucky and have one of&n;&t; *&t;the times increment as we use it. Since the value is an&n;&t; *&t;atomically safe type this is just fine. Conceptually its&n;&t; *&t;as if the syscall took an instant longer to occur.&n;&t; */
r_if
c_cond
(paren
id|tbuf
)paren
(brace
r_struct
id|tms
id|tmp
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_struct
id|task_struct
op_star
id|t
suffix:semicolon
r_int
r_int
id|utime
comma
id|stime
comma
id|cutime
comma
id|cstime
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|utime
op_assign
id|tsk-&gt;signal-&gt;utime
suffix:semicolon
id|stime
op_assign
id|tsk-&gt;signal-&gt;stime
suffix:semicolon
id|t
op_assign
id|tsk
suffix:semicolon
r_do
(brace
id|utime
op_add_assign
id|t-&gt;utime
suffix:semicolon
id|stime
op_add_assign
id|t-&gt;stime
suffix:semicolon
id|t
op_assign
id|next_thread
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|t
op_ne
id|tsk
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * While we have tasklist_lock read-locked, no dying thread&n;&t;&t; * can be updating current-&gt;signal-&gt;[us]time.  Instead,&n;&t;&t; * we got their counts included in the live thread loop.&n;&t;&t; * However, another thread can come in right now and&n;&t;&t; * do a wait call that updates current-&gt;signal-&gt;c[us]time.&n;&t;&t; * To make sure we always see that pair updated atomically,&n;&t;&t; * we take the siglock around fetching them.&n;&t;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|tsk-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
id|cutime
op_assign
id|tsk-&gt;signal-&gt;cutime
suffix:semicolon
id|cstime
op_assign
id|tsk-&gt;signal-&gt;cstime
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|tsk-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|tmp.tms_utime
op_assign
id|jiffies_to_clock_t
c_func
(paren
id|utime
)paren
suffix:semicolon
id|tmp.tms_stime
op_assign
id|jiffies_to_clock_t
c_func
(paren
id|stime
)paren
suffix:semicolon
id|tmp.tms_cutime
op_assign
id|jiffies_to_clock_t
c_func
(paren
id|cutime
)paren
suffix:semicolon
id|tmp.tms_cstime
op_assign
id|jiffies_to_clock_t
c_func
(paren
id|cstime
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|tbuf
comma
op_amp
id|tmp
comma
r_sizeof
(paren
r_struct
id|tms
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
(paren
r_int
)paren
id|jiffies_64_to_clock_t
c_func
(paren
id|get_jiffies_64
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This needs some heavy checking ...&n; * I just haven&squot;t the stomach for it. I also don&squot;t fully&n; * understand sessions/pgrp etc. Let somebody who does explain it.&n; *&n; * OK, I think I have the protection semantics right.... this is really&n; * only important on a multi-user system anyway, to make sure one user&n; * can&squot;t send a signal to a process owned by another.  -TYT, 12/12/91&n; *&n; * Auch. Had to add the &squot;did_exec&squot; flag to conform completely to POSIX.&n; * LBT 04.03.94&n; */
DECL|function|sys_setpgid
id|asmlinkage
r_int
id|sys_setpgid
c_func
(paren
id|pid_t
id|pid
comma
id|pid_t
id|pgid
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pid
)paren
id|pid
op_assign
id|current-&gt;pid
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pgid
)paren
id|pgid
op_assign
id|pid
suffix:semicolon
r_if
c_cond
(paren
id|pgid
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* From this point forward we keep holding onto the tasklist lock&n;&t; * so that our parent does not change from under us. -DaveM&n;&t; */
id|write_lock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ESRCH
suffix:semicolon
id|p
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|thread_group_leader
c_func
(paren
id|p
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;parent
op_eq
id|current
op_logical_or
id|p-&gt;real_parent
op_eq
id|current
)paren
(brace
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;signal-&gt;session
op_ne
id|current-&gt;signal-&gt;session
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;did_exec
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
id|err
op_assign
op_minus
id|ESRCH
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ne
id|current
)paren
r_goto
id|out
suffix:semicolon
)brace
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;signal-&gt;leader
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|pgid
op_ne
id|pid
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|do_each_task_pid
c_func
(paren
id|pgid
comma
id|PIDTYPE_PGID
comma
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;signal-&gt;session
op_eq
id|current-&gt;signal-&gt;session
)paren
r_goto
id|ok_pgid
suffix:semicolon
)brace
id|while_each_task_pid
c_func
(paren
id|pgid
comma
id|PIDTYPE_PGID
comma
id|p
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|ok_pgid
suffix:colon
id|err
op_assign
id|security_task_setpgid
c_func
(paren
id|p
comma
id|pgid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|process_group
c_func
(paren
id|p
)paren
op_ne
id|pgid
)paren
(brace
id|detach_pid
c_func
(paren
id|p
comma
id|PIDTYPE_PGID
)paren
suffix:semicolon
id|p-&gt;signal-&gt;pgrp
op_assign
id|pgid
suffix:semicolon
id|attach_pid
c_func
(paren
id|p
comma
id|PIDTYPE_PGID
comma
id|pgid
)paren
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
multiline_comment|/* All paths lead to here, thus we are safe. -DaveM */
id|write_unlock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sys_getpgid
id|asmlinkage
r_int
id|sys_getpgid
c_func
(paren
id|pid_t
id|pid
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pid
)paren
(brace
r_return
id|process_group
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|p
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ESRCH
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
id|retval
op_assign
id|security_task_getpgid
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|process_group
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
)brace
macro_line|#ifdef __ARCH_WANT_SYS_GETPGRP
DECL|function|sys_getpgrp
id|asmlinkage
r_int
id|sys_getpgrp
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* SMP - assuming writes are word atomic this is fine */
r_return
id|process_group
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|sys_getsid
id|asmlinkage
r_int
id|sys_getsid
c_func
(paren
id|pid_t
id|pid
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pid
)paren
(brace
r_return
id|current-&gt;signal-&gt;session
suffix:semicolon
)brace
r_else
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|p
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ESRCH
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
id|retval
op_assign
id|security_task_getsid
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|p-&gt;signal-&gt;session
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
)brace
DECL|function|sys_setsid
id|asmlinkage
r_int
id|sys_setsid
c_func
(paren
r_void
)paren
(brace
r_struct
id|pid
op_star
id|pid
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|thread_group_leader
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|write_lock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|pid
op_assign
id|find_pid
c_func
(paren
id|PIDTYPE_PGID
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pid
)paren
r_goto
id|out
suffix:semicolon
id|current-&gt;signal-&gt;leader
op_assign
l_int|1
suffix:semicolon
id|__set_special_pids
c_func
(paren
id|current-&gt;pid
comma
id|current-&gt;pid
)paren
suffix:semicolon
id|current-&gt;signal-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|current-&gt;signal-&gt;tty_old_pgrp
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|process_group
c_func
(paren
id|current
)paren
suffix:semicolon
id|out
suffix:colon
id|write_unlock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Supplementary group IDs&n; */
multiline_comment|/* init to 2 - one for init_task, one to ensure it is never freed */
DECL|variable|init_groups
r_struct
id|group_info
id|init_groups
op_assign
(brace
dot
id|usage
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|2
)paren
)brace
suffix:semicolon
DECL|function|groups_alloc
r_struct
id|group_info
op_star
id|groups_alloc
c_func
(paren
r_int
id|gidsetsize
)paren
(brace
r_struct
id|group_info
op_star
id|group_info
suffix:semicolon
r_int
id|nblocks
suffix:semicolon
r_int
id|i
suffix:semicolon
id|nblocks
op_assign
(paren
id|gidsetsize
op_plus
id|NGROUPS_PER_BLOCK
op_minus
l_int|1
)paren
op_div
id|NGROUPS_PER_BLOCK
suffix:semicolon
multiline_comment|/* Make sure we always allocate at least one indirect block pointer */
id|nblocks
op_assign
id|nblocks
ques
c_cond
suffix:colon
l_int|1
suffix:semicolon
id|group_info
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|group_info
)paren
op_plus
id|nblocks
op_star
r_sizeof
(paren
id|gid_t
op_star
)paren
comma
id|GFP_USER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|group_info
)paren
r_return
l_int|NULL
suffix:semicolon
id|group_info-&gt;ngroups
op_assign
id|gidsetsize
suffix:semicolon
id|group_info-&gt;nblocks
op_assign
id|nblocks
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|group_info-&gt;usage
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gidsetsize
op_le
id|NGROUPS_SMALL
)paren
(brace
id|group_info-&gt;blocks
(braket
l_int|0
)braket
op_assign
id|group_info-&gt;small_block
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nblocks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|gid_t
op_star
id|b
suffix:semicolon
id|b
op_assign
(paren
r_void
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_USER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|b
)paren
r_goto
id|out_undo_partial_alloc
suffix:semicolon
id|group_info-&gt;blocks
(braket
id|i
)braket
op_assign
id|b
suffix:semicolon
)brace
)brace
r_return
id|group_info
suffix:semicolon
id|out_undo_partial_alloc
suffix:colon
r_while
c_loop
(paren
op_decrement
id|i
op_ge
l_int|0
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|group_info-&gt;blocks
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|group_info
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|variable|groups_alloc
id|EXPORT_SYMBOL
c_func
(paren
id|groups_alloc
)paren
suffix:semicolon
DECL|function|groups_free
r_void
id|groups_free
c_func
(paren
r_struct
id|group_info
op_star
id|group_info
)paren
(brace
r_if
c_cond
(paren
id|group_info-&gt;blocks
(braket
l_int|0
)braket
op_ne
id|group_info-&gt;small_block
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|group_info-&gt;nblocks
suffix:semicolon
id|i
op_increment
)paren
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|group_info-&gt;blocks
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|group_info
)paren
suffix:semicolon
)brace
DECL|variable|groups_free
id|EXPORT_SYMBOL
c_func
(paren
id|groups_free
)paren
suffix:semicolon
multiline_comment|/* export the group_info to a user-space array */
DECL|function|groups_to_user
r_static
r_int
id|groups_to_user
c_func
(paren
id|gid_t
id|__user
op_star
id|grouplist
comma
r_struct
id|group_info
op_star
id|group_info
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|count
op_assign
id|group_info-&gt;ngroups
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|group_info-&gt;nblocks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|cp_count
op_assign
id|min
c_func
(paren
id|NGROUPS_PER_BLOCK
comma
id|count
)paren
suffix:semicolon
r_int
id|off
op_assign
id|i
op_star
id|NGROUPS_PER_BLOCK
suffix:semicolon
r_int
id|len
op_assign
id|cp_count
op_star
r_sizeof
(paren
op_star
id|grouplist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|grouplist
op_plus
id|off
comma
id|group_info-&gt;blocks
(braket
id|i
)braket
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|count
op_sub_assign
id|cp_count
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* fill a group_info from a user-space array - it must be allocated already */
DECL|function|groups_from_user
r_static
r_int
id|groups_from_user
c_func
(paren
r_struct
id|group_info
op_star
id|group_info
comma
id|gid_t
id|__user
op_star
id|grouplist
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|count
op_assign
id|group_info-&gt;ngroups
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|group_info-&gt;nblocks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|cp_count
op_assign
id|min
c_func
(paren
id|NGROUPS_PER_BLOCK
comma
id|count
)paren
suffix:semicolon
r_int
id|off
op_assign
id|i
op_star
id|NGROUPS_PER_BLOCK
suffix:semicolon
r_int
id|len
op_assign
id|cp_count
op_star
r_sizeof
(paren
op_star
id|grouplist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|group_info-&gt;blocks
(braket
id|i
)braket
comma
id|grouplist
op_plus
id|off
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|count
op_sub_assign
id|cp_count
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* a simple shell-metzner sort */
DECL|function|groups_sort
r_static
r_void
id|groups_sort
c_func
(paren
r_struct
id|group_info
op_star
id|group_info
)paren
(brace
r_int
id|base
comma
id|max
comma
id|stride
suffix:semicolon
r_int
id|gidsetsize
op_assign
id|group_info-&gt;ngroups
suffix:semicolon
r_for
c_loop
(paren
id|stride
op_assign
l_int|1
suffix:semicolon
id|stride
OL
id|gidsetsize
suffix:semicolon
id|stride
op_assign
l_int|3
op_star
id|stride
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* nothing */
id|stride
op_div_assign
l_int|3
suffix:semicolon
r_while
c_loop
(paren
id|stride
)paren
(brace
id|max
op_assign
id|gidsetsize
op_minus
id|stride
suffix:semicolon
r_for
c_loop
(paren
id|base
op_assign
l_int|0
suffix:semicolon
id|base
OL
id|max
suffix:semicolon
id|base
op_increment
)paren
(brace
r_int
id|left
op_assign
id|base
suffix:semicolon
r_int
id|right
op_assign
id|left
op_plus
id|stride
suffix:semicolon
id|gid_t
id|tmp
op_assign
id|GROUP_AT
c_func
(paren
id|group_info
comma
id|right
)paren
suffix:semicolon
r_while
c_loop
(paren
id|left
op_ge
l_int|0
op_logical_and
id|GROUP_AT
c_func
(paren
id|group_info
comma
id|left
)paren
OG
id|tmp
)paren
(brace
id|GROUP_AT
c_func
(paren
id|group_info
comma
id|right
)paren
op_assign
id|GROUP_AT
c_func
(paren
id|group_info
comma
id|left
)paren
suffix:semicolon
id|right
op_assign
id|left
suffix:semicolon
id|left
op_sub_assign
id|stride
suffix:semicolon
)brace
id|GROUP_AT
c_func
(paren
id|group_info
comma
id|right
)paren
op_assign
id|tmp
suffix:semicolon
)brace
id|stride
op_div_assign
l_int|3
suffix:semicolon
)brace
)brace
multiline_comment|/* a simple bsearch */
DECL|function|groups_search
r_static
r_int
id|groups_search
c_func
(paren
r_struct
id|group_info
op_star
id|group_info
comma
id|gid_t
id|grp
)paren
(brace
r_int
id|left
comma
id|right
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|group_info
)paren
r_return
l_int|0
suffix:semicolon
id|left
op_assign
l_int|0
suffix:semicolon
id|right
op_assign
id|group_info-&gt;ngroups
suffix:semicolon
r_while
c_loop
(paren
id|left
OL
id|right
)paren
(brace
r_int
id|mid
op_assign
(paren
id|left
op_plus
id|right
)paren
op_div
l_int|2
suffix:semicolon
r_int
id|cmp
op_assign
id|grp
op_minus
id|GROUP_AT
c_func
(paren
id|group_info
comma
id|mid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
OG
l_int|0
)paren
id|left
op_assign
id|mid
op_plus
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmp
OL
l_int|0
)paren
id|right
op_assign
id|mid
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* validate and set current-&gt;group_info */
DECL|function|set_current_groups
r_int
id|set_current_groups
c_func
(paren
r_struct
id|group_info
op_star
id|group_info
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|group_info
op_star
id|old_info
suffix:semicolon
id|retval
op_assign
id|security_task_setgroups
c_func
(paren
id|group_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|groups_sort
c_func
(paren
id|group_info
)paren
suffix:semicolon
id|get_group_info
c_func
(paren
id|group_info
)paren
suffix:semicolon
id|task_lock
c_func
(paren
id|current
)paren
suffix:semicolon
id|old_info
op_assign
id|current-&gt;group_info
suffix:semicolon
id|current-&gt;group_info
op_assign
id|group_info
suffix:semicolon
id|task_unlock
c_func
(paren
id|current
)paren
suffix:semicolon
id|put_group_info
c_func
(paren
id|old_info
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|set_current_groups
id|EXPORT_SYMBOL
c_func
(paren
id|set_current_groups
)paren
suffix:semicolon
DECL|function|sys_getgroups
id|asmlinkage
r_int
id|sys_getgroups
c_func
(paren
r_int
id|gidsetsize
comma
id|gid_t
id|__user
op_star
id|grouplist
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;SMP: Nobody else can change our grouplist. Thus we are&n;&t; *&t;safe.&n;&t; */
r_if
c_cond
(paren
id|gidsetsize
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* no need to grab task_lock here; it cannot change */
id|get_group_info
c_func
(paren
id|current-&gt;group_info
)paren
suffix:semicolon
id|i
op_assign
id|current-&gt;group_info-&gt;ngroups
suffix:semicolon
r_if
c_cond
(paren
id|gidsetsize
)paren
(brace
r_if
c_cond
(paren
id|i
OG
id|gidsetsize
)paren
(brace
id|i
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|groups_to_user
c_func
(paren
id|grouplist
comma
id|current-&gt;group_info
)paren
)paren
(brace
id|i
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|put_group_info
c_func
(paren
id|current-&gt;group_info
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;SMP: Our groups are copy-on-write. We can set them safely&n; *&t;without another task interfering.&n; */
DECL|function|sys_setgroups
id|asmlinkage
r_int
id|sys_setgroups
c_func
(paren
r_int
id|gidsetsize
comma
id|gid_t
id|__user
op_star
id|grouplist
)paren
(brace
r_struct
id|group_info
op_star
id|group_info
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SETGID
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|gidsetsize
OG
id|NGROUPS_MAX
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|group_info
op_assign
id|groups_alloc
c_func
(paren
id|gidsetsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|group_info
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|retval
op_assign
id|groups_from_user
c_func
(paren
id|group_info
comma
id|grouplist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|put_group_info
c_func
(paren
id|group_info
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|retval
op_assign
id|set_current_groups
c_func
(paren
id|group_info
)paren
suffix:semicolon
id|put_group_info
c_func
(paren
id|group_info
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Check whether we&squot;re fsgid/egid or in the supplemental group..&n; */
DECL|function|in_group_p
r_int
id|in_group_p
c_func
(paren
id|gid_t
id|grp
)paren
(brace
r_int
id|retval
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|grp
op_ne
id|current-&gt;fsgid
)paren
(brace
id|get_group_info
c_func
(paren
id|current-&gt;group_info
)paren
suffix:semicolon
id|retval
op_assign
id|groups_search
c_func
(paren
id|current-&gt;group_info
comma
id|grp
)paren
suffix:semicolon
id|put_group_info
c_func
(paren
id|current-&gt;group_info
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|in_group_p
id|EXPORT_SYMBOL
c_func
(paren
id|in_group_p
)paren
suffix:semicolon
DECL|function|in_egroup_p
r_int
id|in_egroup_p
c_func
(paren
id|gid_t
id|grp
)paren
(brace
r_int
id|retval
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|grp
op_ne
id|current-&gt;egid
)paren
(brace
id|get_group_info
c_func
(paren
id|current-&gt;group_info
)paren
suffix:semicolon
id|retval
op_assign
id|groups_search
c_func
(paren
id|current-&gt;group_info
comma
id|grp
)paren
suffix:semicolon
id|put_group_info
c_func
(paren
id|current-&gt;group_info
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|in_egroup_p
id|EXPORT_SYMBOL
c_func
(paren
id|in_egroup_p
)paren
suffix:semicolon
DECL|variable|uts_sem
id|DECLARE_RWSEM
c_func
(paren
id|uts_sem
)paren
suffix:semicolon
DECL|variable|uts_sem
id|EXPORT_SYMBOL
c_func
(paren
id|uts_sem
)paren
suffix:semicolon
DECL|function|sys_newuname
id|asmlinkage
r_int
id|sys_newuname
c_func
(paren
r_struct
id|new_utsname
id|__user
op_star
id|name
)paren
(brace
r_int
id|errno
op_assign
l_int|0
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|uts_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|name
comma
op_amp
id|system_utsname
comma
r_sizeof
op_star
id|name
)paren
)paren
id|errno
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|uts_sem
)paren
suffix:semicolon
r_return
id|errno
suffix:semicolon
)brace
DECL|function|sys_sethostname
id|asmlinkage
r_int
id|sys_sethostname
c_func
(paren
r_char
id|__user
op_star
id|name
comma
r_int
id|len
)paren
(brace
r_int
id|errno
suffix:semicolon
r_char
id|tmp
(braket
id|__NEW_UTS_LEN
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|len
template_param
id|__NEW_UTS_LEN
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|uts_sem
)paren
suffix:semicolon
id|errno
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_from_user
c_func
(paren
id|tmp
comma
id|name
comma
id|len
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|system_utsname.nodename
comma
id|tmp
comma
id|len
)paren
suffix:semicolon
id|system_utsname.nodename
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|errno
op_assign
l_int|0
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|uts_sem
)paren
suffix:semicolon
r_return
id|errno
suffix:semicolon
)brace
macro_line|#ifdef __ARCH_WANT_SYS_GETHOSTNAME
DECL|function|sys_gethostname
id|asmlinkage
r_int
id|sys_gethostname
c_func
(paren
r_char
id|__user
op_star
id|name
comma
r_int
id|len
)paren
(brace
r_int
id|i
comma
id|errno
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|uts_sem
)paren
suffix:semicolon
id|i
op_assign
l_int|1
op_plus
id|strlen
c_func
(paren
id|system_utsname.nodename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
id|len
)paren
id|i
op_assign
id|len
suffix:semicolon
id|errno
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|name
comma
id|system_utsname.nodename
comma
id|i
)paren
)paren
id|errno
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|uts_sem
)paren
suffix:semicolon
r_return
id|errno
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Only setdomainname; getdomainname can be implemented by calling&n; * uname()&n; */
DECL|function|sys_setdomainname
id|asmlinkage
r_int
id|sys_setdomainname
c_func
(paren
r_char
id|__user
op_star
id|name
comma
r_int
id|len
)paren
(brace
r_int
id|errno
suffix:semicolon
r_char
id|tmp
(braket
id|__NEW_UTS_LEN
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|len
template_param
id|__NEW_UTS_LEN
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|uts_sem
)paren
suffix:semicolon
id|errno
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_from_user
c_func
(paren
id|tmp
comma
id|name
comma
id|len
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|system_utsname.domainname
comma
id|tmp
comma
id|len
)paren
suffix:semicolon
id|system_utsname.domainname
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|errno
op_assign
l_int|0
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|uts_sem
)paren
suffix:semicolon
r_return
id|errno
suffix:semicolon
)brace
DECL|function|sys_getrlimit
id|asmlinkage
r_int
id|sys_getrlimit
c_func
(paren
r_int
r_int
id|resource
comma
r_struct
id|rlimit
id|__user
op_star
id|rlim
)paren
(brace
r_if
c_cond
(paren
id|resource
op_ge
id|RLIM_NLIMITS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
(brace
r_struct
id|rlimit
id|value
suffix:semicolon
id|task_lock
c_func
(paren
id|current-&gt;group_leader
)paren
suffix:semicolon
id|value
op_assign
id|current-&gt;signal-&gt;rlim
(braket
id|resource
)braket
suffix:semicolon
id|task_unlock
c_func
(paren
id|current-&gt;group_leader
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
id|rlim
comma
op_amp
id|value
comma
r_sizeof
(paren
op_star
id|rlim
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#ifdef __ARCH_WANT_SYS_OLD_GETRLIMIT
multiline_comment|/*&n; *&t;Back compatibility for getrlimit. Needed for some apps.&n; */
DECL|function|sys_old_getrlimit
id|asmlinkage
r_int
id|sys_old_getrlimit
c_func
(paren
r_int
r_int
id|resource
comma
r_struct
id|rlimit
id|__user
op_star
id|rlim
)paren
(brace
r_struct
id|rlimit
id|x
suffix:semicolon
r_if
c_cond
(paren
id|resource
op_ge
id|RLIM_NLIMITS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|task_lock
c_func
(paren
id|current-&gt;group_leader
)paren
suffix:semicolon
id|x
op_assign
id|current-&gt;signal-&gt;rlim
(braket
id|resource
)braket
suffix:semicolon
id|task_unlock
c_func
(paren
id|current-&gt;group_leader
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x.rlim_cur
OG
l_int|0x7FFFFFFF
)paren
(brace
id|x.rlim_cur
op_assign
l_int|0x7FFFFFFF
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x.rlim_max
OG
l_int|0x7FFFFFFF
)paren
(brace
id|x.rlim_max
op_assign
l_int|0x7FFFFFFF
suffix:semicolon
)brace
r_return
id|copy_to_user
c_func
(paren
id|rlim
comma
op_amp
id|x
comma
r_sizeof
(paren
id|x
)paren
)paren
ques
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|sys_setrlimit
id|asmlinkage
r_int
id|sys_setrlimit
c_func
(paren
r_int
r_int
id|resource
comma
r_struct
id|rlimit
id|__user
op_star
id|rlim
)paren
(brace
r_struct
id|rlimit
id|new_rlim
comma
op_star
id|old_rlim
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|resource
op_ge
id|RLIM_NLIMITS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|new_rlim
comma
id|rlim
comma
r_sizeof
(paren
op_star
id|rlim
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_rlim.rlim_cur
OG
id|new_rlim.rlim_max
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|old_rlim
op_assign
id|current-&gt;signal-&gt;rlim
op_plus
id|resource
suffix:semicolon
r_if
c_cond
(paren
(paren
id|new_rlim.rlim_max
OG
id|old_rlim-&gt;rlim_max
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RESOURCE
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|resource
op_eq
id|RLIMIT_NOFILE
op_logical_and
id|new_rlim.rlim_max
OG
id|NR_OPEN
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|retval
op_assign
id|security_task_setrlimit
c_func
(paren
id|resource
comma
op_amp
id|new_rlim
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|task_lock
c_func
(paren
id|current-&gt;group_leader
)paren
suffix:semicolon
op_star
id|old_rlim
op_assign
id|new_rlim
suffix:semicolon
id|task_unlock
c_func
(paren
id|current-&gt;group_leader
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * It would make sense to put struct rusage in the task_struct,&n; * except that would make the task_struct be *really big*.  After&n; * task_struct gets moved into malloc&squot;ed memory, it would&n; * make sense to do this.  It will make moving the rest of the information&n; * a lot simpler!  (Which we&squot;re not doing right now because we&squot;re not&n; * measuring them yet).&n; *&n; * This expects to be called with tasklist_lock read-locked or better,&n; * and the siglock not locked.  It may momentarily take the siglock.&n; *&n; * When sampling multiple threads for RUSAGE_SELF, under SMP we might have&n; * races with threads incrementing their own counters.  But since word&n; * reads are atomic, we either get new values or old values and we don&squot;t&n; * care which for the sums.  We always take the siglock to protect reading&n; * the c* fields from p-&gt;signal from races with exit.c updating those&n; * fields when reaping, so a sample either gets all the additions of a&n; * given child after it&squot;s reaped, or none so this sample is before reaping.&n; */
DECL|function|k_getrusage
r_void
id|k_getrusage
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
id|who
comma
r_struct
id|rusage
op_star
id|r
)paren
(brace
r_struct
id|task_struct
op_star
id|t
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|utime
comma
id|stime
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|r
comma
l_int|0
comma
r_sizeof
op_star
id|r
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|p-&gt;signal
)paren
)paren
r_return
suffix:semicolon
r_switch
c_cond
(paren
id|who
)paren
(brace
r_case
id|RUSAGE_CHILDREN
suffix:colon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|p-&gt;sighand-&gt;siglock
comma
id|flags
)paren
suffix:semicolon
id|utime
op_assign
id|p-&gt;signal-&gt;cutime
suffix:semicolon
id|stime
op_assign
id|p-&gt;signal-&gt;cstime
suffix:semicolon
id|r-&gt;ru_nvcsw
op_assign
id|p-&gt;signal-&gt;cnvcsw
suffix:semicolon
id|r-&gt;ru_nivcsw
op_assign
id|p-&gt;signal-&gt;cnivcsw
suffix:semicolon
id|r-&gt;ru_minflt
op_assign
id|p-&gt;signal-&gt;cmin_flt
suffix:semicolon
id|r-&gt;ru_majflt
op_assign
id|p-&gt;signal-&gt;cmaj_flt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|p-&gt;sighand-&gt;siglock
comma
id|flags
)paren
suffix:semicolon
id|jiffies_to_timeval
c_func
(paren
id|utime
comma
op_amp
id|r-&gt;ru_utime
)paren
suffix:semicolon
id|jiffies_to_timeval
c_func
(paren
id|stime
comma
op_amp
id|r-&gt;ru_stime
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RUSAGE_SELF
suffix:colon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|p-&gt;sighand-&gt;siglock
comma
id|flags
)paren
suffix:semicolon
id|utime
op_assign
id|stime
op_assign
l_int|0
suffix:semicolon
r_goto
id|sum_group
suffix:semicolon
r_case
id|RUSAGE_BOTH
suffix:colon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|p-&gt;sighand-&gt;siglock
comma
id|flags
)paren
suffix:semicolon
id|utime
op_assign
id|p-&gt;signal-&gt;cutime
suffix:semicolon
id|stime
op_assign
id|p-&gt;signal-&gt;cstime
suffix:semicolon
id|r-&gt;ru_nvcsw
op_assign
id|p-&gt;signal-&gt;cnvcsw
suffix:semicolon
id|r-&gt;ru_nivcsw
op_assign
id|p-&gt;signal-&gt;cnivcsw
suffix:semicolon
id|r-&gt;ru_minflt
op_assign
id|p-&gt;signal-&gt;cmin_flt
suffix:semicolon
id|r-&gt;ru_majflt
op_assign
id|p-&gt;signal-&gt;cmaj_flt
suffix:semicolon
id|sum_group
suffix:colon
id|utime
op_add_assign
id|p-&gt;signal-&gt;utime
suffix:semicolon
id|stime
op_add_assign
id|p-&gt;signal-&gt;stime
suffix:semicolon
id|r-&gt;ru_nvcsw
op_add_assign
id|p-&gt;signal-&gt;nvcsw
suffix:semicolon
id|r-&gt;ru_nivcsw
op_add_assign
id|p-&gt;signal-&gt;nivcsw
suffix:semicolon
id|r-&gt;ru_minflt
op_add_assign
id|p-&gt;signal-&gt;min_flt
suffix:semicolon
id|r-&gt;ru_majflt
op_add_assign
id|p-&gt;signal-&gt;maj_flt
suffix:semicolon
id|t
op_assign
id|p
suffix:semicolon
r_do
(brace
id|utime
op_add_assign
id|t-&gt;utime
suffix:semicolon
id|stime
op_add_assign
id|t-&gt;stime
suffix:semicolon
id|r-&gt;ru_nvcsw
op_add_assign
id|t-&gt;nvcsw
suffix:semicolon
id|r-&gt;ru_nivcsw
op_add_assign
id|t-&gt;nivcsw
suffix:semicolon
id|r-&gt;ru_minflt
op_add_assign
id|t-&gt;min_flt
suffix:semicolon
id|r-&gt;ru_majflt
op_add_assign
id|t-&gt;maj_flt
suffix:semicolon
id|t
op_assign
id|next_thread
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|t
op_ne
id|p
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|p-&gt;sighand-&gt;siglock
comma
id|flags
)paren
suffix:semicolon
id|jiffies_to_timeval
c_func
(paren
id|utime
comma
op_amp
id|r-&gt;ru_utime
)paren
suffix:semicolon
id|jiffies_to_timeval
c_func
(paren
id|stime
comma
op_amp
id|r-&gt;ru_stime
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|getrusage
r_int
id|getrusage
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
id|who
comma
r_struct
id|rusage
id|__user
op_star
id|ru
)paren
(brace
r_struct
id|rusage
id|r
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|k_getrusage
c_func
(paren
id|p
comma
id|who
comma
op_amp
id|r
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
id|ru
comma
op_amp
id|r
comma
r_sizeof
(paren
id|r
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|sys_getrusage
id|asmlinkage
r_int
id|sys_getrusage
c_func
(paren
r_int
id|who
comma
r_struct
id|rusage
id|__user
op_star
id|ru
)paren
(brace
r_if
c_cond
(paren
id|who
op_ne
id|RUSAGE_SELF
op_logical_and
id|who
op_ne
id|RUSAGE_CHILDREN
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|getrusage
c_func
(paren
id|current
comma
id|who
comma
id|ru
)paren
suffix:semicolon
)brace
DECL|function|sys_umask
id|asmlinkage
r_int
id|sys_umask
c_func
(paren
r_int
id|mask
)paren
(brace
id|mask
op_assign
id|xchg
c_func
(paren
op_amp
id|current-&gt;fs-&gt;umask
comma
id|mask
op_amp
id|S_IRWXUGO
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
DECL|function|sys_prctl
id|asmlinkage
r_int
id|sys_prctl
c_func
(paren
r_int
id|option
comma
r_int
r_int
id|arg2
comma
r_int
r_int
id|arg3
comma
r_int
r_int
id|arg4
comma
r_int
r_int
id|arg5
)paren
(brace
r_int
id|error
suffix:semicolon
r_int
id|sig
suffix:semicolon
id|error
op_assign
id|security_task_prctl
c_func
(paren
id|option
comma
id|arg2
comma
id|arg3
comma
id|arg4
comma
id|arg5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_switch
c_cond
(paren
id|option
)paren
(brace
r_case
id|PR_SET_PDEATHSIG
suffix:colon
id|sig
op_assign
id|arg2
suffix:semicolon
r_if
c_cond
(paren
id|sig
template_param
id|_NSIG
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|current-&gt;pdeath_signal
op_assign
id|sig
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PR_GET_PDEATHSIG
suffix:colon
id|error
op_assign
id|put_user
c_func
(paren
id|current-&gt;pdeath_signal
comma
(paren
r_int
id|__user
op_star
)paren
id|arg2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PR_GET_DUMPABLE
suffix:colon
r_if
c_cond
(paren
id|current-&gt;mm-&gt;dumpable
)paren
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PR_SET_DUMPABLE
suffix:colon
r_if
c_cond
(paren
id|arg2
op_ne
l_int|0
op_logical_and
id|arg2
op_ne
l_int|1
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|current-&gt;mm-&gt;dumpable
op_assign
id|arg2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PR_SET_UNALIGN
suffix:colon
id|error
op_assign
id|SET_UNALIGN_CTL
c_func
(paren
id|current
comma
id|arg2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PR_GET_UNALIGN
suffix:colon
id|error
op_assign
id|GET_UNALIGN_CTL
c_func
(paren
id|current
comma
id|arg2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PR_SET_FPEMU
suffix:colon
id|error
op_assign
id|SET_FPEMU_CTL
c_func
(paren
id|current
comma
id|arg2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PR_GET_FPEMU
suffix:colon
id|error
op_assign
id|GET_FPEMU_CTL
c_func
(paren
id|current
comma
id|arg2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PR_SET_FPEXC
suffix:colon
id|error
op_assign
id|SET_FPEXC_CTL
c_func
(paren
id|current
comma
id|arg2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PR_GET_FPEXC
suffix:colon
id|error
op_assign
id|GET_FPEXC_CTL
c_func
(paren
id|current
comma
id|arg2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PR_GET_TIMING
suffix:colon
id|error
op_assign
id|PR_TIMING_STATISTICAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PR_SET_TIMING
suffix:colon
r_if
c_cond
(paren
id|arg2
op_eq
id|PR_TIMING_STATISTICAL
)paren
id|error
op_assign
l_int|0
suffix:semicolon
r_else
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PR_GET_KEEPCAPS
suffix:colon
r_if
c_cond
(paren
id|current-&gt;keep_capabilities
)paren
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PR_SET_KEEPCAPS
suffix:colon
r_if
c_cond
(paren
id|arg2
op_ne
l_int|0
op_logical_and
id|arg2
op_ne
l_int|1
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|current-&gt;keep_capabilities
op_assign
id|arg2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PR_SET_NAME
suffix:colon
(brace
r_struct
id|task_struct
op_star
id|me
op_assign
id|current
suffix:semicolon
r_int
r_char
id|ncomm
(braket
r_sizeof
(paren
id|me-&gt;comm
)paren
)braket
suffix:semicolon
id|ncomm
(braket
r_sizeof
(paren
id|me-&gt;comm
)paren
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|strncpy_from_user
c_func
(paren
id|ncomm
comma
(paren
r_char
id|__user
op_star
)paren
id|arg2
comma
r_sizeof
(paren
id|me-&gt;comm
)paren
op_minus
l_int|1
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|set_task_comm
c_func
(paren
id|me
comma
id|ncomm
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
eof
