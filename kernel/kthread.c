multiline_comment|/* Kernel thread helper functions.&n; *   Copyright (C) 2004 IBM Corporation, Rusty Russell.&n; *&n; * Creation is done via keventd, so that we get a clean environment&n; * even if we&squot;re invoked from userspace (think modprobe, hotplug cpu,&n; * etc.).&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kthread.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/err.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
multiline_comment|/*&n; * We dont want to execute off keventd since it might&n; * hold a semaphore our callers hold too:&n; */
DECL|variable|helper_wq
r_static
r_struct
id|workqueue_struct
op_star
id|helper_wq
suffix:semicolon
DECL|struct|kthread_create_info
r_struct
id|kthread_create_info
(brace
multiline_comment|/* Information passed to kthread() from keventd. */
DECL|member|threadfn
r_int
(paren
op_star
id|threadfn
)paren
(paren
r_void
op_star
id|data
)paren
suffix:semicolon
DECL|member|data
r_void
op_star
id|data
suffix:semicolon
DECL|member|started
r_struct
id|completion
id|started
suffix:semicolon
multiline_comment|/* Result passed back to kthread_create() from keventd. */
DECL|member|result
r_struct
id|task_struct
op_star
id|result
suffix:semicolon
DECL|member|done
r_struct
id|completion
id|done
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|kthread_stop_info
r_struct
id|kthread_stop_info
(brace
DECL|member|k
r_struct
id|task_struct
op_star
id|k
suffix:semicolon
DECL|member|err
r_int
id|err
suffix:semicolon
DECL|member|done
r_struct
id|completion
id|done
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Thread stopping is done by setthing this var: lock serializes&n; * multiple kthread_stop calls. */
r_static
id|DECLARE_MUTEX
c_func
(paren
id|kthread_stop_lock
)paren
suffix:semicolon
DECL|variable|kthread_stop_info
r_static
r_struct
id|kthread_stop_info
id|kthread_stop_info
suffix:semicolon
DECL|function|kthread_should_stop
r_int
id|kthread_should_stop
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|kthread_stop_info.k
op_eq
id|current
)paren
suffix:semicolon
)brace
DECL|variable|kthread_should_stop
id|EXPORT_SYMBOL
c_func
(paren
id|kthread_should_stop
)paren
suffix:semicolon
DECL|function|kthread_exit_files
r_static
r_void
id|kthread_exit_files
c_func
(paren
r_void
)paren
(brace
r_struct
id|fs_struct
op_star
id|fs
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|exit_fs
c_func
(paren
id|tsk
)paren
suffix:semicolon
multiline_comment|/* current-&gt;fs-&gt;count--; */
id|fs
op_assign
id|init_task.fs
suffix:semicolon
id|tsk-&gt;fs
op_assign
id|fs
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|fs-&gt;count
)paren
suffix:semicolon
id|exit_files
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|current-&gt;files
op_assign
id|init_task.files
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|tsk-&gt;files-&gt;count
)paren
suffix:semicolon
)brace
DECL|function|kthread
r_static
r_int
id|kthread
c_func
(paren
r_void
op_star
id|_create
)paren
(brace
r_struct
id|kthread_create_info
op_star
id|create
op_assign
id|_create
suffix:semicolon
r_int
(paren
op_star
id|threadfn
)paren
(paren
r_void
op_star
id|data
)paren
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
id|sigset_t
id|blocked
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINTR
suffix:semicolon
id|kthread_exit_files
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Copy data: it&squot;s on keventd&squot;s stack */
id|threadfn
op_assign
id|create-&gt;threadfn
suffix:semicolon
id|data
op_assign
id|create-&gt;data
suffix:semicolon
multiline_comment|/* Block and flush all signals (in case we&squot;re not from keventd). */
id|sigfillset
c_func
(paren
op_amp
id|blocked
)paren
suffix:semicolon
id|sigprocmask
c_func
(paren
id|SIG_BLOCK
comma
op_amp
id|blocked
comma
l_int|NULL
)paren
suffix:semicolon
id|flush_signals
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/* By default we can run anywhere, unlike keventd. */
id|set_cpus_allowed
c_func
(paren
id|current
comma
id|CPU_MASK_ALL
)paren
suffix:semicolon
multiline_comment|/* OK, tell user we&squot;re spawned, wait for stop or wakeup */
id|__set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|complete
c_func
(paren
op_amp
id|create-&gt;started
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kthread_should_stop
c_func
(paren
)paren
)paren
id|ret
op_assign
id|threadfn
c_func
(paren
id|data
)paren
suffix:semicolon
multiline_comment|/* It might have exited on its own, w/o kthread_stop.  Check. */
r_if
c_cond
(paren
id|kthread_should_stop
c_func
(paren
)paren
)paren
(brace
id|kthread_stop_info.err
op_assign
id|ret
suffix:semicolon
id|complete
c_func
(paren
op_amp
id|kthread_stop_info.done
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We are keventd: create a thread. */
DECL|function|keventd_create_kthread
r_static
r_void
id|keventd_create_kthread
c_func
(paren
r_void
op_star
id|_create
)paren
(brace
r_struct
id|kthread_create_info
op_star
id|create
op_assign
id|_create
suffix:semicolon
r_int
id|pid
suffix:semicolon
multiline_comment|/* We want our own signal handler (we take no signals by default). */
id|pid
op_assign
id|kernel_thread
c_func
(paren
id|kthread
comma
id|create
comma
id|CLONE_FS
op_or
id|CLONE_FILES
op_or
id|SIGCHLD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pid
OL
l_int|0
)paren
(brace
id|create-&gt;result
op_assign
id|ERR_PTR
c_func
(paren
id|pid
)paren
suffix:semicolon
)brace
r_else
(brace
id|wait_for_completion
c_func
(paren
op_amp
id|create-&gt;started
)paren
suffix:semicolon
id|create-&gt;result
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
)brace
id|complete
c_func
(paren
op_amp
id|create-&gt;done
)paren
suffix:semicolon
)brace
DECL|function|kthread_create
r_struct
id|task_struct
op_star
id|kthread_create
c_func
(paren
r_int
(paren
op_star
id|threadfn
)paren
(paren
r_void
op_star
id|data
)paren
comma
r_void
op_star
id|data
comma
r_const
r_char
id|namefmt
(braket
)braket
comma
dot
dot
dot
)paren
(brace
r_struct
id|kthread_create_info
id|create
suffix:semicolon
id|DECLARE_WORK
c_func
(paren
id|work
comma
id|keventd_create_kthread
comma
op_amp
id|create
)paren
suffix:semicolon
id|create.threadfn
op_assign
id|threadfn
suffix:semicolon
id|create.data
op_assign
id|data
suffix:semicolon
id|init_completion
c_func
(paren
op_amp
id|create.started
)paren
suffix:semicolon
id|init_completion
c_func
(paren
op_amp
id|create.done
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The workqueue needs to start up first:&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|helper_wq
)paren
id|work
dot
id|func
c_func
(paren
id|work.data
)paren
suffix:semicolon
r_else
(brace
id|queue_work
c_func
(paren
id|helper_wq
comma
op_amp
id|work
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|create.done
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|create.result
)paren
)paren
(brace
id|va_list
id|args
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|namefmt
)paren
suffix:semicolon
id|vsnprintf
c_func
(paren
id|create.result-&gt;comm
comma
r_sizeof
(paren
id|create.result-&gt;comm
)paren
comma
id|namefmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
)brace
r_return
id|create.result
suffix:semicolon
)brace
DECL|variable|kthread_create
id|EXPORT_SYMBOL
c_func
(paren
id|kthread_create
)paren
suffix:semicolon
DECL|function|kthread_bind
r_void
id|kthread_bind
c_func
(paren
r_struct
id|task_struct
op_star
id|k
comma
r_int
r_int
id|cpu
)paren
(brace
id|BUG_ON
c_func
(paren
id|k-&gt;state
op_ne
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
multiline_comment|/* Must have done schedule() in kthread() before we set_task_cpu */
id|wait_task_inactive
c_func
(paren
id|k
)paren
suffix:semicolon
id|set_task_cpu
c_func
(paren
id|k
comma
id|cpu
)paren
suffix:semicolon
id|k-&gt;cpus_allowed
op_assign
id|cpumask_of_cpu
c_func
(paren
id|cpu
)paren
suffix:semicolon
)brace
DECL|variable|kthread_bind
id|EXPORT_SYMBOL
c_func
(paren
id|kthread_bind
)paren
suffix:semicolon
DECL|function|kthread_stop
r_int
id|kthread_stop
c_func
(paren
r_struct
id|task_struct
op_star
id|k
)paren
(brace
r_int
id|ret
suffix:semicolon
id|down
c_func
(paren
op_amp
id|kthread_stop_lock
)paren
suffix:semicolon
multiline_comment|/* It could exit after stop_info.k set, but before wake_up_process. */
id|get_task_struct
c_func
(paren
id|k
)paren
suffix:semicolon
multiline_comment|/* Must init completion *before* thread sees kthread_stop_info.k */
id|init_completion
c_func
(paren
op_amp
id|kthread_stop_info.done
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Now set kthread_should_stop() to true, and wake it up. */
id|kthread_stop_info.k
op_assign
id|k
suffix:semicolon
id|wake_up_process
c_func
(paren
id|k
)paren
suffix:semicolon
id|put_task_struct
c_func
(paren
id|k
)paren
suffix:semicolon
multiline_comment|/* Once it dies, reset stop ptr, gather result and we&squot;re done. */
id|wait_for_completion
c_func
(paren
op_amp
id|kthread_stop_info.done
)paren
suffix:semicolon
id|kthread_stop_info.k
op_assign
l_int|NULL
suffix:semicolon
id|ret
op_assign
id|kthread_stop_info.err
suffix:semicolon
id|up
c_func
(paren
op_amp
id|kthread_stop_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|kthread_stop
id|EXPORT_SYMBOL
c_func
(paren
id|kthread_stop
)paren
suffix:semicolon
DECL|function|helper_init
r_static
id|__init
r_int
id|helper_init
c_func
(paren
r_void
)paren
(brace
id|helper_wq
op_assign
id|create_singlethread_workqueue
c_func
(paren
l_string|&quot;kthread&quot;
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|helper_wq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|helper_init
id|core_initcall
c_func
(paren
id|helper_init
)paren
suffix:semicolon
eof
