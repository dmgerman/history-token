multiline_comment|/*&n; *  linux/kernel/exit.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/personality.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/namespace.h&gt;
macro_line|#include &lt;linux/key.h&gt;
macro_line|#include &lt;linux/security.h&gt;
macro_line|#include &lt;linux/cpu.h&gt;
macro_line|#include &lt;linux/acct.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/binfmts.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/profile.h&gt;
macro_line|#include &lt;linux/mount.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/mempolicy.h&gt;
macro_line|#include &lt;linux/syscalls.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/unistd.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
r_extern
r_void
id|sem_exit
(paren
r_void
)paren
suffix:semicolon
r_extern
r_struct
id|task_struct
op_star
id|child_reaper
suffix:semicolon
r_int
id|getrusage
c_func
(paren
r_struct
id|task_struct
op_star
comma
r_int
comma
r_struct
id|rusage
id|__user
op_star
)paren
suffix:semicolon
DECL|function|__unhash_process
r_static
r_void
id|__unhash_process
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
id|nr_threads
op_decrement
suffix:semicolon
id|detach_pid
c_func
(paren
id|p
comma
id|PIDTYPE_PID
)paren
suffix:semicolon
id|detach_pid
c_func
(paren
id|p
comma
id|PIDTYPE_TGID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thread_group_leader
c_func
(paren
id|p
)paren
)paren
(brace
id|detach_pid
c_func
(paren
id|p
comma
id|PIDTYPE_PGID
)paren
suffix:semicolon
id|detach_pid
c_func
(paren
id|p
comma
id|PIDTYPE_SID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;pid
)paren
id|__get_cpu_var
c_func
(paren
id|process_counts
)paren
op_decrement
suffix:semicolon
)brace
id|REMOVE_LINKS
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
DECL|function|release_task
r_void
id|release_task
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_int
id|zap_leader
suffix:semicolon
id|task_t
op_star
id|leader
suffix:semicolon
r_struct
id|dentry
op_star
id|proc_dentry
suffix:semicolon
id|repeat
suffix:colon
id|atomic_dec
c_func
(paren
op_amp
id|p-&gt;user-&gt;processes
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|p-&gt;proc_lock
)paren
suffix:semicolon
id|proc_dentry
op_assign
id|proc_pid_unhash
c_func
(paren
id|p
)paren
suffix:semicolon
id|write_lock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|p-&gt;ptrace
)paren
)paren
id|__ptrace_unlink
c_func
(paren
id|p
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|p-&gt;ptrace_list
)paren
op_logical_or
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|p-&gt;ptrace_children
)paren
)paren
suffix:semicolon
id|__exit_signal
c_func
(paren
id|p
)paren
suffix:semicolon
id|__exit_sighand
c_func
(paren
id|p
)paren
suffix:semicolon
id|__unhash_process
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we are the last non-leader member of the thread&n;&t; * group, and the leader is zombie, then notify the&n;&t; * group leader&squot;s parent process. (if it wants notification.)&n;&t; */
id|zap_leader
op_assign
l_int|0
suffix:semicolon
id|leader
op_assign
id|p-&gt;group_leader
suffix:semicolon
r_if
c_cond
(paren
id|leader
op_ne
id|p
op_logical_and
id|thread_group_empty
c_func
(paren
id|leader
)paren
op_logical_and
id|leader-&gt;exit_state
op_eq
id|EXIT_ZOMBIE
)paren
(brace
id|BUG_ON
c_func
(paren
id|leader-&gt;exit_signal
op_eq
op_minus
l_int|1
)paren
suffix:semicolon
id|do_notify_parent
c_func
(paren
id|leader
comma
id|leader-&gt;exit_signal
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we were the last child thread and the leader has&n;&t;&t; * exited already, and the leader&squot;s parent ignores SIGCHLD,&n;&t;&t; * then we are the one who should release the leader.&n;&t;&t; *&n;&t;&t; * do_notify_parent() will have marked it self-reaping in&n;&t;&t; * that case.&n;&t;&t; */
id|zap_leader
op_assign
(paren
id|leader-&gt;exit_signal
op_eq
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|sched_exit
c_func
(paren
id|p
)paren
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|p-&gt;proc_lock
)paren
suffix:semicolon
id|proc_pid_flush
c_func
(paren
id|proc_dentry
)paren
suffix:semicolon
id|release_thread
c_func
(paren
id|p
)paren
suffix:semicolon
id|put_task_struct
c_func
(paren
id|p
)paren
suffix:semicolon
id|p
op_assign
id|leader
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|zap_leader
)paren
)paren
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/* we are using it only for SMP init */
DECL|function|unhash_process
r_void
id|unhash_process
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_struct
id|dentry
op_star
id|proc_dentry
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|p-&gt;proc_lock
)paren
suffix:semicolon
id|proc_dentry
op_assign
id|proc_pid_unhash
c_func
(paren
id|p
)paren
suffix:semicolon
id|write_lock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|__unhash_process
c_func
(paren
id|p
)paren
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|p-&gt;proc_lock
)paren
suffix:semicolon
id|proc_pid_flush
c_func
(paren
id|proc_dentry
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This checks not only the pgrp, but falls back on the pid if no&n; * satisfactory pgrp is found. I dunno - gdb doesn&squot;t work correctly&n; * without this...&n; */
DECL|function|session_of_pgrp
r_int
id|session_of_pgrp
c_func
(paren
r_int
id|pgrp
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|sid
op_assign
op_minus
l_int|1
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|do_each_task_pid
c_func
(paren
id|pgrp
comma
id|PIDTYPE_PGID
comma
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;signal-&gt;session
OG
l_int|0
)paren
(brace
id|sid
op_assign
id|p-&gt;signal-&gt;session
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|while_each_task_pid
c_func
(paren
id|pgrp
comma
id|PIDTYPE_PGID
comma
id|p
)paren
suffix:semicolon
id|p
op_assign
id|find_task_by_pid
c_func
(paren
id|pgrp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|sid
op_assign
id|p-&gt;signal-&gt;session
suffix:semicolon
id|out
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|sid
suffix:semicolon
)brace
multiline_comment|/*&n; * Determine if a process group is &quot;orphaned&quot;, according to the POSIX&n; * definition in 2.2.2.52.  Orphaned process groups are not to be affected&n; * by terminal-generated stop signals.  Newly orphaned process groups are&n; * to receive a SIGHUP and a SIGCONT.&n; *&n; * &quot;I ask you, have you ever known what it is to be an orphan?&quot;&n; */
DECL|function|will_become_orphaned_pgrp
r_static
r_int
id|will_become_orphaned_pgrp
c_func
(paren
r_int
id|pgrp
comma
id|task_t
op_star
id|ignored_task
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
id|do_each_task_pid
c_func
(paren
id|pgrp
comma
id|PIDTYPE_PGID
comma
id|p
)paren
(brace
r_if
c_cond
(paren
id|p
op_eq
id|ignored_task
op_logical_or
id|p-&gt;exit_state
op_logical_or
id|p-&gt;real_parent-&gt;pid
op_eq
l_int|1
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|process_group
c_func
(paren
id|p-&gt;real_parent
)paren
op_ne
id|pgrp
op_logical_and
id|p-&gt;real_parent-&gt;signal-&gt;session
op_eq
id|p-&gt;signal-&gt;session
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|while_each_task_pid
c_func
(paren
id|pgrp
comma
id|PIDTYPE_PGID
comma
id|p
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
multiline_comment|/* (sighing) &quot;Often!&quot; */
)brace
DECL|function|is_orphaned_pgrp
r_int
id|is_orphaned_pgrp
c_func
(paren
r_int
id|pgrp
)paren
(brace
r_int
id|retval
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|retval
op_assign
id|will_become_orphaned_pgrp
c_func
(paren
id|pgrp
comma
l_int|NULL
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|has_stopped_jobs
r_static
r_inline
r_int
id|has_stopped_jobs
c_func
(paren
r_int
id|pgrp
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|do_each_task_pid
c_func
(paren
id|pgrp
comma
id|PIDTYPE_PGID
comma
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;state
op_ne
id|TASK_STOPPED
)paren
r_continue
suffix:semicolon
multiline_comment|/* If p is stopped by a debugger on a signal that won&squot;t&n;&t;&t;   stop it, then don&squot;t count p as stopped.  This isn&squot;t&n;&t;&t;   perfect but it&squot;s a good approximation.  */
r_if
c_cond
(paren
id|unlikely
(paren
id|p-&gt;ptrace
)paren
op_logical_and
id|p-&gt;exit_code
op_ne
id|SIGSTOP
op_logical_and
id|p-&gt;exit_code
op_ne
id|SIGTSTP
op_logical_and
id|p-&gt;exit_code
op_ne
id|SIGTTOU
op_logical_and
id|p-&gt;exit_code
op_ne
id|SIGTTIN
)paren
r_continue
suffix:semicolon
id|retval
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|while_each_task_pid
c_func
(paren
id|pgrp
comma
id|PIDTYPE_PGID
comma
id|p
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * reparent_to_init() - Reparent the calling kernel thread to the init task.&n; *&n; * If a kernel thread is launched as a result of a system call, or if&n; * it ever exits, it should generally reparent itself to init so that&n; * it is correctly cleaned up on exit.&n; *&n; * The various task state such as scheduling policy and priority may have&n; * been inherited from a user process, so we reset them to sane values here.&n; *&n; * NOTE that reparent_to_init() gives the caller full capabilities.&n; */
DECL|function|reparent_to_init
r_void
id|reparent_to_init
c_func
(paren
r_void
)paren
(brace
id|write_lock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|ptrace_unlink
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/* Reparent to init */
id|REMOVE_LINKS
c_func
(paren
id|current
)paren
suffix:semicolon
id|current-&gt;parent
op_assign
id|child_reaper
suffix:semicolon
id|current-&gt;real_parent
op_assign
id|child_reaper
suffix:semicolon
id|SET_LINKS
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/* Set the exit signal to SIGCHLD so we signal init on exit */
id|current-&gt;exit_signal
op_assign
id|SIGCHLD
suffix:semicolon
r_if
c_cond
(paren
(paren
id|current-&gt;policy
op_eq
id|SCHED_NORMAL
)paren
op_logical_and
(paren
id|task_nice
c_func
(paren
id|current
)paren
OL
l_int|0
)paren
)paren
id|set_user_nice
c_func
(paren
id|current
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* cpus_allowed? */
multiline_comment|/* rt_priority? */
multiline_comment|/* signals? */
id|security_task_reparent_to_init
c_func
(paren
id|current
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|current-&gt;signal-&gt;rlim
comma
id|init_task.signal-&gt;rlim
comma
r_sizeof
(paren
id|current-&gt;signal-&gt;rlim
)paren
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
(paren
id|INIT_USER-&gt;__count
)paren
)paren
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|switch_uid
c_func
(paren
id|INIT_USER
)paren
suffix:semicolon
)brace
DECL|function|__set_special_pids
r_void
id|__set_special_pids
c_func
(paren
id|pid_t
id|session
comma
id|pid_t
id|pgrp
)paren
(brace
r_struct
id|task_struct
op_star
id|curr
op_assign
id|current
suffix:semicolon
r_if
c_cond
(paren
id|curr-&gt;signal-&gt;session
op_ne
id|session
)paren
(brace
id|detach_pid
c_func
(paren
id|curr
comma
id|PIDTYPE_SID
)paren
suffix:semicolon
id|curr-&gt;signal-&gt;session
op_assign
id|session
suffix:semicolon
id|attach_pid
c_func
(paren
id|curr
comma
id|PIDTYPE_SID
comma
id|session
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|process_group
c_func
(paren
id|curr
)paren
op_ne
id|pgrp
)paren
(brace
id|detach_pid
c_func
(paren
id|curr
comma
id|PIDTYPE_PGID
)paren
suffix:semicolon
id|curr-&gt;signal-&gt;pgrp
op_assign
id|pgrp
suffix:semicolon
id|attach_pid
c_func
(paren
id|curr
comma
id|PIDTYPE_PGID
comma
id|pgrp
)paren
suffix:semicolon
)brace
)brace
DECL|function|set_special_pids
r_void
id|set_special_pids
c_func
(paren
id|pid_t
id|session
comma
id|pid_t
id|pgrp
)paren
(brace
id|write_lock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|__set_special_pids
c_func
(paren
id|session
comma
id|pgrp
)paren
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Let kernel threads use this to say that they&n; * allow a certain signal (since daemonize() will&n; * have disabled all of them by default).&n; */
DECL|function|allow_signal
r_int
id|allow_signal
c_func
(paren
r_int
id|sig
)paren
(brace
r_if
c_cond
(paren
id|sig
template_param
id|_NSIG
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
id|sigdelset
c_func
(paren
op_amp
id|current-&gt;blocked
comma
id|sig
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;mm
)paren
(brace
multiline_comment|/* Kernel threads handle their own signals.&n;&t;&t;   Let the signal code know it&squot;ll be handled, so&n;&t;&t;   that they don&squot;t get converted to SIGKILL or&n;&t;&t;   just silently dropped */
id|current-&gt;sighand-&gt;action
(braket
(paren
id|sig
)paren
op_minus
l_int|1
)braket
dot
id|sa.sa_handler
op_assign
(paren
r_void
id|__user
op_star
)paren
l_int|2
suffix:semicolon
)brace
id|recalc_sigpending
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|allow_signal
id|EXPORT_SYMBOL
c_func
(paren
id|allow_signal
)paren
suffix:semicolon
DECL|function|disallow_signal
r_int
id|disallow_signal
c_func
(paren
r_int
id|sig
)paren
(brace
r_if
c_cond
(paren
id|sig
template_param
id|_NSIG
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
id|sigaddset
c_func
(paren
op_amp
id|current-&gt;blocked
comma
id|sig
)paren
suffix:semicolon
id|recalc_sigpending
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|disallow_signal
id|EXPORT_SYMBOL
c_func
(paren
id|disallow_signal
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Put all the gunge required to become a kernel thread without&n; *&t;attached user resources in one place where it belongs.&n; */
DECL|function|daemonize
r_void
id|daemonize
c_func
(paren
r_const
r_char
op_star
id|name
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_struct
id|fs_struct
op_star
id|fs
suffix:semicolon
id|sigset_t
id|blocked
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|name
)paren
suffix:semicolon
id|vsnprintf
c_func
(paren
id|current-&gt;comm
comma
r_sizeof
(paren
id|current-&gt;comm
)paren
comma
id|name
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we were started as result of loading a module, close all of the&n;&t; * user space pages.  We don&squot;t need them, and if we didn&squot;t close them&n;&t; * they would be locked into memory.&n;&t; */
id|exit_mm
c_func
(paren
id|current
)paren
suffix:semicolon
id|set_special_pids
c_func
(paren
l_int|1
comma
l_int|1
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|tty_sem
)paren
suffix:semicolon
id|current-&gt;signal-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|up
c_func
(paren
op_amp
id|tty_sem
)paren
suffix:semicolon
multiline_comment|/* Block and flush all signals */
id|sigfillset
c_func
(paren
op_amp
id|blocked
)paren
suffix:semicolon
id|sigprocmask
c_func
(paren
id|SIG_BLOCK
comma
op_amp
id|blocked
comma
l_int|NULL
)paren
suffix:semicolon
id|flush_signals
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/* Become as one with the init task */
id|exit_fs
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/* current-&gt;fs-&gt;count--; */
id|fs
op_assign
id|init_task.fs
suffix:semicolon
id|current-&gt;fs
op_assign
id|fs
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|fs-&gt;count
)paren
suffix:semicolon
id|exit_files
c_func
(paren
id|current
)paren
suffix:semicolon
id|current-&gt;files
op_assign
id|init_task.files
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|current-&gt;files-&gt;count
)paren
suffix:semicolon
id|reparent_to_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|daemonize
id|EXPORT_SYMBOL
c_func
(paren
id|daemonize
)paren
suffix:semicolon
DECL|function|close_files
r_static
r_inline
r_void
id|close_files
c_func
(paren
r_struct
id|files_struct
op_star
id|files
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
r_int
id|set
suffix:semicolon
id|i
op_assign
id|j
op_star
id|__NFDBITS
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|files-&gt;max_fdset
op_logical_or
id|i
op_ge
id|files-&gt;max_fds
)paren
r_break
suffix:semicolon
id|set
op_assign
id|files-&gt;open_fds-&gt;fds_bits
(braket
id|j
op_increment
)braket
suffix:semicolon
r_while
c_loop
(paren
id|set
)paren
(brace
r_if
c_cond
(paren
id|set
op_amp
l_int|1
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|xchg
c_func
(paren
op_amp
id|files-&gt;fd
(braket
id|i
)braket
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
id|filp_close
c_func
(paren
id|file
comma
id|files
)paren
suffix:semicolon
)brace
id|i
op_increment
suffix:semicolon
id|set
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
DECL|function|get_files_struct
r_struct
id|files_struct
op_star
id|get_files_struct
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
(brace
r_struct
id|files_struct
op_star
id|files
suffix:semicolon
id|task_lock
c_func
(paren
id|task
)paren
suffix:semicolon
id|files
op_assign
id|task-&gt;files
suffix:semicolon
r_if
c_cond
(paren
id|files
)paren
id|atomic_inc
c_func
(paren
op_amp
id|files-&gt;count
)paren
suffix:semicolon
id|task_unlock
c_func
(paren
id|task
)paren
suffix:semicolon
r_return
id|files
suffix:semicolon
)brace
DECL|function|put_files_struct
r_void
id|fastcall
id|put_files_struct
c_func
(paren
r_struct
id|files_struct
op_star
id|files
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|files-&gt;count
)paren
)paren
(brace
id|close_files
c_func
(paren
id|files
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Free the fd and fdset arrays if we expanded them.&n;&t;&t; */
r_if
c_cond
(paren
id|files-&gt;fd
op_ne
op_amp
id|files-&gt;fd_array
(braket
l_int|0
)braket
)paren
id|free_fd_array
c_func
(paren
id|files-&gt;fd
comma
id|files-&gt;max_fds
)paren
suffix:semicolon
r_if
c_cond
(paren
id|files-&gt;max_fdset
OG
id|__FD_SETSIZE
)paren
(brace
id|free_fdset
c_func
(paren
id|files-&gt;open_fds
comma
id|files-&gt;max_fdset
)paren
suffix:semicolon
id|free_fdset
c_func
(paren
id|files-&gt;close_on_exec
comma
id|files-&gt;max_fdset
)paren
suffix:semicolon
)brace
id|kmem_cache_free
c_func
(paren
id|files_cachep
comma
id|files
)paren
suffix:semicolon
)brace
)brace
DECL|variable|put_files_struct
id|EXPORT_SYMBOL
c_func
(paren
id|put_files_struct
)paren
suffix:semicolon
DECL|function|__exit_files
r_static
r_inline
r_void
id|__exit_files
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_struct
id|files_struct
op_star
id|files
op_assign
id|tsk-&gt;files
suffix:semicolon
r_if
c_cond
(paren
id|files
)paren
(brace
id|task_lock
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|tsk-&gt;files
op_assign
l_int|NULL
suffix:semicolon
id|task_unlock
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|put_files_struct
c_func
(paren
id|files
)paren
suffix:semicolon
)brace
)brace
DECL|function|exit_files
r_void
id|exit_files
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
id|__exit_files
c_func
(paren
id|tsk
)paren
suffix:semicolon
)brace
DECL|function|__put_fs_struct
r_static
r_inline
r_void
id|__put_fs_struct
c_func
(paren
r_struct
id|fs_struct
op_star
id|fs
)paren
(brace
multiline_comment|/* No need to hold fs-&gt;lock if we are killing it */
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|fs-&gt;count
)paren
)paren
(brace
id|dput
c_func
(paren
id|fs-&gt;root
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|fs-&gt;rootmnt
)paren
suffix:semicolon
id|dput
c_func
(paren
id|fs-&gt;pwd
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|fs-&gt;pwdmnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fs-&gt;altroot
)paren
(brace
id|dput
c_func
(paren
id|fs-&gt;altroot
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|fs-&gt;altrootmnt
)paren
suffix:semicolon
)brace
id|kmem_cache_free
c_func
(paren
id|fs_cachep
comma
id|fs
)paren
suffix:semicolon
)brace
)brace
DECL|function|put_fs_struct
r_void
id|put_fs_struct
c_func
(paren
r_struct
id|fs_struct
op_star
id|fs
)paren
(brace
id|__put_fs_struct
c_func
(paren
id|fs
)paren
suffix:semicolon
)brace
DECL|function|__exit_fs
r_static
r_inline
r_void
id|__exit_fs
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_struct
id|fs_struct
op_star
id|fs
op_assign
id|tsk-&gt;fs
suffix:semicolon
r_if
c_cond
(paren
id|fs
)paren
(brace
id|task_lock
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|tsk-&gt;fs
op_assign
l_int|NULL
suffix:semicolon
id|task_unlock
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|__put_fs_struct
c_func
(paren
id|fs
)paren
suffix:semicolon
)brace
)brace
DECL|function|exit_fs
r_void
id|exit_fs
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
id|__exit_fs
c_func
(paren
id|tsk
)paren
suffix:semicolon
)brace
DECL|variable|exit_fs
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|exit_fs
)paren
suffix:semicolon
multiline_comment|/*&n; * Turn us into a lazy TLB process if we&n; * aren&squot;t already..&n; */
DECL|function|exit_mm
r_void
id|exit_mm
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|tsk-&gt;mm
suffix:semicolon
id|mm_release
c_func
(paren
id|tsk
comma
id|mm
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mm
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Serialize with any possible pending coredump.&n;&t; * We must hold mmap_sem around checking core_waiters&n;&t; * and clearing tsk-&gt;mm.  The core-inducing thread&n;&t; * will increment core_waiters for each thread in the&n;&t; * group with -&gt;mm != NULL.&n;&t; */
id|down_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;core_waiters
)paren
(brace
id|up_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|mm-&gt;core_waiters
)paren
id|complete
c_func
(paren
id|mm-&gt;core_startup_done
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|mm-&gt;core_done
)paren
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|mm-&gt;mm_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_ne
id|tsk-&gt;active_mm
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* more a memory barrier than a real lock */
id|task_lock
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|tsk-&gt;mm
op_assign
l_int|NULL
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|enter_lazy_tlb
c_func
(paren
id|mm
comma
id|current
)paren
suffix:semicolon
id|task_unlock
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|mmput
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
DECL|function|choose_new_parent
r_static
r_inline
r_void
id|choose_new_parent
c_func
(paren
id|task_t
op_star
id|p
comma
id|task_t
op_star
id|reaper
comma
id|task_t
op_star
id|child_reaper
)paren
(brace
multiline_comment|/*&n;&t; * Make sure we&squot;re not reparenting to ourselves and that&n;&t; * the parent is not a zombie.&n;&t; */
id|BUG_ON
c_func
(paren
id|p
op_eq
id|reaper
op_logical_or
id|reaper-&gt;exit_state
op_ge
id|EXIT_ZOMBIE
)paren
suffix:semicolon
id|p-&gt;real_parent
op_assign
id|reaper
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;parent
op_eq
id|p-&gt;real_parent
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|reparent_thread
r_static
r_inline
r_void
id|reparent_thread
c_func
(paren
id|task_t
op_star
id|p
comma
id|task_t
op_star
id|father
comma
r_int
id|traced
)paren
(brace
multiline_comment|/* We don&squot;t want people slaying init.  */
r_if
c_cond
(paren
id|p-&gt;exit_signal
op_ne
op_minus
l_int|1
)paren
id|p-&gt;exit_signal
op_assign
id|SIGCHLD
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;pdeath_signal
)paren
multiline_comment|/* We already hold the tasklist_lock here.  */
id|group_send_sig_info
c_func
(paren
id|p-&gt;pdeath_signal
comma
(paren
r_void
op_star
)paren
l_int|0
comma
id|p
)paren
suffix:semicolon
multiline_comment|/* Move the child from its dying parent to the new one.  */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|traced
)paren
)paren
(brace
multiline_comment|/* Preserve ptrace links if someone else is tracing this child.  */
id|list_del_init
c_func
(paren
op_amp
id|p-&gt;ptrace_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;parent
op_ne
id|p-&gt;real_parent
)paren
id|list_add
c_func
(paren
op_amp
id|p-&gt;ptrace_list
comma
op_amp
id|p-&gt;real_parent-&gt;ptrace_children
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If this child is being traced, then we&squot;re the one tracing it&n;&t;&t; * anyway, so let go of it.&n;&t;&t; */
id|p-&gt;ptrace
op_assign
l_int|0
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|p-&gt;sibling
)paren
suffix:semicolon
id|p-&gt;parent
op_assign
id|p-&gt;real_parent
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|p-&gt;sibling
comma
op_amp
id|p-&gt;parent-&gt;children
)paren
suffix:semicolon
multiline_comment|/* If we&squot;d notified the old parent about this child&squot;s death,&n;&t;&t; * also notify the new parent.&n;&t;&t; */
r_if
c_cond
(paren
id|p-&gt;exit_state
op_eq
id|EXIT_ZOMBIE
op_logical_and
id|p-&gt;exit_signal
op_ne
op_minus
l_int|1
op_logical_and
id|thread_group_empty
c_func
(paren
id|p
)paren
)paren
id|do_notify_parent
c_func
(paren
id|p
comma
id|p-&gt;exit_signal
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|p-&gt;state
op_eq
id|TASK_TRACED
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If it was at a trace stop, turn it into&n;&t;&t;&t; * a normal stop since it&squot;s no longer being&n;&t;&t;&t; * traced.&n;&t;&t;&t; */
id|ptrace_untrace
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * process group orphan check&n;&t; * Case ii: Our child is in a different pgrp&n;&t; * than we are, and it was the only connection&n;&t; * outside, so the child pgrp is now orphaned.&n;&t; */
r_if
c_cond
(paren
(paren
id|process_group
c_func
(paren
id|p
)paren
op_ne
id|process_group
c_func
(paren
id|father
)paren
)paren
op_logical_and
(paren
id|p-&gt;signal-&gt;session
op_eq
id|father-&gt;signal-&gt;session
)paren
)paren
(brace
r_int
id|pgrp
op_assign
id|process_group
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|will_become_orphaned_pgrp
c_func
(paren
id|pgrp
comma
l_int|NULL
)paren
op_logical_and
id|has_stopped_jobs
c_func
(paren
id|pgrp
)paren
)paren
(brace
id|__kill_pg_info
c_func
(paren
id|SIGHUP
comma
(paren
r_void
op_star
)paren
l_int|1
comma
id|pgrp
)paren
suffix:semicolon
id|__kill_pg_info
c_func
(paren
id|SIGCONT
comma
(paren
r_void
op_star
)paren
l_int|1
comma
id|pgrp
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * When we die, we re-parent all our children.&n; * Try to give them to another thread in our thread&n; * group, and if no such member exists, give it to&n; * the global child reaper process (ie &quot;init&quot;)&n; */
DECL|function|forget_original_parent
r_static
r_inline
r_void
id|forget_original_parent
c_func
(paren
r_struct
id|task_struct
op_star
id|father
comma
r_struct
id|list_head
op_star
id|to_release
)paren
(brace
r_struct
id|task_struct
op_star
id|p
comma
op_star
id|reaper
op_assign
id|father
suffix:semicolon
r_struct
id|list_head
op_star
id|_p
comma
op_star
id|_n
suffix:semicolon
r_do
(brace
id|reaper
op_assign
id|next_thread
c_func
(paren
id|reaper
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reaper
op_eq
id|father
)paren
(brace
id|reaper
op_assign
id|child_reaper
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|reaper-&gt;exit_state
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * There are only two places where our children can be:&n;&t; *&n;&t; * - in our child list&n;&t; * - in our ptraced child list&n;&t; *&n;&t; * Search them and reparent children.&n;&t; */
id|list_for_each_safe
c_func
(paren
id|_p
comma
id|_n
comma
op_amp
id|father-&gt;children
)paren
(brace
r_int
id|ptrace
suffix:semicolon
id|p
op_assign
id|list_entry
c_func
(paren
id|_p
comma
r_struct
id|task_struct
comma
id|sibling
)paren
suffix:semicolon
id|ptrace
op_assign
id|p-&gt;ptrace
suffix:semicolon
multiline_comment|/* if father isn&squot;t the real parent, then ptrace must be enabled */
id|BUG_ON
c_func
(paren
id|father
op_ne
id|p-&gt;real_parent
op_logical_and
op_logical_neg
id|ptrace
)paren
suffix:semicolon
r_if
c_cond
(paren
id|father
op_eq
id|p-&gt;real_parent
)paren
(brace
multiline_comment|/* reparent with a reaper, real father it&squot;s us */
id|choose_new_parent
c_func
(paren
id|p
comma
id|reaper
comma
id|child_reaper
)paren
suffix:semicolon
id|reparent_thread
c_func
(paren
id|p
comma
id|father
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* reparent ptraced task to its real parent */
id|__ptrace_unlink
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;exit_state
op_eq
id|EXIT_ZOMBIE
op_logical_and
id|p-&gt;exit_signal
op_ne
op_minus
l_int|1
op_logical_and
id|thread_group_empty
c_func
(paren
id|p
)paren
)paren
id|do_notify_parent
c_func
(paren
id|p
comma
id|p-&gt;exit_signal
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * if the ptraced child is a zombie with exit_signal == -1&n;&t;&t; * we must collect it before we exit, or it will remain&n;&t;&t; * zombie forever since we prevented it from self-reap itself&n;&t;&t; * while it was being traced by us, to be able to see it in wait4.&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ptrace
op_logical_and
id|p-&gt;exit_state
op_eq
id|EXIT_ZOMBIE
op_logical_and
id|p-&gt;exit_signal
op_eq
op_minus
l_int|1
)paren
)paren
id|list_add
c_func
(paren
op_amp
id|p-&gt;ptrace_list
comma
id|to_release
)paren
suffix:semicolon
)brace
id|list_for_each_safe
c_func
(paren
id|_p
comma
id|_n
comma
op_amp
id|father-&gt;ptrace_children
)paren
(brace
id|p
op_assign
id|list_entry
c_func
(paren
id|_p
comma
r_struct
id|task_struct
comma
id|ptrace_list
)paren
suffix:semicolon
id|choose_new_parent
c_func
(paren
id|p
comma
id|reaper
comma
id|child_reaper
)paren
suffix:semicolon
id|reparent_thread
c_func
(paren
id|p
comma
id|father
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Send signals to all our closest relatives so that they know&n; * to properly mourn us..&n; */
DECL|function|exit_notify
r_static
r_void
id|exit_notify
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_int
id|state
suffix:semicolon
r_struct
id|task_struct
op_star
id|t
suffix:semicolon
r_struct
id|list_head
id|ptrace_dead
comma
op_star
id|_p
comma
op_star
id|_n
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|tsk
)paren
op_logical_and
op_logical_neg
(paren
id|tsk-&gt;signal-&gt;flags
op_amp
id|SIGNAL_GROUP_EXIT
)paren
op_logical_and
op_logical_neg
id|thread_group_empty
c_func
(paren
id|tsk
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * This occurs when there was a race between our exit&n;&t;&t; * syscall and a group signal choosing us as the one to&n;&t;&t; * wake up.  It could be that we are the only thread&n;&t;&t; * alerted to check for pending signals, but another thread&n;&t;&t; * should be woken now to take the signal since we will not.&n;&t;&t; * Now we&squot;ll wake all the threads in the group just to make&n;&t;&t; * sure someone gets all the pending signals.&n;&t;&t; */
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|tsk-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|t
op_assign
id|next_thread
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|t
op_ne
id|tsk
suffix:semicolon
id|t
op_assign
id|next_thread
c_func
(paren
id|t
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
id|signal_pending
c_func
(paren
id|t
)paren
op_logical_and
op_logical_neg
(paren
id|t-&gt;flags
op_amp
id|PF_EXITING
)paren
)paren
(brace
id|recalc_sigpending_tsk
c_func
(paren
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|t
)paren
)paren
id|signal_wake_up
c_func
(paren
id|t
comma
l_int|0
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|tsk-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
id|write_lock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This does two things:&n;&t; *&n;  &t; * A.  Make init inherit all the child processes&n;&t; * B.  Check to see if any process groups have become orphaned&n;&t; *&t;as a result of our exiting, and if they have any stopped&n;&t; *&t;jobs, send them a SIGHUP and then a SIGCONT.  (POSIX 3.2.2.2)&n;&t; */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ptrace_dead
)paren
suffix:semicolon
id|forget_original_parent
c_func
(paren
id|tsk
comma
op_amp
id|ptrace_dead
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|tsk-&gt;children
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|tsk-&gt;ptrace_children
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check to see if any process groups have become orphaned&n;&t; * as a result of our exiting, and if they have any stopped&n;&t; * jobs, send them a SIGHUP and then a SIGCONT.  (POSIX 3.2.2.2)&n;&t; *&n;&t; * Case i: Our father is in a different pgrp than we are&n;&t; * and we were the only connection outside, so our pgrp&n;&t; * is about to become orphaned.&n;&t; */
id|t
op_assign
id|tsk-&gt;real_parent
suffix:semicolon
r_if
c_cond
(paren
(paren
id|process_group
c_func
(paren
id|t
)paren
op_ne
id|process_group
c_func
(paren
id|tsk
)paren
)paren
op_logical_and
(paren
id|t-&gt;signal-&gt;session
op_eq
id|tsk-&gt;signal-&gt;session
)paren
op_logical_and
id|will_become_orphaned_pgrp
c_func
(paren
id|process_group
c_func
(paren
id|tsk
)paren
comma
id|tsk
)paren
op_logical_and
id|has_stopped_jobs
c_func
(paren
id|process_group
c_func
(paren
id|tsk
)paren
)paren
)paren
(brace
id|__kill_pg_info
c_func
(paren
id|SIGHUP
comma
(paren
r_void
op_star
)paren
l_int|1
comma
id|process_group
c_func
(paren
id|tsk
)paren
)paren
suffix:semicolon
id|__kill_pg_info
c_func
(paren
id|SIGCONT
comma
(paren
r_void
op_star
)paren
l_int|1
comma
id|process_group
c_func
(paren
id|tsk
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Let father know we died &n;&t; *&n;&t; * Thread signals are configurable, but you aren&squot;t going to use&n;&t; * that to send signals to arbitary processes. &n;&t; * That stops right now.&n;&t; *&n;&t; * If the parent exec id doesn&squot;t match the exec id we saved&n;&t; * when we started then we know the parent has changed security&n;&t; * domain.&n;&t; *&n;&t; * If our self_exec id doesn&squot;t match our parent_exec_id then&n;&t; * we have changed execution domain as these two values started&n;&t; * the same after a fork.&n;&t; *&t;&n;&t; */
r_if
c_cond
(paren
id|tsk-&gt;exit_signal
op_ne
id|SIGCHLD
op_logical_and
id|tsk-&gt;exit_signal
op_ne
op_minus
l_int|1
op_logical_and
(paren
id|tsk-&gt;parent_exec_id
op_ne
id|t-&gt;self_exec_id
op_logical_or
id|tsk-&gt;self_exec_id
op_ne
id|tsk-&gt;parent_exec_id
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_KILL
)paren
)paren
id|tsk-&gt;exit_signal
op_assign
id|SIGCHLD
suffix:semicolon
multiline_comment|/* If something other than our normal parent is ptracing us, then&n;&t; * send it a SIGCHLD instead of honoring exit_signal.  exit_signal&n;&t; * only has special meaning to our real parent.&n;&t; */
r_if
c_cond
(paren
id|tsk-&gt;exit_signal
op_ne
op_minus
l_int|1
op_logical_and
id|thread_group_empty
c_func
(paren
id|tsk
)paren
)paren
(brace
r_int
id|signal
op_assign
id|tsk-&gt;parent
op_eq
id|tsk-&gt;real_parent
ques
c_cond
id|tsk-&gt;exit_signal
suffix:colon
id|SIGCHLD
suffix:semicolon
id|do_notify_parent
c_func
(paren
id|tsk
comma
id|signal
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tsk-&gt;ptrace
)paren
(brace
id|do_notify_parent
c_func
(paren
id|tsk
comma
id|SIGCHLD
)paren
suffix:semicolon
)brace
id|state
op_assign
id|EXIT_ZOMBIE
suffix:semicolon
r_if
c_cond
(paren
id|tsk-&gt;exit_signal
op_eq
op_minus
l_int|1
op_logical_and
id|tsk-&gt;ptrace
op_eq
l_int|0
)paren
id|state
op_assign
id|EXIT_DEAD
suffix:semicolon
id|tsk-&gt;exit_state
op_assign
id|state
suffix:semicolon
multiline_comment|/*&n;&t; * Clear these here so that update_process_times() won&squot;t try to deliver&n;&t; * itimer, profile or rlimit signals to this task while it is in late exit.&n;&t; */
id|tsk-&gt;it_virt_value
op_assign
l_int|0
suffix:semicolon
id|tsk-&gt;it_prof_value
op_assign
l_int|0
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|_p
comma
id|_n
comma
op_amp
id|ptrace_dead
)paren
(brace
id|list_del_init
c_func
(paren
id|_p
)paren
suffix:semicolon
id|t
op_assign
id|list_entry
c_func
(paren
id|_p
comma
r_struct
id|task_struct
comma
id|ptrace_list
)paren
suffix:semicolon
id|release_task
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
multiline_comment|/* If the process is dead, release it - nobody will wait for it */
r_if
c_cond
(paren
id|state
op_eq
id|EXIT_DEAD
)paren
id|release_task
c_func
(paren
id|tsk
)paren
suffix:semicolon
multiline_comment|/* PF_DEAD causes final put_task_struct after we schedule. */
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
id|tsk-&gt;flags
op_or_assign
id|PF_DEAD
suffix:semicolon
)brace
DECL|function|do_exit
id|fastcall
id|NORET_TYPE
r_void
id|do_exit
c_func
(paren
r_int
id|code
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_int
id|group_dead
suffix:semicolon
id|profile_task_exit
c_func
(paren
id|tsk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Aiee, killing interrupt handler!&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|tsk-&gt;pid
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Attempted to kill the idle task!&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|tsk-&gt;pid
op_eq
l_int|1
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Attempted to kill init!&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tsk-&gt;io_context
)paren
id|exit_io_context
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|current-&gt;ptrace
op_amp
id|PT_TRACE_EXIT
)paren
)paren
(brace
id|current-&gt;ptrace_message
op_assign
id|code
suffix:semicolon
id|ptrace_notify
c_func
(paren
(paren
id|PTRACE_EVENT_EXIT
op_lshift
l_int|8
)paren
op_or
id|SIGTRAP
)paren
suffix:semicolon
)brace
id|tsk-&gt;flags
op_or_assign
id|PF_EXITING
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|tsk-&gt;real_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|in_atomic
c_func
(paren
)paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;note: %s[%d] exited with preempt_count %d&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
id|preempt_count
c_func
(paren
)paren
)paren
suffix:semicolon
id|acct_update_integrals
c_func
(paren
)paren
suffix:semicolon
id|update_mem_hiwater
c_func
(paren
)paren
suffix:semicolon
id|group_dead
op_assign
id|atomic_dec_and_test
c_func
(paren
op_amp
id|tsk-&gt;signal-&gt;live
)paren
suffix:semicolon
r_if
c_cond
(paren
id|group_dead
)paren
id|acct_process
c_func
(paren
id|code
)paren
suffix:semicolon
id|exit_mm
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|exit_sem
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|__exit_files
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|__exit_fs
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|exit_namespace
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|exit_thread
c_func
(paren
)paren
suffix:semicolon
id|exit_keys
c_func
(paren
id|tsk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|group_dead
op_logical_and
id|tsk-&gt;signal-&gt;leader
)paren
id|disassociate_ctty
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|tsk-&gt;thread_info-&gt;exec_domain-&gt;module
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tsk-&gt;binfmt
)paren
id|module_put
c_func
(paren
id|tsk-&gt;binfmt-&gt;module
)paren
suffix:semicolon
id|tsk-&gt;exit_code
op_assign
id|code
suffix:semicolon
id|exit_notify
c_func
(paren
id|tsk
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NUMA
id|mpol_free
c_func
(paren
id|tsk-&gt;mempolicy
)paren
suffix:semicolon
id|tsk-&gt;mempolicy
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
id|BUG_ON
c_func
(paren
op_logical_neg
(paren
id|current-&gt;flags
op_amp
id|PF_DEAD
)paren
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Avoid &quot;noreturn function does return&quot;.  */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
suffix:semicolon
)brace
DECL|function|complete_and_exit
id|NORET_TYPE
r_void
id|complete_and_exit
c_func
(paren
r_struct
id|completion
op_star
id|comp
comma
r_int
id|code
)paren
(brace
r_if
c_cond
(paren
id|comp
)paren
id|complete
c_func
(paren
id|comp
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|code
)paren
suffix:semicolon
)brace
DECL|variable|complete_and_exit
id|EXPORT_SYMBOL
c_func
(paren
id|complete_and_exit
)paren
suffix:semicolon
DECL|function|sys_exit
id|asmlinkage
r_int
id|sys_exit
c_func
(paren
r_int
id|error_code
)paren
(brace
id|do_exit
c_func
(paren
(paren
id|error_code
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
DECL|function|next_thread
id|task_t
id|fastcall
op_star
id|next_thread
c_func
(paren
r_const
id|task_t
op_star
id|p
)paren
(brace
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;sighand
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|spin_is_locked
c_func
(paren
op_amp
id|p-&gt;sighand-&gt;siglock
)paren
op_logical_and
op_logical_neg
id|rwlock_is_locked
c_func
(paren
op_amp
id|tasklist_lock
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|pid_task
c_func
(paren
id|p-&gt;pids
(braket
id|PIDTYPE_TGID
)braket
dot
id|pid_list.next
comma
id|PIDTYPE_TGID
)paren
suffix:semicolon
)brace
DECL|variable|next_thread
id|EXPORT_SYMBOL
c_func
(paren
id|next_thread
)paren
suffix:semicolon
multiline_comment|/*&n; * Take down every thread in the group.  This is called by fatal signals&n; * as well as by sys_exit_group (below).&n; */
id|NORET_TYPE
r_void
DECL|function|do_group_exit
id|do_group_exit
c_func
(paren
r_int
id|exit_code
)paren
(brace
id|BUG_ON
c_func
(paren
id|exit_code
op_amp
l_int|0x80
)paren
suffix:semicolon
multiline_comment|/* core dumps don&squot;t get here */
r_if
c_cond
(paren
id|current-&gt;signal-&gt;flags
op_amp
id|SIGNAL_GROUP_EXIT
)paren
id|exit_code
op_assign
id|current-&gt;signal-&gt;group_exit_code
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|thread_group_empty
c_func
(paren
id|current
)paren
)paren
(brace
r_struct
id|signal_struct
op_star
r_const
id|sig
op_assign
id|current-&gt;signal
suffix:semicolon
r_struct
id|sighand_struct
op_star
r_const
id|sighand
op_assign
id|current-&gt;sighand
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|sighand-&gt;siglock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sig-&gt;flags
op_amp
id|SIGNAL_GROUP_EXIT
)paren
multiline_comment|/* Another thread got here before we took the lock.  */
id|exit_code
op_assign
id|sig-&gt;group_exit_code
suffix:semicolon
r_else
(brace
id|sig-&gt;flags
op_assign
id|SIGNAL_GROUP_EXIT
suffix:semicolon
id|sig-&gt;group_exit_code
op_assign
id|exit_code
suffix:semicolon
id|zap_other_threads
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|sighand-&gt;siglock
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
id|do_exit
c_func
(paren
id|exit_code
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
multiline_comment|/*&n; * this kills every thread in the thread group. Note that any externally&n; * wait4()-ing process will get the correct exit code - even if this&n; * thread is not the thread group leader.&n; */
DECL|function|sys_exit_group
id|asmlinkage
r_void
id|sys_exit_group
c_func
(paren
r_int
id|error_code
)paren
(brace
id|do_group_exit
c_func
(paren
(paren
id|error_code
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
DECL|function|eligible_child
r_static
r_int
id|eligible_child
c_func
(paren
id|pid_t
id|pid
comma
r_int
id|options
comma
id|task_t
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|pid
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;pid
op_ne
id|pid
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|pid
)paren
(brace
r_if
c_cond
(paren
id|process_group
c_func
(paren
id|p
)paren
op_ne
id|process_group
c_func
(paren
id|current
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pid
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|process_group
c_func
(paren
id|p
)paren
op_ne
op_minus
id|pid
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Do not consider detached threads that are&n;&t; * not ptraced:&n;&t; */
r_if
c_cond
(paren
id|p-&gt;exit_signal
op_eq
op_minus
l_int|1
op_logical_and
op_logical_neg
id|p-&gt;ptrace
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Wait for all children (clone and not) if __WALL is set;&n;&t; * otherwise, wait for clone children *only* if __WCLONE is&n;&t; * set; otherwise, wait for non-clone children *only*.  (Note:&n;&t; * A &quot;clone&quot; child here is one that reports to its parent&n;&t; * using a signal other than SIGCHLD.) */
r_if
c_cond
(paren
(paren
(paren
id|p-&gt;exit_signal
op_ne
id|SIGCHLD
)paren
op_xor
(paren
(paren
id|options
op_amp
id|__WCLONE
)paren
op_ne
l_int|0
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|options
op_amp
id|__WALL
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Do not consider thread group leaders that are&n;&t; * in a non-empty thread group:&n;&t; */
r_if
c_cond
(paren
id|current-&gt;tgid
op_ne
id|p-&gt;tgid
op_logical_and
id|delay_group_leader
c_func
(paren
id|p
)paren
)paren
r_return
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|security_task_wait
c_func
(paren
id|p
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|wait_noreap_copyout
r_static
r_int
id|wait_noreap_copyout
c_func
(paren
id|task_t
op_star
id|p
comma
id|pid_t
id|pid
comma
id|uid_t
id|uid
comma
r_int
id|why
comma
r_int
id|status
comma
r_struct
id|siginfo
id|__user
op_star
id|infop
comma
r_struct
id|rusage
id|__user
op_star
id|rusagep
)paren
(brace
r_int
id|retval
op_assign
id|rusagep
ques
c_cond
id|getrusage
c_func
(paren
id|p
comma
id|RUSAGE_BOTH
comma
id|rusagep
)paren
suffix:colon
l_int|0
suffix:semicolon
id|put_task_struct
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|put_user
c_func
(paren
id|SIGCHLD
comma
op_amp
id|infop-&gt;si_signo
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|put_user
c_func
(paren
l_int|0
comma
op_amp
id|infop-&gt;si_errno
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|put_user
c_func
(paren
(paren
r_int
)paren
id|why
comma
op_amp
id|infop-&gt;si_code
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|put_user
c_func
(paren
id|pid
comma
op_amp
id|infop-&gt;si_pid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|put_user
c_func
(paren
id|uid
comma
op_amp
id|infop-&gt;si_uid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|put_user
c_func
(paren
id|status
comma
op_amp
id|infop-&gt;si_status
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|pid
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle sys_wait4 work for one task in state EXIT_ZOMBIE.  We hold&n; * read_lock(&amp;tasklist_lock) on entry.  If we return zero, we still hold&n; * the lock and this task is uninteresting.  If we return nonzero, we have&n; * released the lock and the system call should return.&n; */
DECL|function|wait_task_zombie
r_static
r_int
id|wait_task_zombie
c_func
(paren
id|task_t
op_star
id|p
comma
r_int
id|noreap
comma
r_struct
id|siginfo
id|__user
op_star
id|infop
comma
r_int
id|__user
op_star
id|stat_addr
comma
r_struct
id|rusage
id|__user
op_star
id|ru
)paren
(brace
r_int
r_int
id|state
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|noreap
)paren
)paren
(brace
id|pid_t
id|pid
op_assign
id|p-&gt;pid
suffix:semicolon
id|uid_t
id|uid
op_assign
id|p-&gt;uid
suffix:semicolon
r_int
id|exit_code
op_assign
id|p-&gt;exit_code
suffix:semicolon
r_int
id|why
comma
id|status
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|p-&gt;exit_state
op_ne
id|EXIT_ZOMBIE
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|p-&gt;exit_signal
op_eq
op_minus
l_int|1
op_logical_and
id|p-&gt;ptrace
op_eq
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|get_task_struct
c_func
(paren
id|p
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|exit_code
op_amp
l_int|0x7f
)paren
op_eq
l_int|0
)paren
(brace
id|why
op_assign
id|CLD_EXITED
suffix:semicolon
id|status
op_assign
id|exit_code
op_rshift
l_int|8
suffix:semicolon
)brace
r_else
(brace
id|why
op_assign
(paren
id|exit_code
op_amp
l_int|0x80
)paren
ques
c_cond
id|CLD_DUMPED
suffix:colon
id|CLD_KILLED
suffix:semicolon
id|status
op_assign
id|exit_code
op_amp
l_int|0x7f
suffix:semicolon
)brace
r_return
id|wait_noreap_copyout
c_func
(paren
id|p
comma
id|pid
comma
id|uid
comma
id|why
comma
id|status
comma
id|infop
comma
id|ru
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Try to move the task&squot;s state to DEAD&n;&t; * only one thread is allowed to do this:&n;&t; */
id|state
op_assign
id|xchg
c_func
(paren
op_amp
id|p-&gt;exit_state
comma
id|EXIT_DEAD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_ne
id|EXIT_ZOMBIE
)paren
(brace
id|BUG_ON
c_func
(paren
id|state
op_ne
id|EXIT_DEAD
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|p-&gt;exit_signal
op_eq
op_minus
l_int|1
op_logical_and
id|p-&gt;ptrace
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * This can only happen in a race with a ptraced thread&n;&t;&t; * dying on another processor.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|p-&gt;real_parent
op_eq
id|p-&gt;parent
)paren
op_logical_and
id|likely
c_func
(paren
id|p-&gt;signal
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * The resource counters for the group leader are in its&n;&t;&t; * own task_struct.  Those for dead threads in the group&n;&t;&t; * are in its signal_struct, as are those for the child&n;&t;&t; * processes it has previously reaped.  All these&n;&t;&t; * accumulate in the parent&squot;s signal_struct c* fields.&n;&t;&t; *&n;&t;&t; * We don&squot;t bother to take a lock here to protect these&n;&t;&t; * p-&gt;signal fields, because they are only touched by&n;&t;&t; * __exit_signal, which runs with tasklist_lock&n;&t;&t; * write-locked anyway, and so is excluded here.  We do&n;&t;&t; * need to protect the access to p-&gt;parent-&gt;signal fields,&n;&t;&t; * as other threads in the parent group can be right&n;&t;&t; * here reaping other children at the same time.&n;&t;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|p-&gt;parent-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
id|p-&gt;parent-&gt;signal-&gt;cutime
op_add_assign
id|p-&gt;utime
op_plus
id|p-&gt;signal-&gt;utime
op_plus
id|p-&gt;signal-&gt;cutime
suffix:semicolon
id|p-&gt;parent-&gt;signal-&gt;cstime
op_add_assign
id|p-&gt;stime
op_plus
id|p-&gt;signal-&gt;stime
op_plus
id|p-&gt;signal-&gt;cstime
suffix:semicolon
id|p-&gt;parent-&gt;signal-&gt;cmin_flt
op_add_assign
id|p-&gt;min_flt
op_plus
id|p-&gt;signal-&gt;min_flt
op_plus
id|p-&gt;signal-&gt;cmin_flt
suffix:semicolon
id|p-&gt;parent-&gt;signal-&gt;cmaj_flt
op_add_assign
id|p-&gt;maj_flt
op_plus
id|p-&gt;signal-&gt;maj_flt
op_plus
id|p-&gt;signal-&gt;cmaj_flt
suffix:semicolon
id|p-&gt;parent-&gt;signal-&gt;cnvcsw
op_add_assign
id|p-&gt;nvcsw
op_plus
id|p-&gt;signal-&gt;nvcsw
op_plus
id|p-&gt;signal-&gt;cnvcsw
suffix:semicolon
id|p-&gt;parent-&gt;signal-&gt;cnivcsw
op_add_assign
id|p-&gt;nivcsw
op_plus
id|p-&gt;signal-&gt;nivcsw
op_plus
id|p-&gt;signal-&gt;cnivcsw
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|p-&gt;parent-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now we are sure this task is interesting, and no other&n;&t; * thread can reap it because we set its state to EXIT_DEAD.&n;&t; */
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|retval
op_assign
id|ru
ques
c_cond
id|getrusage
c_func
(paren
id|p
comma
id|RUSAGE_BOTH
comma
id|ru
)paren
suffix:colon
l_int|0
suffix:semicolon
id|status
op_assign
(paren
id|p-&gt;signal-&gt;flags
op_amp
id|SIGNAL_GROUP_EXIT
)paren
ques
c_cond
id|p-&gt;signal-&gt;group_exit_code
suffix:colon
id|p-&gt;exit_code
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
op_logical_and
id|stat_addr
)paren
id|retval
op_assign
id|put_user
c_func
(paren
id|status
comma
id|stat_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
op_logical_and
id|infop
)paren
id|retval
op_assign
id|put_user
c_func
(paren
id|SIGCHLD
comma
op_amp
id|infop-&gt;si_signo
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
op_logical_and
id|infop
)paren
id|retval
op_assign
id|put_user
c_func
(paren
l_int|0
comma
op_amp
id|infop-&gt;si_errno
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
op_logical_and
id|infop
)paren
(brace
r_int
id|why
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0x7f
)paren
op_eq
l_int|0
)paren
(brace
id|why
op_assign
id|CLD_EXITED
suffix:semicolon
id|status
op_rshift_assign
l_int|8
suffix:semicolon
)brace
r_else
(brace
id|why
op_assign
(paren
id|status
op_amp
l_int|0x80
)paren
ques
c_cond
id|CLD_DUMPED
suffix:colon
id|CLD_KILLED
suffix:semicolon
id|status
op_and_assign
l_int|0x7f
suffix:semicolon
)brace
id|retval
op_assign
id|put_user
c_func
(paren
(paren
r_int
)paren
id|why
comma
op_amp
id|infop-&gt;si_code
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|put_user
c_func
(paren
id|status
comma
op_amp
id|infop-&gt;si_status
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|retval
op_logical_and
id|infop
)paren
id|retval
op_assign
id|put_user
c_func
(paren
id|p-&gt;pid
comma
op_amp
id|infop-&gt;si_pid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
op_logical_and
id|infop
)paren
id|retval
op_assign
id|put_user
c_func
(paren
id|p-&gt;uid
comma
op_amp
id|infop-&gt;si_uid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
singleline_comment|// TODO: is this safe?
id|p-&gt;exit_state
op_assign
id|EXIT_ZOMBIE
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|retval
op_assign
id|p-&gt;pid
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;real_parent
op_ne
id|p-&gt;parent
)paren
(brace
id|write_lock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
multiline_comment|/* Double-check with lock held.  */
r_if
c_cond
(paren
id|p-&gt;real_parent
op_ne
id|p-&gt;parent
)paren
(brace
id|__ptrace_unlink
c_func
(paren
id|p
)paren
suffix:semicolon
singleline_comment|// TODO: is this safe?
id|p-&gt;exit_state
op_assign
id|EXIT_ZOMBIE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If this is not a detached task, notify the parent.&n;&t;&t;&t; * If it&squot;s still not detached after that, don&squot;t release&n;&t;&t;&t; * it now.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|p-&gt;exit_signal
op_ne
op_minus
l_int|1
)paren
(brace
id|do_notify_parent
c_func
(paren
id|p
comma
id|p-&gt;exit_signal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;exit_signal
op_ne
op_minus
l_int|1
)paren
id|p
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|write_unlock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
op_ne
l_int|NULL
)paren
id|release_task
c_func
(paren
id|p
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle sys_wait4 work for one task in state TASK_STOPPED.  We hold&n; * read_lock(&amp;tasklist_lock) on entry.  If we return zero, we still hold&n; * the lock and this task is uninteresting.  If we return nonzero, we have&n; * released the lock and the system call should return.&n; */
DECL|function|wait_task_stopped
r_static
r_int
id|wait_task_stopped
c_func
(paren
id|task_t
op_star
id|p
comma
r_int
id|delayed_group_leader
comma
r_int
id|noreap
comma
r_struct
id|siginfo
id|__user
op_star
id|infop
comma
r_int
id|__user
op_star
id|stat_addr
comma
r_struct
id|rusage
id|__user
op_star
id|ru
)paren
(brace
r_int
id|retval
comma
id|exit_code
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;exit_code
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|delayed_group_leader
op_logical_and
op_logical_neg
(paren
id|p-&gt;ptrace
op_amp
id|PT_PTRACED
)paren
op_logical_and
id|p-&gt;signal
op_logical_and
id|p-&gt;signal-&gt;group_stop_count
OG
l_int|0
)paren
multiline_comment|/*&n;&t;&t; * A group stop is in progress and this is the group leader.&n;&t;&t; * We won&squot;t report until all threads have stopped.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Now we are pretty sure this task is interesting.&n;&t; * Make sure it doesn&squot;t get reaped out from under us while we&n;&t; * give up the lock and then examine it below.  We don&squot;t want to&n;&t; * keep holding onto the tasklist_lock while we call getrusage and&n;&t; * possibly take page faults for user memory.&n;&t; */
id|get_task_struct
c_func
(paren
id|p
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|noreap
)paren
)paren
(brace
id|pid_t
id|pid
op_assign
id|p-&gt;pid
suffix:semicolon
id|uid_t
id|uid
op_assign
id|p-&gt;uid
suffix:semicolon
r_int
id|why
op_assign
(paren
id|p-&gt;ptrace
op_amp
id|PT_PTRACED
)paren
ques
c_cond
id|CLD_TRAPPED
suffix:colon
id|CLD_STOPPED
suffix:semicolon
id|exit_code
op_assign
id|p-&gt;exit_code
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|exit_code
)paren
op_logical_or
id|unlikely
c_func
(paren
id|p-&gt;state
OG
id|TASK_STOPPED
)paren
)paren
r_goto
id|bail_ref
suffix:semicolon
r_return
id|wait_noreap_copyout
c_func
(paren
id|p
comma
id|pid
comma
id|uid
comma
id|why
comma
(paren
id|exit_code
op_lshift
l_int|8
)paren
op_or
l_int|0x7f
comma
id|infop
comma
id|ru
)paren
suffix:semicolon
)brace
id|write_lock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This uses xchg to be atomic with the thread resuming and setting&n;&t; * it.  It must also be done with the write lock held to prevent a&n;&t; * race with the EXIT_ZOMBIE case.&n;&t; */
id|exit_code
op_assign
id|xchg
c_func
(paren
op_amp
id|p-&gt;exit_code
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|p-&gt;exit_state
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * The task resumed and then died.  Let the next iteration&n;&t;&t; * catch it in EXIT_ZOMBIE.  Note that exit_code might&n;&t;&t; * already be zero here if it resumed and did _exit(0).&n;&t;&t; * The task itself is dead and won&squot;t touch exit_code again;&n;&t;&t; * other processors in this function are locked out.&n;&t;&t; */
id|p-&gt;exit_code
op_assign
id|exit_code
suffix:semicolon
id|exit_code
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|exit_code
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Another thread in this function got to it first, or it&n;&t;&t; * resumed, or it resumed and then died.&n;&t;&t; */
id|write_unlock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|bail_ref
suffix:colon
id|put_task_struct
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We are returning to the wait loop without having successfully&n;&t;&t; * removed the process and having released the lock. We cannot&n;&t;&t; * continue, since the &quot;p&quot; task pointer is potentially stale.&n;&t;&t; *&n;&t;&t; * Return -EAGAIN, and do_wait() will restart the loop from the&n;&t;&t; * beginning. Do _not_ re-acquire the lock.&n;&t;&t; */
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/* move to end of parent&squot;s list to avoid starvation */
id|remove_parent
c_func
(paren
id|p
)paren
suffix:semicolon
id|add_parent
c_func
(paren
id|p
comma
id|p-&gt;parent
)paren
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|retval
op_assign
id|ru
ques
c_cond
id|getrusage
c_func
(paren
id|p
comma
id|RUSAGE_BOTH
comma
id|ru
)paren
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
op_logical_and
id|stat_addr
)paren
id|retval
op_assign
id|put_user
c_func
(paren
(paren
id|exit_code
op_lshift
l_int|8
)paren
op_or
l_int|0x7f
comma
id|stat_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
op_logical_and
id|infop
)paren
id|retval
op_assign
id|put_user
c_func
(paren
id|SIGCHLD
comma
op_amp
id|infop-&gt;si_signo
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
op_logical_and
id|infop
)paren
id|retval
op_assign
id|put_user
c_func
(paren
l_int|0
comma
op_amp
id|infop-&gt;si_errno
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
op_logical_and
id|infop
)paren
id|retval
op_assign
id|put_user
c_func
(paren
(paren
r_int
)paren
(paren
(paren
id|p-&gt;ptrace
op_amp
id|PT_PTRACED
)paren
ques
c_cond
id|CLD_TRAPPED
suffix:colon
id|CLD_STOPPED
)paren
comma
op_amp
id|infop-&gt;si_code
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
op_logical_and
id|infop
)paren
id|retval
op_assign
id|put_user
c_func
(paren
id|exit_code
comma
op_amp
id|infop-&gt;si_status
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
op_logical_and
id|infop
)paren
id|retval
op_assign
id|put_user
c_func
(paren
id|p-&gt;pid
comma
op_amp
id|infop-&gt;si_pid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
op_logical_and
id|infop
)paren
id|retval
op_assign
id|put_user
c_func
(paren
id|p-&gt;uid
comma
op_amp
id|infop-&gt;si_uid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|p-&gt;pid
suffix:semicolon
id|put_task_struct
c_func
(paren
id|p
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle do_wait work for one task in a live, non-stopped state.&n; * read_lock(&amp;tasklist_lock) on entry.  If we return zero, we still hold&n; * the lock and this task is uninteresting.  If we return nonzero, we have&n; * released the lock and the system call should return.&n; */
DECL|function|wait_task_continued
r_static
r_int
id|wait_task_continued
c_func
(paren
id|task_t
op_star
id|p
comma
r_int
id|noreap
comma
r_struct
id|siginfo
id|__user
op_star
id|infop
comma
r_int
id|__user
op_star
id|stat_addr
comma
r_struct
id|rusage
id|__user
op_star
id|ru
)paren
(brace
r_int
id|retval
suffix:semicolon
id|pid_t
id|pid
suffix:semicolon
id|uid_t
id|uid
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|p-&gt;signal
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;signal-&gt;flags
op_amp
id|SIGNAL_STOP_CONTINUED
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|p-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
multiline_comment|/* Re-check with the lock held.  */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;signal-&gt;flags
op_amp
id|SIGNAL_STOP_CONTINUED
)paren
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|p-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|noreap
)paren
id|p-&gt;signal-&gt;flags
op_and_assign
op_complement
id|SIGNAL_STOP_CONTINUED
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|p-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
id|pid
op_assign
id|p-&gt;pid
suffix:semicolon
id|uid
op_assign
id|p-&gt;uid
suffix:semicolon
id|get_task_struct
c_func
(paren
id|p
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|infop
)paren
(brace
id|retval
op_assign
id|ru
ques
c_cond
id|getrusage
c_func
(paren
id|p
comma
id|RUSAGE_BOTH
comma
id|ru
)paren
suffix:colon
l_int|0
suffix:semicolon
id|put_task_struct
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
op_logical_and
id|stat_addr
)paren
id|retval
op_assign
id|put_user
c_func
(paren
l_int|0xffff
comma
id|stat_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|p-&gt;pid
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|wait_noreap_copyout
c_func
(paren
id|p
comma
id|pid
comma
id|uid
comma
id|CLD_CONTINUED
comma
id|SIGCONT
comma
id|infop
comma
id|ru
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|retval
op_eq
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|my_ptrace_child
r_static
r_inline
r_int
id|my_ptrace_child
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;ptrace
op_amp
id|PT_PTRACED
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;ptrace
op_amp
id|PT_ATTACHED
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * This child was PTRACE_ATTACH&squot;d.  We should be seeing it only if&n;&t; * we are the attacher.  If we are the real parent, this is a race&n;&t; * inside ptrace_attach.  It is waiting for the tasklist_lock,&n;&t; * which we have to switch the parent links, but has already set&n;&t; * the flags in p-&gt;ptrace.&n;&t; */
r_return
(paren
id|p-&gt;parent
op_ne
id|p-&gt;real_parent
)paren
suffix:semicolon
)brace
DECL|function|do_wait
r_static
r_int
id|do_wait
c_func
(paren
id|pid_t
id|pid
comma
r_int
id|options
comma
r_struct
id|siginfo
id|__user
op_star
id|infop
comma
r_int
id|__user
op_star
id|stat_addr
comma
r_struct
id|rusage
id|__user
op_star
id|ru
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
suffix:semicolon
r_int
id|flag
comma
id|retval
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|current-&gt;signal-&gt;wait_chldexit
comma
op_amp
id|wait
)paren
suffix:semicolon
id|repeat
suffix:colon
multiline_comment|/*&n;&t; * We will set this flag if we see any child that might later&n;&t; * match our criteria, even if we are not able to reap it yet.&n;&t; */
id|flag
op_assign
l_int|0
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|tsk
op_assign
id|current
suffix:semicolon
r_do
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_struct
id|list_head
op_star
id|_p
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|list_for_each
c_func
(paren
id|_p
comma
op_amp
id|tsk-&gt;children
)paren
(brace
id|p
op_assign
id|list_entry
c_func
(paren
id|_p
comma
r_struct
id|task_struct
comma
id|sibling
)paren
suffix:semicolon
id|ret
op_assign
id|eligible_child
c_func
(paren
id|pid
comma
id|options
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
r_continue
suffix:semicolon
r_switch
c_cond
(paren
id|p-&gt;state
)paren
(brace
r_case
id|TASK_TRACED
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|my_ptrace_child
c_func
(paren
id|p
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*FALLTHROUGH*/
r_case
id|TASK_STOPPED
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * It&squot;s stopped now, so it might later&n;&t;&t;&t;&t; * continue, exit, or stop again.&n;&t;&t;&t;&t; */
id|flag
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|options
op_amp
id|WUNTRACED
)paren
op_logical_and
op_logical_neg
id|my_ptrace_child
c_func
(paren
id|p
)paren
)paren
r_continue
suffix:semicolon
id|retval
op_assign
id|wait_task_stopped
c_func
(paren
id|p
comma
id|ret
op_eq
l_int|2
comma
(paren
id|options
op_amp
id|WNOWAIT
)paren
comma
id|infop
comma
id|stat_addr
comma
id|ru
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
op_minus
id|EAGAIN
)paren
r_goto
id|repeat
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
l_int|0
)paren
multiline_comment|/* He released the lock.  */
r_goto
id|end
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
singleline_comment|// case EXIT_DEAD:
r_if
c_cond
(paren
id|p-&gt;exit_state
op_eq
id|EXIT_DEAD
)paren
r_continue
suffix:semicolon
singleline_comment|// case EXIT_ZOMBIE:
r_if
c_cond
(paren
id|p-&gt;exit_state
op_eq
id|EXIT_ZOMBIE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Eligible but we cannot release&n;&t;&t;&t;&t;&t; * it yet:&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ret
op_eq
l_int|2
)paren
r_goto
id|check_continued
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|likely
c_func
(paren
id|options
op_amp
id|WEXITED
)paren
)paren
r_continue
suffix:semicolon
id|retval
op_assign
id|wait_task_zombie
c_func
(paren
id|p
comma
(paren
id|options
op_amp
id|WNOWAIT
)paren
comma
id|infop
comma
id|stat_addr
comma
id|ru
)paren
suffix:semicolon
multiline_comment|/* He released the lock.  */
r_if
c_cond
(paren
id|retval
op_ne
l_int|0
)paren
r_goto
id|end
suffix:semicolon
r_break
suffix:semicolon
)brace
id|check_continued
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * It&squot;s running now, so it might later&n;&t;&t;&t;&t; * exit, stop, or stop and then continue.&n;&t;&t;&t;&t; */
id|flag
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|unlikely
c_func
(paren
id|options
op_amp
id|WCONTINUED
)paren
)paren
r_continue
suffix:semicolon
id|retval
op_assign
id|wait_task_continued
c_func
(paren
id|p
comma
(paren
id|options
op_amp
id|WNOWAIT
)paren
comma
id|infop
comma
id|stat_addr
comma
id|ru
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
l_int|0
)paren
multiline_comment|/* He released the lock.  */
r_goto
id|end
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
(brace
id|list_for_each
c_func
(paren
id|_p
comma
op_amp
id|tsk-&gt;ptrace_children
)paren
(brace
id|p
op_assign
id|list_entry
c_func
(paren
id|_p
comma
r_struct
id|task_struct
comma
id|ptrace_list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eligible_child
c_func
(paren
id|pid
comma
id|options
comma
id|p
)paren
)paren
r_continue
suffix:semicolon
id|flag
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|options
op_amp
id|__WNOTHREAD
)paren
r_break
suffix:semicolon
id|tsk
op_assign
id|next_thread
c_func
(paren
id|tsk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tsk-&gt;signal
op_ne
id|current-&gt;signal
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tsk
op_ne
id|current
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
)paren
(brace
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|options
op_amp
id|WNOHANG
)paren
r_goto
id|end
suffix:semicolon
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_goto
id|end
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|retval
op_assign
op_minus
id|ECHILD
suffix:semicolon
id|end
suffix:colon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|current-&gt;signal-&gt;wait_chldexit
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|infop
)paren
(brace
r_if
c_cond
(paren
id|retval
OG
l_int|0
)paren
id|retval
op_assign
l_int|0
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * For a WNOHANG return, clear out all the fields&n;&t;&t;&t; * we would set so the user can easily tell the&n;&t;&t;&t; * difference.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|put_user
c_func
(paren
l_int|0
comma
op_amp
id|infop-&gt;si_signo
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|put_user
c_func
(paren
l_int|0
comma
op_amp
id|infop-&gt;si_errno
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|put_user
c_func
(paren
l_int|0
comma
op_amp
id|infop-&gt;si_code
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|put_user
c_func
(paren
l_int|0
comma
op_amp
id|infop-&gt;si_pid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|put_user
c_func
(paren
l_int|0
comma
op_amp
id|infop-&gt;si_uid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|put_user
c_func
(paren
l_int|0
comma
op_amp
id|infop-&gt;si_status
)paren
suffix:semicolon
)brace
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|sys_waitid
id|asmlinkage
r_int
id|sys_waitid
c_func
(paren
r_int
id|which
comma
id|pid_t
id|pid
comma
r_struct
id|siginfo
id|__user
op_star
id|infop
comma
r_int
id|options
comma
r_struct
id|rusage
id|__user
op_star
id|ru
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|options
op_amp
op_complement
(paren
id|WNOHANG
op_or
id|WNOWAIT
op_or
id|WEXITED
op_or
id|WSTOPPED
op_or
id|WCONTINUED
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|options
op_amp
(paren
id|WEXITED
op_or
id|WSTOPPED
op_or
id|WCONTINUED
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|which
)paren
(brace
r_case
id|P_ALL
suffix:colon
id|pid
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_PID
suffix:colon
r_if
c_cond
(paren
id|pid
op_le
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_PGID
suffix:colon
r_if
c_cond
(paren
id|pid
op_le
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|pid
op_assign
op_minus
id|pid
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ret
op_assign
id|do_wait
c_func
(paren
id|pid
comma
id|options
comma
id|infop
comma
l_int|NULL
comma
id|ru
)paren
suffix:semicolon
multiline_comment|/* avoid REGPARM breakage on x86: */
id|prevent_tail_call
c_func
(paren
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sys_wait4
id|asmlinkage
r_int
id|sys_wait4
c_func
(paren
id|pid_t
id|pid
comma
r_int
id|__user
op_star
id|stat_addr
comma
r_int
id|options
comma
r_struct
id|rusage
id|__user
op_star
id|ru
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|options
op_amp
op_complement
(paren
id|WNOHANG
op_or
id|WUNTRACED
op_or
id|WCONTINUED
op_or
id|__WNOTHREAD
op_or
id|__WCLONE
op_or
id|__WALL
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ret
op_assign
id|do_wait
c_func
(paren
id|pid
comma
id|options
op_or
id|WEXITED
comma
l_int|NULL
comma
id|stat_addr
comma
id|ru
)paren
suffix:semicolon
multiline_comment|/* avoid REGPARM breakage on x86: */
id|prevent_tail_call
c_func
(paren
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef __ARCH_WANT_SYS_WAITPID
multiline_comment|/*&n; * sys_waitpid() remains for compatibility. waitpid() should be&n; * implemented by calling sys_wait4() from libc.a.&n; */
DECL|function|sys_waitpid
id|asmlinkage
r_int
id|sys_waitpid
c_func
(paren
id|pid_t
id|pid
comma
r_int
id|__user
op_star
id|stat_addr
comma
r_int
id|options
)paren
(brace
r_return
id|sys_wait4
c_func
(paren
id|pid
comma
id|stat_addr
comma
id|options
comma
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
