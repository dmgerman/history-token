multiline_comment|/* audit.c -- Auditing support -*- linux-c -*-&n; * Gateway between the kernel (e.g., selinux) and the user-space audit daemon.&n; * System-call specific features have moved to auditsc.c&n; *&n; * Copyright 2003-2004 Red Hat Inc., Durham, North Carolina.&n; * All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; *&n; * Written by Rickard E. (Rik) Faith &lt;faith@redhat.com&gt;&n; *&n; * Goals: 1) Integrate fully with SELinux.&n; *&t;  2) Minimal run-time overhead:&n; *&t;     a) Minimal when syscall auditing is disabled (audit_enable=0).&n; *&t;     b) Small when syscall auditing is enabled and no audit record&n; *&t;&t;is generated (defer as much work as possible to record&n; *&t;&t;generation time):&n; *&t;&t;i) context is allocated,&n; *&t;&t;ii) names from getname are stored without a copy, and&n; *&t;&t;iii) inode information stored from path_lookup.&n; *&t;  3) Ability to disable syscall auditing at boot time (audit=0).&n; *&t;  4) Usable by other parts of the kernel (if audit_log* is called,&n; *&t;     then a syscall record will be generated automatically for the&n; *&t;     current syscall).&n; *&t;  5) Netlink interface to user-space.&n; *&t;  6) Support low-overhead kernel-based filtering to minimize the&n; *&t;     information that must be passed to user-space.&n; *&n; * Example user-space utilities: http://people.redhat.com/faith/audit/&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/types.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/audit.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/netlink.h&gt;
multiline_comment|/* No auditing will take place until audit_initialized != 0.&n; * (Initialization happens after skb_init is called.) */
DECL|variable|audit_initialized
r_static
r_int
id|audit_initialized
suffix:semicolon
multiline_comment|/* No syscall auditing will take place unless audit_enabled != 0. */
DECL|variable|audit_enabled
r_int
id|audit_enabled
suffix:semicolon
multiline_comment|/* Default state when kernel boots without any parameters. */
DECL|variable|audit_default
r_static
r_int
id|audit_default
suffix:semicolon
multiline_comment|/* If auditing cannot proceed, audit_failure selects what happens. */
DECL|variable|audit_failure
r_static
r_int
id|audit_failure
op_assign
id|AUDIT_FAIL_PRINTK
suffix:semicolon
multiline_comment|/* If audit records are to be written to the netlink socket, audit_pid&n; * contains the (non-zero) pid. */
DECL|variable|audit_pid
r_static
r_int
id|audit_pid
suffix:semicolon
multiline_comment|/* If audit_limit is non-zero, limit the rate of sending audit records&n; * to that number per second.  This prevents DoS attacks, but results in&n; * audit records being dropped. */
DECL|variable|audit_rate_limit
r_static
r_int
id|audit_rate_limit
suffix:semicolon
multiline_comment|/* Number of outstanding audit_buffers allowed. */
DECL|variable|audit_backlog_limit
r_static
r_int
id|audit_backlog_limit
op_assign
l_int|64
suffix:semicolon
DECL|variable|audit_backlog
r_static
id|atomic_t
id|audit_backlog
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Records can be lost in several ways:&n;   0) [suppressed in audit_alloc]&n;   1) out of memory in audit_log_start [kmalloc of struct audit_buffer]&n;   2) out of memory in audit_log_move [alloc_skb]&n;   3) suppressed due to audit_rate_limit&n;   4) suppressed due to audit_backlog_limit&n;*/
DECL|variable|audit_lost
r_static
id|atomic_t
id|audit_lost
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* The netlink socket. */
DECL|variable|audit_sock
r_static
r_struct
id|sock
op_star
id|audit_sock
suffix:semicolon
multiline_comment|/* There are two lists of audit buffers.  The txlist contains audit&n; * buffers that cannot be sent immediately to the netlink device because&n; * we are in an irq context (these are sent later in a tasklet).&n; *&n; * The second list is a list of pre-allocated audit buffers (if more&n; * than AUDIT_MAXFREE are in use, the audit buffer is freed instead of&n; * being placed on the freelist). */
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|audit_txlist_lock
)paren
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|audit_freelist_lock
)paren
suffix:semicolon
DECL|variable|audit_freelist_count
r_static
r_int
id|audit_freelist_count
op_assign
l_int|0
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|audit_txlist
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|audit_freelist
)paren
suffix:semicolon
multiline_comment|/* There are three lists of rules -- one to search at task creation&n; * time, one to search at syscall entry time, and another to search at&n; * syscall exit time. */
r_static
id|LIST_HEAD
c_func
(paren
id|audit_tsklist
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|audit_entlist
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|audit_extlist
)paren
suffix:semicolon
multiline_comment|/* The netlink socket is only to be read by 1 CPU, which lets us assume&n; * that list additions and deletions never happen simultaneiously in&n; * auditsc.c */
r_static
id|DECLARE_MUTEX
c_func
(paren
id|audit_netlink_sem
)paren
suffix:semicolon
multiline_comment|/* AUDIT_BUFSIZ is the size of the temporary buffer used for formatting&n; * audit records.  Since printk uses a 1024 byte buffer, this buffer&n; * should be at least that large. */
DECL|macro|AUDIT_BUFSIZ
mdefine_line|#define AUDIT_BUFSIZ 1024
multiline_comment|/* AUDIT_MAXFREE is the number of empty audit_buffers we keep on the&n; * audit_freelist.  Doing so eliminates many kmalloc/kfree calls. */
DECL|macro|AUDIT_MAXFREE
mdefine_line|#define AUDIT_MAXFREE  (2*NR_CPUS)
multiline_comment|/* The audit_buffer is used when formatting an audit record.  The caller&n; * locks briefly to get the record off the freelist or to allocate the&n; * buffer, and locks briefly to send the buffer to the netlink layer or&n; * to place it on a transmit queue.  Multiple audit_buffers can be in&n; * use simultaneously. */
DECL|struct|audit_buffer
r_struct
id|audit_buffer
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|sklist
r_struct
id|sk_buff_head
id|sklist
suffix:semicolon
multiline_comment|/* formatted skbs ready to send */
DECL|member|ctx
r_struct
id|audit_context
op_star
id|ctx
suffix:semicolon
multiline_comment|/* NULL or associated context */
DECL|member|len
r_int
id|len
suffix:semicolon
multiline_comment|/* used area of tmp */
DECL|member|tmp
r_char
id|tmp
(braket
id|AUDIT_BUFSIZ
)braket
suffix:semicolon
multiline_comment|/* Pointer to header and contents */
DECL|member|nlh
r_struct
id|nlmsghdr
op_star
id|nlh
suffix:semicolon
DECL|member|total
r_int
id|total
suffix:semicolon
DECL|member|type
r_int
id|type
suffix:semicolon
DECL|member|pid
r_int
id|pid
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
multiline_comment|/* Times requeued */
)brace
suffix:semicolon
DECL|function|audit_set_type
r_void
id|audit_set_type
c_func
(paren
r_struct
id|audit_buffer
op_star
id|ab
comma
r_int
id|type
)paren
(brace
id|ab-&gt;type
op_assign
id|type
suffix:semicolon
)brace
DECL|struct|audit_entry
r_struct
id|audit_entry
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|rule
r_struct
id|audit_rule
id|rule
suffix:semicolon
)brace
suffix:semicolon
DECL|function|audit_panic
r_static
r_void
id|audit_panic
c_func
(paren
r_const
r_char
op_star
id|message
)paren
(brace
r_switch
c_cond
(paren
id|audit_failure
)paren
(brace
r_case
id|AUDIT_FAIL_SILENT
suffix:colon
r_break
suffix:semicolon
r_case
id|AUDIT_FAIL_PRINTK
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;audit: %s&bslash;n&quot;
comma
id|message
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_FAIL_PANIC
suffix:colon
id|panic
c_func
(paren
l_string|&quot;audit: %s&bslash;n&quot;
comma
id|message
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|audit_rate_check
r_static
r_inline
r_int
id|audit_rate_check
c_func
(paren
r_void
)paren
(brace
r_static
r_int
r_int
id|last_check
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|messages
op_assign
l_int|0
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|lock
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|now
suffix:semicolon
r_int
r_int
id|elapsed
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|audit_rate_limit
)paren
r_return
l_int|1
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|messages
OL
id|audit_rate_limit
)paren
(brace
id|retval
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|now
op_assign
id|jiffies
suffix:semicolon
id|elapsed
op_assign
id|now
op_minus
id|last_check
suffix:semicolon
r_if
c_cond
(paren
id|elapsed
OG
id|HZ
)paren
(brace
id|last_check
op_assign
id|now
suffix:semicolon
id|messages
op_assign
l_int|0
suffix:semicolon
id|retval
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Emit at least 1 message per second, even if audit_rate_check is&n; * throttling. */
DECL|function|audit_log_lost
r_void
id|audit_log_lost
c_func
(paren
r_const
r_char
op_star
id|message
)paren
(brace
r_static
r_int
r_int
id|last_msg
op_assign
l_int|0
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|lock
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|now
suffix:semicolon
r_int
id|print
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|audit_lost
)paren
suffix:semicolon
id|print
op_assign
(paren
id|audit_failure
op_eq
id|AUDIT_FAIL_PANIC
op_logical_or
op_logical_neg
id|audit_rate_limit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|print
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lock
comma
id|flags
)paren
suffix:semicolon
id|now
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|now
op_minus
id|last_msg
OG
id|HZ
)paren
(brace
id|print
op_assign
l_int|1
suffix:semicolon
id|last_msg
op_assign
id|now
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|print
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;audit: audit_lost=%d audit_backlog=%d&quot;
l_string|&quot; audit_rate_limit=%d audit_backlog_limit=%d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|audit_lost
)paren
comma
id|atomic_read
c_func
(paren
op_amp
id|audit_backlog
)paren
comma
id|audit_rate_limit
comma
id|audit_backlog_limit
)paren
suffix:semicolon
id|audit_panic
c_func
(paren
id|message
)paren
suffix:semicolon
)brace
)brace
DECL|function|audit_set_rate_limit
r_int
id|audit_set_rate_limit
c_func
(paren
r_int
id|limit
)paren
(brace
r_int
id|old
op_assign
id|audit_rate_limit
suffix:semicolon
id|audit_rate_limit
op_assign
id|limit
suffix:semicolon
id|audit_log
c_func
(paren
id|current-&gt;audit_context
comma
l_string|&quot;audit_rate_limit=%d old=%d&quot;
comma
id|audit_rate_limit
comma
id|old
)paren
suffix:semicolon
r_return
id|old
suffix:semicolon
)brace
DECL|function|audit_set_backlog_limit
r_int
id|audit_set_backlog_limit
c_func
(paren
r_int
id|limit
)paren
(brace
r_int
id|old
op_assign
id|audit_backlog_limit
suffix:semicolon
id|audit_backlog_limit
op_assign
id|limit
suffix:semicolon
id|audit_log
c_func
(paren
id|current-&gt;audit_context
comma
l_string|&quot;audit_backlog_limit=%d old=%d&quot;
comma
id|audit_backlog_limit
comma
id|old
)paren
suffix:semicolon
r_return
id|old
suffix:semicolon
)brace
DECL|function|audit_set_enabled
r_int
id|audit_set_enabled
c_func
(paren
r_int
id|state
)paren
(brace
r_int
id|old
op_assign
id|audit_enabled
suffix:semicolon
r_if
c_cond
(paren
id|state
op_ne
l_int|0
op_logical_and
id|state
op_ne
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|audit_enabled
op_assign
id|state
suffix:semicolon
id|audit_log
c_func
(paren
id|current-&gt;audit_context
comma
l_string|&quot;audit_enabled=%d old=%d&quot;
comma
id|audit_enabled
comma
id|old
)paren
suffix:semicolon
r_return
id|old
suffix:semicolon
)brace
DECL|function|audit_set_failure
r_int
id|audit_set_failure
c_func
(paren
r_int
id|state
)paren
(brace
r_int
id|old
op_assign
id|audit_failure
suffix:semicolon
r_if
c_cond
(paren
id|state
op_ne
id|AUDIT_FAIL_SILENT
op_logical_and
id|state
op_ne
id|AUDIT_FAIL_PRINTK
op_logical_and
id|state
op_ne
id|AUDIT_FAIL_PANIC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|audit_failure
op_assign
id|state
suffix:semicolon
id|audit_log
c_func
(paren
id|current-&gt;audit_context
comma
l_string|&quot;audit_failure=%d old=%d&quot;
comma
id|audit_failure
comma
id|old
)paren
suffix:semicolon
r_return
id|old
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NET
DECL|function|audit_send_reply
r_void
id|audit_send_reply
c_func
(paren
r_int
id|pid
comma
r_int
id|seq
comma
r_int
id|type
comma
r_int
id|done
comma
r_int
id|multi
comma
r_void
op_star
id|payload
comma
r_int
id|size
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|nlmsghdr
op_star
id|nlh
suffix:semicolon
r_int
id|len
op_assign
id|NLMSG_SPACE
c_func
(paren
id|size
)paren
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
r_int
id|flags
op_assign
id|multi
ques
c_cond
id|NLM_F_MULTI
suffix:colon
l_int|0
suffix:semicolon
r_int
id|t
op_assign
id|done
ques
c_cond
id|NLMSG_DONE
suffix:colon
id|type
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_goto
id|nlmsg_failure
suffix:semicolon
id|nlh
op_assign
id|NLMSG_PUT
c_func
(paren
id|skb
comma
id|pid
comma
id|seq
comma
id|t
comma
id|len
op_minus
r_sizeof
(paren
op_star
id|nlh
)paren
)paren
suffix:semicolon
id|nlh-&gt;nlmsg_flags
op_assign
id|flags
suffix:semicolon
id|data
op_assign
id|NLMSG_DATA
c_func
(paren
id|nlh
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|data
comma
id|payload
comma
id|size
)paren
suffix:semicolon
id|netlink_unicast
c_func
(paren
id|audit_sock
comma
id|skb
comma
id|pid
comma
id|MSG_DONTWAIT
)paren
suffix:semicolon
r_return
suffix:semicolon
id|nlmsg_failure
suffix:colon
multiline_comment|/* Used by NLMSG_PUT */
r_if
c_cond
(paren
id|skb
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check for appropriate CAP_AUDIT_ capabilities on incoming audit&n; * control messages.&n; */
DECL|function|audit_netlink_ok
r_static
r_int
id|audit_netlink_ok
c_func
(paren
id|kernel_cap_t
id|eff_cap
comma
id|u16
id|msg_type
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|msg_type
)paren
(brace
r_case
id|AUDIT_GET
suffix:colon
r_case
id|AUDIT_LIST
suffix:colon
r_case
id|AUDIT_SET
suffix:colon
r_case
id|AUDIT_ADD
suffix:colon
r_case
id|AUDIT_DEL
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|cap_raised
c_func
(paren
id|eff_cap
comma
id|CAP_AUDIT_CONTROL
)paren
)paren
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_USER
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|cap_raised
c_func
(paren
id|eff_cap
comma
id|CAP_AUDIT_WRITE
)paren
)paren
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* bad msg */
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|function|audit_receive_msg
r_static
r_int
id|audit_receive_msg
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|nlmsghdr
op_star
id|nlh
)paren
(brace
id|u32
id|uid
comma
id|pid
comma
id|seq
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
r_struct
id|audit_status
op_star
id|status_get
comma
id|status_set
suffix:semicolon
r_int
id|err
suffix:semicolon
r_struct
id|audit_buffer
op_star
id|ab
suffix:semicolon
id|u16
id|msg_type
op_assign
id|nlh-&gt;nlmsg_type
suffix:semicolon
id|err
op_assign
id|audit_netlink_ok
c_func
(paren
id|NETLINK_CB
c_func
(paren
id|skb
)paren
dot
id|eff_cap
comma
id|msg_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|pid
op_assign
id|NETLINK_CREDS
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|pid
suffix:semicolon
id|uid
op_assign
id|NETLINK_CREDS
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|uid
suffix:semicolon
id|seq
op_assign
id|nlh-&gt;nlmsg_seq
suffix:semicolon
id|data
op_assign
id|NLMSG_DATA
c_func
(paren
id|nlh
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|msg_type
)paren
(brace
r_case
id|AUDIT_GET
suffix:colon
id|status_set.enabled
op_assign
id|audit_enabled
suffix:semicolon
id|status_set.failure
op_assign
id|audit_failure
suffix:semicolon
id|status_set.pid
op_assign
id|audit_pid
suffix:semicolon
id|status_set.rate_limit
op_assign
id|audit_rate_limit
suffix:semicolon
id|status_set.backlog_limit
op_assign
id|audit_backlog_limit
suffix:semicolon
id|status_set.lost
op_assign
id|atomic_read
c_func
(paren
op_amp
id|audit_lost
)paren
suffix:semicolon
id|status_set.backlog
op_assign
id|atomic_read
c_func
(paren
op_amp
id|audit_backlog
)paren
suffix:semicolon
id|audit_send_reply
c_func
(paren
id|pid
comma
id|seq
comma
id|AUDIT_GET
comma
l_int|0
comma
l_int|0
comma
op_amp
id|status_set
comma
r_sizeof
(paren
id|status_set
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_SET
suffix:colon
r_if
c_cond
(paren
id|nlh-&gt;nlmsg_len
OL
r_sizeof
(paren
r_struct
id|audit_status
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|status_get
op_assign
(paren
r_struct
id|audit_status
op_star
)paren
id|data
suffix:semicolon
r_if
c_cond
(paren
id|status_get-&gt;mask
op_amp
id|AUDIT_STATUS_ENABLED
)paren
(brace
id|err
op_assign
id|audit_set_enabled
c_func
(paren
id|status_get-&gt;enabled
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status_get-&gt;mask
op_amp
id|AUDIT_STATUS_FAILURE
)paren
(brace
id|err
op_assign
id|audit_set_failure
c_func
(paren
id|status_get-&gt;failure
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status_get-&gt;mask
op_amp
id|AUDIT_STATUS_PID
)paren
(brace
r_int
id|old
op_assign
id|audit_pid
suffix:semicolon
id|audit_pid
op_assign
id|status_get-&gt;pid
suffix:semicolon
id|audit_log
c_func
(paren
id|current-&gt;audit_context
comma
l_string|&quot;audit_pid=%d old=%d&quot;
comma
id|audit_pid
comma
id|old
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status_get-&gt;mask
op_amp
id|AUDIT_STATUS_RATE_LIMIT
)paren
id|audit_set_rate_limit
c_func
(paren
id|status_get-&gt;rate_limit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status_get-&gt;mask
op_amp
id|AUDIT_STATUS_BACKLOG_LIMIT
)paren
id|audit_set_backlog_limit
c_func
(paren
id|status_get-&gt;backlog_limit
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_USER
suffix:colon
id|ab
op_assign
id|audit_log_start
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ab
)paren
r_break
suffix:semicolon
multiline_comment|/* audit_panic has been called */
id|audit_log_format
c_func
(paren
id|ab
comma
l_string|&quot;user pid=%d uid=%d length=%d msg=&squot;%.1024s&squot;&quot;
comma
id|pid
comma
id|uid
comma
(paren
r_int
)paren
(paren
id|nlh-&gt;nlmsg_len
op_minus
(paren
(paren
r_char
op_star
)paren
id|data
op_minus
(paren
r_char
op_star
)paren
id|nlh
)paren
)paren
comma
(paren
r_char
op_star
)paren
id|data
)paren
suffix:semicolon
id|ab-&gt;type
op_assign
id|AUDIT_USER
suffix:semicolon
id|ab-&gt;pid
op_assign
id|pid
suffix:semicolon
id|audit_log_end
c_func
(paren
id|ab
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_ADD
suffix:colon
r_case
id|AUDIT_DEL
suffix:colon
r_if
c_cond
(paren
id|nlh-&gt;nlmsg_len
OL
r_sizeof
(paren
r_struct
id|audit_rule
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* fallthrough */
r_case
id|AUDIT_LIST
suffix:colon
macro_line|#ifdef CONFIG_AUDITSYSCALL
id|err
op_assign
id|audit_receive_filter
c_func
(paren
id|nlh-&gt;nlmsg_type
comma
id|pid
comma
id|uid
comma
id|seq
comma
id|data
)paren
suffix:semicolon
macro_line|#else
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|err
OL
l_int|0
ques
c_cond
id|err
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get message from skb (based on rtnetlink_rcv_skb).  Each message is&n; * processed by audit_receive_msg.  Malformed skbs with wrong length are&n; * discarded silently.  */
DECL|function|audit_receive_skb
r_static
r_int
id|audit_receive_skb
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|nlmsghdr
op_star
id|nlh
suffix:semicolon
id|u32
id|rlen
suffix:semicolon
r_while
c_loop
(paren
id|skb-&gt;len
op_ge
id|NLMSG_SPACE
c_func
(paren
l_int|0
)paren
)paren
(brace
id|nlh
op_assign
(paren
r_struct
id|nlmsghdr
op_star
)paren
id|skb-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|nlh-&gt;nlmsg_len
OL
r_sizeof
(paren
op_star
id|nlh
)paren
op_logical_or
id|skb-&gt;len
OL
id|nlh-&gt;nlmsg_len
)paren
r_return
l_int|0
suffix:semicolon
id|rlen
op_assign
id|NLMSG_ALIGN
c_func
(paren
id|nlh-&gt;nlmsg_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rlen
OG
id|skb-&gt;len
)paren
id|rlen
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|audit_receive_msg
c_func
(paren
id|skb
comma
id|nlh
)paren
)paren
)paren
(brace
id|netlink_ack
c_func
(paren
id|skb
comma
id|nlh
comma
id|err
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|nlh-&gt;nlmsg_flags
op_amp
id|NLM_F_ACK
)paren
id|netlink_ack
c_func
(paren
id|skb
comma
id|nlh
comma
l_int|0
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
id|rlen
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Receive messages from netlink socket. */
DECL|function|audit_receive
r_static
r_void
id|audit_receive
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|length
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|down_trylock
c_func
(paren
op_amp
id|audit_netlink_sem
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* FIXME: this must not cause starvation */
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;sk_receive_queue
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|audit_receive_skb
c_func
(paren
id|skb
)paren
op_logical_and
id|skb-&gt;len
)paren
id|skb_queue_head
c_func
(paren
op_amp
id|sk-&gt;sk_receive_queue
comma
id|skb
)paren
suffix:semicolon
r_else
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|audit_netlink_sem
)paren
suffix:semicolon
)brace
multiline_comment|/* Move data from tmp buffer into an skb.  This is an extra copy, and&n; * that is unfortunate.  However, the copy will only occur when a record&n; * is being written to user space, which is already a high-overhead&n; * operation.  (Elimination of the copy is possible, for example, by&n; * writing directly into a pre-allocated skb, at the cost of wasting&n; * memory. */
DECL|function|audit_log_move
r_static
r_void
id|audit_log_move
c_func
(paren
r_struct
id|audit_buffer
op_star
id|ab
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_char
op_star
id|start
suffix:semicolon
r_int
id|extra
op_assign
id|ab-&gt;nlh
ques
c_cond
l_int|0
suffix:colon
id|NLMSG_SPACE
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* possible resubmission */
r_if
c_cond
(paren
id|ab-&gt;len
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|ab-&gt;sklist
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
op_logical_or
id|skb_tailroom
c_func
(paren
id|skb
)paren
op_le
id|ab-&gt;len
op_plus
id|extra
)paren
(brace
id|skb
op_assign
id|alloc_skb
c_func
(paren
l_int|2
op_star
id|ab-&gt;len
op_plus
id|extra
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|ab-&gt;len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Lose information in ab-&gt;tmp */
id|audit_log_lost
c_func
(paren
l_string|&quot;out of memory in audit_log_move&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|__skb_queue_tail
c_func
(paren
op_amp
id|ab-&gt;sklist
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ab-&gt;nlh
)paren
id|ab-&gt;nlh
op_assign
(paren
r_struct
id|nlmsghdr
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
id|NLMSG_SPACE
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
id|start
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|ab-&gt;len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|start
comma
id|ab-&gt;tmp
comma
id|ab-&gt;len
)paren
suffix:semicolon
id|ab-&gt;len
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Iterate over the skbuff in the audit_buffer, sending their contents&n; * to user space. */
DECL|function|audit_log_drain
r_static
r_inline
r_int
id|audit_log_drain
c_func
(paren
r_struct
id|audit_buffer
op_star
id|ab
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|ab-&gt;sklist
)paren
)paren
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|audit_pid
)paren
(brace
r_if
c_cond
(paren
id|ab-&gt;nlh
)paren
(brace
id|ab-&gt;nlh-&gt;nlmsg_len
op_assign
id|ab-&gt;total
suffix:semicolon
id|ab-&gt;nlh-&gt;nlmsg_type
op_assign
id|ab-&gt;type
suffix:semicolon
id|ab-&gt;nlh-&gt;nlmsg_flags
op_assign
l_int|0
suffix:semicolon
id|ab-&gt;nlh-&gt;nlmsg_seq
op_assign
l_int|0
suffix:semicolon
id|ab-&gt;nlh-&gt;nlmsg_pid
op_assign
id|ab-&gt;pid
suffix:semicolon
)brace
id|skb_get
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* because netlink_* frees */
id|retval
op_assign
id|netlink_unicast
c_func
(paren
id|audit_sock
comma
id|skb
comma
id|audit_pid
comma
id|MSG_DONTWAIT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_eq
op_minus
id|EAGAIN
op_logical_and
id|ab-&gt;count
OL
l_int|5
)paren
(brace
op_increment
id|ab-&gt;count
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|ab-&gt;sklist
comma
id|skb
)paren
suffix:semicolon
id|audit_log_end_irq
c_func
(paren
id|ab
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|retval
op_eq
op_minus
id|ECONNREFUSED
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;audit: *NO* daemon at audit_pid=%d&bslash;n&quot;
comma
id|audit_pid
)paren
suffix:semicolon
id|audit_pid
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|audit_log_lost
c_func
(paren
l_string|&quot;netlink socket too busy&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|audit_pid
)paren
(brace
multiline_comment|/* No daemon */
r_int
id|offset
op_assign
id|ab-&gt;nlh
ques
c_cond
id|NLMSG_SPACE
c_func
(paren
l_int|0
)paren
suffix:colon
l_int|0
suffix:semicolon
r_int
id|len
op_assign
id|skb-&gt;len
op_minus
id|offset
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%*.*s&bslash;n&quot;
comma
id|len
comma
id|len
comma
id|skb-&gt;data
op_plus
id|offset
)paren
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ab-&gt;nlh
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Initialize audit support at boot time. */
DECL|function|audit_init
r_int
id|__init
id|audit_init
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;audit: initializing netlink socket (%s)&bslash;n&quot;
comma
id|audit_default
ques
c_cond
l_string|&quot;enabled&quot;
suffix:colon
l_string|&quot;disabled&quot;
)paren
suffix:semicolon
id|audit_sock
op_assign
id|netlink_kernel_create
c_func
(paren
id|NETLINK_AUDIT
comma
id|audit_receive
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|audit_sock
)paren
id|audit_panic
c_func
(paren
l_string|&quot;cannot initialize netlink socket&quot;
)paren
suffix:semicolon
id|audit_initialized
op_assign
l_int|1
suffix:semicolon
id|audit_enabled
op_assign
id|audit_default
suffix:semicolon
id|audit_log
c_func
(paren
l_int|NULL
comma
l_string|&quot;initialized&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/* Without CONFIG_NET, we have no skbuffs.  For now, print what we have&n; * in the buffer. */
DECL|function|audit_log_move
r_static
r_void
id|audit_log_move
c_func
(paren
r_struct
id|audit_buffer
op_star
id|ab
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%*.*s&bslash;n&quot;
comma
id|ab-&gt;len
comma
id|ab-&gt;len
comma
id|ab-&gt;tmp
)paren
suffix:semicolon
id|ab-&gt;len
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|audit_log_drain
r_static
r_inline
r_int
id|audit_log_drain
c_func
(paren
r_struct
id|audit_buffer
op_star
id|ab
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Initialize audit support at boot time. */
DECL|function|audit_init
r_int
id|__init
id|audit_init
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;audit: initializing WITHOUT netlink support&bslash;n&quot;
)paren
suffix:semicolon
id|audit_sock
op_assign
l_int|NULL
suffix:semicolon
id|audit_pid
op_assign
l_int|0
suffix:semicolon
id|audit_initialized
op_assign
l_int|1
suffix:semicolon
id|audit_enabled
op_assign
id|audit_default
suffix:semicolon
id|audit_log
c_func
(paren
l_int|NULL
comma
l_string|&quot;initialized&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|variable|audit_init
id|__initcall
c_func
(paren
id|audit_init
)paren
suffix:semicolon
multiline_comment|/* Process kernel command-line parameter at boot time.  audit=0 or audit=1. */
DECL|function|audit_enable
r_static
r_int
id|__init
id|audit_enable
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|audit_default
op_assign
op_logical_neg
op_logical_neg
id|simple_strtol
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;audit: %s%s&bslash;n&quot;
comma
id|audit_default
ques
c_cond
l_string|&quot;enabled&quot;
suffix:colon
l_string|&quot;disabled&quot;
comma
id|audit_initialized
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; (after initialization)&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|audit_initialized
)paren
id|audit_enabled
op_assign
id|audit_default
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;audit=&quot;
comma
id|audit_enable
)paren
suffix:semicolon
multiline_comment|/* Obtain an audit buffer.  This routine does locking to obtain the&n; * audit buffer, but then no locking is required for calls to&n; * audit_log_*format.  If the tsk is a task that is currently in a&n; * syscall, then the syscall is marked as auditable and an audit record&n; * will be written at syscall exit.  If there is no associated task, tsk&n; * should be NULL. */
DECL|function|audit_log_start
r_struct
id|audit_buffer
op_star
id|audit_log_start
c_func
(paren
r_struct
id|audit_context
op_star
id|ctx
)paren
(brace
r_struct
id|audit_buffer
op_star
id|ab
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|timespec
id|t
suffix:semicolon
r_int
id|serial
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|audit_initialized
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|audit_backlog_limit
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|audit_backlog
)paren
OG
id|audit_backlog_limit
)paren
(brace
r_if
c_cond
(paren
id|audit_rate_check
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;audit: audit_backlog=%d &gt; &quot;
l_string|&quot;audit_backlog_limit=%d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|audit_backlog
)paren
comma
id|audit_backlog_limit
)paren
suffix:semicolon
id|audit_log_lost
c_func
(paren
l_string|&quot;backlog limit exceeded&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|audit_freelist_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|audit_freelist
)paren
)paren
(brace
id|ab
op_assign
id|list_entry
c_func
(paren
id|audit_freelist.next
comma
r_struct
id|audit_buffer
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|ab-&gt;list
)paren
suffix:semicolon
op_decrement
id|audit_freelist_count
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|audit_freelist_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ab
)paren
id|ab
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ab
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ab
)paren
(brace
id|audit_log_lost
c_func
(paren
l_string|&quot;out of memory in audit_log_start&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|audit_backlog
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|ab-&gt;sklist
)paren
suffix:semicolon
id|ab-&gt;ctx
op_assign
id|ctx
suffix:semicolon
id|ab-&gt;len
op_assign
l_int|0
suffix:semicolon
id|ab-&gt;nlh
op_assign
l_int|NULL
suffix:semicolon
id|ab-&gt;total
op_assign
l_int|0
suffix:semicolon
id|ab-&gt;type
op_assign
id|AUDIT_KERNEL
suffix:semicolon
id|ab-&gt;pid
op_assign
l_int|0
suffix:semicolon
id|ab-&gt;count
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_AUDITSYSCALL
r_if
c_cond
(paren
id|ab-&gt;ctx
)paren
id|audit_get_stamp
c_func
(paren
id|ab-&gt;ctx
comma
op_amp
id|t
comma
op_amp
id|serial
)paren
suffix:semicolon
r_else
macro_line|#endif
id|t
op_assign
id|CURRENT_TIME
suffix:semicolon
id|audit_log_format
c_func
(paren
id|ab
comma
l_string|&quot;audit(%lu.%03lu:%u): &quot;
comma
id|t.tv_sec
comma
id|t.tv_nsec
op_div
l_int|1000000
comma
id|serial
)paren
suffix:semicolon
r_return
id|ab
suffix:semicolon
)brace
multiline_comment|/* Format an audit message into the audit buffer.  If there isn&squot;t enough&n; * room in the audit buffer, more room will be allocated and vsnprint&n; * will be called a second time.  Currently, we assume that a printk&n; * can&squot;t format message larger than 1024 bytes, so we don&squot;t either. */
DECL|function|audit_log_vformat
r_static
r_void
id|audit_log_vformat
c_func
(paren
r_struct
id|audit_buffer
op_star
id|ab
comma
r_const
r_char
op_star
id|fmt
comma
id|va_list
id|args
)paren
(brace
r_int
id|len
comma
id|avail
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ab
)paren
r_return
suffix:semicolon
id|avail
op_assign
r_sizeof
(paren
id|ab-&gt;tmp
)paren
op_minus
id|ab-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|avail
op_le
l_int|0
)paren
(brace
id|audit_log_move
c_func
(paren
id|ab
)paren
suffix:semicolon
id|avail
op_assign
r_sizeof
(paren
id|ab-&gt;tmp
)paren
op_minus
id|ab-&gt;len
suffix:semicolon
)brace
id|len
op_assign
id|vsnprintf
c_func
(paren
id|ab-&gt;tmp
op_plus
id|ab-&gt;len
comma
id|avail
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|avail
)paren
(brace
multiline_comment|/* The printk buffer is 1024 bytes long, so if we get&n;&t;&t; * here and AUDIT_BUFSIZ is at least 1024, then we can&n;&t;&t; * log everything that printk could have logged. */
id|audit_log_move
c_func
(paren
id|ab
)paren
suffix:semicolon
id|avail
op_assign
r_sizeof
(paren
id|ab-&gt;tmp
)paren
op_minus
id|ab-&gt;len
suffix:semicolon
id|len
op_assign
id|vsnprintf
c_func
(paren
id|ab-&gt;tmp
op_plus
id|ab-&gt;len
comma
id|avail
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
)brace
id|ab-&gt;len
op_add_assign
(paren
id|len
OL
id|avail
)paren
ques
c_cond
id|len
suffix:colon
id|avail
suffix:semicolon
id|ab-&gt;total
op_add_assign
(paren
id|len
OL
id|avail
)paren
ques
c_cond
id|len
suffix:colon
id|avail
suffix:semicolon
)brace
multiline_comment|/* Format a message into the audit buffer.  All the work is done in&n; * audit_log_vformat. */
DECL|function|audit_log_format
r_void
id|audit_log_format
c_func
(paren
r_struct
id|audit_buffer
op_star
id|ab
comma
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ab
)paren
r_return
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|audit_log_vformat
c_func
(paren
id|ab
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
)brace
multiline_comment|/* This is a helper-function to print the d_path without using a static&n; * buffer or allocating another buffer in addition to the one in&n; * audit_buffer. */
DECL|function|audit_log_d_path
r_void
id|audit_log_d_path
c_func
(paren
r_struct
id|audit_buffer
op_star
id|ab
comma
r_const
r_char
op_star
id|prefix
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|vfsmount
op_star
id|vfsmnt
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_int
id|len
comma
id|avail
suffix:semicolon
r_if
c_cond
(paren
id|prefix
)paren
id|audit_log_format
c_func
(paren
id|ab
comma
l_string|&quot; %s&quot;
comma
id|prefix
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ab-&gt;len
OG
l_int|128
)paren
id|audit_log_move
c_func
(paren
id|ab
)paren
suffix:semicolon
id|avail
op_assign
r_sizeof
(paren
id|ab-&gt;tmp
)paren
op_minus
id|ab-&gt;len
suffix:semicolon
id|p
op_assign
id|d_path
c_func
(paren
id|dentry
comma
id|vfsmnt
comma
id|ab-&gt;tmp
op_plus
id|ab-&gt;len
comma
id|avail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|p
)paren
)paren
(brace
multiline_comment|/* FIXME: can we save some information here? */
id|audit_log_format
c_func
(paren
id|ab
comma
l_string|&quot;&lt;toolong&gt;&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* path isn&squot;t at start of buffer */
id|len
op_assign
(paren
id|ab-&gt;tmp
op_plus
r_sizeof
(paren
id|ab-&gt;tmp
)paren
op_minus
l_int|1
)paren
op_minus
id|p
suffix:semicolon
id|memmove
c_func
(paren
id|ab-&gt;tmp
op_plus
id|ab-&gt;len
comma
id|p
comma
id|len
)paren
suffix:semicolon
id|ab-&gt;len
op_add_assign
id|len
suffix:semicolon
id|ab-&gt;total
op_add_assign
id|len
suffix:semicolon
)brace
)brace
multiline_comment|/* Remove queued messages from the audit_txlist and send them to userspace. */
DECL|function|audit_tasklet_handler
r_static
r_void
id|audit_tasklet_handler
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
id|LIST_HEAD
c_func
(paren
id|list
)paren
suffix:semicolon
r_struct
id|audit_buffer
op_star
id|ab
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|audit_txlist_lock
comma
id|flags
)paren
suffix:semicolon
id|list_splice_init
c_func
(paren
op_amp
id|audit_txlist
comma
op_amp
id|list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|audit_txlist_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|list
)paren
)paren
(brace
id|ab
op_assign
id|list_entry
c_func
(paren
id|list.next
comma
r_struct
id|audit_buffer
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|ab-&gt;list
)paren
suffix:semicolon
id|audit_log_end_fast
c_func
(paren
id|ab
)paren
suffix:semicolon
)brace
)brace
r_static
id|DECLARE_TASKLET
c_func
(paren
id|audit_tasklet
comma
id|audit_tasklet_handler
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* The netlink_* functions cannot be called inside an irq context, so&n; * the audit buffer is places on a queue and a tasklet is scheduled to&n; * remove them from the queue outside the irq context.  May be called in&n; * any context. */
DECL|function|audit_log_end_irq
r_void
id|audit_log_end_irq
c_func
(paren
r_struct
id|audit_buffer
op_star
id|ab
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ab
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|audit_txlist_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|ab-&gt;list
comma
op_amp
id|audit_txlist
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|audit_txlist_lock
comma
id|flags
)paren
suffix:semicolon
id|tasklet_schedule
c_func
(paren
op_amp
id|audit_tasklet
)paren
suffix:semicolon
)brace
multiline_comment|/* Send the message in the audit buffer directly to user space.  May not&n; * be called in an irq context. */
DECL|function|audit_log_end_fast
r_void
id|audit_log_end_fast
c_func
(paren
r_struct
id|audit_buffer
op_star
id|ab
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|BUG_ON
c_func
(paren
id|in_irq
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ab
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|audit_rate_check
c_func
(paren
)paren
)paren
(brace
id|audit_log_lost
c_func
(paren
l_string|&quot;rate limit exceeded&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|audit_log_move
c_func
(paren
id|ab
)paren
suffix:semicolon
r_if
c_cond
(paren
id|audit_log_drain
c_func
(paren
id|ab
)paren
)paren
r_return
suffix:semicolon
)brace
id|atomic_dec
c_func
(paren
op_amp
id|audit_backlog
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|audit_freelist_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|audit_freelist_count
OG
id|AUDIT_MAXFREE
)paren
id|kfree
c_func
(paren
id|ab
)paren
suffix:semicolon
r_else
id|list_add
c_func
(paren
op_amp
id|ab-&gt;list
comma
op_amp
id|audit_freelist
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|audit_freelist_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Send or queue the message in the audit buffer, depending on the&n; * current context.  (A convenience function that may be called in any&n; * context.) */
DECL|function|audit_log_end
r_void
id|audit_log_end
c_func
(paren
r_struct
id|audit_buffer
op_star
id|ab
)paren
(brace
r_if
c_cond
(paren
id|in_irq
c_func
(paren
)paren
)paren
id|audit_log_end_irq
c_func
(paren
id|ab
)paren
suffix:semicolon
r_else
id|audit_log_end_fast
c_func
(paren
id|ab
)paren
suffix:semicolon
)brace
multiline_comment|/* Log an audit record.  This is a convenience function that calls&n; * audit_log_start, audit_log_vformat, and audit_log_end.  It may be&n; * called in any context. */
DECL|function|audit_log
r_void
id|audit_log
c_func
(paren
r_struct
id|audit_context
op_star
id|ctx
comma
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
r_struct
id|audit_buffer
op_star
id|ab
suffix:semicolon
id|va_list
id|args
suffix:semicolon
id|ab
op_assign
id|audit_log_start
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ab
)paren
(brace
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|audit_log_vformat
c_func
(paren
id|ab
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
id|audit_log_end
c_func
(paren
id|ab
)paren
suffix:semicolon
)brace
)brace
eof
