multiline_comment|/*&n; *  linux/kernel/timer.c&n; *&n; *  Kernel internal timers, kernel timekeeping, basic process system calls&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; *&n; *  1997-01-28  Modified by Finn Arne Gangstad to make timers scale better.&n; *&n; *  1997-09-10  Updated NTP code according to technical memorandum Jan &squot;96&n; *              &quot;A Kernel Model for Precision Timekeeping&quot; by Dave Mills&n; *  1998-12-24  Fixed a xtime SMP race (we need the xtime_lock rw spinlock to&n; *              serialize accesses to xtime/lost_ticks).&n; *                              Copyright (C) 1998  Andrea Arcangeli&n; *  1999-03-10  Improved NTP compatibility by Ulrich Windl&n; *  2002-05-31&t;Move sys_sysinfo here and make its locking sane, Robert Love&n; *  2000-10-05  Implemented scalable SMP per-CPU timer handling.&n; *                              Copyright (C) 2000, 2001, 2002  Ingo Molnar&n; *              Designed by David S. Miller, Alexey Kuznetsov and Ingo Molnar&n; */
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/percpu.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/thread_info.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/jiffies.h&gt;
macro_line|#include &lt;linux/cpu.h&gt;
macro_line|#include &lt;linux/syscalls.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/unistd.h&gt;
macro_line|#include &lt;asm/div64.h&gt;
macro_line|#include &lt;asm/timex.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#ifdef CONFIG_TIME_INTERPOLATION
r_static
r_void
id|time_interpolator_update
c_func
(paren
r_int
id|delta_nsec
)paren
suffix:semicolon
macro_line|#else
DECL|macro|time_interpolator_update
mdefine_line|#define time_interpolator_update(x)
macro_line|#endif
multiline_comment|/*&n; * per-CPU timer vector definitions:&n; */
DECL|macro|TVN_BITS
mdefine_line|#define TVN_BITS 6
DECL|macro|TVR_BITS
mdefine_line|#define TVR_BITS 8
DECL|macro|TVN_SIZE
mdefine_line|#define TVN_SIZE (1 &lt;&lt; TVN_BITS)
DECL|macro|TVR_SIZE
mdefine_line|#define TVR_SIZE (1 &lt;&lt; TVR_BITS)
DECL|macro|TVN_MASK
mdefine_line|#define TVN_MASK (TVN_SIZE - 1)
DECL|macro|TVR_MASK
mdefine_line|#define TVR_MASK (TVR_SIZE - 1)
DECL|struct|tvec_s
r_typedef
r_struct
id|tvec_s
(brace
DECL|member|vec
r_struct
id|list_head
id|vec
(braket
id|TVN_SIZE
)braket
suffix:semicolon
DECL|typedef|tvec_t
)brace
id|tvec_t
suffix:semicolon
DECL|struct|tvec_root_s
r_typedef
r_struct
id|tvec_root_s
(brace
DECL|member|vec
r_struct
id|list_head
id|vec
(braket
id|TVR_SIZE
)braket
suffix:semicolon
DECL|typedef|tvec_root_t
)brace
id|tvec_root_t
suffix:semicolon
DECL|struct|tvec_t_base_s
r_struct
id|tvec_t_base_s
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|timer_jiffies
r_int
r_int
id|timer_jiffies
suffix:semicolon
DECL|member|running_timer
r_struct
id|timer_list
op_star
id|running_timer
suffix:semicolon
DECL|member|tv1
id|tvec_root_t
id|tv1
suffix:semicolon
DECL|member|tv2
id|tvec_t
id|tv2
suffix:semicolon
DECL|member|tv3
id|tvec_t
id|tv3
suffix:semicolon
DECL|member|tv4
id|tvec_t
id|tv4
suffix:semicolon
DECL|member|tv5
id|tvec_t
id|tv5
suffix:semicolon
DECL|variable|____cacheline_aligned_in_smp
)brace
id|____cacheline_aligned_in_smp
suffix:semicolon
DECL|typedef|tvec_base_t
r_typedef
r_struct
id|tvec_t_base_s
id|tvec_base_t
suffix:semicolon
DECL|function|set_running_timer
r_static
r_inline
r_void
id|set_running_timer
c_func
(paren
id|tvec_base_t
op_star
id|base
comma
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
macro_line|#ifdef CONFIG_SMP
id|base-&gt;running_timer
op_assign
id|timer
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Fake initialization */
r_static
id|DEFINE_PER_CPU
c_func
(paren
id|tvec_base_t
comma
id|tvec_bases
)paren
op_assign
(brace
id|SPIN_LOCK_UNLOCKED
)brace
suffix:semicolon
DECL|function|check_timer_failed
r_static
r_void
id|check_timer_failed
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
r_static
r_int
id|whine_count
suffix:semicolon
r_if
c_cond
(paren
id|whine_count
OL
l_int|16
)paren
(brace
id|whine_count
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Uninitialised timer!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;This is just a warning.  Your computer is OK&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;function=0x%p, data=0x%lx&bslash;n&quot;
comma
id|timer-&gt;function
comma
id|timer-&gt;data
)paren
suffix:semicolon
id|dump_stack
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now fix it up&n;&t; */
id|spin_lock_init
c_func
(paren
op_amp
id|timer-&gt;lock
)paren
suffix:semicolon
id|timer-&gt;magic
op_assign
id|TIMER_MAGIC
suffix:semicolon
)brace
DECL|function|check_timer
r_static
r_inline
r_void
id|check_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
r_if
c_cond
(paren
id|timer-&gt;magic
op_ne
id|TIMER_MAGIC
)paren
id|check_timer_failed
c_func
(paren
id|timer
)paren
suffix:semicolon
)brace
DECL|function|internal_add_timer
r_static
r_void
id|internal_add_timer
c_func
(paren
id|tvec_base_t
op_star
id|base
comma
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
r_int
r_int
id|expires
op_assign
id|timer-&gt;expires
suffix:semicolon
r_int
r_int
id|idx
op_assign
id|expires
op_minus
id|base-&gt;timer_jiffies
suffix:semicolon
r_struct
id|list_head
op_star
id|vec
suffix:semicolon
r_if
c_cond
(paren
id|idx
OL
id|TVR_SIZE
)paren
(brace
r_int
id|i
op_assign
id|expires
op_amp
id|TVR_MASK
suffix:semicolon
id|vec
op_assign
id|base-&gt;tv1.vec
op_plus
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|idx
OL
l_int|1
op_lshift
(paren
id|TVR_BITS
op_plus
id|TVN_BITS
)paren
)paren
(brace
r_int
id|i
op_assign
(paren
id|expires
op_rshift
id|TVR_BITS
)paren
op_amp
id|TVN_MASK
suffix:semicolon
id|vec
op_assign
id|base-&gt;tv2.vec
op_plus
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|idx
OL
l_int|1
op_lshift
(paren
id|TVR_BITS
op_plus
l_int|2
op_star
id|TVN_BITS
)paren
)paren
(brace
r_int
id|i
op_assign
(paren
id|expires
op_rshift
(paren
id|TVR_BITS
op_plus
id|TVN_BITS
)paren
)paren
op_amp
id|TVN_MASK
suffix:semicolon
id|vec
op_assign
id|base-&gt;tv3.vec
op_plus
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|idx
OL
l_int|1
op_lshift
(paren
id|TVR_BITS
op_plus
l_int|3
op_star
id|TVN_BITS
)paren
)paren
(brace
r_int
id|i
op_assign
(paren
id|expires
op_rshift
(paren
id|TVR_BITS
op_plus
l_int|2
op_star
id|TVN_BITS
)paren
)paren
op_amp
id|TVN_MASK
suffix:semicolon
id|vec
op_assign
id|base-&gt;tv4.vec
op_plus
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|idx
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Can happen if you add a timer with expires == jiffies,&n;&t;&t; * or you set a timer to go off in the past&n;&t;&t; */
id|vec
op_assign
id|base-&gt;tv1.vec
op_plus
(paren
id|base-&gt;timer_jiffies
op_amp
id|TVR_MASK
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* If the timeout is larger than 0xffffffff on 64-bit&n;&t;&t; * architectures then we use the maximum timeout:&n;&t;&t; */
r_if
c_cond
(paren
id|idx
OG
l_int|0xffffffffUL
)paren
(brace
id|idx
op_assign
l_int|0xffffffffUL
suffix:semicolon
id|expires
op_assign
id|idx
op_plus
id|base-&gt;timer_jiffies
suffix:semicolon
)brace
id|i
op_assign
(paren
id|expires
op_rshift
(paren
id|TVR_BITS
op_plus
l_int|3
op_star
id|TVN_BITS
)paren
)paren
op_amp
id|TVN_MASK
suffix:semicolon
id|vec
op_assign
id|base-&gt;tv5.vec
op_plus
id|i
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Timers are FIFO:&n;&t; */
id|list_add_tail
c_func
(paren
op_amp
id|timer-&gt;entry
comma
id|vec
)paren
suffix:semicolon
)brace
DECL|function|__mod_timer
r_int
id|__mod_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
comma
r_int
r_int
id|expires
)paren
(brace
id|tvec_base_t
op_star
id|old_base
comma
op_star
id|new_base
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|timer-&gt;function
)paren
suffix:semicolon
id|check_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|timer-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|new_base
op_assign
op_amp
id|__get_cpu_var
c_func
(paren
id|tvec_bases
)paren
suffix:semicolon
id|repeat
suffix:colon
id|old_base
op_assign
id|timer-&gt;base
suffix:semicolon
multiline_comment|/*&n;&t; * Prevent deadlocks via ordering by old_base &lt; new_base.&n;&t; */
r_if
c_cond
(paren
id|old_base
op_logical_and
(paren
id|new_base
op_ne
id|old_base
)paren
)paren
(brace
r_if
c_cond
(paren
id|old_base
OL
id|new_base
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|new_base-&gt;lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|old_base-&gt;lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|spin_lock
c_func
(paren
op_amp
id|old_base-&gt;lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|new_base-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The timer base might have been cancelled while we were&n;&t;&t; * trying to take the lock(s):&n;&t;&t; */
r_if
c_cond
(paren
id|timer-&gt;base
op_ne
id|old_base
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|new_base-&gt;lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|old_base-&gt;lock
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
r_else
(brace
id|spin_lock
c_func
(paren
op_amp
id|new_base-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer-&gt;base
op_ne
id|old_base
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|new_base-&gt;lock
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Delete the previous timeout (if there was any), and install&n;&t; * the new one:&n;&t; */
r_if
c_cond
(paren
id|old_base
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|timer-&gt;entry
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
id|timer-&gt;expires
op_assign
id|expires
suffix:semicolon
id|internal_add_timer
c_func
(paren
id|new_base
comma
id|timer
)paren
suffix:semicolon
id|timer-&gt;base
op_assign
id|new_base
suffix:semicolon
r_if
c_cond
(paren
id|old_base
op_logical_and
(paren
id|new_base
op_ne
id|old_base
)paren
)paren
id|spin_unlock
c_func
(paren
op_amp
id|old_base-&gt;lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|new_base-&gt;lock
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|timer-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|__mod_timer
id|EXPORT_SYMBOL
c_func
(paren
id|__mod_timer
)paren
suffix:semicolon
multiline_comment|/***&n; * add_timer_on - start a timer on a particular CPU&n; * @timer: the timer to be added&n; * @cpu: the CPU to start it on&n; *&n; * This is not very scalable on SMP. Double adds are not possible.&n; */
DECL|function|add_timer_on
r_void
id|add_timer_on
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
comma
r_int
id|cpu
)paren
(brace
id|tvec_base_t
op_star
id|base
op_assign
op_amp
id|per_cpu
c_func
(paren
id|tvec_bases
comma
id|cpu
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|BUG_ON
c_func
(paren
id|timer_pending
c_func
(paren
id|timer
)paren
op_logical_or
op_logical_neg
id|timer-&gt;function
)paren
suffix:semicolon
id|check_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|base-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|internal_add_timer
c_func
(paren
id|base
comma
id|timer
)paren
suffix:semicolon
id|timer-&gt;base
op_assign
id|base
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|base-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/***&n; * mod_timer - modify a timer&squot;s timeout&n; * @timer: the timer to be modified&n; *&n; * mod_timer is a more efficient way to update the expire field of an&n; * active timer (if the timer is inactive it will be activated)&n; *&n; * mod_timer(timer, expires) is equivalent to:&n; *&n; *     del_timer(timer); timer-&gt;expires = expires; add_timer(timer);&n; *&n; * Note that if there are multiple unserialized concurrent users of the&n; * same timer, then mod_timer() is the only safe way to modify the timeout,&n; * since add_timer() cannot modify an already running timer.&n; *&n; * The function returns whether it has modified a pending timer or not.&n; * (ie. mod_timer() of an inactive timer returns 0, mod_timer() of an&n; * active timer returns 1.)&n; */
DECL|function|mod_timer
r_int
id|mod_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
comma
r_int
r_int
id|expires
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|timer-&gt;function
)paren
suffix:semicolon
id|check_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This is a common optimization triggered by the&n;&t; * networking code - if the timer is re-modified&n;&t; * to be the same thing then just return:&n;&t; */
r_if
c_cond
(paren
id|timer-&gt;expires
op_eq
id|expires
op_logical_and
id|timer_pending
c_func
(paren
id|timer
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|__mod_timer
c_func
(paren
id|timer
comma
id|expires
)paren
suffix:semicolon
)brace
DECL|variable|mod_timer
id|EXPORT_SYMBOL
c_func
(paren
id|mod_timer
)paren
suffix:semicolon
multiline_comment|/***&n; * del_timer - deactive a timer.&n; * @timer: the timer to be deactivated&n; *&n; * del_timer() deactivates a timer - this works on both active and inactive&n; * timers.&n; *&n; * The function returns whether it has deactivated a pending timer or not.&n; * (ie. del_timer() of an inactive timer returns 0, del_timer() of an&n; * active timer returns 1.)&n; */
DECL|function|del_timer
r_int
id|del_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|tvec_base_t
op_star
id|base
suffix:semicolon
id|check_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|repeat
suffix:colon
id|base
op_assign
id|timer-&gt;base
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
r_return
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|base-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_ne
id|timer-&gt;base
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|base-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|list_del
c_func
(paren
op_amp
id|timer-&gt;entry
)paren
suffix:semicolon
multiline_comment|/* Need to make sure that anybody who sees a NULL base also sees the list ops */
id|smp_wmb
c_func
(paren
)paren
suffix:semicolon
id|timer-&gt;base
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|base-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|del_timer
id|EXPORT_SYMBOL
c_func
(paren
id|del_timer
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/***&n; * del_timer_sync - deactivate a timer and wait for the handler to finish.&n; * @timer: the timer to be deactivated&n; *&n; * This function only differs from del_timer() on SMP: besides deactivating&n; * the timer it also makes sure the handler has finished executing on other&n; * CPUs.&n; *&n; * Synchronization rules: callers must prevent restarting of the timer,&n; * otherwise this function is meaningless. It must not be called from&n; * interrupt contexts. The caller must not hold locks which would prevent&n; * completion of the timer&squot;s handler.  Upon exit the timer is not queued and&n; * the handler is not running on any CPU.&n; *&n; * The function returns whether it has deactivated a pending timer or not.&n; *&n; * del_timer_sync() is slow and complicated because it copes with timer&n; * handlers which re-arm the timer (periodic timers).  If the timer handler&n; * is known to not do this (a single shot timer) then use&n; * del_singleshot_timer_sync() instead.&n; */
DECL|function|del_timer_sync
r_int
id|del_timer_sync
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
id|tvec_base_t
op_star
id|base
suffix:semicolon
r_int
id|i
comma
id|ret
op_assign
l_int|0
suffix:semicolon
id|check_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|del_again
suffix:colon
id|ret
op_add_assign
id|del_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|for_each_online_cpu
c_func
(paren
id|i
)paren
(brace
id|base
op_assign
op_amp
id|per_cpu
c_func
(paren
id|tvec_bases
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base-&gt;running_timer
op_eq
id|timer
)paren
(brace
r_while
c_loop
(paren
id|base-&gt;running_timer
op_eq
id|timer
)paren
(brace
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
id|preempt_check_resched
c_func
(paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|smp_rmb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
id|timer
)paren
)paren
r_goto
id|del_again
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|del_timer_sync
id|EXPORT_SYMBOL
c_func
(paren
id|del_timer_sync
)paren
suffix:semicolon
multiline_comment|/***&n; * del_singleshot_timer_sync - deactivate a non-recursive timer&n; * @timer: the timer to be deactivated&n; *&n; * This function is an optimization of del_timer_sync for the case where the&n; * caller can guarantee the timer does not reschedule itself in its timer&n; * function.&n; *&n; * Synchronization rules: callers must prevent restarting of the timer,&n; * otherwise this function is meaningless. It must not be called from&n; * interrupt contexts. The caller must not hold locks which wold prevent&n; * completion of the timer&squot;s handler.  Upon exit the timer is not queued and&n; * the handler is not running on any CPU.&n; *&n; * The function returns whether it has deactivated a pending timer or not.&n; */
DECL|function|del_singleshot_timer_sync
r_int
id|del_singleshot_timer_sync
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
r_int
id|ret
op_assign
id|del_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|ret
op_assign
id|del_timer_sync
c_func
(paren
id|timer
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|ret
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|del_singleshot_timer_sync
id|EXPORT_SYMBOL
c_func
(paren
id|del_singleshot_timer_sync
)paren
suffix:semicolon
macro_line|#endif
DECL|function|cascade
r_static
r_int
id|cascade
c_func
(paren
id|tvec_base_t
op_star
id|base
comma
id|tvec_t
op_star
id|tv
comma
r_int
id|index
)paren
(brace
multiline_comment|/* cascade all the timers from tv up one level */
r_struct
id|list_head
op_star
id|head
comma
op_star
id|curr
suffix:semicolon
id|head
op_assign
id|tv-&gt;vec
op_plus
id|index
suffix:semicolon
id|curr
op_assign
id|head-&gt;next
suffix:semicolon
multiline_comment|/*&n;&t; * We are removing _all_ timers from the list, so we don&squot;t  have to&n;&t; * detach them individually, just clear the list afterwards.&n;&t; */
r_while
c_loop
(paren
id|curr
op_ne
id|head
)paren
(brace
r_struct
id|timer_list
op_star
id|tmp
suffix:semicolon
id|tmp
op_assign
id|list_entry
c_func
(paren
id|curr
comma
r_struct
id|timer_list
comma
id|entry
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|tmp-&gt;base
op_ne
id|base
)paren
suffix:semicolon
id|curr
op_assign
id|curr-&gt;next
suffix:semicolon
id|internal_add_timer
c_func
(paren
id|base
comma
id|tmp
)paren
suffix:semicolon
)brace
id|INIT_LIST_HEAD
c_func
(paren
id|head
)paren
suffix:semicolon
r_return
id|index
suffix:semicolon
)brace
multiline_comment|/***&n; * __run_timers - run all expired timers (if any) on this CPU.&n; * @base: the timer vector to be processed.&n; *&n; * This function cascades all vectors and executes all expired timer&n; * vectors.&n; */
DECL|macro|INDEX
mdefine_line|#define INDEX(N) (base-&gt;timer_jiffies &gt;&gt; (TVR_BITS + N * TVN_BITS)) &amp; TVN_MASK
DECL|function|__run_timers
r_static
r_inline
r_void
id|__run_timers
c_func
(paren
id|tvec_base_t
op_star
id|base
)paren
(brace
r_struct
id|timer_list
op_star
id|timer
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|base-&gt;lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|base-&gt;timer_jiffies
)paren
)paren
(brace
r_struct
id|list_head
id|work_list
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|work_list
)paren
suffix:semicolon
r_struct
id|list_head
op_star
id|head
op_assign
op_amp
id|work_list
suffix:semicolon
r_int
id|index
op_assign
id|base-&gt;timer_jiffies
op_amp
id|TVR_MASK
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Cascade timers:&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|index
op_logical_and
(paren
op_logical_neg
id|cascade
c_func
(paren
id|base
comma
op_amp
id|base-&gt;tv2
comma
id|INDEX
c_func
(paren
l_int|0
)paren
)paren
)paren
op_logical_and
(paren
op_logical_neg
id|cascade
c_func
(paren
id|base
comma
op_amp
id|base-&gt;tv3
comma
id|INDEX
c_func
(paren
l_int|1
)paren
)paren
)paren
op_logical_and
op_logical_neg
id|cascade
c_func
(paren
id|base
comma
op_amp
id|base-&gt;tv4
comma
id|INDEX
c_func
(paren
l_int|2
)paren
)paren
)paren
id|cascade
c_func
(paren
id|base
comma
op_amp
id|base-&gt;tv5
comma
id|INDEX
c_func
(paren
l_int|3
)paren
)paren
suffix:semicolon
op_increment
id|base-&gt;timer_jiffies
suffix:semicolon
id|list_splice_init
c_func
(paren
id|base-&gt;tv1.vec
op_plus
id|index
comma
op_amp
id|work_list
)paren
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|head
)paren
)paren
(brace
r_void
(paren
op_star
id|fn
)paren
(paren
r_int
r_int
)paren
suffix:semicolon
r_int
r_int
id|data
suffix:semicolon
id|timer
op_assign
id|list_entry
c_func
(paren
id|head-&gt;next
comma
r_struct
id|timer_list
comma
id|entry
)paren
suffix:semicolon
id|fn
op_assign
id|timer-&gt;function
suffix:semicolon
id|data
op_assign
id|timer-&gt;data
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|timer-&gt;entry
)paren
suffix:semicolon
id|set_running_timer
c_func
(paren
id|base
comma
id|timer
)paren
suffix:semicolon
id|smp_wmb
c_func
(paren
)paren
suffix:semicolon
id|timer-&gt;base
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|base-&gt;lock
)paren
suffix:semicolon
(brace
id|u32
id|preempt_count
op_assign
id|preempt_count
c_func
(paren
)paren
suffix:semicolon
id|fn
c_func
(paren
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|preempt_count
op_ne
id|preempt_count
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;huh, entered %p with %08x, exited with %08x?&bslash;n&quot;
comma
id|fn
comma
id|preempt_count
comma
id|preempt_count
c_func
(paren
)paren
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|spin_lock_irq
c_func
(paren
op_amp
id|base-&gt;lock
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
id|set_running_timer
c_func
(paren
id|base
comma
l_int|NULL
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|base-&gt;lock
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NO_IDLE_HZ
multiline_comment|/*&n; * Find out when the next timer event is due to happen. This&n; * is used on S/390 to stop all activity when a cpus is idle.&n; * This functions needs to be called disabled.&n; */
DECL|function|next_timer_interrupt
r_int
r_int
id|next_timer_interrupt
c_func
(paren
r_void
)paren
(brace
id|tvec_base_t
op_star
id|base
suffix:semicolon
r_struct
id|list_head
op_star
id|list
suffix:semicolon
r_struct
id|timer_list
op_star
id|nte
suffix:semicolon
r_int
r_int
id|expires
suffix:semicolon
id|tvec_t
op_star
id|varray
(braket
l_int|4
)braket
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|base
op_assign
op_amp
id|__get_cpu_var
c_func
(paren
id|tvec_bases
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|base-&gt;lock
)paren
suffix:semicolon
id|expires
op_assign
id|base-&gt;timer_jiffies
op_plus
(paren
id|LONG_MAX
op_rshift
l_int|1
)paren
suffix:semicolon
id|list
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Look for timer events in tv1. */
id|j
op_assign
id|base-&gt;timer_jiffies
op_amp
id|TVR_MASK
suffix:semicolon
r_do
(brace
id|list_for_each_entry
c_func
(paren
id|nte
comma
id|base-&gt;tv1.vec
op_plus
id|j
comma
id|entry
)paren
(brace
id|expires
op_assign
id|nte-&gt;expires
suffix:semicolon
r_if
c_cond
(paren
id|j
OL
(paren
id|base-&gt;timer_jiffies
op_amp
id|TVR_MASK
)paren
)paren
id|list
op_assign
id|base-&gt;tv2.vec
op_plus
(paren
id|INDEX
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_goto
id|found
suffix:semicolon
)brace
id|j
op_assign
(paren
id|j
op_plus
l_int|1
)paren
op_amp
id|TVR_MASK
suffix:semicolon
)brace
r_while
c_loop
(paren
id|j
op_ne
(paren
id|base-&gt;timer_jiffies
op_amp
id|TVR_MASK
)paren
)paren
suffix:semicolon
multiline_comment|/* Check tv2-tv5. */
id|varray
(braket
l_int|0
)braket
op_assign
op_amp
id|base-&gt;tv2
suffix:semicolon
id|varray
(braket
l_int|1
)braket
op_assign
op_amp
id|base-&gt;tv3
suffix:semicolon
id|varray
(braket
l_int|2
)braket
op_assign
op_amp
id|base-&gt;tv4
suffix:semicolon
id|varray
(braket
l_int|3
)braket
op_assign
op_amp
id|base-&gt;tv5
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|j
op_assign
id|INDEX
c_func
(paren
id|i
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|varray
(braket
id|i
)braket
op_member_access_from_pointer
id|vec
op_plus
id|j
)paren
)paren
(brace
id|j
op_assign
(paren
id|j
op_plus
l_int|1
)paren
op_amp
id|TVN_MASK
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|list_for_each_entry
c_func
(paren
id|nte
comma
id|varray
(braket
id|i
)braket
op_member_access_from_pointer
id|vec
op_plus
id|j
comma
id|entry
)paren
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|nte-&gt;expires
comma
id|expires
)paren
)paren
id|expires
op_assign
id|nte-&gt;expires
suffix:semicolon
r_if
c_cond
(paren
id|j
OL
(paren
id|INDEX
c_func
(paren
id|i
)paren
)paren
op_logical_and
id|i
OL
l_int|3
)paren
id|list
op_assign
id|varray
(braket
id|i
op_plus
l_int|1
)braket
op_member_access_from_pointer
id|vec
op_plus
(paren
id|INDEX
c_func
(paren
id|i
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_goto
id|found
suffix:semicolon
)brace
r_while
c_loop
(paren
id|j
op_ne
(paren
id|INDEX
c_func
(paren
id|i
)paren
)paren
)paren
suffix:semicolon
)brace
id|found
suffix:colon
r_if
c_cond
(paren
id|list
)paren
(brace
multiline_comment|/*&n;&t;&t; * The search wrapped. We need to look at the next list&n;&t;&t; * from next tv element that would cascade into tv element&n;&t;&t; * where we found the timer element.&n;&t;&t; */
id|list_for_each_entry
c_func
(paren
id|nte
comma
id|list
comma
id|entry
)paren
(brace
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|nte-&gt;expires
comma
id|expires
)paren
)paren
id|expires
op_assign
id|nte-&gt;expires
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|base-&gt;lock
)paren
suffix:semicolon
r_return
id|expires
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/******************************************************************/
multiline_comment|/*&n; * Timekeeping variables&n; */
DECL|variable|tick_usec
r_int
r_int
id|tick_usec
op_assign
id|TICK_USEC
suffix:semicolon
multiline_comment|/* USER_HZ period (usec) */
DECL|variable|tick_nsec
r_int
r_int
id|tick_nsec
op_assign
id|TICK_NSEC
suffix:semicolon
multiline_comment|/* ACTHZ period (nsec) */
multiline_comment|/* &n; * The current time &n; * wall_to_monotonic is what we need to add to xtime (or xtime corrected &n; * for sub jiffie times) to get to monotonic time.  Monotonic is pegged at zero&n; * at zero at system boot time, so wall_to_monotonic will be negative,&n; * however, we will ALWAYS keep the tv_nsec part positive so we can use&n; * the usual normalization.&n; */
DECL|variable|xtime
r_struct
id|timespec
id|xtime
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|16
)paren
)paren
)paren
suffix:semicolon
DECL|variable|wall_to_monotonic
r_struct
id|timespec
id|wall_to_monotonic
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|16
)paren
)paren
)paren
suffix:semicolon
DECL|variable|xtime
id|EXPORT_SYMBOL
c_func
(paren
id|xtime
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t completely fail for HZ &gt; 500.  */
DECL|variable|tickadj
r_int
id|tickadj
op_assign
l_int|500
op_div
id|HZ
ques
c_cond
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* microsecs */
multiline_comment|/*&n; * phase-lock loop variables&n; */
multiline_comment|/* TIME_ERROR prevents overwriting the CMOS clock */
DECL|variable|time_state
r_int
id|time_state
op_assign
id|TIME_OK
suffix:semicolon
multiline_comment|/* clock synchronization status&t;*/
DECL|variable|time_status
r_int
id|time_status
op_assign
id|STA_UNSYNC
suffix:semicolon
multiline_comment|/* clock status bits&t;&t;*/
DECL|variable|time_offset
r_int
id|time_offset
suffix:semicolon
multiline_comment|/* time adjustment (us)&t;&t;*/
DECL|variable|time_constant
r_int
id|time_constant
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* pll time constant&t;&t;*/
DECL|variable|time_tolerance
r_int
id|time_tolerance
op_assign
id|MAXFREQ
suffix:semicolon
multiline_comment|/* frequency tolerance (ppm)&t;*/
DECL|variable|time_precision
r_int
id|time_precision
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* clock precision (us)&t;&t;*/
DECL|variable|time_maxerror
r_int
id|time_maxerror
op_assign
id|NTP_PHASE_LIMIT
suffix:semicolon
multiline_comment|/* maximum error (us)&t;&t;*/
DECL|variable|time_esterror
r_int
id|time_esterror
op_assign
id|NTP_PHASE_LIMIT
suffix:semicolon
multiline_comment|/* estimated error (us)&t;&t;*/
DECL|variable|time_phase
r_int
id|time_phase
suffix:semicolon
multiline_comment|/* phase offset (scaled us)&t;*/
DECL|variable|time_freq
r_int
id|time_freq
op_assign
(paren
(paren
(paren
id|NSEC_PER_SEC
op_plus
id|HZ
op_div
l_int|2
)paren
op_mod
id|HZ
op_minus
id|HZ
op_div
l_int|2
)paren
op_lshift
id|SHIFT_USEC
)paren
op_div
id|NSEC_PER_USEC
suffix:semicolon
multiline_comment|/* frequency offset (scaled ppm)*/
DECL|variable|time_adj
r_int
id|time_adj
suffix:semicolon
multiline_comment|/* tick adjust (scaled 1 / HZ)&t;*/
DECL|variable|time_reftime
r_int
id|time_reftime
suffix:semicolon
multiline_comment|/* time at last adjustment (s)&t;*/
DECL|variable|time_adjust
r_int
id|time_adjust
suffix:semicolon
DECL|variable|time_next_adjust
r_int
id|time_next_adjust
suffix:semicolon
multiline_comment|/*&n; * this routine handles the overflow of the microsecond field&n; *&n; * The tricky bits of code to handle the accurate clock support&n; * were provided by Dave Mills (Mills@UDEL.EDU) of NTP fame.&n; * They were originally developed for SUN and DEC kernels.&n; * All the kudos should go to Dave for this stuff.&n; *&n; */
DECL|function|second_overflow
r_static
r_void
id|second_overflow
c_func
(paren
r_void
)paren
(brace
r_int
id|ltemp
suffix:semicolon
multiline_comment|/* Bump the maxerror field */
id|time_maxerror
op_add_assign
id|time_tolerance
op_rshift
id|SHIFT_USEC
suffix:semicolon
r_if
c_cond
(paren
id|time_maxerror
OG
id|NTP_PHASE_LIMIT
)paren
(brace
id|time_maxerror
op_assign
id|NTP_PHASE_LIMIT
suffix:semicolon
id|time_status
op_or_assign
id|STA_UNSYNC
suffix:semicolon
)brace
multiline_comment|/*&n;     * Leap second processing. If in leap-insert state at&n;     * the end of the day, the system clock is set back one&n;     * second; if in leap-delete state, the system clock is&n;     * set ahead one second. The microtime() routine or&n;     * external clock driver will insure that reported time&n;     * is always monotonic. The ugly divides should be&n;     * replaced.&n;     */
r_switch
c_cond
(paren
id|time_state
)paren
(brace
r_case
id|TIME_OK
suffix:colon
r_if
c_cond
(paren
id|time_status
op_amp
id|STA_INS
)paren
id|time_state
op_assign
id|TIME_INS
suffix:semicolon
r_else
r_if
c_cond
(paren
id|time_status
op_amp
id|STA_DEL
)paren
id|time_state
op_assign
id|TIME_DEL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_INS
suffix:colon
r_if
c_cond
(paren
id|xtime.tv_sec
op_mod
l_int|86400
op_eq
l_int|0
)paren
(brace
id|xtime.tv_sec
op_decrement
suffix:semicolon
id|wall_to_monotonic.tv_sec
op_increment
suffix:semicolon
multiline_comment|/* The timer interpolator will make time change gradually instead&n;&t;     * of an immediate jump by one second.&n;&t;     */
id|time_interpolator_update
c_func
(paren
op_minus
id|NSEC_PER_SEC
)paren
suffix:semicolon
id|time_state
op_assign
id|TIME_OOP
suffix:semicolon
id|clock_was_set
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Clock: inserting leap second 23:59:60 UTC&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIME_DEL
suffix:colon
r_if
c_cond
(paren
(paren
id|xtime.tv_sec
op_plus
l_int|1
)paren
op_mod
l_int|86400
op_eq
l_int|0
)paren
(brace
id|xtime.tv_sec
op_increment
suffix:semicolon
id|wall_to_monotonic.tv_sec
op_decrement
suffix:semicolon
multiline_comment|/* Use of time interpolator for a gradual change of time */
id|time_interpolator_update
c_func
(paren
id|NSEC_PER_SEC
)paren
suffix:semicolon
id|time_state
op_assign
id|TIME_WAIT
suffix:semicolon
id|clock_was_set
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Clock: deleting leap second 23:59:59 UTC&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIME_OOP
suffix:colon
id|time_state
op_assign
id|TIME_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_WAIT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|time_status
op_amp
(paren
id|STA_INS
op_or
id|STA_DEL
)paren
)paren
)paren
id|time_state
op_assign
id|TIME_OK
suffix:semicolon
)brace
multiline_comment|/*&n;     * Compute the phase adjustment for the next second. In&n;     * PLL mode, the offset is reduced by a fixed factor&n;     * times the time constant. In FLL mode the offset is&n;     * used directly. In either mode, the maximum phase&n;     * adjustment for each second is clamped so as to spread&n;     * the adjustment over not more than the number of&n;     * seconds between updates.&n;     */
r_if
c_cond
(paren
id|time_offset
OL
l_int|0
)paren
(brace
id|ltemp
op_assign
op_minus
id|time_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|time_status
op_amp
id|STA_FLL
)paren
)paren
id|ltemp
op_rshift_assign
id|SHIFT_KG
op_plus
id|time_constant
suffix:semicolon
r_if
c_cond
(paren
id|ltemp
OG
(paren
id|MAXPHASE
op_div
id|MINSEC
)paren
op_lshift
id|SHIFT_UPDATE
)paren
id|ltemp
op_assign
(paren
id|MAXPHASE
op_div
id|MINSEC
)paren
op_lshift
id|SHIFT_UPDATE
suffix:semicolon
id|time_offset
op_add_assign
id|ltemp
suffix:semicolon
id|time_adj
op_assign
op_minus
id|ltemp
op_lshift
(paren
id|SHIFT_SCALE
op_minus
id|SHIFT_HZ
op_minus
id|SHIFT_UPDATE
)paren
suffix:semicolon
)brace
r_else
(brace
id|ltemp
op_assign
id|time_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|time_status
op_amp
id|STA_FLL
)paren
)paren
id|ltemp
op_rshift_assign
id|SHIFT_KG
op_plus
id|time_constant
suffix:semicolon
r_if
c_cond
(paren
id|ltemp
OG
(paren
id|MAXPHASE
op_div
id|MINSEC
)paren
op_lshift
id|SHIFT_UPDATE
)paren
id|ltemp
op_assign
(paren
id|MAXPHASE
op_div
id|MINSEC
)paren
op_lshift
id|SHIFT_UPDATE
suffix:semicolon
id|time_offset
op_sub_assign
id|ltemp
suffix:semicolon
id|time_adj
op_assign
id|ltemp
op_lshift
(paren
id|SHIFT_SCALE
op_minus
id|SHIFT_HZ
op_minus
id|SHIFT_UPDATE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Compute the frequency estimate and additional phase&n;     * adjustment due to frequency error for the next&n;     * second. When the PPS signal is engaged, gnaw on the&n;     * watchdog counter and update the frequency computed by&n;     * the pll and the PPS signal.&n;     */
id|pps_valid
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pps_valid
op_eq
id|PPS_VALID
)paren
(brace
multiline_comment|/* PPS signal lost */
id|pps_jitter
op_assign
id|MAXTIME
suffix:semicolon
id|pps_stabil
op_assign
id|MAXFREQ
suffix:semicolon
id|time_status
op_and_assign
op_complement
(paren
id|STA_PPSSIGNAL
op_or
id|STA_PPSJITTER
op_or
id|STA_PPSWANDER
op_or
id|STA_PPSERROR
)paren
suffix:semicolon
)brace
id|ltemp
op_assign
id|time_freq
op_plus
id|pps_freq
suffix:semicolon
r_if
c_cond
(paren
id|ltemp
OL
l_int|0
)paren
id|time_adj
op_sub_assign
op_minus
id|ltemp
op_rshift
(paren
id|SHIFT_USEC
op_plus
id|SHIFT_HZ
op_minus
id|SHIFT_SCALE
)paren
suffix:semicolon
r_else
id|time_adj
op_add_assign
id|ltemp
op_rshift
(paren
id|SHIFT_USEC
op_plus
id|SHIFT_HZ
op_minus
id|SHIFT_SCALE
)paren
suffix:semicolon
macro_line|#if HZ == 100
multiline_comment|/* Compensate for (HZ==100) != (1 &lt;&lt; SHIFT_HZ).&n;     * Add 25% and 3.125% to get 128.125; =&gt; only 0.125% error (p. 14)&n;     */
r_if
c_cond
(paren
id|time_adj
OL
l_int|0
)paren
id|time_adj
op_sub_assign
(paren
op_minus
id|time_adj
op_rshift
l_int|2
)paren
op_plus
(paren
op_minus
id|time_adj
op_rshift
l_int|5
)paren
suffix:semicolon
r_else
id|time_adj
op_add_assign
(paren
id|time_adj
op_rshift
l_int|2
)paren
op_plus
(paren
id|time_adj
op_rshift
l_int|5
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if HZ == 1000
multiline_comment|/* Compensate for (HZ==1000) != (1 &lt;&lt; SHIFT_HZ).&n;     * Add 1.5625% and 0.78125% to get 1023.4375; =&gt; only 0.05% error (p. 14)&n;     */
r_if
c_cond
(paren
id|time_adj
OL
l_int|0
)paren
id|time_adj
op_sub_assign
(paren
op_minus
id|time_adj
op_rshift
l_int|6
)paren
op_plus
(paren
op_minus
id|time_adj
op_rshift
l_int|7
)paren
suffix:semicolon
r_else
id|time_adj
op_add_assign
(paren
id|time_adj
op_rshift
l_int|6
)paren
op_plus
(paren
id|time_adj
op_rshift
l_int|7
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* in the NTP reference this is called &quot;hardclock()&quot; */
DECL|function|update_wall_time_one_tick
r_static
r_void
id|update_wall_time_one_tick
c_func
(paren
r_void
)paren
(brace
r_int
id|time_adjust_step
comma
id|delta_nsec
suffix:semicolon
r_if
c_cond
(paren
(paren
id|time_adjust_step
op_assign
id|time_adjust
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* We are doing an adjtime thing. &n;&t;     *&n;&t;     * Prepare time_adjust_step to be within bounds.&n;&t;     * Note that a positive time_adjust means we want the clock&n;&t;     * to run faster.&n;&t;     *&n;&t;     * Limit the amount of the step to be in the range&n;&t;     * -tickadj .. +tickadj&n;&t;     */
r_if
c_cond
(paren
id|time_adjust
OG
id|tickadj
)paren
id|time_adjust_step
op_assign
id|tickadj
suffix:semicolon
r_else
r_if
c_cond
(paren
id|time_adjust
OL
op_minus
id|tickadj
)paren
id|time_adjust_step
op_assign
op_minus
id|tickadj
suffix:semicolon
multiline_comment|/* Reduce by this step the amount of time left  */
id|time_adjust
op_sub_assign
id|time_adjust_step
suffix:semicolon
)brace
id|delta_nsec
op_assign
id|tick_nsec
op_plus
id|time_adjust_step
op_star
l_int|1000
suffix:semicolon
multiline_comment|/*&n;&t; * Advance the phase, once it gets to one microsecond, then&n;&t; * advance the tick more.&n;&t; */
id|time_phase
op_add_assign
id|time_adj
suffix:semicolon
r_if
c_cond
(paren
id|time_phase
op_le
op_minus
id|FINENSEC
)paren
(brace
r_int
id|ltemp
op_assign
op_minus
id|time_phase
op_rshift
(paren
id|SHIFT_SCALE
op_minus
l_int|10
)paren
suffix:semicolon
id|time_phase
op_add_assign
id|ltemp
op_lshift
(paren
id|SHIFT_SCALE
op_minus
l_int|10
)paren
suffix:semicolon
id|delta_nsec
op_sub_assign
id|ltemp
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|time_phase
op_ge
id|FINENSEC
)paren
(brace
r_int
id|ltemp
op_assign
id|time_phase
op_rshift
(paren
id|SHIFT_SCALE
op_minus
l_int|10
)paren
suffix:semicolon
id|time_phase
op_sub_assign
id|ltemp
op_lshift
(paren
id|SHIFT_SCALE
op_minus
l_int|10
)paren
suffix:semicolon
id|delta_nsec
op_add_assign
id|ltemp
suffix:semicolon
)brace
id|xtime.tv_nsec
op_add_assign
id|delta_nsec
suffix:semicolon
id|time_interpolator_update
c_func
(paren
id|delta_nsec
)paren
suffix:semicolon
multiline_comment|/* Changes by adjtime() do not take effect till next tick. */
r_if
c_cond
(paren
id|time_next_adjust
op_ne
l_int|0
)paren
(brace
id|time_adjust
op_assign
id|time_next_adjust
suffix:semicolon
id|time_next_adjust
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Using a loop looks inefficient, but &quot;ticks&quot; is&n; * usually just one (we shouldn&squot;t be losing ticks,&n; * we&squot;re doing this this way mainly for interrupt&n; * latency reasons, not because we think we&squot;ll&n; * have lots of lost timer ticks&n; */
DECL|function|update_wall_time
r_static
r_void
id|update_wall_time
c_func
(paren
r_int
r_int
id|ticks
)paren
(brace
r_do
(brace
id|ticks
op_decrement
suffix:semicolon
id|update_wall_time_one_tick
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xtime.tv_nsec
op_ge
l_int|1000000000
)paren
(brace
id|xtime.tv_nsec
op_sub_assign
l_int|1000000000
suffix:semicolon
id|xtime.tv_sec
op_increment
suffix:semicolon
id|second_overflow
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|ticks
)paren
suffix:semicolon
)brace
DECL|function|do_process_times
r_static
r_inline
r_void
id|do_process_times
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
r_int
id|user
comma
r_int
r_int
id|system
)paren
(brace
r_int
r_int
id|psecs
suffix:semicolon
id|psecs
op_assign
(paren
id|p-&gt;utime
op_add_assign
id|user
)paren
suffix:semicolon
id|psecs
op_add_assign
(paren
id|p-&gt;stime
op_add_assign
id|system
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;signal
op_logical_and
op_logical_neg
id|unlikely
c_func
(paren
id|p-&gt;exit_state
)paren
op_logical_and
id|psecs
op_div
id|HZ
op_ge
id|p-&gt;signal-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_cur
)paren
(brace
multiline_comment|/* Send SIGXCPU every second.. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|psecs
op_mod
id|HZ
)paren
)paren
id|send_sig
c_func
(paren
id|SIGXCPU
comma
id|p
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* and SIGKILL when we go over max.. */
r_if
c_cond
(paren
id|psecs
op_div
id|HZ
op_ge
id|p-&gt;signal-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_max
)paren
id|send_sig
c_func
(paren
id|SIGKILL
comma
id|p
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
DECL|function|do_it_virt
r_static
r_inline
r_void
id|do_it_virt
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
r_int
id|ticks
)paren
(brace
r_int
r_int
id|it_virt
op_assign
id|p-&gt;it_virt_value
suffix:semicolon
r_if
c_cond
(paren
id|it_virt
)paren
(brace
id|it_virt
op_sub_assign
id|ticks
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|it_virt
)paren
(brace
id|it_virt
op_assign
id|p-&gt;it_virt_incr
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGVTALRM
comma
id|p
comma
l_int|1
)paren
suffix:semicolon
)brace
id|p-&gt;it_virt_value
op_assign
id|it_virt
suffix:semicolon
)brace
)brace
DECL|function|do_it_prof
r_static
r_inline
r_void
id|do_it_prof
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_int
r_int
id|it_prof
op_assign
id|p-&gt;it_prof_value
suffix:semicolon
r_if
c_cond
(paren
id|it_prof
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|it_prof
op_eq
l_int|0
)paren
(brace
id|it_prof
op_assign
id|p-&gt;it_prof_incr
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGPROF
comma
id|p
comma
l_int|1
)paren
suffix:semicolon
)brace
id|p-&gt;it_prof_value
op_assign
id|it_prof
suffix:semicolon
)brace
)brace
DECL|function|update_one_process
r_static
r_void
id|update_one_process
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
r_int
id|user
comma
r_int
r_int
id|system
comma
r_int
id|cpu
)paren
(brace
id|do_process_times
c_func
(paren
id|p
comma
id|user
comma
id|system
)paren
suffix:semicolon
id|do_it_virt
c_func
(paren
id|p
comma
id|user
)paren
suffix:semicolon
id|do_it_prof
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called from the timer interrupt handler to charge one tick to the current &n; * process.  user_tick is 1 if the tick is user time, 0 for system.&n; */
DECL|function|update_process_times
r_void
id|update_process_times
c_func
(paren
r_int
id|user_tick
)paren
(brace
r_struct
id|task_struct
op_star
id|p
op_assign
id|current
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
comma
id|system
op_assign
id|user_tick
op_xor
l_int|1
suffix:semicolon
id|update_one_process
c_func
(paren
id|p
comma
id|user_tick
comma
id|system
comma
id|cpu
)paren
suffix:semicolon
id|run_local_timers
c_func
(paren
)paren
suffix:semicolon
id|scheduler_tick
c_func
(paren
id|user_tick
comma
id|system
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Nr of active tasks - counted in fixed-point numbers&n; */
DECL|function|count_active_tasks
r_static
r_int
r_int
id|count_active_tasks
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|nr_running
c_func
(paren
)paren
op_plus
id|nr_uninterruptible
c_func
(paren
)paren
)paren
op_star
id|FIXED_1
suffix:semicolon
)brace
multiline_comment|/*&n; * Hmm.. Changed this, as the GNU make sources (load.c) seems to&n; * imply that avenrun[] is the standard name for this kind of thing.&n; * Nothing else seems to be standardized: the fractional size etc&n; * all seem to differ on different machines.&n; *&n; * Requires xtime_lock to access.&n; */
DECL|variable|avenrun
r_int
r_int
id|avenrun
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/*&n; * calc_load - given tick count, update the avenrun load estimates.&n; * This is called while holding a write_lock on xtime_lock.&n; */
DECL|function|calc_load
r_static
r_inline
r_void
id|calc_load
c_func
(paren
r_int
r_int
id|ticks
)paren
(brace
r_int
r_int
id|active_tasks
suffix:semicolon
multiline_comment|/* fixed-point */
r_static
r_int
id|count
op_assign
id|LOAD_FREQ
suffix:semicolon
id|count
op_sub_assign
id|ticks
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
(brace
id|count
op_add_assign
id|LOAD_FREQ
suffix:semicolon
id|active_tasks
op_assign
id|count_active_tasks
c_func
(paren
)paren
suffix:semicolon
id|CALC_LOAD
c_func
(paren
id|avenrun
(braket
l_int|0
)braket
comma
id|EXP_1
comma
id|active_tasks
)paren
suffix:semicolon
id|CALC_LOAD
c_func
(paren
id|avenrun
(braket
l_int|1
)braket
comma
id|EXP_5
comma
id|active_tasks
)paren
suffix:semicolon
id|CALC_LOAD
c_func
(paren
id|avenrun
(braket
l_int|2
)braket
comma
id|EXP_15
comma
id|active_tasks
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* jiffies at the most recent update of wall time */
DECL|variable|wall_jiffies
r_int
r_int
id|wall_jiffies
op_assign
id|INITIAL_JIFFIES
suffix:semicolon
multiline_comment|/*&n; * This read-write spinlock protects us from races in SMP while&n; * playing with xtime and avenrun.&n; */
macro_line|#ifndef ARCH_HAVE_XTIME_LOCK
DECL|variable|__cacheline_aligned_in_smp
id|seqlock_t
id|xtime_lock
id|__cacheline_aligned_in_smp
op_assign
id|SEQLOCK_UNLOCKED
suffix:semicolon
DECL|variable|xtime_lock
id|EXPORT_SYMBOL
c_func
(paren
id|xtime_lock
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * This function runs timers and the timer-tq in bottom half context.&n; */
DECL|function|run_timer_softirq
r_static
r_void
id|run_timer_softirq
c_func
(paren
r_struct
id|softirq_action
op_star
id|h
)paren
(brace
id|tvec_base_t
op_star
id|base
op_assign
op_amp
id|__get_cpu_var
c_func
(paren
id|tvec_bases
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|base-&gt;timer_jiffies
)paren
)paren
id|__run_timers
c_func
(paren
id|base
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by the local, per-CPU timer interrupt on SMP.&n; */
DECL|function|run_local_timers
r_void
id|run_local_timers
c_func
(paren
r_void
)paren
(brace
id|raise_softirq
c_func
(paren
id|TIMER_SOFTIRQ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by the timer interrupt. xtime_lock must already be taken&n; * by the timer IRQ!&n; */
DECL|function|update_times
r_static
r_inline
r_void
id|update_times
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|ticks
suffix:semicolon
id|ticks
op_assign
id|jiffies
op_minus
id|wall_jiffies
suffix:semicolon
r_if
c_cond
(paren
id|ticks
)paren
(brace
id|wall_jiffies
op_add_assign
id|ticks
suffix:semicolon
id|update_wall_time
c_func
(paren
id|ticks
)paren
suffix:semicolon
)brace
id|calc_load
c_func
(paren
id|ticks
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The 64-bit jiffies value is not atomic - you MUST NOT read it&n; * without sampling the sequence number in xtime_lock.&n; * jiffies is defined in the linker script...&n; */
DECL|function|do_timer
r_void
id|do_timer
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|jiffies_64
op_increment
suffix:semicolon
id|update_times
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef __ARCH_WANT_SYS_ALARM
multiline_comment|/*&n; * For backwards compatibility?  This can be done in libc so Alpha&n; * and all newer ports shouldn&squot;t need it.&n; */
DECL|function|sys_alarm
id|asmlinkage
r_int
r_int
id|sys_alarm
c_func
(paren
r_int
r_int
id|seconds
)paren
(brace
r_struct
id|itimerval
id|it_new
comma
id|it_old
suffix:semicolon
r_int
r_int
id|oldalarm
suffix:semicolon
id|it_new.it_interval.tv_sec
op_assign
id|it_new.it_interval.tv_usec
op_assign
l_int|0
suffix:semicolon
id|it_new.it_value.tv_sec
op_assign
id|seconds
suffix:semicolon
id|it_new.it_value.tv_usec
op_assign
l_int|0
suffix:semicolon
id|do_setitimer
c_func
(paren
id|ITIMER_REAL
comma
op_amp
id|it_new
comma
op_amp
id|it_old
)paren
suffix:semicolon
id|oldalarm
op_assign
id|it_old.it_value.tv_sec
suffix:semicolon
multiline_comment|/* ehhh.. We can&squot;t return 0 if we have an alarm pending.. */
multiline_comment|/* And we&squot;d better return too much than too little anyway */
r_if
c_cond
(paren
(paren
op_logical_neg
id|oldalarm
op_logical_and
id|it_old.it_value.tv_usec
)paren
op_logical_or
id|it_old.it_value.tv_usec
op_ge
l_int|500000
)paren
id|oldalarm
op_increment
suffix:semicolon
r_return
id|oldalarm
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifndef __alpha__
multiline_comment|/*&n; * The Alpha uses getxpid, getxuid, and getxgid instead.  Maybe this&n; * should be moved into arch/i386 instead?&n; */
multiline_comment|/**&n; * sys_getpid - return the thread group id of the current process&n; *&n; * Note, despite the name, this returns the tgid not the pid.  The tgid and&n; * the pid are identical unless CLONE_THREAD was specified on clone() in&n; * which case the tgid is the same in all threads of the same group.&n; *&n; * This is SMP safe as current-&gt;tgid does not change.&n; */
DECL|function|sys_getpid
id|asmlinkage
r_int
id|sys_getpid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;tgid
suffix:semicolon
)brace
multiline_comment|/*&n; * Accessing -&gt;group_leader-&gt;real_parent is not SMP-safe, it could&n; * change from under us. However, rather than getting any lock&n; * we can use an optimistic algorithm: get the parent&n; * pid, and go back and check that the parent is still&n; * the same. If it has changed (which is extremely unlikely&n; * indeed), we just try again..&n; *&n; * NOTE! This depends on the fact that even if we _do_&n; * get an old value of &quot;parent&quot;, we can happily dereference&n; * the pointer (it was and remains a dereferencable kernel pointer&n; * no matter what): we just can&squot;t necessarily trust the result&n; * until we know that the parent pointer is valid.&n; *&n; * NOTE2: -&gt;group_leader never changes from under us.&n; */
DECL|function|sys_getppid
id|asmlinkage
r_int
id|sys_getppid
c_func
(paren
r_void
)paren
(brace
r_int
id|pid
suffix:semicolon
r_struct
id|task_struct
op_star
id|me
op_assign
id|current
suffix:semicolon
r_struct
id|task_struct
op_star
id|parent
suffix:semicolon
id|parent
op_assign
id|me-&gt;group_leader-&gt;real_parent
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|pid
op_assign
id|parent-&gt;tgid
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
(brace
r_struct
id|task_struct
op_star
id|old
op_assign
id|parent
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure we read the pid before re-reading the&n;&t;&t; * parent pointer:&n;&t;&t; */
id|rmb
c_func
(paren
)paren
suffix:semicolon
id|parent
op_assign
id|me-&gt;group_leader-&gt;real_parent
suffix:semicolon
r_if
c_cond
(paren
id|old
op_ne
id|parent
)paren
r_continue
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
)brace
r_return
id|pid
suffix:semicolon
)brace
DECL|function|sys_getuid
id|asmlinkage
r_int
id|sys_getuid
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Only we change this so SMP safe */
r_return
id|current-&gt;uid
suffix:semicolon
)brace
DECL|function|sys_geteuid
id|asmlinkage
r_int
id|sys_geteuid
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Only we change this so SMP safe */
r_return
id|current-&gt;euid
suffix:semicolon
)brace
DECL|function|sys_getgid
id|asmlinkage
r_int
id|sys_getgid
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Only we change this so SMP safe */
r_return
id|current-&gt;gid
suffix:semicolon
)brace
DECL|function|sys_getegid
id|asmlinkage
r_int
id|sys_getegid
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Only we change this so SMP safe */
r_return
id|current-&gt;egid
suffix:semicolon
)brace
macro_line|#endif
DECL|function|process_timeout
r_static
r_void
id|process_timeout
c_func
(paren
r_int
r_int
id|__data
)paren
(brace
id|wake_up_process
c_func
(paren
(paren
id|task_t
op_star
)paren
id|__data
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * schedule_timeout - sleep until timeout&n; * @timeout: timeout value in jiffies&n; *&n; * Make the current task sleep until @timeout jiffies have&n; * elapsed. The routine will return immediately unless&n; * the current task state has been set (see set_current_state()).&n; *&n; * You can set the task state as follows -&n; *&n; * %TASK_UNINTERRUPTIBLE - at least @timeout jiffies are guaranteed to&n; * pass before the routine returns. The routine will return 0&n; *&n; * %TASK_INTERRUPTIBLE - the routine may return early if a signal is&n; * delivered to the current task. In this case the remaining time&n; * in jiffies will be returned, or 0 if the timer expired in time&n; *&n; * The current task state is guaranteed to be TASK_RUNNING when this&n; * routine returns.&n; *&n; * Specifying a @timeout value of %MAX_SCHEDULE_TIMEOUT will schedule&n; * the CPU away without a bound on the timeout. In this case the return&n; * value will be %MAX_SCHEDULE_TIMEOUT.&n; *&n; * In all cases the return value is guaranteed to be non-negative.&n; */
DECL|function|schedule_timeout
id|fastcall
r_int
r_int
id|__sched
id|schedule_timeout
c_func
(paren
r_int
r_int
id|timeout
)paren
(brace
r_struct
id|timer_list
id|timer
suffix:semicolon
r_int
r_int
id|expire
suffix:semicolon
r_switch
c_cond
(paren
id|timeout
)paren
(brace
r_case
id|MAX_SCHEDULE_TIMEOUT
suffix:colon
multiline_comment|/*&n;&t;&t; * These two special cases are useful to be comfortable&n;&t;&t; * in the caller. Nothing more. We could take&n;&t;&t; * MAX_SCHEDULE_TIMEOUT from one of the negative value&n;&t;&t; * but I&squot; d like to return a valid offset (&gt;=0) to allow&n;&t;&t; * the caller to do everything it want with the retval.&n;&t;&t; */
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/*&n;&t;&t; * Another bit of PARANOID. Note that the retval will be&n;&t;&t; * 0 since no piece of kernel is supposed to do a check&n;&t;&t; * for a negative retval of schedule_timeout() (since it&n;&t;&t; * should never happens anyway). You just have the printk()&n;&t;&t; * that will tell you if something is gone wrong and where.&n;&t;&t; */
r_if
c_cond
(paren
id|timeout
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;schedule_timeout: wrong timeout &quot;
l_string|&quot;value %lx from %p&bslash;n&quot;
comma
id|timeout
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|expire
op_assign
id|timeout
op_plus
id|jiffies
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|timer.expires
op_assign
id|expire
suffix:semicolon
id|timer.data
op_assign
(paren
r_int
r_int
)paren
id|current
suffix:semicolon
id|timer.function
op_assign
id|process_timeout
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|del_singleshot_timer_sync
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|timeout
op_assign
id|expire
op_minus
id|jiffies
suffix:semicolon
id|out
suffix:colon
r_return
id|timeout
OL
l_int|0
ques
c_cond
l_int|0
suffix:colon
id|timeout
suffix:semicolon
)brace
DECL|variable|schedule_timeout
id|EXPORT_SYMBOL
c_func
(paren
id|schedule_timeout
)paren
suffix:semicolon
multiline_comment|/* Thread ID - the internal kernel &quot;pid&quot; */
DECL|function|sys_gettid
id|asmlinkage
r_int
id|sys_gettid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;pid
suffix:semicolon
)brace
DECL|function|nanosleep_restart
r_static
r_int
id|__sched
id|nanosleep_restart
c_func
(paren
r_struct
id|restart_block
op_star
id|restart
)paren
(brace
r_int
r_int
id|expire
op_assign
id|restart-&gt;arg0
comma
id|now
op_assign
id|jiffies
suffix:semicolon
r_struct
id|timespec
id|__user
op_star
id|rmtp
op_assign
(paren
r_struct
id|timespec
id|__user
op_star
)paren
id|restart-&gt;arg1
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* Did it expire while we handled signals? */
r_if
c_cond
(paren
op_logical_neg
id|time_after
c_func
(paren
id|expire
comma
id|now
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|expire
op_assign
id|schedule_timeout
c_func
(paren
id|expire
op_minus
id|now
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|expire
)paren
(brace
r_struct
id|timespec
id|t
suffix:semicolon
id|jiffies_to_timespec
c_func
(paren
id|expire
comma
op_amp
id|t
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ERESTART_RESTARTBLOCK
suffix:semicolon
r_if
c_cond
(paren
id|rmtp
op_logical_and
id|copy_to_user
c_func
(paren
id|rmtp
comma
op_amp
id|t
comma
r_sizeof
(paren
id|t
)paren
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* The &squot;restart&squot; block is already filled in */
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sys_nanosleep
id|asmlinkage
r_int
id|sys_nanosleep
c_func
(paren
r_struct
id|timespec
id|__user
op_star
id|rqtp
comma
r_struct
id|timespec
id|__user
op_star
id|rmtp
)paren
(brace
r_struct
id|timespec
id|t
suffix:semicolon
r_int
r_int
id|expire
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|t
comma
id|rqtp
comma
r_sizeof
(paren
id|t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|t.tv_nsec
op_ge
l_int|1000000000L
)paren
op_logical_or
(paren
id|t.tv_nsec
OL
l_int|0
)paren
op_logical_or
(paren
id|t.tv_sec
OL
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|expire
op_assign
id|timespec_to_jiffies
c_func
(paren
op_amp
id|t
)paren
op_plus
(paren
id|t.tv_sec
op_logical_or
id|t.tv_nsec
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|expire
op_assign
id|schedule_timeout
c_func
(paren
id|expire
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|expire
)paren
(brace
r_struct
id|restart_block
op_star
id|restart
suffix:semicolon
id|jiffies_to_timespec
c_func
(paren
id|expire
comma
op_amp
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rmtp
op_logical_and
id|copy_to_user
c_func
(paren
id|rmtp
comma
op_amp
id|t
comma
r_sizeof
(paren
id|t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|restart
op_assign
op_amp
id|current_thread_info
c_func
(paren
)paren
op_member_access_from_pointer
id|restart_block
suffix:semicolon
id|restart-&gt;fn
op_assign
id|nanosleep_restart
suffix:semicolon
id|restart-&gt;arg0
op_assign
id|jiffies
op_plus
id|expire
suffix:semicolon
id|restart-&gt;arg1
op_assign
(paren
r_int
r_int
)paren
id|rmtp
suffix:semicolon
id|ret
op_assign
op_minus
id|ERESTART_RESTARTBLOCK
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * sys_sysinfo - fill in sysinfo struct&n; */
DECL|function|sys_sysinfo
id|asmlinkage
r_int
id|sys_sysinfo
c_func
(paren
r_struct
id|sysinfo
id|__user
op_star
id|info
)paren
(brace
r_struct
id|sysinfo
id|val
suffix:semicolon
r_int
r_int
id|mem_total
comma
id|sav_total
suffix:semicolon
r_int
r_int
id|mem_unit
comma
id|bitcount
suffix:semicolon
r_int
r_int
id|seq
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|val
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sysinfo
)paren
)paren
suffix:semicolon
r_do
(brace
r_struct
id|timespec
id|tp
suffix:semicolon
id|seq
op_assign
id|read_seqbegin
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This is annoying.  The below is the same thing&n;&t;&t; * posix_get_clock_monotonic() does, but it wants to&n;&t;&t; * take the lock which we want to cover the loads stuff&n;&t;&t; * too.&n;&t;&t; */
id|getnstimeofday
c_func
(paren
op_amp
id|tp
)paren
suffix:semicolon
id|tp.tv_sec
op_add_assign
id|wall_to_monotonic.tv_sec
suffix:semicolon
id|tp.tv_nsec
op_add_assign
id|wall_to_monotonic.tv_nsec
suffix:semicolon
r_if
c_cond
(paren
id|tp.tv_nsec
op_minus
id|NSEC_PER_SEC
op_ge
l_int|0
)paren
(brace
id|tp.tv_nsec
op_assign
id|tp.tv_nsec
op_minus
id|NSEC_PER_SEC
suffix:semicolon
id|tp.tv_sec
op_increment
suffix:semicolon
)brace
id|val.uptime
op_assign
id|tp.tv_sec
op_plus
(paren
id|tp.tv_nsec
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|val.loads
(braket
l_int|0
)braket
op_assign
id|avenrun
(braket
l_int|0
)braket
op_lshift
(paren
id|SI_LOAD_SHIFT
op_minus
id|FSHIFT
)paren
suffix:semicolon
id|val.loads
(braket
l_int|1
)braket
op_assign
id|avenrun
(braket
l_int|1
)braket
op_lshift
(paren
id|SI_LOAD_SHIFT
op_minus
id|FSHIFT
)paren
suffix:semicolon
id|val.loads
(braket
l_int|2
)braket
op_assign
id|avenrun
(braket
l_int|2
)braket
op_lshift
(paren
id|SI_LOAD_SHIFT
op_minus
id|FSHIFT
)paren
suffix:semicolon
id|val.procs
op_assign
id|nr_threads
suffix:semicolon
)brace
r_while
c_loop
(paren
id|read_seqretry
c_func
(paren
op_amp
id|xtime_lock
comma
id|seq
)paren
)paren
suffix:semicolon
id|si_meminfo
c_func
(paren
op_amp
id|val
)paren
suffix:semicolon
id|si_swapinfo
c_func
(paren
op_amp
id|val
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the sum of all the available memory (i.e. ram + swap)&n;&t; * is less than can be stored in a 32 bit unsigned long then&n;&t; * we can be binary compatible with 2.2.x kernels.  If not,&n;&t; * well, in that case 2.2.x was broken anyways...&n;&t; *&n;&t; *  -Erik Andersen &lt;andersee@debian.org&gt;&n;&t; */
id|mem_total
op_assign
id|val.totalram
op_plus
id|val.totalswap
suffix:semicolon
r_if
c_cond
(paren
id|mem_total
OL
id|val.totalram
op_logical_or
id|mem_total
OL
id|val.totalswap
)paren
r_goto
id|out
suffix:semicolon
id|bitcount
op_assign
l_int|0
suffix:semicolon
id|mem_unit
op_assign
id|val.mem_unit
suffix:semicolon
r_while
c_loop
(paren
id|mem_unit
OG
l_int|1
)paren
(brace
id|bitcount
op_increment
suffix:semicolon
id|mem_unit
op_rshift_assign
l_int|1
suffix:semicolon
id|sav_total
op_assign
id|mem_total
suffix:semicolon
id|mem_total
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|mem_total
OL
id|sav_total
)paren
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If mem_total did not overflow, multiply all memory values by&n;&t; * val.mem_unit and set it to 1.  This leaves things compatible&n;&t; * with 2.2.x, and also retains compatibility with earlier 2.4.x&n;&t; * kernels...&n;&t; */
id|val.mem_unit
op_assign
l_int|1
suffix:semicolon
id|val.totalram
op_lshift_assign
id|bitcount
suffix:semicolon
id|val.freeram
op_lshift_assign
id|bitcount
suffix:semicolon
id|val.sharedram
op_lshift_assign
id|bitcount
suffix:semicolon
id|val.bufferram
op_lshift_assign
id|bitcount
suffix:semicolon
id|val.totalswap
op_lshift_assign
id|bitcount
suffix:semicolon
id|val.freeswap
op_lshift_assign
id|bitcount
suffix:semicolon
id|val.totalhigh
op_lshift_assign
id|bitcount
suffix:semicolon
id|val.freehigh
op_lshift_assign
id|bitcount
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|info
comma
op_amp
id|val
comma
r_sizeof
(paren
r_struct
id|sysinfo
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|init_timers_cpu
r_static
r_void
id|__devinit
id|init_timers_cpu
c_func
(paren
r_int
id|cpu
)paren
(brace
r_int
id|j
suffix:semicolon
id|tvec_base_t
op_star
id|base
suffix:semicolon
id|base
op_assign
op_amp
id|per_cpu
c_func
(paren
id|tvec_bases
comma
id|cpu
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|base-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|TVN_SIZE
suffix:semicolon
id|j
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
id|base-&gt;tv5.vec
op_plus
id|j
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
id|base-&gt;tv4.vec
op_plus
id|j
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
id|base-&gt;tv3.vec
op_plus
id|j
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
id|base-&gt;tv2.vec
op_plus
id|j
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|TVR_SIZE
suffix:semicolon
id|j
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
id|base-&gt;tv1.vec
op_plus
id|j
)paren
suffix:semicolon
id|base-&gt;timer_jiffies
op_assign
id|jiffies
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_HOTPLUG_CPU
DECL|function|migrate_timer_list
r_static
r_int
id|migrate_timer_list
c_func
(paren
id|tvec_base_t
op_star
id|new_base
comma
r_struct
id|list_head
op_star
id|head
)paren
(brace
r_struct
id|timer_list
op_star
id|timer
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|head
)paren
)paren
(brace
id|timer
op_assign
id|list_entry
c_func
(paren
id|head-&gt;next
comma
r_struct
id|timer_list
comma
id|entry
)paren
suffix:semicolon
multiline_comment|/* We&squot;re locking backwards from __mod_timer order here,&n;&t;&t;   beware deadlock. */
r_if
c_cond
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|timer-&gt;lock
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|timer-&gt;entry
)paren
suffix:semicolon
id|internal_add_timer
c_func
(paren
id|new_base
comma
id|timer
)paren
suffix:semicolon
id|timer-&gt;base
op_assign
id|new_base
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|timer-&gt;lock
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|migrate_timers
r_static
r_void
id|__devinit
id|migrate_timers
c_func
(paren
r_int
id|cpu
)paren
(brace
id|tvec_base_t
op_star
id|old_base
suffix:semicolon
id|tvec_base_t
op_star
id|new_base
suffix:semicolon
r_int
id|i
suffix:semicolon
id|BUG_ON
c_func
(paren
id|cpu_online
c_func
(paren
id|cpu
)paren
)paren
suffix:semicolon
id|old_base
op_assign
op_amp
id|per_cpu
c_func
(paren
id|tvec_bases
comma
id|cpu
)paren
suffix:semicolon
id|new_base
op_assign
op_amp
id|get_cpu_var
c_func
(paren
id|tvec_bases
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|again
suffix:colon
multiline_comment|/* Prevent deadlocks via ordering by old_base &lt; new_base. */
r_if
c_cond
(paren
id|old_base
OL
id|new_base
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|new_base-&gt;lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|old_base-&gt;lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|spin_lock
c_func
(paren
op_amp
id|old_base-&gt;lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|new_base-&gt;lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_base-&gt;running_timer
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TVR_SIZE
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|migrate_timer_list
c_func
(paren
id|new_base
comma
id|old_base-&gt;tv1.vec
op_plus
id|i
)paren
)paren
r_goto
id|unlock_again
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TVN_SIZE
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|migrate_timer_list
c_func
(paren
id|new_base
comma
id|old_base-&gt;tv2.vec
op_plus
id|i
)paren
op_logical_or
op_logical_neg
id|migrate_timer_list
c_func
(paren
id|new_base
comma
id|old_base-&gt;tv3.vec
op_plus
id|i
)paren
op_logical_or
op_logical_neg
id|migrate_timer_list
c_func
(paren
id|new_base
comma
id|old_base-&gt;tv4.vec
op_plus
id|i
)paren
op_logical_or
op_logical_neg
id|migrate_timer_list
c_func
(paren
id|new_base
comma
id|old_base-&gt;tv5.vec
op_plus
id|i
)paren
)paren
r_goto
id|unlock_again
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|old_base-&gt;lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|new_base-&gt;lock
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|put_cpu_var
c_func
(paren
id|tvec_bases
)paren
suffix:semicolon
r_return
suffix:semicolon
id|unlock_again
suffix:colon
multiline_comment|/* Avoid deadlock with __mod_timer, by backing off. */
id|spin_unlock
c_func
(paren
op_amp
id|old_base-&gt;lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|new_base-&gt;lock
)paren
suffix:semicolon
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_HOTPLUG_CPU */
DECL|function|timer_cpu_notify
r_static
r_int
id|__devinit
id|timer_cpu_notify
c_func
(paren
r_struct
id|notifier_block
op_star
id|self
comma
r_int
r_int
id|action
comma
r_void
op_star
id|hcpu
)paren
(brace
r_int
id|cpu
op_assign
(paren
r_int
)paren
id|hcpu
suffix:semicolon
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
id|CPU_UP_PREPARE
suffix:colon
id|init_timers_cpu
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_HOTPLUG_CPU
r_case
id|CPU_DEAD
suffix:colon
id|migrate_timers
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|NOTIFY_OK
suffix:semicolon
)brace
DECL|variable|timers_nb
r_static
r_struct
id|notifier_block
id|__devinitdata
id|timers_nb
op_assign
(brace
dot
id|notifier_call
op_assign
id|timer_cpu_notify
comma
)brace
suffix:semicolon
DECL|function|init_timers
r_void
id|__init
id|init_timers
c_func
(paren
r_void
)paren
(brace
id|timer_cpu_notify
c_func
(paren
op_amp
id|timers_nb
comma
(paren
r_int
r_int
)paren
id|CPU_UP_PREPARE
comma
(paren
r_void
op_star
)paren
(paren
r_int
)paren
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|register_cpu_notifier
c_func
(paren
op_amp
id|timers_nb
)paren
suffix:semicolon
id|open_softirq
c_func
(paren
id|TIMER_SOFTIRQ
comma
id|run_timer_softirq
comma
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_TIME_INTERPOLATION
DECL|variable|time_interpolator
r_struct
id|time_interpolator
op_star
id|time_interpolator
suffix:semicolon
DECL|variable|time_interpolator_list
r_static
r_struct
id|time_interpolator
op_star
id|time_interpolator_list
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|time_interpolator_lock
)paren
suffix:semicolon
DECL|function|time_interpolator_get_cycles
r_static
r_inline
id|u64
id|time_interpolator_get_cycles
c_func
(paren
r_int
r_int
id|src
)paren
(brace
r_int
r_int
(paren
op_star
id|x
)paren
(paren
r_void
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|src
)paren
(brace
r_case
id|TIME_SOURCE_FUNCTION
suffix:colon
id|x
op_assign
id|time_interpolator-&gt;addr
suffix:semicolon
r_return
id|x
c_func
(paren
)paren
suffix:semicolon
r_case
id|TIME_SOURCE_MMIO64
suffix:colon
r_return
id|readq
c_func
(paren
id|time_interpolator-&gt;addr
)paren
suffix:semicolon
r_case
id|TIME_SOURCE_MMIO32
suffix:colon
r_return
id|readl
c_func
(paren
id|time_interpolator-&gt;addr
)paren
suffix:semicolon
r_default
suffix:colon
r_return
id|get_cycles
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|time_interpolator_get_counter
r_static
r_inline
id|u64
id|time_interpolator_get_counter
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|src
op_assign
id|time_interpolator-&gt;source
suffix:semicolon
r_if
c_cond
(paren
id|time_interpolator-&gt;jitter
)paren
(brace
id|u64
id|lcycle
suffix:semicolon
id|u64
id|now
suffix:semicolon
r_do
(brace
id|lcycle
op_assign
id|time_interpolator-&gt;last_cycle
suffix:semicolon
id|now
op_assign
id|time_interpolator_get_cycles
c_func
(paren
id|src
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lcycle
op_logical_and
id|time_after
c_func
(paren
id|lcycle
comma
id|now
)paren
)paren
r_return
id|lcycle
suffix:semicolon
multiline_comment|/* Keep track of the last timer value returned. The use of cmpxchg here&n;&t;&t;&t; * will cause contention in an SMP environment.&n;&t;&t;&t; */
)brace
r_while
c_loop
(paren
id|unlikely
c_func
(paren
id|cmpxchg
c_func
(paren
op_amp
id|time_interpolator-&gt;last_cycle
comma
id|lcycle
comma
id|now
)paren
op_ne
id|lcycle
)paren
)paren
suffix:semicolon
r_return
id|now
suffix:semicolon
)brace
r_else
r_return
id|time_interpolator_get_cycles
c_func
(paren
id|src
)paren
suffix:semicolon
)brace
DECL|function|time_interpolator_reset
r_void
id|time_interpolator_reset
c_func
(paren
r_void
)paren
(brace
id|time_interpolator-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|time_interpolator-&gt;last_counter
op_assign
id|time_interpolator_get_counter
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|macro|GET_TI_NSECS
mdefine_line|#define GET_TI_NSECS(count,i) (((((count) - i-&gt;last_counter) &amp; (i)-&gt;mask) * (i)-&gt;nsec_per_cyc) &gt;&gt; (i)-&gt;shift)
DECL|function|time_interpolator_get_offset
r_int
r_int
id|time_interpolator_get_offset
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* If we do not have a time interpolator set up then just return zero */
r_if
c_cond
(paren
op_logical_neg
id|time_interpolator
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|time_interpolator-&gt;offset
op_plus
id|GET_TI_NSECS
c_func
(paren
id|time_interpolator_get_counter
c_func
(paren
)paren
comma
id|time_interpolator
)paren
suffix:semicolon
)brace
DECL|macro|INTERPOLATOR_ADJUST
mdefine_line|#define INTERPOLATOR_ADJUST 65536
DECL|macro|INTERPOLATOR_MAX_SKIP
mdefine_line|#define INTERPOLATOR_MAX_SKIP 10*INTERPOLATOR_ADJUST
DECL|function|time_interpolator_update
r_static
r_void
id|time_interpolator_update
c_func
(paren
r_int
id|delta_nsec
)paren
(brace
id|u64
id|counter
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
multiline_comment|/* If there is no time interpolator set up then do nothing */
r_if
c_cond
(paren
op_logical_neg
id|time_interpolator
)paren
r_return
suffix:semicolon
multiline_comment|/* The interpolator compensates for late ticks by accumulating&n;         * the late time in time_interpolator-&gt;offset. A tick earlier than&n;&t; * expected will lead to a reset of the offset and a corresponding&n;&t; * jump of the clock forward. Again this only works if the&n;&t; * interpolator clock is running slightly slower than the regular clock&n;&t; * and the tuning logic insures that.&n;         */
id|counter
op_assign
id|time_interpolator_get_counter
c_func
(paren
)paren
suffix:semicolon
id|offset
op_assign
id|time_interpolator-&gt;offset
op_plus
id|GET_TI_NSECS
c_func
(paren
id|counter
comma
id|time_interpolator
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta_nsec
OL
l_int|0
op_logical_or
(paren
r_int
r_int
)paren
id|delta_nsec
OL
id|offset
)paren
id|time_interpolator-&gt;offset
op_assign
id|offset
op_minus
id|delta_nsec
suffix:semicolon
r_else
(brace
id|time_interpolator-&gt;skips
op_increment
suffix:semicolon
id|time_interpolator-&gt;ns_skipped
op_add_assign
id|delta_nsec
op_minus
id|offset
suffix:semicolon
id|time_interpolator-&gt;offset
op_assign
l_int|0
suffix:semicolon
)brace
id|time_interpolator-&gt;last_counter
op_assign
id|counter
suffix:semicolon
multiline_comment|/* Tuning logic for time interpolator invoked every minute or so.&n;&t; * Decrease interpolator clock speed if no skips occurred and an offset is carried.&n;&t; * Increase interpolator clock speed if we skip too much time.&n;&t; */
r_if
c_cond
(paren
id|jiffies
op_mod
id|INTERPOLATOR_ADJUST
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|time_interpolator-&gt;skips
op_eq
l_int|0
op_logical_and
id|time_interpolator-&gt;offset
OG
id|TICK_NSEC
)paren
id|time_interpolator-&gt;nsec_per_cyc
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|time_interpolator-&gt;ns_skipped
OG
id|INTERPOLATOR_MAX_SKIP
op_logical_and
id|time_interpolator-&gt;offset
op_eq
l_int|0
)paren
id|time_interpolator-&gt;nsec_per_cyc
op_increment
suffix:semicolon
id|time_interpolator-&gt;skips
op_assign
l_int|0
suffix:semicolon
id|time_interpolator-&gt;ns_skipped
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_static
r_inline
r_int
DECL|function|is_better_time_interpolator
id|is_better_time_interpolator
c_func
(paren
r_struct
id|time_interpolator
op_star
r_new
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|time_interpolator
)paren
r_return
l_int|1
suffix:semicolon
r_return
r_new
op_member_access_from_pointer
id|frequency
OG
l_int|2
op_star
id|time_interpolator-&gt;frequency
op_logical_or
(paren
r_int
r_int
)paren
r_new
op_member_access_from_pointer
id|drift
OL
(paren
r_int
r_int
)paren
id|time_interpolator-&gt;drift
suffix:semicolon
)brace
r_void
DECL|function|register_time_interpolator
id|register_time_interpolator
c_func
(paren
r_struct
id|time_interpolator
op_star
id|ti
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Sanity check */
r_if
c_cond
(paren
id|ti-&gt;frequency
op_eq
l_int|0
op_logical_or
id|ti-&gt;mask
op_eq
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|ti-&gt;nsec_per_cyc
op_assign
(paren
(paren
id|u64
)paren
id|NSEC_PER_SEC
op_lshift
id|ti-&gt;shift
)paren
op_div
id|ti-&gt;frequency
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|time_interpolator_lock
)paren
suffix:semicolon
id|write_seqlock_irqsave
c_func
(paren
op_amp
id|xtime_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_better_time_interpolator
c_func
(paren
id|ti
)paren
)paren
(brace
id|time_interpolator
op_assign
id|ti
suffix:semicolon
id|time_interpolator_reset
c_func
(paren
)paren
suffix:semicolon
)brace
id|write_sequnlock_irqrestore
c_func
(paren
op_amp
id|xtime_lock
comma
id|flags
)paren
suffix:semicolon
id|ti-&gt;next
op_assign
id|time_interpolator_list
suffix:semicolon
id|time_interpolator_list
op_assign
id|ti
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|time_interpolator_lock
)paren
suffix:semicolon
)brace
r_void
DECL|function|unregister_time_interpolator
id|unregister_time_interpolator
c_func
(paren
r_struct
id|time_interpolator
op_star
id|ti
)paren
(brace
r_struct
id|time_interpolator
op_star
id|curr
comma
op_star
op_star
id|prev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|time_interpolator_lock
)paren
suffix:semicolon
id|prev
op_assign
op_amp
id|time_interpolator_list
suffix:semicolon
r_for
c_loop
(paren
id|curr
op_assign
op_star
id|prev
suffix:semicolon
id|curr
suffix:semicolon
id|curr
op_assign
id|curr-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|curr
op_eq
id|ti
)paren
(brace
op_star
id|prev
op_assign
id|curr-&gt;next
suffix:semicolon
r_break
suffix:semicolon
)brace
id|prev
op_assign
op_amp
id|curr-&gt;next
suffix:semicolon
)brace
id|write_seqlock_irqsave
c_func
(paren
op_amp
id|xtime_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ti
op_eq
id|time_interpolator
)paren
(brace
multiline_comment|/* we lost the best time-interpolator: */
id|time_interpolator
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* find the next-best interpolator */
r_for
c_loop
(paren
id|curr
op_assign
id|time_interpolator_list
suffix:semicolon
id|curr
suffix:semicolon
id|curr
op_assign
id|curr-&gt;next
)paren
r_if
c_cond
(paren
id|is_better_time_interpolator
c_func
(paren
id|curr
)paren
)paren
id|time_interpolator
op_assign
id|curr
suffix:semicolon
id|time_interpolator_reset
c_func
(paren
)paren
suffix:semicolon
)brace
id|write_sequnlock_irqrestore
c_func
(paren
op_amp
id|xtime_lock
comma
id|flags
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|time_interpolator_lock
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_TIME_INTERPOLATION */
multiline_comment|/**&n; * msleep - sleep safely even with waitqueue interruptions&n; * @msecs: Time in milliseconds to sleep for&n; */
DECL|function|msleep
r_void
id|msleep
c_func
(paren
r_int
r_int
id|msecs
)paren
(brace
r_int
r_int
id|timeout
op_assign
id|msecs_to_jiffies
c_func
(paren
id|msecs
)paren
op_plus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|timeout
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|timeout
op_assign
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
)brace
)brace
DECL|variable|msleep
id|EXPORT_SYMBOL
c_func
(paren
id|msleep
)paren
suffix:semicolon
multiline_comment|/**&n; * msleep_interruptible - sleep waiting for waitqueue interruptions&n; * @msecs: Time in milliseconds to sleep for&n; */
DECL|function|msleep_interruptible
r_int
r_int
id|msleep_interruptible
c_func
(paren
r_int
r_int
id|msecs
)paren
(brace
r_int
r_int
id|timeout
op_assign
id|msecs_to_jiffies
c_func
(paren
id|msecs
)paren
op_plus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|timeout
op_logical_and
op_logical_neg
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|timeout
op_assign
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
)brace
r_return
id|jiffies_to_msecs
c_func
(paren
id|timeout
)paren
suffix:semicolon
)brace
DECL|variable|msleep_interruptible
id|EXPORT_SYMBOL
c_func
(paren
id|msleep_interruptible
)paren
suffix:semicolon
eof
