multiline_comment|/* auditsc.c -- System-call auditing support -*- linux-c -*-&n; * Handles all system-call specific auditing features.&n; *&n; * Copyright 2003-2004 Red Hat Inc., Durham, North Carolina.&n; * All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; *&n; * Written by Rickard E. (Rik) Faith &lt;faith@redhat.com&gt;&n; *&n; * Many of the ideas implemented here are from Stephen C. Tweedie,&n; * especially the idea of avoiding a copy by using getname.&n; *&n; * The method for actual interception of syscall entry and exit (not in&n; * this file -- see entry.S) is based on a GPL&squot;d patch written by&n; * okir@suse.de and Copyright 2003 SuSE Linux AG.&n; *&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/types.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/audit.h&gt;
macro_line|#include &lt;linux/personality.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;asm/unistd.h&gt;
multiline_comment|/* 0 = no checking&n;   1 = put_count checking&n;   2 = verbose put_count checking&n;*/
DECL|macro|AUDIT_DEBUG
mdefine_line|#define AUDIT_DEBUG 0
multiline_comment|/* No syscall auditing will take place unless audit_enabled != 0. */
r_extern
r_int
id|audit_enabled
suffix:semicolon
multiline_comment|/* AUDIT_NAMES is the number of slots we reserve in the audit_context&n; * for saving names from getname(). */
DECL|macro|AUDIT_NAMES
mdefine_line|#define AUDIT_NAMES    20
multiline_comment|/* AUDIT_NAMES_RESERVED is the number of slots we reserve in the&n; * audit_context from being used for nameless inodes from&n; * path_lookup. */
DECL|macro|AUDIT_NAMES_RESERVED
mdefine_line|#define AUDIT_NAMES_RESERVED 7
multiline_comment|/* At task start time, the audit_state is set in the audit_context using&n;   a per-task filter.  At syscall entry, the audit_state is augmented by&n;   the syscall filter. */
DECL|enum|audit_state
r_enum
id|audit_state
(brace
DECL|enumerator|AUDIT_DISABLED
id|AUDIT_DISABLED
comma
multiline_comment|/* Do not create per-task audit_context.&n;&t;&t;&t;&t; * No syscall-specific audit records can&n;&t;&t;&t;&t; * be generated. */
DECL|enumerator|AUDIT_SETUP_CONTEXT
id|AUDIT_SETUP_CONTEXT
comma
multiline_comment|/* Create the per-task audit_context,&n;&t;&t;&t;&t; * but don&squot;t necessarily fill it in at&n;&t;&t;&t;&t; * syscall entry time (i.e., filter&n;&t;&t;&t;&t; * instead). */
DECL|enumerator|AUDIT_BUILD_CONTEXT
id|AUDIT_BUILD_CONTEXT
comma
multiline_comment|/* Create the per-task audit_context,&n;&t;&t;&t;&t; * and always fill it in at syscall&n;&t;&t;&t;&t; * entry time.  This makes a full&n;&t;&t;&t;&t; * syscall record available if some&n;&t;&t;&t;&t; * other part of the kernel decides it&n;&t;&t;&t;&t; * should be recorded. */
DECL|enumerator|AUDIT_RECORD_CONTEXT
id|AUDIT_RECORD_CONTEXT
multiline_comment|/* Create the per-task audit_context,&n;&t;&t;&t;&t; * always fill it in at syscall entry&n;&t;&t;&t;&t; * time, and always write out the audit&n;&t;&t;&t;&t; * record at syscall exit time.  */
)brace
suffix:semicolon
multiline_comment|/* When fs/namei.c:getname() is called, we store the pointer in name and&n; * we don&squot;t let putname() free it (instead we free all of the saved&n; * pointers at syscall exit time).&n; *&n; * Further, in fs/namei.c:path_lookup() we store the inode and device. */
DECL|struct|audit_names
r_struct
id|audit_names
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|ino
r_int
r_int
id|ino
suffix:semicolon
DECL|member|rdev
id|dev_t
id|rdev
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* The per-task audit context. */
DECL|struct|audit_context
r_struct
id|audit_context
(brace
DECL|member|in_syscall
r_int
id|in_syscall
suffix:semicolon
multiline_comment|/* 1 if task is in a syscall */
DECL|member|state
r_enum
id|audit_state
id|state
suffix:semicolon
DECL|member|serial
r_int
r_int
id|serial
suffix:semicolon
multiline_comment|/* serial number for record */
DECL|member|ctime
r_struct
id|timespec
id|ctime
suffix:semicolon
multiline_comment|/* time of syscall entry */
DECL|member|loginuid
id|uid_t
id|loginuid
suffix:semicolon
multiline_comment|/* login uid (identity) */
DECL|member|major
r_int
id|major
suffix:semicolon
multiline_comment|/* syscall number */
DECL|member|argv
r_int
r_int
id|argv
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* syscall arguments */
DECL|member|return_valid
r_int
id|return_valid
suffix:semicolon
multiline_comment|/* return code is valid */
DECL|member|return_code
r_int
id|return_code
suffix:semicolon
multiline_comment|/* syscall return code */
DECL|member|auditable
r_int
id|auditable
suffix:semicolon
multiline_comment|/* 1 if record should be written */
DECL|member|name_count
r_int
id|name_count
suffix:semicolon
DECL|member|names
r_struct
id|audit_names
id|names
(braket
id|AUDIT_NAMES
)braket
suffix:semicolon
DECL|member|previous
r_struct
id|audit_context
op_star
id|previous
suffix:semicolon
multiline_comment|/* For nested syscalls */
multiline_comment|/* Save things to print about task_struct */
DECL|member|pid
id|pid_t
id|pid
suffix:semicolon
DECL|member|uid
DECL|member|euid
DECL|member|suid
DECL|member|fsuid
id|uid_t
id|uid
comma
id|euid
comma
id|suid
comma
id|fsuid
suffix:semicolon
DECL|member|gid
DECL|member|egid
DECL|member|sgid
DECL|member|fsgid
id|gid_t
id|gid
comma
id|egid
comma
id|sgid
comma
id|fsgid
suffix:semicolon
DECL|member|personality
r_int
r_int
id|personality
suffix:semicolon
macro_line|#if AUDIT_DEBUG
DECL|member|put_count
r_int
id|put_count
suffix:semicolon
DECL|member|ino_count
r_int
id|ino_count
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/* Public API */
multiline_comment|/* There are three lists of rules -- one to search at task creation&n; * time, one to search at syscall entry time, and another to search at&n; * syscall exit time. */
r_static
id|LIST_HEAD
c_func
(paren
id|audit_tsklist
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|audit_entlist
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|audit_extlist
)paren
suffix:semicolon
DECL|struct|audit_entry
r_struct
id|audit_entry
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|rcu
r_struct
id|rcu_head
id|rcu
suffix:semicolon
DECL|member|rule
r_struct
id|audit_rule
id|rule
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Check to see if two rules are identical.  It is called from&n; * audit_del_rule during AUDIT_DEL. */
DECL|function|audit_compare_rule
r_static
r_int
id|audit_compare_rule
c_func
(paren
r_struct
id|audit_rule
op_star
id|a
comma
r_struct
id|audit_rule
op_star
id|b
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;flags
op_ne
id|b-&gt;flags
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;action
op_ne
id|b-&gt;action
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;field_count
op_ne
id|b-&gt;field_count
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|a-&gt;field_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|a-&gt;fields
(braket
id|i
)braket
op_ne
id|b-&gt;fields
(braket
id|i
)braket
op_logical_or
id|a-&gt;values
(braket
id|i
)braket
op_ne
id|b-&gt;values
(braket
id|i
)braket
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AUDIT_BITMASK_SIZE
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|a-&gt;mask
(braket
id|i
)braket
op_ne
id|b-&gt;mask
(braket
id|i
)braket
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Note that audit_add_rule and audit_del_rule are called via&n; * audit_receive() in audit.c, and are protected by&n; * audit_netlink_sem. */
DECL|function|audit_add_rule
r_static
r_inline
r_int
id|audit_add_rule
c_func
(paren
r_struct
id|audit_entry
op_star
id|entry
comma
r_struct
id|list_head
op_star
id|list
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;rule.flags
op_amp
id|AUDIT_PREPEND
)paren
(brace
id|entry-&gt;rule.flags
op_and_assign
op_complement
id|AUDIT_PREPEND
suffix:semicolon
id|list_add_rcu
c_func
(paren
op_amp
id|entry-&gt;list
comma
id|list
)paren
suffix:semicolon
)brace
r_else
(brace
id|list_add_tail_rcu
c_func
(paren
op_amp
id|entry-&gt;list
comma
id|list
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|audit_free_rule
r_static
r_void
id|audit_free_rule
c_func
(paren
r_struct
id|rcu_head
op_star
id|head
)paren
(brace
r_struct
id|audit_entry
op_star
id|e
op_assign
id|container_of
c_func
(paren
id|head
comma
r_struct
id|audit_entry
comma
id|rcu
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|e
)paren
suffix:semicolon
)brace
multiline_comment|/* Note that audit_add_rule and audit_del_rule are called via&n; * audit_receive() in audit.c, and are protected by&n; * audit_netlink_sem. */
DECL|function|audit_del_rule
r_static
r_inline
r_int
id|audit_del_rule
c_func
(paren
r_struct
id|audit_rule
op_star
id|rule
comma
r_struct
id|list_head
op_star
id|list
)paren
(brace
r_struct
id|audit_entry
op_star
id|e
suffix:semicolon
multiline_comment|/* Do not use the _rcu iterator here, since this is the only&n;&t; * deletion routine. */
id|list_for_each_entry
c_func
(paren
id|e
comma
id|list
comma
id|list
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|audit_compare_rule
c_func
(paren
id|rule
comma
op_amp
id|e-&gt;rule
)paren
)paren
(brace
id|list_del_rcu
c_func
(paren
op_amp
id|e-&gt;list
)paren
suffix:semicolon
id|call_rcu
c_func
(paren
op_amp
id|e-&gt;rcu
comma
id|audit_free_rule
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* No matching rule */
)brace
macro_line|#ifdef CONFIG_NET
multiline_comment|/* Copy rule from user-space to kernel-space.  Called during&n; * AUDIT_ADD. */
DECL|function|audit_copy_rule
r_static
r_int
id|audit_copy_rule
c_func
(paren
r_struct
id|audit_rule
op_star
id|d
comma
r_struct
id|audit_rule
op_star
id|s
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;action
op_ne
id|AUDIT_NEVER
op_logical_and
id|s-&gt;action
op_ne
id|AUDIT_POSSIBLE
op_logical_and
id|s-&gt;action
op_ne
id|AUDIT_ALWAYS
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;field_count
template_param
id|AUDIT_MAX_FIELDS
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|d-&gt;flags
op_assign
id|s-&gt;flags
suffix:semicolon
id|d-&gt;action
op_assign
id|s-&gt;action
suffix:semicolon
id|d-&gt;field_count
op_assign
id|s-&gt;field_count
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|d-&gt;field_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|d-&gt;fields
(braket
id|i
)braket
op_assign
id|s-&gt;fields
(braket
id|i
)braket
suffix:semicolon
id|d-&gt;values
(braket
id|i
)braket
op_assign
id|s-&gt;values
(braket
id|i
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AUDIT_BITMASK_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|d-&gt;mask
(braket
id|i
)braket
op_assign
id|s-&gt;mask
(braket
id|i
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|audit_receive_filter
r_int
id|audit_receive_filter
c_func
(paren
r_int
id|type
comma
r_int
id|pid
comma
r_int
id|uid
comma
r_int
id|seq
comma
r_void
op_star
id|data
)paren
(brace
id|u32
id|flags
suffix:semicolon
r_struct
id|audit_entry
op_star
id|entry
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|AUDIT_LIST
suffix:colon
multiline_comment|/* The *_rcu iterators not needed here because we are&n;&t;&t;   always called with audit_netlink_sem held. */
id|list_for_each_entry
c_func
(paren
id|entry
comma
op_amp
id|audit_tsklist
comma
id|list
)paren
id|audit_send_reply
c_func
(paren
id|pid
comma
id|seq
comma
id|AUDIT_LIST
comma
l_int|0
comma
l_int|1
comma
op_amp
id|entry-&gt;rule
comma
r_sizeof
(paren
id|entry-&gt;rule
)paren
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|entry
comma
op_amp
id|audit_entlist
comma
id|list
)paren
id|audit_send_reply
c_func
(paren
id|pid
comma
id|seq
comma
id|AUDIT_LIST
comma
l_int|0
comma
l_int|1
comma
op_amp
id|entry-&gt;rule
comma
r_sizeof
(paren
id|entry-&gt;rule
)paren
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|entry
comma
op_amp
id|audit_extlist
comma
id|list
)paren
id|audit_send_reply
c_func
(paren
id|pid
comma
id|seq
comma
id|AUDIT_LIST
comma
l_int|0
comma
l_int|1
comma
op_amp
id|entry-&gt;rule
comma
r_sizeof
(paren
id|entry-&gt;rule
)paren
)paren
suffix:semicolon
id|audit_send_reply
c_func
(paren
id|pid
comma
id|seq
comma
id|AUDIT_LIST
comma
l_int|1
comma
l_int|1
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_ADD
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|entry
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|audit_copy_rule
c_func
(paren
op_amp
id|entry-&gt;rule
comma
id|data
)paren
)paren
(brace
id|kfree
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|flags
op_assign
id|entry-&gt;rule.flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
(paren
id|flags
op_amp
id|AUDIT_PER_TASK
)paren
)paren
id|err
op_assign
id|audit_add_rule
c_func
(paren
id|entry
comma
op_amp
id|audit_tsklist
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
(paren
id|flags
op_amp
id|AUDIT_AT_ENTRY
)paren
)paren
id|err
op_assign
id|audit_add_rule
c_func
(paren
id|entry
comma
op_amp
id|audit_entlist
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
(paren
id|flags
op_amp
id|AUDIT_AT_EXIT
)paren
)paren
id|err
op_assign
id|audit_add_rule
c_func
(paren
id|entry
comma
op_amp
id|audit_extlist
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_DEL
suffix:colon
id|flags
op_assign
(paren
(paren
r_struct
id|audit_rule
op_star
)paren
id|data
)paren
op_member_access_from_pointer
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
(paren
id|flags
op_amp
id|AUDIT_PER_TASK
)paren
)paren
id|err
op_assign
id|audit_del_rule
c_func
(paren
id|data
comma
op_amp
id|audit_tsklist
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
(paren
id|flags
op_amp
id|AUDIT_AT_ENTRY
)paren
)paren
id|err
op_assign
id|audit_del_rule
c_func
(paren
id|data
comma
op_amp
id|audit_entlist
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
(paren
id|flags
op_amp
id|AUDIT_AT_EXIT
)paren
)paren
id|err
op_assign
id|audit_del_rule
c_func
(paren
id|data
comma
op_amp
id|audit_extlist
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Compare a task_struct with an audit_rule.  Return 1 on match, 0&n; * otherwise. */
DECL|function|audit_filter_rules
r_static
r_int
id|audit_filter_rules
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_struct
id|audit_rule
op_star
id|rule
comma
r_struct
id|audit_context
op_star
id|ctx
comma
r_enum
id|audit_state
op_star
id|state
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|rule-&gt;field_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|u32
id|field
op_assign
id|rule-&gt;fields
(braket
id|i
)braket
op_amp
op_complement
id|AUDIT_NEGATE
suffix:semicolon
id|u32
id|value
op_assign
id|rule-&gt;values
(braket
id|i
)braket
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|field
)paren
(brace
r_case
id|AUDIT_PID
suffix:colon
id|result
op_assign
(paren
id|tsk-&gt;pid
op_eq
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_UID
suffix:colon
id|result
op_assign
(paren
id|tsk-&gt;uid
op_eq
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_EUID
suffix:colon
id|result
op_assign
(paren
id|tsk-&gt;euid
op_eq
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_SUID
suffix:colon
id|result
op_assign
(paren
id|tsk-&gt;suid
op_eq
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_FSUID
suffix:colon
id|result
op_assign
(paren
id|tsk-&gt;fsuid
op_eq
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_GID
suffix:colon
id|result
op_assign
(paren
id|tsk-&gt;gid
op_eq
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_EGID
suffix:colon
id|result
op_assign
(paren
id|tsk-&gt;egid
op_eq
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_SGID
suffix:colon
id|result
op_assign
(paren
id|tsk-&gt;sgid
op_eq
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_FSGID
suffix:colon
id|result
op_assign
(paren
id|tsk-&gt;fsgid
op_eq
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_PERS
suffix:colon
id|result
op_assign
(paren
id|tsk-&gt;personality
op_eq
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_EXIT
suffix:colon
r_if
c_cond
(paren
id|ctx
op_logical_and
id|ctx-&gt;return_valid
)paren
id|result
op_assign
(paren
id|ctx-&gt;return_code
op_eq
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_SUCCESS
suffix:colon
r_if
c_cond
(paren
id|ctx
op_logical_and
id|ctx-&gt;return_valid
)paren
id|result
op_assign
(paren
id|ctx-&gt;return_code
op_ge
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_DEVMAJOR
suffix:colon
r_if
c_cond
(paren
id|ctx
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ctx-&gt;name_count
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|ctx-&gt;names
(braket
id|j
)braket
dot
id|rdev
)paren
op_eq
id|value
)paren
(brace
op_increment
id|result
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_break
suffix:semicolon
r_case
id|AUDIT_DEVMINOR
suffix:colon
r_if
c_cond
(paren
id|ctx
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ctx-&gt;name_count
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|MINOR
c_func
(paren
id|ctx-&gt;names
(braket
id|j
)braket
dot
id|rdev
)paren
op_eq
id|value
)paren
(brace
op_increment
id|result
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_break
suffix:semicolon
r_case
id|AUDIT_INODE
suffix:colon
r_if
c_cond
(paren
id|ctx
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ctx-&gt;name_count
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|MINOR
c_func
(paren
id|ctx-&gt;names
(braket
id|j
)braket
dot
id|ino
)paren
op_eq
id|value
)paren
(brace
op_increment
id|result
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_break
suffix:semicolon
r_case
id|AUDIT_LOGINUID
suffix:colon
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ctx
)paren
id|result
op_assign
(paren
id|ctx-&gt;loginuid
op_eq
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_ARG0
suffix:colon
r_case
id|AUDIT_ARG1
suffix:colon
r_case
id|AUDIT_ARG2
suffix:colon
r_case
id|AUDIT_ARG3
suffix:colon
r_if
c_cond
(paren
id|ctx
)paren
id|result
op_assign
(paren
id|ctx-&gt;argv
(braket
id|field
op_minus
id|AUDIT_ARG0
)braket
op_eq
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rule-&gt;fields
(braket
id|i
)braket
op_amp
id|AUDIT_NEGATE
)paren
id|result
op_assign
op_logical_neg
id|result
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|rule-&gt;action
)paren
(brace
r_case
id|AUDIT_NEVER
suffix:colon
op_star
id|state
op_assign
id|AUDIT_DISABLED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_POSSIBLE
suffix:colon
op_star
id|state
op_assign
id|AUDIT_BUILD_CONTEXT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIT_ALWAYS
suffix:colon
op_star
id|state
op_assign
id|AUDIT_RECORD_CONTEXT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* At process creation time, we can determine if system-call auditing is&n; * completely disabled for this task.  Since we only have the task&n; * structure at this point, we can only check uid and gid.&n; */
DECL|function|audit_filter_task
r_static
r_enum
id|audit_state
id|audit_filter_task
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_struct
id|audit_entry
op_star
id|e
suffix:semicolon
r_enum
id|audit_state
id|state
suffix:semicolon
id|rcu_read_lock
c_func
(paren
)paren
suffix:semicolon
id|list_for_each_entry_rcu
c_func
(paren
id|e
comma
op_amp
id|audit_tsklist
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|audit_filter_rules
c_func
(paren
id|tsk
comma
op_amp
id|e-&gt;rule
comma
l_int|NULL
comma
op_amp
id|state
)paren
)paren
(brace
id|rcu_read_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|state
suffix:semicolon
)brace
)brace
id|rcu_read_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|AUDIT_BUILD_CONTEXT
suffix:semicolon
)brace
multiline_comment|/* At syscall entry and exit time, this filter is called if the&n; * audit_state is not low enough that auditing cannot take place, but is&n; * also not high enough that we already know we have to write and audit&n; * record (i.e., the state is AUDIT_SETUP_CONTEXT or  AUDIT_BUILD_CONTEXT).&n; */
DECL|function|audit_filter_syscall
r_static
r_enum
id|audit_state
id|audit_filter_syscall
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_struct
id|audit_context
op_star
id|ctx
comma
r_struct
id|list_head
op_star
id|list
)paren
(brace
r_struct
id|audit_entry
op_star
id|e
suffix:semicolon
r_enum
id|audit_state
id|state
suffix:semicolon
r_int
id|word
op_assign
id|AUDIT_WORD
c_func
(paren
id|ctx-&gt;major
)paren
suffix:semicolon
r_int
id|bit
op_assign
id|AUDIT_BIT
c_func
(paren
id|ctx-&gt;major
)paren
suffix:semicolon
id|rcu_read_lock
c_func
(paren
)paren
suffix:semicolon
id|list_for_each_entry_rcu
c_func
(paren
id|e
comma
id|list
comma
id|list
)paren
(brace
r_if
c_cond
(paren
(paren
id|e-&gt;rule.mask
(braket
id|word
)braket
op_amp
id|bit
)paren
op_eq
id|bit
op_logical_and
id|audit_filter_rules
c_func
(paren
id|tsk
comma
op_amp
id|e-&gt;rule
comma
id|ctx
comma
op_amp
id|state
)paren
)paren
(brace
id|rcu_read_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|state
suffix:semicolon
)brace
)brace
id|rcu_read_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
id|AUDIT_BUILD_CONTEXT
suffix:semicolon
)brace
multiline_comment|/* This should be called with task_lock() held. */
DECL|function|audit_get_context
r_static
r_inline
r_struct
id|audit_context
op_star
id|audit_get_context
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
id|return_valid
comma
r_int
id|return_code
)paren
(brace
r_struct
id|audit_context
op_star
id|context
op_assign
id|tsk-&gt;audit_context
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|context
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|context-&gt;return_valid
op_assign
id|return_valid
suffix:semicolon
id|context-&gt;return_code
op_assign
id|return_code
suffix:semicolon
r_if
c_cond
(paren
id|context-&gt;in_syscall
op_logical_and
op_logical_neg
id|context-&gt;auditable
)paren
(brace
r_enum
id|audit_state
id|state
suffix:semicolon
id|state
op_assign
id|audit_filter_syscall
c_func
(paren
id|tsk
comma
id|context
comma
op_amp
id|audit_extlist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
id|AUDIT_RECORD_CONTEXT
)paren
id|context-&gt;auditable
op_assign
l_int|1
suffix:semicolon
)brace
id|context-&gt;pid
op_assign
id|tsk-&gt;pid
suffix:semicolon
id|context-&gt;uid
op_assign
id|tsk-&gt;uid
suffix:semicolon
id|context-&gt;gid
op_assign
id|tsk-&gt;gid
suffix:semicolon
id|context-&gt;euid
op_assign
id|tsk-&gt;euid
suffix:semicolon
id|context-&gt;suid
op_assign
id|tsk-&gt;suid
suffix:semicolon
id|context-&gt;fsuid
op_assign
id|tsk-&gt;fsuid
suffix:semicolon
id|context-&gt;egid
op_assign
id|tsk-&gt;egid
suffix:semicolon
id|context-&gt;sgid
op_assign
id|tsk-&gt;sgid
suffix:semicolon
id|context-&gt;fsgid
op_assign
id|tsk-&gt;fsgid
suffix:semicolon
id|context-&gt;personality
op_assign
id|tsk-&gt;personality
suffix:semicolon
id|tsk-&gt;audit_context
op_assign
l_int|NULL
suffix:semicolon
r_return
id|context
suffix:semicolon
)brace
DECL|function|audit_free_names
r_static
r_inline
r_void
id|audit_free_names
c_func
(paren
r_struct
id|audit_context
op_star
id|context
)paren
(brace
r_int
id|i
suffix:semicolon
macro_line|#if AUDIT_DEBUG == 2
r_if
c_cond
(paren
id|context-&gt;auditable
op_logical_or
id|context-&gt;put_count
op_plus
id|context-&gt;ino_count
op_ne
id|context-&gt;name_count
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;audit.c:%d(:%d): major=%d in_syscall=%d&quot;
l_string|&quot; name_count=%d put_count=%d&quot;
l_string|&quot; ino_count=%d [NOT freeing]&bslash;n&quot;
comma
id|__LINE__
comma
id|context-&gt;serial
comma
id|context-&gt;major
comma
id|context-&gt;in_syscall
comma
id|context-&gt;name_count
comma
id|context-&gt;put_count
comma
id|context-&gt;ino_count
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|context-&gt;name_count
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;names[%d] = %p = %s&bslash;n&quot;
comma
id|i
comma
id|context-&gt;names
(braket
id|i
)braket
dot
id|name
comma
id|context-&gt;names
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|dump_stack
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if AUDIT_DEBUG
id|context-&gt;put_count
op_assign
l_int|0
suffix:semicolon
id|context-&gt;ino_count
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|context-&gt;name_count
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|context-&gt;names
(braket
id|i
)braket
dot
id|name
)paren
id|__putname
c_func
(paren
id|context-&gt;names
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|context-&gt;name_count
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|audit_zero_context
r_static
r_inline
r_void
id|audit_zero_context
c_func
(paren
r_struct
id|audit_context
op_star
id|context
comma
r_enum
id|audit_state
id|state
)paren
(brace
id|uid_t
id|loginuid
op_assign
id|context-&gt;loginuid
suffix:semicolon
id|memset
c_func
(paren
id|context
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|context
)paren
)paren
suffix:semicolon
id|context-&gt;state
op_assign
id|state
suffix:semicolon
id|context-&gt;loginuid
op_assign
id|loginuid
suffix:semicolon
)brace
DECL|function|audit_alloc_context
r_static
r_inline
r_struct
id|audit_context
op_star
id|audit_alloc_context
c_func
(paren
r_enum
id|audit_state
id|state
)paren
(brace
r_struct
id|audit_context
op_star
id|context
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|context
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|context
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|audit_zero_context
c_func
(paren
id|context
comma
id|state
)paren
suffix:semicolon
r_return
id|context
suffix:semicolon
)brace
multiline_comment|/* Filter on the task information and allocate a per-task audit context&n; * if necessary.  Doing so turns on system call auditing for the&n; * specified task.  This is called from copy_process, so no lock is&n; * needed. */
DECL|function|audit_alloc
r_int
id|audit_alloc
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_struct
id|audit_context
op_star
id|context
suffix:semicolon
r_enum
id|audit_state
id|state
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|audit_enabled
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Return if not auditing. */
id|state
op_assign
id|audit_filter_task
c_func
(paren
id|tsk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|state
op_eq
id|AUDIT_DISABLED
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|context
op_assign
id|audit_alloc_context
c_func
(paren
id|state
)paren
)paren
)paren
(brace
id|audit_log_lost
c_func
(paren
l_string|&quot;out of memory in audit_alloc&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Preserve login uid */
id|context-&gt;loginuid
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|tsk-&gt;audit_context
)paren
id|context-&gt;loginuid
op_assign
id|tsk-&gt;audit_context-&gt;loginuid
suffix:semicolon
id|tsk-&gt;audit_context
op_assign
id|context
suffix:semicolon
id|set_tsk_thread_flag
c_func
(paren
id|tsk
comma
id|TIF_SYSCALL_AUDIT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|audit_free_context
r_static
r_inline
r_void
id|audit_free_context
c_func
(paren
r_struct
id|audit_context
op_star
id|context
)paren
(brace
r_struct
id|audit_context
op_star
id|previous
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|previous
op_assign
id|context-&gt;previous
suffix:semicolon
r_if
c_cond
(paren
id|previous
op_logical_or
(paren
id|count
op_logical_and
id|count
OL
l_int|10
)paren
)paren
(brace
op_increment
id|count
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;audit(:%d): major=%d name_count=%d:&quot;
l_string|&quot; freeing multiple contexts (%d)&bslash;n&quot;
comma
id|context-&gt;serial
comma
id|context-&gt;major
comma
id|context-&gt;name_count
comma
id|count
)paren
suffix:semicolon
)brace
id|audit_free_names
c_func
(paren
id|context
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|context
)paren
suffix:semicolon
id|context
op_assign
id|previous
suffix:semicolon
)brace
r_while
c_loop
(paren
id|context
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ge
l_int|10
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;audit: freed %d contexts&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
)brace
DECL|function|audit_log_exit
r_static
r_void
id|audit_log_exit
c_func
(paren
r_struct
id|audit_context
op_star
id|context
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|audit_buffer
op_star
id|ab
suffix:semicolon
id|ab
op_assign
id|audit_log_start
c_func
(paren
id|context
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ab
)paren
r_return
suffix:semicolon
multiline_comment|/* audit_panic has been called */
id|audit_log_format
c_func
(paren
id|ab
comma
l_string|&quot;syscall=%d&quot;
comma
id|context-&gt;major
)paren
suffix:semicolon
r_if
c_cond
(paren
id|context-&gt;personality
op_ne
id|PER_LINUX
)paren
id|audit_log_format
c_func
(paren
id|ab
comma
l_string|&quot; per=%lx&quot;
comma
id|context-&gt;personality
)paren
suffix:semicolon
r_if
c_cond
(paren
id|context-&gt;return_valid
)paren
id|audit_log_format
c_func
(paren
id|ab
comma
l_string|&quot; exit=%d&quot;
comma
id|context-&gt;return_code
)paren
suffix:semicolon
id|audit_log_format
c_func
(paren
id|ab
comma
l_string|&quot; a0=%lx a1=%lx a2=%lx a3=%lx items=%d&quot;
l_string|&quot; pid=%d loginuid=%d uid=%d gid=%d&quot;
l_string|&quot; euid=%d suid=%d fsuid=%d&quot;
l_string|&quot; egid=%d sgid=%d fsgid=%d&quot;
comma
id|context-&gt;argv
(braket
l_int|0
)braket
comma
id|context-&gt;argv
(braket
l_int|1
)braket
comma
id|context-&gt;argv
(braket
l_int|2
)braket
comma
id|context-&gt;argv
(braket
l_int|3
)braket
comma
id|context-&gt;name_count
comma
id|context-&gt;pid
comma
id|context-&gt;loginuid
comma
id|context-&gt;uid
comma
id|context-&gt;gid
comma
id|context-&gt;euid
comma
id|context-&gt;suid
comma
id|context-&gt;fsuid
comma
id|context-&gt;egid
comma
id|context-&gt;sgid
comma
id|context-&gt;fsgid
)paren
suffix:semicolon
id|audit_log_end
c_func
(paren
id|ab
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|context-&gt;name_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ab
op_assign
id|audit_log_start
c_func
(paren
id|context
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ab
)paren
r_continue
suffix:semicolon
multiline_comment|/* audit_panic has been called */
id|audit_log_format
c_func
(paren
id|ab
comma
l_string|&quot;item=%d&quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|context-&gt;names
(braket
id|i
)braket
dot
id|name
)paren
id|audit_log_format
c_func
(paren
id|ab
comma
l_string|&quot; name=%s&quot;
comma
id|context-&gt;names
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|context-&gt;names
(braket
id|i
)braket
dot
id|ino
op_ne
(paren
r_int
r_int
)paren
op_minus
l_int|1
)paren
id|audit_log_format
c_func
(paren
id|ab
comma
l_string|&quot; inode=%lu&quot;
comma
id|context-&gt;names
(braket
id|i
)braket
dot
id|ino
)paren
suffix:semicolon
multiline_comment|/* FIXME: should use format_dev_t, but ab structure is&n;&t;&t; * opaque. */
r_if
c_cond
(paren
id|context-&gt;names
(braket
id|i
)braket
dot
id|rdev
op_ne
op_minus
l_int|1
)paren
id|audit_log_format
c_func
(paren
id|ab
comma
l_string|&quot; dev=%02x:%02x&quot;
comma
id|MAJOR
c_func
(paren
id|context-&gt;names
(braket
id|i
)braket
dot
id|rdev
)paren
comma
id|MINOR
c_func
(paren
id|context-&gt;names
(braket
id|i
)braket
dot
id|rdev
)paren
)paren
suffix:semicolon
id|audit_log_end
c_func
(paren
id|ab
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Free a per-task audit context.  Called from copy_process and&n; * __put_task_struct. */
DECL|function|audit_free
r_void
id|audit_free
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_struct
id|audit_context
op_star
id|context
suffix:semicolon
id|task_lock
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|context
op_assign
id|audit_get_context
c_func
(paren
id|tsk
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|task_unlock
c_func
(paren
id|tsk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|context
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Check for system calls that do not go through the exit&n;&t; * function (e.g., exit_group), then free context block. */
r_if
c_cond
(paren
id|context-&gt;in_syscall
op_logical_and
id|context-&gt;auditable
)paren
id|audit_log_exit
c_func
(paren
id|context
)paren
suffix:semicolon
id|audit_free_context
c_func
(paren
id|context
)paren
suffix:semicolon
)brace
multiline_comment|/* Compute a serial number for the audit record.  Audit records are&n; * written to user-space as soon as they are generated, so a complete&n; * audit record may be written in several pieces.  The timestamp of the&n; * record and this serial number are used by the user-space daemon to&n; * determine which pieces belong to the same audit record.  The&n; * (timestamp,serial) tuple is unique for each syscall and is live from&n; * syscall entry to syscall exit.&n; *&n; * Atomic values are only guaranteed to be 24-bit, so we count down.&n; *&n; * NOTE: Another possibility is to store the formatted records off the&n; * audit context (for those records that have a context), and emit them&n; * all at syscall exit.  However, this could delay the reporting of&n; * significant errors until syscall exit (or never, if the system&n; * halts). */
DECL|function|audit_serial
r_static
r_inline
r_int
r_int
id|audit_serial
c_func
(paren
r_void
)paren
(brace
r_static
id|atomic_t
id|serial
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0xffffff
)paren
suffix:semicolon
r_int
r_int
id|a
comma
id|b
suffix:semicolon
r_do
(brace
id|a
op_assign
id|atomic_read
c_func
(paren
op_amp
id|serial
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|serial
)paren
)paren
id|atomic_set
c_func
(paren
op_amp
id|serial
comma
l_int|0xffffff
)paren
suffix:semicolon
id|b
op_assign
id|atomic_read
c_func
(paren
op_amp
id|serial
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|b
op_ne
id|a
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0xffffff
op_minus
id|b
suffix:semicolon
)brace
multiline_comment|/* Fill in audit context at syscall entry.  This only happens if the&n; * audit context was created when the task was created and the state or&n; * filters demand the audit context be built.  If the state from the&n; * per-task filter or from the per-syscall filter is AUDIT_RECORD_CONTEXT,&n; * then the record will be written at syscall exit time (otherwise, it&n; * will only be written if another part of the kernel requests that it&n; * be written). */
DECL|function|audit_syscall_entry
r_void
id|audit_syscall_entry
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
id|major
comma
r_int
r_int
id|a1
comma
r_int
r_int
id|a2
comma
r_int
r_int
id|a3
comma
r_int
r_int
id|a4
)paren
(brace
r_struct
id|audit_context
op_star
id|context
op_assign
id|tsk-&gt;audit_context
suffix:semicolon
r_enum
id|audit_state
id|state
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|context
)paren
suffix:semicolon
multiline_comment|/* This happens only on certain architectures that make system&n;&t; * calls in kernel_thread via the entry.S interface, instead of&n;&t; * with direct calls.  (If you are porting to a new&n;&t; * architecture, hitting this condition can indicate that you&n;&t; * got the _exit/_leave calls backward in entry.S.)&n;&t; *&n;&t; * i386     no&n;&t; * x86_64   no&n;&t; * ppc64    yes (see arch/ppc64/kernel/misc.S)&n;&t; *&n;&t; * This also happens with vm86 emulation in a non-nested manner&n;&t; * (entries without exits), so this case must be caught.&n;&t; */
r_if
c_cond
(paren
id|context-&gt;in_syscall
)paren
(brace
r_struct
id|audit_context
op_star
id|newctx
suffix:semicolon
macro_line|#if defined(__NR_vm86) &amp;&amp; defined(__NR_vm86old)
multiline_comment|/* vm86 mode should only be entered once */
r_if
c_cond
(paren
id|major
op_eq
id|__NR_vm86
op_logical_or
id|major
op_eq
id|__NR_vm86old
)paren
r_return
suffix:semicolon
macro_line|#endif
macro_line|#if AUDIT_DEBUG
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;audit(:%d) pid=%d in syscall=%d;&quot;
l_string|&quot; entering syscall=%d&bslash;n&quot;
comma
id|context-&gt;serial
comma
id|tsk-&gt;pid
comma
id|context-&gt;major
comma
id|major
)paren
suffix:semicolon
macro_line|#endif
id|newctx
op_assign
id|audit_alloc_context
c_func
(paren
id|context-&gt;state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newctx
)paren
(brace
id|newctx-&gt;previous
op_assign
id|context
suffix:semicolon
id|context
op_assign
id|newctx
suffix:semicolon
id|tsk-&gt;audit_context
op_assign
id|newctx
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If we can&squot;t alloc a new context, the best we&n;&t;&t;&t; * can do is to leak memory (any pending putname&n;&t;&t;&t; * will be lost).  The only other alternative is&n;&t;&t;&t; * to abandon auditing. */
id|audit_zero_context
c_func
(paren
id|context
comma
id|context-&gt;state
)paren
suffix:semicolon
)brace
)brace
id|BUG_ON
c_func
(paren
id|context-&gt;in_syscall
op_logical_or
id|context-&gt;name_count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|audit_enabled
)paren
r_return
suffix:semicolon
id|context-&gt;major
op_assign
id|major
suffix:semicolon
id|context-&gt;argv
(braket
l_int|0
)braket
op_assign
id|a1
suffix:semicolon
id|context-&gt;argv
(braket
l_int|1
)braket
op_assign
id|a2
suffix:semicolon
id|context-&gt;argv
(braket
l_int|2
)braket
op_assign
id|a3
suffix:semicolon
id|context-&gt;argv
(braket
l_int|3
)braket
op_assign
id|a4
suffix:semicolon
id|state
op_assign
id|context-&gt;state
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
id|AUDIT_SETUP_CONTEXT
op_logical_or
id|state
op_eq
id|AUDIT_BUILD_CONTEXT
)paren
id|state
op_assign
id|audit_filter_syscall
c_func
(paren
id|tsk
comma
id|context
comma
op_amp
id|audit_entlist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|state
op_eq
id|AUDIT_DISABLED
)paren
)paren
r_return
suffix:semicolon
id|context-&gt;serial
op_assign
id|audit_serial
c_func
(paren
)paren
suffix:semicolon
id|context-&gt;ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|context-&gt;in_syscall
op_assign
l_int|1
suffix:semicolon
id|context-&gt;auditable
op_assign
op_logical_neg
op_logical_neg
(paren
id|state
op_eq
id|AUDIT_RECORD_CONTEXT
)paren
suffix:semicolon
)brace
multiline_comment|/* Tear down after system call.  If the audit context has been marked as&n; * auditable (either because of the AUDIT_RECORD_CONTEXT state from&n; * filtering, or because some other part of the kernel write an audit&n; * message), then write out the syscall information.  In call cases,&n; * free the names stored from getname(). */
DECL|function|audit_syscall_exit
r_void
id|audit_syscall_exit
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
id|return_code
)paren
(brace
r_struct
id|audit_context
op_star
id|context
suffix:semicolon
id|get_task_struct
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|task_lock
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|context
op_assign
id|audit_get_context
c_func
(paren
id|tsk
comma
l_int|1
comma
id|return_code
)paren
suffix:semicolon
id|task_unlock
c_func
(paren
id|tsk
)paren
suffix:semicolon
multiline_comment|/* Not having a context here is ok, since the parent may have&n;&t; * called __put_task_struct. */
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|context
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|context-&gt;in_syscall
op_logical_and
id|context-&gt;auditable
)paren
id|audit_log_exit
c_func
(paren
id|context
)paren
suffix:semicolon
id|context-&gt;in_syscall
op_assign
l_int|0
suffix:semicolon
id|context-&gt;auditable
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|context-&gt;previous
)paren
(brace
r_struct
id|audit_context
op_star
id|new_context
op_assign
id|context-&gt;previous
suffix:semicolon
id|context-&gt;previous
op_assign
l_int|NULL
suffix:semicolon
id|audit_free_context
c_func
(paren
id|context
)paren
suffix:semicolon
id|tsk-&gt;audit_context
op_assign
id|new_context
suffix:semicolon
)brace
r_else
(brace
id|audit_free_names
c_func
(paren
id|context
)paren
suffix:semicolon
id|audit_zero_context
c_func
(paren
id|context
comma
id|context-&gt;state
)paren
suffix:semicolon
id|tsk-&gt;audit_context
op_assign
id|context
suffix:semicolon
)brace
id|put_task_struct
c_func
(paren
id|tsk
)paren
suffix:semicolon
)brace
multiline_comment|/* Add a name to the list.  Called from fs/namei.c:getname(). */
DECL|function|audit_getname
r_void
id|audit_getname
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|audit_context
op_star
id|context
op_assign
id|current-&gt;audit_context
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|context
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|context-&gt;in_syscall
)paren
(brace
macro_line|#if AUDIT_DEBUG == 2
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s:%d(:%d): ignoring getname(%p)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|context-&gt;serial
comma
id|name
)paren
suffix:semicolon
id|dump_stack
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
id|context-&gt;name_count
op_ge
id|AUDIT_NAMES
)paren
suffix:semicolon
id|context-&gt;names
(braket
id|context-&gt;name_count
)braket
dot
id|name
op_assign
id|name
suffix:semicolon
id|context-&gt;names
(braket
id|context-&gt;name_count
)braket
dot
id|ino
op_assign
(paren
r_int
r_int
)paren
op_minus
l_int|1
suffix:semicolon
id|context-&gt;names
(braket
id|context-&gt;name_count
)braket
dot
id|rdev
op_assign
op_minus
l_int|1
suffix:semicolon
op_increment
id|context-&gt;name_count
suffix:semicolon
)brace
multiline_comment|/* Intercept a putname request.  Called from&n; * include/linux/fs.h:putname().  If we have stored the name from&n; * getname in the audit context, then we delay the putname until syscall&n; * exit. */
DECL|function|audit_putname
r_void
id|audit_putname
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|audit_context
op_star
id|context
op_assign
id|current-&gt;audit_context
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|context
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|context-&gt;in_syscall
)paren
(brace
macro_line|#if AUDIT_DEBUG == 2
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s:%d(:%d): __putname(%p)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|context-&gt;serial
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|context-&gt;name_count
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|context-&gt;name_count
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;name[%d] = %p = %s&bslash;n&quot;
comma
id|i
comma
id|context-&gt;names
(braket
id|i
)braket
dot
id|name
comma
id|context-&gt;names
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
)brace
macro_line|#endif
id|__putname
c_func
(paren
id|name
)paren
suffix:semicolon
)brace
macro_line|#if AUDIT_DEBUG
r_else
(brace
op_increment
id|context-&gt;put_count
suffix:semicolon
r_if
c_cond
(paren
id|context-&gt;put_count
OG
id|context-&gt;name_count
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s:%d(:%d): major=%d&quot;
l_string|&quot; in_syscall=%d putname(%p) name_count=%d&quot;
l_string|&quot; put_count=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|context-&gt;serial
comma
id|context-&gt;major
comma
id|context-&gt;in_syscall
comma
id|name
comma
id|context-&gt;name_count
comma
id|context-&gt;put_count
)paren
suffix:semicolon
id|dump_stack
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
DECL|variable|audit_putname
id|EXPORT_SYMBOL
c_func
(paren
id|audit_putname
)paren
suffix:semicolon
multiline_comment|/* Store the inode and device from a lookup.  Called from&n; * fs/namei.c:path_lookup(). */
DECL|function|audit_inode
r_void
id|audit_inode
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|ino
comma
id|dev_t
id|rdev
)paren
(brace
r_int
id|idx
suffix:semicolon
r_struct
id|audit_context
op_star
id|context
op_assign
id|current-&gt;audit_context
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|context-&gt;in_syscall
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|context-&gt;name_count
op_logical_and
id|context-&gt;names
(braket
id|context-&gt;name_count
op_minus
l_int|1
)braket
dot
id|name
op_logical_and
id|context-&gt;names
(braket
id|context-&gt;name_count
op_minus
l_int|1
)braket
dot
id|name
op_eq
id|name
)paren
id|idx
op_assign
id|context-&gt;name_count
op_minus
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|context-&gt;name_count
OG
l_int|1
op_logical_and
id|context-&gt;names
(braket
id|context-&gt;name_count
op_minus
l_int|2
)braket
dot
id|name
op_logical_and
id|context-&gt;names
(braket
id|context-&gt;name_count
op_minus
l_int|2
)braket
dot
id|name
op_eq
id|name
)paren
id|idx
op_assign
id|context-&gt;name_count
op_minus
l_int|2
suffix:semicolon
r_else
(brace
multiline_comment|/* FIXME: how much do we care about inodes that have no&n;&t;&t; * associated name? */
r_if
c_cond
(paren
id|context-&gt;name_count
op_ge
id|AUDIT_NAMES
op_minus
id|AUDIT_NAMES_RESERVED
)paren
r_return
suffix:semicolon
id|idx
op_assign
id|context-&gt;name_count
op_increment
suffix:semicolon
id|context-&gt;names
(braket
id|idx
)braket
dot
id|name
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if AUDIT_DEBUG
op_increment
id|context-&gt;ino_count
suffix:semicolon
macro_line|#endif
)brace
id|context-&gt;names
(braket
id|idx
)braket
dot
id|ino
op_assign
id|ino
suffix:semicolon
id|context-&gt;names
(braket
id|idx
)braket
dot
id|rdev
op_assign
id|rdev
suffix:semicolon
)brace
DECL|function|audit_get_stamp
r_void
id|audit_get_stamp
c_func
(paren
r_struct
id|audit_context
op_star
id|ctx
comma
r_struct
id|timespec
op_star
id|t
comma
r_int
op_star
id|serial
)paren
(brace
r_if
c_cond
(paren
id|ctx
)paren
(brace
id|t-&gt;tv_sec
op_assign
id|ctx-&gt;ctime.tv_sec
suffix:semicolon
id|t-&gt;tv_nsec
op_assign
id|ctx-&gt;ctime.tv_nsec
suffix:semicolon
op_star
id|serial
op_assign
id|ctx-&gt;serial
suffix:semicolon
id|ctx-&gt;auditable
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
op_star
id|t
op_assign
id|CURRENT_TIME
suffix:semicolon
op_star
id|serial
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|audit_set_loginuid
r_int
id|audit_set_loginuid
c_func
(paren
r_struct
id|audit_context
op_star
id|ctx
comma
id|uid_t
id|loginuid
)paren
(brace
r_if
c_cond
(paren
id|ctx
)paren
(brace
r_if
c_cond
(paren
id|loginuid
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ctx-&gt;loginuid
op_assign
id|loginuid
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
