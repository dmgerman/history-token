multiline_comment|/* Rewritten by Rusty Russell, on the backs of many others...&n;   Copyright (C) 2002 Richard Henderson&n;   Copyright (C) 2001 Rusty Russell, 2002 Rusty Russell IBM.&n;&n;    This program is free software; you can redistribute it and/or modify&n;    it under the terms of the GNU General Public License as published by&n;    the Free Software Foundation; either version 2 of the License, or&n;    (at your option) any later version.&n;&n;    This program is distributed in the hope that it will be useful,&n;    but WITHOUT ANY WARRANTY; without even the implied warranty of&n;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;    GNU General Public License for more details.&n;&n;    You should have received a copy of the GNU General Public License&n;    along with this program; if not, write to the Free Software&n;    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n;*/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleloader.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/elf.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/rcupdate.h&gt;
macro_line|#include &lt;linux/cpu.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/err.h&gt;
macro_line|#include &lt;linux/vermagic.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/cacheflush.h&gt;
macro_line|#if 0
mdefine_line|#define DEBUGP printk
macro_line|#else
DECL|macro|DEBUGP
mdefine_line|#define DEBUGP(fmt , a...)
macro_line|#endif
macro_line|#ifndef ARCH_SHF_SMALL
DECL|macro|ARCH_SHF_SMALL
mdefine_line|#define ARCH_SHF_SMALL 0
macro_line|#endif
multiline_comment|/* If this is set, the section belongs in the init part of the module */
DECL|macro|INIT_OFFSET_MASK
mdefine_line|#define INIT_OFFSET_MASK (1UL &lt;&lt; (BITS_PER_LONG-1))
DECL|macro|symbol_is
mdefine_line|#define symbol_is(literal, string)&t;&t;&t;&t;&bslash;&n;&t;(strcmp(MODULE_SYMBOL_PREFIX literal, (string)) == 0)
multiline_comment|/* Protects module list */
DECL|variable|modlist_lock
r_static
id|spinlock_t
id|modlist_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* List of modules, protected by module_mutex AND modlist_lock */
r_static
id|DECLARE_MUTEX
c_func
(paren
id|module_mutex
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|modules
)paren
suffix:semicolon
r_static
id|DECLARE_MUTEX
c_func
(paren
id|notify_mutex
)paren
suffix:semicolon
DECL|variable|module_notify_list
r_static
r_struct
id|notifier_block
op_star
id|module_notify_list
suffix:semicolon
DECL|function|register_module_notifier
r_int
id|register_module_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
)paren
(brace
r_int
id|err
suffix:semicolon
id|down
c_func
(paren
op_amp
id|notify_mutex
)paren
suffix:semicolon
id|err
op_assign
id|notifier_chain_register
c_func
(paren
op_amp
id|module_notify_list
comma
id|nb
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|notify_mutex
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|register_module_notifier
id|EXPORT_SYMBOL
c_func
(paren
id|register_module_notifier
)paren
suffix:semicolon
DECL|function|unregister_module_notifier
r_int
id|unregister_module_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
)paren
(brace
r_int
id|err
suffix:semicolon
id|down
c_func
(paren
op_amp
id|notify_mutex
)paren
suffix:semicolon
id|err
op_assign
id|notifier_chain_unregister
c_func
(paren
op_amp
id|module_notify_list
comma
id|nb
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|notify_mutex
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|unregister_module_notifier
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_module_notifier
)paren
suffix:semicolon
multiline_comment|/* We require a truly strong try_module_get() */
DECL|function|strong_try_module_get
r_static
r_inline
r_int
id|strong_try_module_get
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
r_if
c_cond
(paren
id|mod
op_logical_and
id|mod-&gt;state
op_eq
id|MODULE_STATE_COMING
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|try_module_get
c_func
(paren
id|mod
)paren
suffix:semicolon
)brace
multiline_comment|/* Stub function for modules which don&squot;t have an initfn */
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|init_module
id|EXPORT_SYMBOL
c_func
(paren
id|init_module
)paren
suffix:semicolon
multiline_comment|/* A thread that wants to hold a reference to a module only while it&n; * is running can call ths to safely exit.&n; * nfsd and lockd use this.&n; */
DECL|function|__module_put_and_exit
r_void
id|__module_put_and_exit
c_func
(paren
r_struct
id|module
op_star
id|mod
comma
r_int
id|code
)paren
(brace
id|module_put
c_func
(paren
id|mod
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|code
)paren
suffix:semicolon
)brace
DECL|variable|__module_put_and_exit
id|EXPORT_SYMBOL
c_func
(paren
id|__module_put_and_exit
)paren
suffix:semicolon
multiline_comment|/* Find a module section: 0 means not found. */
DECL|function|find_sec
r_static
r_int
r_int
id|find_sec
c_func
(paren
id|Elf_Ehdr
op_star
id|hdr
comma
id|Elf_Shdr
op_star
id|sechdrs
comma
r_const
r_char
op_star
id|secstrings
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|hdr-&gt;e_shnum
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/* Alloc bit cleared means &quot;ignore it.&quot; */
r_if
c_cond
(paren
(paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_flags
op_amp
id|SHF_ALLOC
)paren
op_logical_and
id|strcmp
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
comma
id|name
)paren
op_eq
l_int|0
)paren
r_return
id|i
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Provided by the linker */
r_extern
r_const
r_struct
id|kernel_symbol
id|__start___ksymtab
(braket
)braket
suffix:semicolon
r_extern
r_const
r_struct
id|kernel_symbol
id|__stop___ksymtab
(braket
)braket
suffix:semicolon
r_extern
r_const
r_struct
id|kernel_symbol
id|__start___ksymtab_gpl
(braket
)braket
suffix:semicolon
r_extern
r_const
r_struct
id|kernel_symbol
id|__stop___ksymtab_gpl
(braket
)braket
suffix:semicolon
r_extern
r_const
r_int
r_int
id|__start___kcrctab
(braket
)braket
suffix:semicolon
r_extern
r_const
r_int
r_int
id|__start___kcrctab_gpl
(braket
)braket
suffix:semicolon
macro_line|#ifndef CONFIG_MODVERSIONS
DECL|macro|symversion
mdefine_line|#define symversion(base, idx) NULL
macro_line|#else
DECL|macro|symversion
mdefine_line|#define symversion(base, idx) ((base) ? ((base) + (idx)) : NULL)
macro_line|#endif
multiline_comment|/* Find a symbol, return value, crc and module which owns it */
DECL|function|__find_symbol
r_static
r_int
r_int
id|__find_symbol
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|module
op_star
op_star
id|owner
comma
r_const
r_int
r_int
op_star
op_star
id|crc
comma
r_int
id|gplok
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
multiline_comment|/* Core kernel first. */
op_star
id|owner
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|__start___ksymtab
op_plus
id|i
OL
id|__stop___ksymtab
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|__start___ksymtab
(braket
id|i
)braket
dot
id|name
comma
id|name
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|crc
op_assign
id|symversion
c_func
(paren
id|__start___kcrctab
comma
id|i
)paren
suffix:semicolon
r_return
id|__start___ksymtab
(braket
id|i
)braket
dot
id|value
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|gplok
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|__start___ksymtab_gpl
op_plus
id|i
OL
id|__stop___ksymtab_gpl
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|__start___ksymtab_gpl
(braket
id|i
)braket
dot
id|name
comma
id|name
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|crc
op_assign
id|symversion
c_func
(paren
id|__start___kcrctab_gpl
comma
id|i
)paren
suffix:semicolon
r_return
id|__start___ksymtab_gpl
(braket
id|i
)braket
dot
id|value
suffix:semicolon
)brace
)brace
multiline_comment|/* Now try modules. */
id|list_for_each_entry
c_func
(paren
id|mod
comma
op_amp
id|modules
comma
id|list
)paren
(brace
op_star
id|owner
op_assign
id|mod
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mod-&gt;num_syms
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|mod-&gt;syms
(braket
id|i
)braket
dot
id|name
comma
id|name
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|crc
op_assign
id|symversion
c_func
(paren
id|mod-&gt;crcs
comma
id|i
)paren
suffix:semicolon
r_return
id|mod-&gt;syms
(braket
id|i
)braket
dot
id|value
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gplok
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mod-&gt;num_gpl_syms
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|mod-&gt;gpl_syms
(braket
id|i
)braket
dot
id|name
comma
id|name
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|crc
op_assign
id|symversion
c_func
(paren
id|mod-&gt;gpl_crcs
comma
id|i
)paren
suffix:semicolon
r_return
id|mod-&gt;gpl_syms
(braket
id|i
)braket
dot
id|value
suffix:semicolon
)brace
)brace
)brace
)brace
id|DEBUGP
c_func
(paren
l_string|&quot;Failed to find symbol %s&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Find a symbol in this elf symbol table */
DECL|function|find_local_symbol
r_static
r_int
r_int
id|find_local_symbol
c_func
(paren
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|symindex
comma
r_const
r_char
op_star
id|strtab
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|Elf_Sym
op_star
id|sym
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_addr
suffix:semicolon
multiline_comment|/* Search (defined) internal symbols first. */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
op_star
id|sym
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sym
(braket
id|i
)braket
dot
id|st_shndx
op_ne
id|SHN_UNDEF
op_logical_and
id|strcmp
c_func
(paren
id|name
comma
id|strtab
op_plus
id|sym
(braket
id|i
)braket
dot
id|st_name
)paren
op_eq
l_int|0
)paren
r_return
id|sym
(braket
id|i
)braket
dot
id|st_value
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Search for module by name: must hold module_mutex. */
DECL|function|find_module
r_static
r_struct
id|module
op_star
id|find_module
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|mod
comma
op_amp
id|modules
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|mod-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
r_return
id|mod
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* Number of blocks used and allocated. */
DECL|variable|pcpu_num_used
DECL|variable|pcpu_num_allocated
r_static
r_int
r_int
id|pcpu_num_used
comma
id|pcpu_num_allocated
suffix:semicolon
multiline_comment|/* Size of each block.  -ve means used. */
DECL|variable|pcpu_size
r_static
r_int
op_star
id|pcpu_size
suffix:semicolon
DECL|function|split_block
r_static
r_int
id|split_block
c_func
(paren
r_int
r_int
id|i
comma
r_int
r_int
id|size
)paren
(brace
multiline_comment|/* Reallocation required? */
r_if
c_cond
(paren
id|pcpu_num_used
op_plus
l_int|1
OG
id|pcpu_num_allocated
)paren
(brace
r_int
op_star
r_new
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_new
(braket
l_int|0
)braket
)paren
op_star
id|pcpu_num_allocated
op_star
l_int|2
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
r_new
comma
id|pcpu_size
comma
r_sizeof
(paren
r_new
(braket
l_int|0
)braket
)paren
op_star
id|pcpu_num_allocated
)paren
suffix:semicolon
id|pcpu_num_allocated
op_mul_assign
l_int|2
suffix:semicolon
id|kfree
c_func
(paren
id|pcpu_size
)paren
suffix:semicolon
id|pcpu_size
op_assign
r_new
suffix:semicolon
)brace
multiline_comment|/* Insert a new subblock */
id|memmove
c_func
(paren
op_amp
id|pcpu_size
(braket
id|i
op_plus
l_int|1
)braket
comma
op_amp
id|pcpu_size
(braket
id|i
)braket
comma
r_sizeof
(paren
id|pcpu_size
(braket
l_int|0
)braket
)paren
op_star
(paren
id|pcpu_num_used
op_minus
id|i
)paren
)paren
suffix:semicolon
id|pcpu_num_used
op_increment
suffix:semicolon
id|pcpu_size
(braket
id|i
op_plus
l_int|1
)braket
op_sub_assign
id|size
suffix:semicolon
id|pcpu_size
(braket
id|i
)braket
op_assign
id|size
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|block_size
r_static
r_inline
r_int
r_int
id|block_size
c_func
(paren
r_int
id|val
)paren
(brace
r_if
c_cond
(paren
id|val
OL
l_int|0
)paren
r_return
op_minus
id|val
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
multiline_comment|/* Created by linker magic */
r_extern
r_char
id|__per_cpu_start
(braket
)braket
comma
id|__per_cpu_end
(braket
)braket
suffix:semicolon
DECL|function|percpu_modalloc
r_static
r_void
op_star
id|percpu_modalloc
c_func
(paren
r_int
r_int
id|size
comma
r_int
r_int
id|align
)paren
(brace
r_int
r_int
id|extra
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_void
op_star
id|ptr
suffix:semicolon
id|BUG_ON
c_func
(paren
id|align
OG
id|SMP_CACHE_BYTES
)paren
suffix:semicolon
id|ptr
op_assign
id|__per_cpu_start
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pcpu_num_used
suffix:semicolon
id|ptr
op_add_assign
id|block_size
c_func
(paren
id|pcpu_size
(braket
id|i
)braket
)paren
comma
id|i
op_increment
)paren
(brace
multiline_comment|/* Extra for alignment requirement. */
id|extra
op_assign
id|ALIGN
c_func
(paren
(paren
r_int
r_int
)paren
id|ptr
comma
id|align
)paren
op_minus
(paren
r_int
r_int
)paren
id|ptr
suffix:semicolon
id|BUG_ON
c_func
(paren
id|i
op_eq
l_int|0
op_logical_and
id|extra
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcpu_size
(braket
id|i
)braket
OL
l_int|0
op_logical_or
id|pcpu_size
(braket
id|i
)braket
OL
id|extra
op_plus
id|size
)paren
r_continue
suffix:semicolon
multiline_comment|/* Transfer extra to previous block. */
r_if
c_cond
(paren
id|pcpu_size
(braket
id|i
op_minus
l_int|1
)braket
OL
l_int|0
)paren
id|pcpu_size
(braket
id|i
op_minus
l_int|1
)braket
op_sub_assign
id|extra
suffix:semicolon
r_else
id|pcpu_size
(braket
id|i
op_minus
l_int|1
)braket
op_add_assign
id|extra
suffix:semicolon
id|pcpu_size
(braket
id|i
)braket
op_sub_assign
id|extra
suffix:semicolon
id|ptr
op_add_assign
id|extra
suffix:semicolon
multiline_comment|/* Split block if warranted */
r_if
c_cond
(paren
id|pcpu_size
(braket
id|i
)braket
op_minus
id|size
OG
r_sizeof
(paren
r_int
r_int
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
id|split_block
c_func
(paren
id|i
comma
id|size
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Mark allocated */
id|pcpu_size
(braket
id|i
)braket
op_assign
op_minus
id|pcpu_size
(braket
id|i
)braket
suffix:semicolon
r_return
id|ptr
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Could not allocate %lu bytes percpu data&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|percpu_modfree
r_static
r_void
id|percpu_modfree
c_func
(paren
r_void
op_star
id|freeme
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_void
op_star
id|ptr
op_assign
id|__per_cpu_start
op_plus
id|block_size
c_func
(paren
id|pcpu_size
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* First entry is core kernel percpu data. */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|pcpu_num_used
suffix:semicolon
id|ptr
op_add_assign
id|block_size
c_func
(paren
id|pcpu_size
(braket
id|i
)braket
)paren
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ptr
op_eq
id|freeme
)paren
(brace
id|pcpu_size
(braket
id|i
)braket
op_assign
op_minus
id|pcpu_size
(braket
id|i
)braket
suffix:semicolon
r_goto
id|free
suffix:semicolon
)brace
)brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|free
suffix:colon
multiline_comment|/* Merge with previous? */
r_if
c_cond
(paren
id|pcpu_size
(braket
id|i
op_minus
l_int|1
)braket
op_ge
l_int|0
)paren
(brace
id|pcpu_size
(braket
id|i
op_minus
l_int|1
)braket
op_add_assign
id|pcpu_size
(braket
id|i
)braket
suffix:semicolon
id|pcpu_num_used
op_decrement
suffix:semicolon
id|memmove
c_func
(paren
op_amp
id|pcpu_size
(braket
id|i
)braket
comma
op_amp
id|pcpu_size
(braket
id|i
op_plus
l_int|1
)braket
comma
(paren
id|pcpu_num_used
op_minus
id|i
)paren
op_star
r_sizeof
(paren
id|pcpu_size
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
multiline_comment|/* Merge with next? */
r_if
c_cond
(paren
id|i
op_plus
l_int|1
OL
id|pcpu_num_used
op_logical_and
id|pcpu_size
(braket
id|i
op_plus
l_int|1
)braket
op_ge
l_int|0
)paren
(brace
id|pcpu_size
(braket
id|i
)braket
op_add_assign
id|pcpu_size
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
id|pcpu_num_used
op_decrement
suffix:semicolon
id|memmove
c_func
(paren
op_amp
id|pcpu_size
(braket
id|i
op_plus
l_int|1
)braket
comma
op_amp
id|pcpu_size
(braket
id|i
op_plus
l_int|2
)braket
comma
(paren
id|pcpu_num_used
op_minus
(paren
id|i
op_plus
l_int|1
)paren
)paren
op_star
r_sizeof
(paren
id|pcpu_size
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|find_pcpusec
r_static
r_int
r_int
id|find_pcpusec
c_func
(paren
id|Elf_Ehdr
op_star
id|hdr
comma
id|Elf_Shdr
op_star
id|sechdrs
comma
r_const
r_char
op_star
id|secstrings
)paren
(brace
r_return
id|find_sec
c_func
(paren
id|hdr
comma
id|sechdrs
comma
id|secstrings
comma
l_string|&quot;.data.percpu&quot;
)paren
suffix:semicolon
)brace
DECL|function|percpu_modinit
r_static
r_int
id|percpu_modinit
c_func
(paren
r_void
)paren
(brace
id|pcpu_num_used
op_assign
l_int|2
suffix:semicolon
id|pcpu_num_allocated
op_assign
l_int|2
suffix:semicolon
id|pcpu_size
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|pcpu_size
(braket
l_int|0
)braket
)paren
op_star
id|pcpu_num_allocated
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* Static in-kernel percpu data (used). */
id|pcpu_size
(braket
l_int|0
)braket
op_assign
op_minus
id|ALIGN
c_func
(paren
id|__per_cpu_end
op_minus
id|__per_cpu_start
comma
id|SMP_CACHE_BYTES
)paren
suffix:semicolon
multiline_comment|/* Free room. */
id|pcpu_size
(braket
l_int|1
)braket
op_assign
id|PERCPU_ENOUGH_ROOM
op_plus
id|pcpu_size
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pcpu_size
(braket
l_int|1
)braket
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;No per-cpu room for modules.&bslash;n&quot;
)paren
suffix:semicolon
id|pcpu_num_used
op_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|percpu_modinit
id|__initcall
c_func
(paren
id|percpu_modinit
)paren
suffix:semicolon
macro_line|#else /* ... !CONFIG_SMP */
DECL|function|percpu_modalloc
r_static
r_inline
r_void
op_star
id|percpu_modalloc
c_func
(paren
r_int
r_int
id|size
comma
r_int
r_int
id|align
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|percpu_modfree
r_static
r_inline
r_void
id|percpu_modfree
c_func
(paren
r_void
op_star
id|pcpuptr
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|find_pcpusec
r_static
r_inline
r_int
r_int
id|find_pcpusec
c_func
(paren
id|Elf_Ehdr
op_star
id|hdr
comma
id|Elf_Shdr
op_star
id|sechdrs
comma
r_const
r_char
op_star
id|secstrings
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|percpu_modcopy
r_static
r_inline
r_void
id|percpu_modcopy
c_func
(paren
r_void
op_star
id|pcpudst
comma
r_const
r_void
op_star
id|src
comma
r_int
r_int
id|size
)paren
(brace
multiline_comment|/* pcpusec should be 0, and size of that section should be 0. */
id|BUG_ON
c_func
(paren
id|size
op_ne
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SMP */
macro_line|#ifdef CONFIG_MODULE_UNLOAD
multiline_comment|/* Init the unload section of the module. */
DECL|function|module_unload_init
r_static
r_void
id|module_unload_init
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|mod-&gt;modules_which_use_me
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|local_set
c_func
(paren
op_amp
id|mod-&gt;ref
(braket
id|i
)braket
dot
id|count
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Hold reference count during initialization. */
id|local_set
c_func
(paren
op_amp
id|mod-&gt;ref
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|count
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Backwards compatibility macros put refcount during init. */
id|mod-&gt;waiter
op_assign
id|current
suffix:semicolon
)brace
multiline_comment|/* modules using other modules */
DECL|struct|module_use
r_struct
id|module_use
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|module_which_uses
r_struct
id|module
op_star
id|module_which_uses
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Does a already use b? */
DECL|function|already_uses
r_static
r_int
id|already_uses
c_func
(paren
r_struct
id|module
op_star
id|a
comma
r_struct
id|module
op_star
id|b
)paren
(brace
r_struct
id|module_use
op_star
id|use
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|use
comma
op_amp
id|b-&gt;modules_which_use_me
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|use-&gt;module_which_uses
op_eq
id|a
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;%s uses %s!&bslash;n&quot;
comma
id|a-&gt;name
comma
id|b-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|DEBUGP
c_func
(paren
l_string|&quot;%s does not use %s!&bslash;n&quot;
comma
id|a-&gt;name
comma
id|b-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Module a uses b */
DECL|function|use_module
r_static
r_int
id|use_module
c_func
(paren
r_struct
id|module
op_star
id|a
comma
r_struct
id|module
op_star
id|b
)paren
(brace
r_struct
id|module_use
op_star
id|use
suffix:semicolon
r_if
c_cond
(paren
id|b
op_eq
l_int|NULL
op_logical_or
id|already_uses
c_func
(paren
id|a
comma
id|b
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strong_try_module_get
c_func
(paren
id|b
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;Allocating new usage for %s.&bslash;n&quot;
comma
id|a-&gt;name
)paren
suffix:semicolon
id|use
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|use
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: out of memory loading&bslash;n&quot;
comma
id|a-&gt;name
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|b
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|use-&gt;module_which_uses
op_assign
id|a
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|use-&gt;list
comma
op_amp
id|b-&gt;modules_which_use_me
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Clear the unload stuff of the module. */
DECL|function|module_unload_free
r_static
r_void
id|module_unload_free
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
r_struct
id|module
op_star
id|i
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|i
comma
op_amp
id|modules
comma
id|list
)paren
(brace
r_struct
id|module_use
op_star
id|use
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|use
comma
op_amp
id|i-&gt;modules_which_use_me
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|use-&gt;module_which_uses
op_eq
id|mod
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;%s unusing %s&bslash;n&quot;
comma
id|mod-&gt;name
comma
id|i-&gt;name
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|i
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|use-&gt;list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|use
)paren
suffix:semicolon
multiline_comment|/* There can be at most one match. */
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* Thread to stop each CPU in user context. */
DECL|enum|stopref_state
r_enum
id|stopref_state
(brace
DECL|enumerator|STOPREF_WAIT
id|STOPREF_WAIT
comma
DECL|enumerator|STOPREF_PREPARE
id|STOPREF_PREPARE
comma
DECL|enumerator|STOPREF_DISABLE_IRQ
id|STOPREF_DISABLE_IRQ
comma
DECL|enumerator|STOPREF_EXIT
id|STOPREF_EXIT
comma
)brace
suffix:semicolon
DECL|variable|stopref_state
r_static
r_enum
id|stopref_state
id|stopref_state
suffix:semicolon
DECL|variable|stopref_num_threads
r_static
r_int
r_int
id|stopref_num_threads
suffix:semicolon
DECL|variable|stopref_thread_ack
r_static
id|atomic_t
id|stopref_thread_ack
suffix:semicolon
DECL|function|stopref
r_static
r_int
id|stopref
c_func
(paren
r_void
op_star
id|cpu
)paren
(brace
r_int
id|irqs_disabled
op_assign
l_int|0
suffix:semicolon
r_int
id|prepared
op_assign
l_int|0
suffix:semicolon
id|sprintf
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;kmodule%lu&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|cpu
)paren
suffix:semicolon
multiline_comment|/* Highest priority we can manage, and move to right CPU. */
macro_line|#if 0 /* FIXME */
r_struct
id|sched_param
id|param
op_assign
(brace
dot
id|sched_priority
op_assign
id|MAX_RT_PRIO
op_minus
l_int|1
)brace
suffix:semicolon
id|setscheduler
c_func
(paren
id|current-&gt;pid
comma
id|SCHED_FIFO
comma
op_amp
id|param
)paren
suffix:semicolon
macro_line|#endif
id|set_cpus_allowed
c_func
(paren
id|current
comma
l_int|1UL
op_lshift
(paren
r_int
r_int
)paren
id|cpu
)paren
suffix:semicolon
multiline_comment|/* Ack: we are alive */
id|atomic_inc
c_func
(paren
op_amp
id|stopref_thread_ack
)paren
suffix:semicolon
multiline_comment|/* Simple state machine */
r_while
c_loop
(paren
id|stopref_state
op_ne
id|STOPREF_EXIT
)paren
(brace
r_if
c_cond
(paren
id|stopref_state
op_eq
id|STOPREF_DISABLE_IRQ
op_logical_and
op_logical_neg
id|irqs_disabled
)paren
(brace
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|irqs_disabled
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Ack: irqs disabled. */
id|atomic_inc
c_func
(paren
op_amp
id|stopref_thread_ack
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|stopref_state
op_eq
id|STOPREF_PREPARE
op_logical_and
op_logical_neg
id|prepared
)paren
(brace
multiline_comment|/* Everyone is in place, hold CPU. */
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
id|prepared
op_assign
l_int|1
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|stopref_thread_ack
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irqs_disabled
op_logical_or
id|prepared
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
r_else
id|yield
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Ack: we are exiting. */
id|atomic_inc
c_func
(paren
op_amp
id|stopref_thread_ack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irqs_disabled
)paren
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prepared
)paren
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Change the thread state */
DECL|function|stopref_set_state
r_static
r_void
id|stopref_set_state
c_func
(paren
r_enum
id|stopref_state
id|state
comma
r_int
id|sleep
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|stopref_thread_ack
comma
l_int|0
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|stopref_state
op_assign
id|state
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|stopref_thread_ack
)paren
op_ne
id|stopref_num_threads
)paren
(brace
r_if
c_cond
(paren
id|sleep
)paren
id|yield
c_func
(paren
)paren
suffix:semicolon
r_else
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Stop the machine.  Disables irqs. */
DECL|function|stop_refcounts
r_static
r_int
id|stop_refcounts
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
comma
id|cpu
suffix:semicolon
r_int
r_int
id|old_allowed
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* One thread per cpu.  We&squot;ll do our own. */
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: racy with set_cpus_allowed. */
id|old_allowed
op_assign
id|current-&gt;cpus_allowed
suffix:semicolon
id|set_cpus_allowed
c_func
(paren
id|current
comma
l_int|1UL
op_lshift
(paren
r_int
r_int
)paren
id|cpu
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|stopref_thread_ack
comma
l_int|0
)paren
suffix:semicolon
id|stopref_num_threads
op_assign
l_int|0
suffix:semicolon
id|stopref_state
op_assign
id|STOPREF_WAIT
suffix:semicolon
multiline_comment|/* No CPUs can come up or down during this. */
id|down
c_func
(paren
op_amp
id|cpucontrol
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|cpu
op_logical_or
op_logical_neg
id|cpu_online
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
id|ret
op_assign
id|kernel_thread
c_func
(paren
id|stopref
comma
(paren
r_void
op_star
)paren
(paren
r_int
)paren
id|i
comma
id|CLONE_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_break
suffix:semicolon
id|stopref_num_threads
op_increment
suffix:semicolon
)brace
multiline_comment|/* Wait for them all to come to life. */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|stopref_thread_ack
)paren
op_ne
id|stopref_num_threads
)paren
id|yield
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If some failed, kill them all. */
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|stopref_set_state
c_func
(paren
id|STOPREF_EXIT
comma
l_int|1
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cpucontrol
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t schedule us away at this point, please. */
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Now they are all scheduled, make them hold the CPUs, ready. */
id|stopref_set_state
c_func
(paren
id|STOPREF_PREPARE
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Make them disable irqs. */
id|stopref_set_state
c_func
(paren
id|STOPREF_DISABLE_IRQ
comma
l_int|0
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Restart the machine.  Re-enables irqs. */
DECL|function|restart_refcounts
r_static
r_void
id|restart_refcounts
c_func
(paren
r_void
)paren
(brace
id|stopref_set_state
c_func
(paren
id|STOPREF_EXIT
comma
l_int|0
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cpucontrol
)paren
suffix:semicolon
)brace
macro_line|#else /* ...!SMP */
DECL|function|stop_refcounts
r_static
r_inline
r_int
id|stop_refcounts
c_func
(paren
r_void
)paren
(brace
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|restart_refcounts
r_static
r_inline
r_void
id|restart_refcounts
c_func
(paren
r_void
)paren
(brace
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|module_refcount
r_int
r_int
id|module_refcount
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
r_int
r_int
id|i
comma
id|total
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|total
op_add_assign
id|local_read
c_func
(paren
op_amp
id|mod-&gt;ref
(braket
id|i
)braket
dot
id|count
)paren
suffix:semicolon
r_return
id|total
suffix:semicolon
)brace
DECL|variable|module_refcount
id|EXPORT_SYMBOL
c_func
(paren
id|module_refcount
)paren
suffix:semicolon
multiline_comment|/* This exists whether we can unload or not */
r_static
r_void
id|free_module
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MODULE_FORCE_UNLOAD
DECL|function|try_force
r_static
r_inline
r_int
id|try_force
c_func
(paren
r_int
r_int
id|flags
)paren
(brace
r_int
id|ret
op_assign
(paren
id|flags
op_amp
id|O_TRUNC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|tainted
op_or_assign
id|TAINT_FORCED_MODULE
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#else
DECL|function|try_force
r_static
r_inline
r_int
id|try_force
c_func
(paren
r_int
r_int
id|flags
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_MODULE_FORCE_UNLOAD */
multiline_comment|/* Stub function for modules which don&squot;t have an exitfn */
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
)brace
DECL|variable|cleanup_module
id|EXPORT_SYMBOL
c_func
(paren
id|cleanup_module
)paren
suffix:semicolon
DECL|function|wait_for_zero_refcount
r_static
r_void
id|wait_for_zero_refcount
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
multiline_comment|/* Since we might sleep for some time, drop the semaphore first */
id|up
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;Looking at refcount...&bslash;n&quot;
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|module_refcount
c_func
(paren
id|mod
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|down
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_delete_module
id|sys_delete_module
c_func
(paren
r_const
r_char
id|__user
op_star
id|name_user
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_char
id|name
(braket
id|MODULE_NAME_LEN
)braket
suffix:semicolon
r_int
id|ret
comma
id|forced
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_MODULE
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|strncpy_from_user
c_func
(paren
id|name
comma
id|name_user
comma
id|MODULE_NAME_LEN
op_minus
l_int|1
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|name
(braket
id|MODULE_NAME_LEN
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|module_mutex
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
id|mod
op_assign
id|find_module
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mod
)paren
(brace
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mod-&gt;modules_which_use_me
)paren
)paren
(brace
multiline_comment|/* Other modules depend on us: get rid of them first. */
id|ret
op_assign
op_minus
id|EWOULDBLOCK
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Already dying? */
r_if
c_cond
(paren
id|mod-&gt;state
op_eq
id|MODULE_STATE_GOING
)paren
(brace
multiline_comment|/* FIXME: if (force), slam module count and wake up&n;                   waiter --RR */
id|DEBUGP
c_func
(paren
l_string|&quot;%s already dying&bslash;n&quot;
comma
id|mod-&gt;name
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* If it has an init func, it must have an exit func to unload */
r_if
c_cond
(paren
(paren
id|mod-&gt;init
op_ne
id|init_module
op_logical_and
id|mod
op_member_access_from_pointer
m_exit
op_eq
id|cleanup_module
)paren
op_logical_or
id|mod-&gt;unsafe
)paren
(brace
id|forced
op_assign
id|try_force
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|forced
)paren
(brace
multiline_comment|/* This module can&squot;t be removed */
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/* Stop the machine so refcounts can&squot;t move: irqs disabled. */
id|DEBUGP
c_func
(paren
l_string|&quot;Stopping refcounts...&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|stop_refcounts
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* If it&squot;s not unused, quit unless we are told to block. */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|O_NONBLOCK
)paren
op_logical_and
id|module_refcount
c_func
(paren
id|mod
)paren
op_ne
l_int|0
)paren
(brace
id|forced
op_assign
id|try_force
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|forced
)paren
(brace
id|ret
op_assign
op_minus
id|EWOULDBLOCK
suffix:semicolon
id|restart_refcounts
c_func
(paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/* Mark it as dying. */
id|mod-&gt;waiter
op_assign
id|current
suffix:semicolon
id|mod-&gt;state
op_assign
id|MODULE_STATE_GOING
suffix:semicolon
id|restart_refcounts
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Never wait if forced. */
r_if
c_cond
(paren
op_logical_neg
id|forced
op_logical_and
id|module_refcount
c_func
(paren
id|mod
)paren
op_ne
l_int|0
)paren
id|wait_for_zero_refcount
c_func
(paren
id|mod
)paren
suffix:semicolon
multiline_comment|/* Final destruction now noone is using it. */
id|mod
op_member_access_from_pointer
m_exit
(paren
)paren
suffix:semicolon
id|free_module
c_func
(paren
id|mod
)paren
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|print_unload_info
r_static
r_void
id|print_unload_info
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_struct
id|module
op_star
id|mod
)paren
(brace
r_struct
id|module_use
op_star
id|use
suffix:semicolon
r_int
id|printed_something
op_assign
l_int|0
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot; %u &quot;
comma
id|module_refcount
c_func
(paren
id|mod
)paren
)paren
suffix:semicolon
multiline_comment|/* Always include a trailing , so userspace can differentiate&n;           between this and the old multi-field proc format. */
id|list_for_each_entry
c_func
(paren
id|use
comma
op_amp
id|mod-&gt;modules_which_use_me
comma
id|list
)paren
(brace
id|printed_something
op_assign
l_int|1
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;%s,&quot;
comma
id|use-&gt;module_which_uses-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod-&gt;unsafe
)paren
(brace
id|printed_something
op_assign
l_int|1
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;[unsafe],&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod-&gt;init
op_ne
id|init_module
op_logical_and
id|mod
op_member_access_from_pointer
m_exit
op_eq
id|cleanup_module
)paren
(brace
id|printed_something
op_assign
l_int|1
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;[permanent],&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|printed_something
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;-&quot;
)paren
suffix:semicolon
)brace
DECL|function|__symbol_put
r_void
id|__symbol_put
c_func
(paren
r_const
r_char
op_star
id|symbol
)paren
(brace
r_struct
id|module
op_star
id|owner
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_const
r_int
r_int
op_star
id|crc
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|__find_symbol
c_func
(paren
id|symbol
comma
op_amp
id|owner
comma
op_amp
id|crc
comma
l_int|1
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|owner
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|__symbol_put
id|EXPORT_SYMBOL
c_func
(paren
id|__symbol_put
)paren
suffix:semicolon
DECL|function|symbol_put_addr
r_void
id|symbol_put_addr
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kernel_text_address
c_func
(paren
(paren
r_int
r_int
)paren
id|addr
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|module_text_address
c_func
(paren
(paren
r_int
r_int
)paren
id|addr
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|symbol_put_addr
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|symbol_put_addr
)paren
suffix:semicolon
macro_line|#else /* !CONFIG_MODULE_UNLOAD */
DECL|function|print_unload_info
r_static
r_void
id|print_unload_info
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_struct
id|module
op_star
id|mod
)paren
(brace
multiline_comment|/* We don&squot;t know the usage count, or what modules are using. */
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot; - -&quot;
)paren
suffix:semicolon
)brace
DECL|function|module_unload_free
r_static
r_inline
r_void
id|module_unload_free
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
)brace
DECL|function|use_module
r_static
r_inline
r_int
id|use_module
c_func
(paren
r_struct
id|module
op_star
id|a
comma
r_struct
id|module
op_star
id|b
)paren
(brace
r_return
id|strong_try_module_get
c_func
(paren
id|b
)paren
suffix:semicolon
)brace
DECL|function|module_unload_init
r_static
r_inline
r_void
id|module_unload_init
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
)brace
id|asmlinkage
r_int
DECL|function|sys_delete_module
id|sys_delete_module
c_func
(paren
r_const
r_char
op_star
id|name_user
comma
r_int
r_int
id|flags
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_MODULE_UNLOAD */
macro_line|#ifdef CONFIG_OBSOLETE_MODPARM
DECL|function|param_set_byte
r_static
r_int
id|param_set_byte
c_func
(paren
r_const
r_char
op_star
id|val
comma
r_struct
id|kernel_param
op_star
id|kp
)paren
(brace
r_char
op_star
id|endp
suffix:semicolon
r_int
id|l
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|val
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|l
op_assign
id|simple_strtol
c_func
(paren
id|val
comma
op_amp
id|endp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|endp
op_eq
id|val
op_logical_or
op_star
id|endp
op_logical_or
(paren
(paren
r_char
)paren
id|l
op_ne
id|l
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
op_star
(paren
(paren
r_char
op_star
)paren
id|kp-&gt;arg
)paren
op_assign
id|l
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Bounds checking done below */
DECL|function|obsparm_copy_string
r_static
r_int
id|obsparm_copy_string
c_func
(paren
r_const
r_char
op_star
id|val
comma
r_struct
id|kernel_param
op_star
id|kp
)paren
(brace
id|strcpy
c_func
(paren
id|kp-&gt;arg
comma
id|val
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|set_obsolete
r_int
id|set_obsolete
c_func
(paren
r_const
r_char
op_star
id|val
comma
r_struct
id|kernel_param
op_star
id|kp
)paren
(brace
r_int
r_int
id|min
comma
id|max
suffix:semicolon
r_int
r_int
id|size
comma
id|maxsize
suffix:semicolon
r_char
op_star
id|endp
suffix:semicolon
r_const
r_char
op_star
id|p
suffix:semicolon
r_struct
id|obsolete_modparm
op_star
id|obsparm
op_assign
id|kp-&gt;arg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|val
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Parameter %s needs an argument&bslash;n&quot;
comma
id|kp-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* type is: [min[-max]]{b,h,i,l,s} */
id|p
op_assign
id|obsparm-&gt;type
suffix:semicolon
id|min
op_assign
id|simple_strtol
c_func
(paren
id|p
comma
op_amp
id|endp
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|endp
op_eq
id|obsparm-&gt;type
)paren
id|min
op_assign
id|max
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|endp
op_eq
l_char|&squot;-&squot;
)paren
(brace
id|p
op_assign
id|endp
op_plus
l_int|1
suffix:semicolon
id|max
op_assign
id|simple_strtol
c_func
(paren
id|p
comma
op_amp
id|endp
comma
l_int|10
)paren
suffix:semicolon
)brace
r_else
id|max
op_assign
id|min
suffix:semicolon
r_switch
c_cond
(paren
op_star
id|endp
)paren
(brace
r_case
l_char|&squot;b&squot;
suffix:colon
r_return
id|param_array
c_func
(paren
id|kp-&gt;name
comma
id|val
comma
id|min
comma
id|max
comma
id|obsparm-&gt;addr
comma
l_int|1
comma
id|param_set_byte
)paren
suffix:semicolon
r_case
l_char|&squot;h&squot;
suffix:colon
r_return
id|param_array
c_func
(paren
id|kp-&gt;name
comma
id|val
comma
id|min
comma
id|max
comma
id|obsparm-&gt;addr
comma
r_sizeof
(paren
r_int
)paren
comma
id|param_set_short
)paren
suffix:semicolon
r_case
l_char|&squot;i&squot;
suffix:colon
r_return
id|param_array
c_func
(paren
id|kp-&gt;name
comma
id|val
comma
id|min
comma
id|max
comma
id|obsparm-&gt;addr
comma
r_sizeof
(paren
r_int
)paren
comma
id|param_set_int
)paren
suffix:semicolon
r_case
l_char|&squot;l&squot;
suffix:colon
r_return
id|param_array
c_func
(paren
id|kp-&gt;name
comma
id|val
comma
id|min
comma
id|max
comma
id|obsparm-&gt;addr
comma
r_sizeof
(paren
r_int
)paren
comma
id|param_set_long
)paren
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
r_return
id|param_array
c_func
(paren
id|kp-&gt;name
comma
id|val
comma
id|min
comma
id|max
comma
id|obsparm-&gt;addr
comma
r_sizeof
(paren
r_char
op_star
)paren
comma
id|param_set_charp
)paren
suffix:semicolon
r_case
l_char|&squot;c&squot;
suffix:colon
multiline_comment|/* Undocumented: 1-5c50 means 1-5 strings of up to 49 chars,&n;&t;&t;   and the decl is &quot;char xxx[5][50];&quot; */
id|p
op_assign
id|endp
op_plus
l_int|1
suffix:semicolon
id|maxsize
op_assign
id|simple_strtol
c_func
(paren
id|p
comma
op_amp
id|endp
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/* We check lengths here (yes, this is a hack). */
id|p
op_assign
id|val
suffix:semicolon
r_while
c_loop
(paren
id|p
(braket
id|size
op_assign
id|strcspn
c_func
(paren
id|p
comma
l_string|&quot;,&quot;
)paren
)braket
)paren
(brace
r_if
c_cond
(paren
id|size
op_ge
id|maxsize
)paren
r_goto
id|oversize
suffix:semicolon
id|p
op_add_assign
id|size
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
op_ge
id|maxsize
)paren
r_goto
id|oversize
suffix:semicolon
r_return
id|param_array
c_func
(paren
id|kp-&gt;name
comma
id|val
comma
id|min
comma
id|max
comma
id|obsparm-&gt;addr
comma
id|maxsize
comma
id|obsparm_copy_string
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unknown obsolete parameter type %s&bslash;n&quot;
comma
id|obsparm-&gt;type
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
id|oversize
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Parameter %s doesn&squot;t fit in %u chars.&bslash;n&quot;
comma
id|kp-&gt;name
comma
id|maxsize
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|obsolete_params
r_static
r_int
id|obsolete_params
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_char
op_star
id|args
comma
r_struct
id|obsolete_modparm
id|obsparm
(braket
)braket
comma
r_int
r_int
id|num
comma
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|symindex
comma
r_const
r_char
op_star
id|strtab
)paren
(brace
r_struct
id|kernel_param
op_star
id|kp
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|kp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|kp
(braket
l_int|0
)braket
)paren
op_star
id|num
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kp
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
id|sym_name
(braket
l_int|128
op_plus
r_sizeof
(paren
id|MODULE_SYMBOL_PREFIX
)paren
)braket
suffix:semicolon
id|snprintf
c_func
(paren
id|sym_name
comma
r_sizeof
(paren
id|sym_name
)paren
comma
l_string|&quot;%s%s&quot;
comma
id|MODULE_SYMBOL_PREFIX
comma
id|obsparm
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|kp
(braket
id|i
)braket
dot
id|name
op_assign
id|obsparm
(braket
id|i
)braket
dot
id|name
suffix:semicolon
id|kp
(braket
id|i
)braket
dot
id|perm
op_assign
l_int|000
suffix:semicolon
id|kp
(braket
id|i
)braket
dot
id|set
op_assign
id|set_obsolete
suffix:semicolon
id|kp
(braket
id|i
)braket
dot
id|get
op_assign
l_int|NULL
suffix:semicolon
id|obsparm
(braket
id|i
)braket
dot
id|addr
op_assign
(paren
r_void
op_star
)paren
id|find_local_symbol
c_func
(paren
id|sechdrs
comma
id|symindex
comma
id|strtab
comma
id|sym_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obsparm
(braket
id|i
)braket
dot
id|addr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: falsely claims to have parameter %s&bslash;n&quot;
comma
id|name
comma
id|obsparm
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|kp
(braket
id|i
)braket
dot
id|arg
op_assign
op_amp
id|obsparm
(braket
id|i
)braket
suffix:semicolon
)brace
id|ret
op_assign
id|parse_args
c_func
(paren
id|name
comma
id|args
comma
id|kp
comma
id|num
comma
l_int|NULL
)paren
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
id|kp
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#else
DECL|function|obsolete_params
r_static
r_int
id|obsolete_params
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_char
op_star
id|args
comma
r_struct
id|obsolete_modparm
id|obsparm
(braket
)braket
comma
r_int
r_int
id|num
comma
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|symindex
comma
r_const
r_char
op_star
id|strtab
)paren
(brace
r_if
c_cond
(paren
id|num
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Ignoring obsolete parameters&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_OBSOLETE_MODPARM */
DECL|variable|vermagic
r_static
r_const
r_char
id|vermagic
(braket
)braket
op_assign
id|VERMAGIC_STRING
suffix:semicolon
macro_line|#ifdef CONFIG_MODVERSIONS
DECL|function|check_version
r_static
r_int
id|check_version
c_func
(paren
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|versindex
comma
r_const
r_char
op_star
id|symname
comma
r_struct
id|module
op_star
id|mod
comma
r_const
r_int
r_int
op_star
id|crc
)paren
(brace
r_int
r_int
id|i
comma
id|num_versions
suffix:semicolon
r_struct
id|modversion_info
op_star
id|versions
suffix:semicolon
multiline_comment|/* Exporting module didn&squot;t supply crcs?  OK, we&squot;re already tainted. */
r_if
c_cond
(paren
op_logical_neg
id|crc
)paren
r_return
l_int|1
suffix:semicolon
id|versions
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|versindex
)braket
dot
id|sh_addr
suffix:semicolon
id|num_versions
op_assign
id|sechdrs
(braket
id|versindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
r_struct
id|modversion_info
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_versions
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|versions
(braket
id|i
)braket
dot
id|name
comma
id|symname
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|versions
(braket
id|i
)braket
dot
id|crc
op_eq
op_star
id|crc
)paren
r_return
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: disagrees about version of symbol %s&bslash;n&quot;
comma
id|mod-&gt;name
comma
id|symname
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;Found checksum %lX vs module %lX&bslash;n&quot;
comma
op_star
id|crc
comma
id|versions
(braket
id|i
)braket
dot
id|crc
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Not in module&squot;s version table.  OK, but that taints the kernel. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|tainted
op_amp
id|TAINT_FORCED_MODULE
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: no version for &bslash;&quot;%s&bslash;&quot; found: kernel tainted.&bslash;n&quot;
comma
id|mod-&gt;name
comma
id|symname
)paren
suffix:semicolon
id|tainted
op_or_assign
id|TAINT_FORCED_MODULE
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|check_modstruct_version
r_static
r_inline
r_int
id|check_modstruct_version
c_func
(paren
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|versindex
comma
r_struct
id|module
op_star
id|mod
)paren
(brace
r_const
r_int
r_int
op_star
id|crc
suffix:semicolon
r_struct
id|module
op_star
id|owner
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|__find_symbol
c_func
(paren
l_string|&quot;struct_module&quot;
comma
op_amp
id|owner
comma
op_amp
id|crc
comma
l_int|1
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
id|check_version
c_func
(paren
id|sechdrs
comma
id|versindex
comma
l_string|&quot;struct_module&quot;
comma
id|mod
comma
id|crc
)paren
suffix:semicolon
)brace
multiline_comment|/* First part is kernel version, which we ignore. */
DECL|function|same_magic
r_static
r_inline
r_int
id|same_magic
c_func
(paren
r_const
r_char
op_star
id|amagic
comma
r_const
r_char
op_star
id|bmagic
)paren
(brace
id|amagic
op_add_assign
id|strcspn
c_func
(paren
id|amagic
comma
l_string|&quot; &quot;
)paren
suffix:semicolon
id|bmagic
op_add_assign
id|strcspn
c_func
(paren
id|bmagic
comma
l_string|&quot; &quot;
)paren
suffix:semicolon
r_return
id|strcmp
c_func
(paren
id|amagic
comma
id|bmagic
)paren
op_eq
l_int|0
suffix:semicolon
)brace
macro_line|#else
DECL|function|check_version
r_static
r_inline
r_int
id|check_version
c_func
(paren
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|versindex
comma
r_const
r_char
op_star
id|symname
comma
r_struct
id|module
op_star
id|mod
comma
r_const
r_int
r_int
op_star
id|crc
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|check_modstruct_version
r_static
r_inline
r_int
id|check_modstruct_version
c_func
(paren
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|versindex
comma
r_struct
id|module
op_star
id|mod
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|same_magic
r_static
r_inline
r_int
id|same_magic
c_func
(paren
r_const
r_char
op_star
id|amagic
comma
r_const
r_char
op_star
id|bmagic
)paren
(brace
r_return
id|strcmp
c_func
(paren
id|amagic
comma
id|bmagic
)paren
op_eq
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_MODVERSIONS */
multiline_comment|/* Resolve a symbol for this module.  I.e. if we find one, record usage.&n;   Must be holding module_mutex. */
DECL|function|resolve_symbol
r_static
r_int
r_int
id|resolve_symbol
c_func
(paren
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|versindex
comma
r_const
r_char
op_star
id|name
comma
r_struct
id|module
op_star
id|mod
)paren
(brace
r_struct
id|module
op_star
id|owner
suffix:semicolon
r_int
r_int
id|ret
suffix:semicolon
r_const
r_int
r_int
op_star
id|crc
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
id|ret
op_assign
id|__find_symbol
c_func
(paren
id|name
comma
op_amp
id|owner
comma
op_amp
id|crc
comma
id|mod-&gt;license_gplok
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/* use_module can fail due to OOM, or module unloading */
r_if
c_cond
(paren
op_logical_neg
id|check_version
c_func
(paren
id|sechdrs
comma
id|versindex
comma
id|name
comma
id|mod
comma
id|crc
)paren
op_logical_or
op_logical_neg
id|use_module
c_func
(paren
id|mod
comma
id|owner
)paren
)paren
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Free a module, remove from lists, etc (must hold module mutex). */
DECL|function|free_module
r_static
r_void
id|free_module
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
multiline_comment|/* Delete from various lists */
id|spin_lock_irq
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|mod-&gt;list
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
multiline_comment|/* Arch-specific cleanup. */
id|module_arch_cleanup
c_func
(paren
id|mod
)paren
suffix:semicolon
multiline_comment|/* Module unload stuff */
id|module_unload_free
c_func
(paren
id|mod
)paren
suffix:semicolon
multiline_comment|/* This may be NULL, but that&squot;s OK */
id|module_free
c_func
(paren
id|mod
comma
id|mod-&gt;module_init
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mod-&gt;args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;percpu
)paren
id|percpu_modfree
c_func
(paren
id|mod-&gt;percpu
)paren
suffix:semicolon
multiline_comment|/* Finally, free the core (containing the module structure) */
id|module_free
c_func
(paren
id|mod
comma
id|mod-&gt;module_core
)paren
suffix:semicolon
)brace
DECL|function|__symbol_get
r_void
op_star
id|__symbol_get
c_func
(paren
r_const
r_char
op_star
id|symbol
)paren
(brace
r_struct
id|module
op_star
id|owner
suffix:semicolon
r_int
r_int
id|value
comma
id|flags
suffix:semicolon
r_const
r_int
r_int
op_star
id|crc
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
id|value
op_assign
id|__find_symbol
c_func
(paren
id|symbol
comma
op_amp
id|owner
comma
op_amp
id|crc
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_logical_and
op_logical_neg
id|strong_try_module_get
c_func
(paren
id|owner
)paren
)paren
id|value
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|value
suffix:semicolon
)brace
DECL|variable|__symbol_get
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|__symbol_get
)paren
suffix:semicolon
multiline_comment|/* Change all symbols so that sh_value encodes the pointer directly. */
DECL|function|simplify_symbols
r_static
r_int
id|simplify_symbols
c_func
(paren
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|symindex
comma
r_const
r_char
op_star
id|strtab
comma
r_int
r_int
id|versindex
comma
r_int
r_int
id|pcpuindex
comma
r_struct
id|module
op_star
id|mod
)paren
(brace
id|Elf_Sym
op_star
id|sym
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_addr
suffix:semicolon
r_int
r_int
id|secbase
suffix:semicolon
r_int
r_int
id|i
comma
id|n
op_assign
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
id|Elf_Sym
)paren
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|sym
(braket
id|i
)braket
dot
id|st_shndx
)paren
(brace
r_case
id|SHN_COMMON
suffix:colon
multiline_comment|/* We compiled with -fno-common.  These are not&n;&t;&t;&t;   supposed to happen.  */
id|DEBUGP
c_func
(paren
l_string|&quot;Common symbol: %s&bslash;n&quot;
comma
id|strtab
op_plus
id|sym
(braket
id|i
)braket
dot
id|st_name
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOEXEC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SHN_ABS
suffix:colon
multiline_comment|/* Don&squot;t need to do anything */
id|DEBUGP
c_func
(paren
l_string|&quot;Absolute symbol: 0x%08lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|sym
(braket
id|i
)braket
dot
id|st_value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SHN_UNDEF
suffix:colon
id|sym
(braket
id|i
)braket
dot
id|st_value
op_assign
id|resolve_symbol
c_func
(paren
id|sechdrs
comma
id|versindex
comma
id|strtab
op_plus
id|sym
(braket
id|i
)braket
dot
id|st_name
comma
id|mod
)paren
suffix:semicolon
multiline_comment|/* Ok if resolved.  */
r_if
c_cond
(paren
id|sym
(braket
id|i
)braket
dot
id|st_value
op_ne
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* Ok if weak.  */
r_if
c_cond
(paren
id|ELF_ST_BIND
c_func
(paren
id|sym
(braket
id|i
)braket
dot
id|st_info
)paren
op_eq
id|STB_WEAK
)paren
r_break
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Unknown symbol %s&bslash;n&quot;
comma
id|mod-&gt;name
comma
id|strtab
op_plus
id|sym
(braket
id|i
)braket
dot
id|st_name
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* Divert to percpu allocation if a percpu var. */
r_if
c_cond
(paren
id|sym
(braket
id|i
)braket
dot
id|st_shndx
op_eq
id|pcpuindex
)paren
id|secbase
op_assign
(paren
r_int
r_int
)paren
id|mod-&gt;percpu
suffix:semicolon
r_else
id|secbase
op_assign
id|sechdrs
(braket
id|sym
(braket
id|i
)braket
dot
id|st_shndx
)braket
dot
id|sh_addr
suffix:semicolon
id|sym
(braket
id|i
)braket
dot
id|st_value
op_add_assign
id|secbase
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Update size with this section: return offset. */
DECL|function|get_offset
r_static
r_int
id|get_offset
c_func
(paren
r_int
r_int
op_star
id|size
comma
id|Elf_Shdr
op_star
id|sechdr
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|ALIGN
c_func
(paren
op_star
id|size
comma
id|sechdr-&gt;sh_addralign
ques
c_cond
suffix:colon
l_int|1
)paren
suffix:semicolon
op_star
id|size
op_assign
id|ret
op_plus
id|sechdr-&gt;sh_size
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Lay out the SHF_ALLOC sections in a way not dissimilar to how ld&n;   might -- code, read-only data, read-write data, small data.  Tally&n;   sizes, and place the offsets into sh_entsize fields: high bit means it&n;   belongs in init. */
DECL|function|layout_sections
r_static
r_void
id|layout_sections
c_func
(paren
r_struct
id|module
op_star
id|mod
comma
r_const
id|Elf_Ehdr
op_star
id|hdr
comma
id|Elf_Shdr
op_star
id|sechdrs
comma
r_const
r_char
op_star
id|secstrings
)paren
(brace
r_static
r_int
r_int
r_const
id|masks
(braket
)braket
(braket
l_int|2
)braket
op_assign
(brace
multiline_comment|/* NOTE: all executable code must be the first section&n;&t;&t; * in this array; otherwise modify the text_size&n;&t;&t; * finder in the two loops below */
(brace
id|SHF_EXECINSTR
op_or
id|SHF_ALLOC
comma
id|ARCH_SHF_SMALL
)brace
comma
(brace
id|SHF_ALLOC
comma
id|SHF_WRITE
op_or
id|ARCH_SHF_SMALL
)brace
comma
(brace
id|SHF_WRITE
op_or
id|SHF_ALLOC
comma
id|ARCH_SHF_SMALL
)brace
comma
(brace
id|ARCH_SHF_SMALL
op_or
id|SHF_ALLOC
comma
l_int|0
)brace
)brace
suffix:semicolon
r_int
r_int
id|m
comma
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hdr-&gt;e_shnum
suffix:semicolon
id|i
op_increment
)paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_entsize
op_assign
op_complement
l_int|0UL
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;Core section allocation order:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|ARRAY_SIZE
c_func
(paren
id|masks
)paren
suffix:semicolon
op_increment
id|m
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hdr-&gt;e_shnum
suffix:semicolon
op_increment
id|i
)paren
(brace
id|Elf_Shdr
op_star
id|s
op_assign
op_amp
id|sechdrs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s-&gt;sh_flags
op_amp
id|masks
(braket
id|m
)braket
(braket
l_int|0
)braket
)paren
op_ne
id|masks
(braket
id|m
)braket
(braket
l_int|0
)braket
op_logical_or
(paren
id|s-&gt;sh_flags
op_amp
id|masks
(braket
id|m
)braket
(braket
l_int|1
)braket
)paren
op_logical_or
id|s-&gt;sh_entsize
op_ne
op_complement
l_int|0UL
op_logical_or
id|strstr
c_func
(paren
id|secstrings
op_plus
id|s-&gt;sh_name
comma
l_string|&quot;.init&quot;
)paren
)paren
r_continue
suffix:semicolon
id|s-&gt;sh_entsize
op_assign
id|get_offset
c_func
(paren
op_amp
id|mod-&gt;core_size
comma
id|s
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;&bslash;t%s&bslash;n&quot;
comma
id|secstrings
op_plus
id|s-&gt;sh_name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m
op_eq
l_int|0
)paren
id|mod-&gt;core_text_size
op_assign
id|mod-&gt;core_size
suffix:semicolon
)brace
id|DEBUGP
c_func
(paren
l_string|&quot;Init section allocation order:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|ARRAY_SIZE
c_func
(paren
id|masks
)paren
suffix:semicolon
op_increment
id|m
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hdr-&gt;e_shnum
suffix:semicolon
op_increment
id|i
)paren
(brace
id|Elf_Shdr
op_star
id|s
op_assign
op_amp
id|sechdrs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s-&gt;sh_flags
op_amp
id|masks
(braket
id|m
)braket
(braket
l_int|0
)braket
)paren
op_ne
id|masks
(braket
id|m
)braket
(braket
l_int|0
)braket
op_logical_or
(paren
id|s-&gt;sh_flags
op_amp
id|masks
(braket
id|m
)braket
(braket
l_int|1
)braket
)paren
op_logical_or
id|s-&gt;sh_entsize
op_ne
op_complement
l_int|0UL
op_logical_or
op_logical_neg
id|strstr
c_func
(paren
id|secstrings
op_plus
id|s-&gt;sh_name
comma
l_string|&quot;.init&quot;
)paren
)paren
r_continue
suffix:semicolon
id|s-&gt;sh_entsize
op_assign
(paren
id|get_offset
c_func
(paren
op_amp
id|mod-&gt;init_size
comma
id|s
)paren
op_or
id|INIT_OFFSET_MASK
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;&bslash;t%s&bslash;n&quot;
comma
id|secstrings
op_plus
id|s-&gt;sh_name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m
op_eq
l_int|0
)paren
id|mod-&gt;init_text_size
op_assign
id|mod-&gt;init_size
suffix:semicolon
)brace
)brace
DECL|function|license_is_gpl_compatible
r_static
r_inline
r_int
id|license_is_gpl_compatible
c_func
(paren
r_const
r_char
op_star
id|license
)paren
(brace
r_return
(paren
id|strcmp
c_func
(paren
id|license
comma
l_string|&quot;GPL&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
c_func
(paren
id|license
comma
l_string|&quot;GPL v2&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
c_func
(paren
id|license
comma
l_string|&quot;GPL and additional rights&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
c_func
(paren
id|license
comma
l_string|&quot;Dual BSD/GPL&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
c_func
(paren
id|license
comma
l_string|&quot;Dual MPL/GPL&quot;
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|set_license
r_static
r_void
id|set_license
c_func
(paren
r_struct
id|module
op_star
id|mod
comma
r_const
r_char
op_star
id|license
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|license
)paren
id|license
op_assign
l_string|&quot;unspecified&quot;
suffix:semicolon
id|mod-&gt;license_gplok
op_assign
id|license_is_gpl_compatible
c_func
(paren
id|license
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mod-&gt;license_gplok
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: module license &squot;%s&squot; taints kernel.&bslash;n&quot;
comma
id|mod-&gt;name
comma
id|license
)paren
suffix:semicolon
id|tainted
op_or_assign
id|TAINT_PROPRIETARY_MODULE
suffix:semicolon
)brace
)brace
multiline_comment|/* Parse tag=value strings from .modinfo section */
DECL|function|next_string
r_static
r_char
op_star
id|next_string
c_func
(paren
r_char
op_star
id|string
comma
r_int
r_int
op_star
id|secsize
)paren
(brace
multiline_comment|/* Skip non-zero chars */
r_while
c_loop
(paren
id|string
(braket
l_int|0
)braket
)paren
(brace
id|string
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|secsize
)paren
op_decrement
op_le
l_int|1
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Skip any zero padding. */
r_while
c_loop
(paren
op_logical_neg
id|string
(braket
l_int|0
)braket
)paren
(brace
id|string
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|secsize
)paren
op_decrement
op_le
l_int|1
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|string
suffix:semicolon
)brace
DECL|function|get_modinfo
r_static
r_char
op_star
id|get_modinfo
c_func
(paren
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|info
comma
r_const
r_char
op_star
id|tag
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_int
r_int
id|taglen
op_assign
id|strlen
c_func
(paren
id|tag
)paren
suffix:semicolon
r_int
r_int
id|size
op_assign
id|sechdrs
(braket
id|info
)braket
dot
id|sh_size
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
(paren
r_char
op_star
)paren
id|sechdrs
(braket
id|info
)braket
dot
id|sh_addr
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|next_string
c_func
(paren
id|p
comma
op_amp
id|size
)paren
)paren
(brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|p
comma
id|tag
comma
id|taglen
)paren
op_eq
l_int|0
op_logical_and
id|p
(braket
id|taglen
)braket
op_eq
l_char|&squot;=&squot;
)paren
r_return
id|p
op_plus
id|taglen
op_plus
l_int|1
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_KALLSYMS
DECL|function|is_exported
r_int
id|is_exported
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_struct
id|module
op_star
id|mod
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mod
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|__start___ksymtab
op_plus
id|i
OL
id|__stop___ksymtab
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|__start___ksymtab
(braket
id|i
)braket
dot
id|name
comma
id|name
)paren
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mod-&gt;num_syms
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|mod-&gt;syms
(braket
id|i
)braket
dot
id|name
comma
id|name
)paren
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* As per nm */
DECL|function|elf_type
r_static
r_char
id|elf_type
c_func
(paren
r_const
id|Elf_Sym
op_star
id|sym
comma
id|Elf_Shdr
op_star
id|sechdrs
comma
r_const
r_char
op_star
id|secstrings
comma
r_struct
id|module
op_star
id|mod
)paren
(brace
r_if
c_cond
(paren
id|ELF_ST_BIND
c_func
(paren
id|sym-&gt;st_info
)paren
op_eq
id|STB_WEAK
)paren
(brace
r_if
c_cond
(paren
id|ELF_ST_TYPE
c_func
(paren
id|sym-&gt;st_info
)paren
op_eq
id|STT_OBJECT
)paren
r_return
l_char|&squot;v&squot;
suffix:semicolon
r_else
r_return
l_char|&squot;w&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sym-&gt;st_shndx
op_eq
id|SHN_UNDEF
)paren
r_return
l_char|&squot;U&squot;
suffix:semicolon
r_if
c_cond
(paren
id|sym-&gt;st_shndx
op_eq
id|SHN_ABS
)paren
r_return
l_char|&squot;a&squot;
suffix:semicolon
r_if
c_cond
(paren
id|sym-&gt;st_shndx
op_ge
id|SHN_LORESERVE
)paren
r_return
l_char|&squot;?&squot;
suffix:semicolon
r_if
c_cond
(paren
id|sechdrs
(braket
id|sym-&gt;st_shndx
)braket
dot
id|sh_flags
op_amp
id|SHF_EXECINSTR
)paren
r_return
l_char|&squot;t&squot;
suffix:semicolon
r_if
c_cond
(paren
id|sechdrs
(braket
id|sym-&gt;st_shndx
)braket
dot
id|sh_flags
op_amp
id|SHF_ALLOC
op_logical_and
id|sechdrs
(braket
id|sym-&gt;st_shndx
)braket
dot
id|sh_type
op_ne
id|SHT_NOBITS
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|sechdrs
(braket
id|sym-&gt;st_shndx
)braket
dot
id|sh_flags
op_amp
id|SHF_WRITE
)paren
)paren
r_return
l_char|&squot;r&squot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sechdrs
(braket
id|sym-&gt;st_shndx
)braket
dot
id|sh_flags
op_amp
id|ARCH_SHF_SMALL
)paren
r_return
l_char|&squot;g&squot;
suffix:semicolon
r_else
r_return
l_char|&squot;d&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sechdrs
(braket
id|sym-&gt;st_shndx
)braket
dot
id|sh_type
op_eq
id|SHT_NOBITS
)paren
(brace
r_if
c_cond
(paren
id|sechdrs
(braket
id|sym-&gt;st_shndx
)braket
dot
id|sh_flags
op_amp
id|ARCH_SHF_SMALL
)paren
r_return
l_char|&squot;s&squot;
suffix:semicolon
r_else
r_return
l_char|&squot;b&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|sym-&gt;st_shndx
)braket
dot
id|sh_name
comma
l_string|&quot;.debug&quot;
comma
id|strlen
c_func
(paren
l_string|&quot;.debug&quot;
)paren
)paren
op_eq
l_int|0
)paren
r_return
l_char|&squot;n&squot;
suffix:semicolon
r_return
l_char|&squot;?&squot;
suffix:semicolon
)brace
DECL|function|add_kallsyms
r_static
r_void
id|add_kallsyms
c_func
(paren
r_struct
id|module
op_star
id|mod
comma
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|symindex
comma
r_int
r_int
id|strindex
comma
r_const
r_char
op_star
id|secstrings
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|mod-&gt;symtab
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_addr
suffix:semicolon
id|mod-&gt;num_symtab
op_assign
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
id|Elf_Sym
)paren
suffix:semicolon
id|mod-&gt;strtab
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|strindex
)braket
dot
id|sh_addr
suffix:semicolon
multiline_comment|/* Set types up while we still have access to sections. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mod-&gt;num_symtab
suffix:semicolon
id|i
op_increment
)paren
id|mod-&gt;symtab
(braket
id|i
)braket
dot
id|st_info
op_assign
id|elf_type
c_func
(paren
op_amp
id|mod-&gt;symtab
(braket
id|i
)braket
comma
id|sechdrs
comma
id|secstrings
comma
id|mod
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Allocate and load the module: note that size of section 0 is always&n;   zero, and we rely on this for optional sections. */
DECL|function|load_module
r_static
r_struct
id|module
op_star
id|load_module
c_func
(paren
r_void
id|__user
op_star
id|umod
comma
r_int
r_int
id|len
comma
r_const
r_char
id|__user
op_star
id|uargs
)paren
(brace
id|Elf_Ehdr
op_star
id|hdr
suffix:semicolon
id|Elf_Shdr
op_star
id|sechdrs
suffix:semicolon
r_char
op_star
id|secstrings
comma
op_star
id|args
comma
op_star
id|modmagic
comma
op_star
id|strtab
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|i
comma
id|symindex
op_assign
l_int|0
comma
id|strindex
op_assign
l_int|0
comma
id|setupindex
comma
id|exindex
comma
id|exportindex
comma
id|modindex
comma
id|obsparmindex
comma
id|infoindex
comma
id|gplindex
comma
id|crcindex
comma
id|gplcrcindex
comma
id|versindex
comma
id|pcpuindex
suffix:semicolon
r_int
id|arglen
suffix:semicolon
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_void
op_star
id|percpu
op_assign
l_int|NULL
comma
op_star
id|ptr
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Stops spurious gcc warning */
id|DEBUGP
c_func
(paren
l_string|&quot;load_module: umod=%p, len=%lu, uargs=%p&bslash;n&quot;
comma
id|umod
comma
id|len
comma
id|uargs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
op_star
id|hdr
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOEXEC
)paren
suffix:semicolon
multiline_comment|/* Suck in entire file: we&squot;ll want most of it. */
multiline_comment|/* vmalloc barfs on &quot;unusual&quot; numbers.  Check here */
r_if
c_cond
(paren
id|len
OG
l_int|64
op_star
l_int|1024
op_star
l_int|1024
op_logical_or
(paren
id|hdr
op_assign
id|vmalloc
c_func
(paren
id|len
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|hdr
comma
id|umod
comma
id|len
)paren
op_ne
l_int|0
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|free_hdr
suffix:semicolon
)brace
multiline_comment|/* Sanity checks against insmoding binaries or wrong arch,&n;           weird elf version */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|hdr-&gt;e_ident
comma
id|ELFMAG
comma
l_int|4
)paren
op_ne
l_int|0
op_logical_or
id|hdr-&gt;e_type
op_ne
id|ET_REL
op_logical_or
op_logical_neg
id|elf_check_arch
c_func
(paren
id|hdr
)paren
op_logical_or
id|hdr-&gt;e_shentsize
op_ne
r_sizeof
(paren
op_star
id|sechdrs
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOEXEC
suffix:semicolon
r_goto
id|free_hdr
suffix:semicolon
)brace
multiline_comment|/* Convenience variables */
id|sechdrs
op_assign
(paren
r_void
op_star
)paren
id|hdr
op_plus
id|hdr-&gt;e_shoff
suffix:semicolon
id|secstrings
op_assign
(paren
r_void
op_star
)paren
id|hdr
op_plus
id|sechdrs
(braket
id|hdr-&gt;e_shstrndx
)braket
dot
id|sh_offset
suffix:semicolon
id|sechdrs
(braket
l_int|0
)braket
dot
id|sh_addr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* And these should exist, but gcc whinges if we don&squot;t init them */
id|symindex
op_assign
id|strindex
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|hdr-&gt;e_shnum
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Mark all sections sh_addr with their address in the&n;&t;&t;   temporary image. */
id|sechdrs
(braket
id|i
)braket
dot
id|sh_addr
op_assign
(paren
r_int
)paren
id|hdr
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_offset
suffix:semicolon
multiline_comment|/* Internal symbols and strings. */
r_if
c_cond
(paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_SYMTAB
)paren
(brace
id|symindex
op_assign
id|i
suffix:semicolon
id|strindex
op_assign
id|sechdrs
(braket
id|i
)braket
dot
id|sh_link
suffix:semicolon
id|strtab
op_assign
(paren
r_char
op_star
)paren
id|hdr
op_plus
id|sechdrs
(braket
id|strindex
)braket
dot
id|sh_offset
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_MODULE_UNLOAD
multiline_comment|/* Don&squot;t load .exit sections */
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
comma
l_string|&quot;.exit&quot;
)paren
)paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_flags
op_and_assign
op_complement
(paren
r_int
r_int
)paren
id|SHF_ALLOC
suffix:semicolon
macro_line|#endif
)brace
id|modindex
op_assign
id|find_sec
c_func
(paren
id|hdr
comma
id|sechdrs
comma
id|secstrings
comma
l_string|&quot;.gnu.linkonce.this_module&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|modindex
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;No module found in object&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOEXEC
suffix:semicolon
r_goto
id|free_hdr
suffix:semicolon
)brace
id|mod
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|modindex
)braket
dot
id|sh_addr
suffix:semicolon
multiline_comment|/* Optional sections */
id|exportindex
op_assign
id|find_sec
c_func
(paren
id|hdr
comma
id|sechdrs
comma
id|secstrings
comma
l_string|&quot;__ksymtab&quot;
)paren
suffix:semicolon
id|gplindex
op_assign
id|find_sec
c_func
(paren
id|hdr
comma
id|sechdrs
comma
id|secstrings
comma
l_string|&quot;__ksymtab_gpl&quot;
)paren
suffix:semicolon
id|crcindex
op_assign
id|find_sec
c_func
(paren
id|hdr
comma
id|sechdrs
comma
id|secstrings
comma
l_string|&quot;__kcrctab&quot;
)paren
suffix:semicolon
id|gplcrcindex
op_assign
id|find_sec
c_func
(paren
id|hdr
comma
id|sechdrs
comma
id|secstrings
comma
l_string|&quot;__kcrctab_gpl&quot;
)paren
suffix:semicolon
id|setupindex
op_assign
id|find_sec
c_func
(paren
id|hdr
comma
id|sechdrs
comma
id|secstrings
comma
l_string|&quot;__param&quot;
)paren
suffix:semicolon
id|exindex
op_assign
id|find_sec
c_func
(paren
id|hdr
comma
id|sechdrs
comma
id|secstrings
comma
l_string|&quot;__ex_table&quot;
)paren
suffix:semicolon
id|obsparmindex
op_assign
id|find_sec
c_func
(paren
id|hdr
comma
id|sechdrs
comma
id|secstrings
comma
l_string|&quot;__obsparm&quot;
)paren
suffix:semicolon
id|versindex
op_assign
id|find_sec
c_func
(paren
id|hdr
comma
id|sechdrs
comma
id|secstrings
comma
l_string|&quot;__versions&quot;
)paren
suffix:semicolon
id|infoindex
op_assign
id|find_sec
c_func
(paren
id|hdr
comma
id|sechdrs
comma
id|secstrings
comma
l_string|&quot;.modinfo&quot;
)paren
suffix:semicolon
id|pcpuindex
op_assign
id|find_pcpusec
c_func
(paren
id|hdr
comma
id|sechdrs
comma
id|secstrings
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t keep modinfo section */
id|sechdrs
(braket
id|infoindex
)braket
dot
id|sh_flags
op_and_assign
op_complement
(paren
r_int
r_int
)paren
id|SHF_ALLOC
suffix:semicolon
macro_line|#ifdef CONFIG_KALLSYMS
multiline_comment|/* Keep symbol and string tables for decoding later. */
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_flags
op_or_assign
id|SHF_ALLOC
suffix:semicolon
id|sechdrs
(braket
id|strindex
)braket
dot
id|sh_flags
op_or_assign
id|SHF_ALLOC
suffix:semicolon
macro_line|#endif
multiline_comment|/* Check module struct version now, before we try to use module. */
r_if
c_cond
(paren
op_logical_neg
id|check_modstruct_version
c_func
(paren
id|sechdrs
comma
id|versindex
comma
id|mod
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOEXEC
suffix:semicolon
r_goto
id|free_hdr
suffix:semicolon
)brace
id|modmagic
op_assign
id|get_modinfo
c_func
(paren
id|sechdrs
comma
id|infoindex
comma
l_string|&quot;vermagic&quot;
)paren
suffix:semicolon
multiline_comment|/* This is allowed: modprobe --force will invalidate it. */
r_if
c_cond
(paren
op_logical_neg
id|modmagic
)paren
(brace
id|tainted
op_or_assign
id|TAINT_FORCED_MODULE
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: no version magic, tainting kernel.&bslash;n&quot;
comma
id|mod-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|same_magic
c_func
(paren
id|modmagic
comma
id|vermagic
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: version magic &squot;%s&squot; should be &squot;%s&squot;&bslash;n&quot;
comma
id|mod-&gt;name
comma
id|modmagic
comma
id|vermagic
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOEXEC
suffix:semicolon
r_goto
id|free_hdr
suffix:semicolon
)brace
multiline_comment|/* Now copy in args */
id|arglen
op_assign
id|strlen_user
c_func
(paren
id|uargs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arglen
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|free_hdr
suffix:semicolon
)brace
id|args
op_assign
id|kmalloc
c_func
(paren
id|arglen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|args
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|free_hdr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|args
comma
id|uargs
comma
id|arglen
)paren
op_ne
l_int|0
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|free_mod
suffix:semicolon
)brace
r_if
c_cond
(paren
id|find_module
c_func
(paren
id|mod-&gt;name
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
id|free_mod
suffix:semicolon
)brace
id|mod-&gt;state
op_assign
id|MODULE_STATE_COMING
suffix:semicolon
multiline_comment|/* Allow arches to frob section contents and sizes.  */
id|err
op_assign
id|module_frob_arch_sections
c_func
(paren
id|hdr
comma
id|sechdrs
comma
id|secstrings
comma
id|mod
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|free_mod
suffix:semicolon
r_if
c_cond
(paren
id|pcpuindex
)paren
(brace
multiline_comment|/* We have a special allocation for this section. */
id|percpu
op_assign
id|percpu_modalloc
c_func
(paren
id|sechdrs
(braket
id|pcpuindex
)braket
dot
id|sh_size
comma
id|sechdrs
(braket
id|pcpuindex
)braket
dot
id|sh_addralign
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|percpu
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|free_mod
suffix:semicolon
)brace
id|sechdrs
(braket
id|pcpuindex
)braket
dot
id|sh_flags
op_and_assign
op_complement
(paren
r_int
r_int
)paren
id|SHF_ALLOC
suffix:semicolon
id|mod-&gt;percpu
op_assign
id|percpu
suffix:semicolon
)brace
multiline_comment|/* Determine total sizes, and put offsets in sh_entsize.  For now&n;&t;   this is done generically; there doesn&squot;t appear to be any&n;&t;   special cases for the architectures. */
id|layout_sections
c_func
(paren
id|mod
comma
id|hdr
comma
id|sechdrs
comma
id|secstrings
)paren
suffix:semicolon
multiline_comment|/* Do the allocs. */
id|ptr
op_assign
id|module_alloc
c_func
(paren
id|mod-&gt;core_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|free_percpu
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ptr
comma
l_int|0
comma
id|mod-&gt;core_size
)paren
suffix:semicolon
id|mod-&gt;module_core
op_assign
id|ptr
suffix:semicolon
id|ptr
op_assign
id|module_alloc
c_func
(paren
id|mod-&gt;init_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
op_logical_and
id|mod-&gt;init_size
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|free_core
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ptr
comma
l_int|0
comma
id|mod-&gt;init_size
)paren
suffix:semicolon
id|mod-&gt;module_init
op_assign
id|ptr
suffix:semicolon
multiline_comment|/* Transfer each section which specifies SHF_ALLOC */
id|DEBUGP
c_func
(paren
l_string|&quot;final section addresses:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hdr-&gt;e_shnum
suffix:semicolon
id|i
op_increment
)paren
(brace
r_void
op_star
id|dest
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_flags
op_amp
id|SHF_ALLOC
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_entsize
op_amp
id|INIT_OFFSET_MASK
)paren
id|dest
op_assign
id|mod-&gt;module_init
op_plus
(paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_entsize
op_amp
op_complement
id|INIT_OFFSET_MASK
)paren
suffix:semicolon
r_else
id|dest
op_assign
id|mod-&gt;module_core
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_entsize
suffix:semicolon
r_if
c_cond
(paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_ne
id|SHT_NOBITS
)paren
id|memcpy
c_func
(paren
id|dest
comma
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_addr
comma
id|sechdrs
(braket
id|i
)braket
dot
id|sh_size
)paren
suffix:semicolon
multiline_comment|/* Update sh_addr to point to copy in image. */
id|sechdrs
(braket
id|i
)braket
dot
id|sh_addr
op_assign
(paren
r_int
r_int
)paren
id|dest
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;&bslash;t0x%lx %s&bslash;n&quot;
comma
id|sechdrs
(braket
id|i
)braket
dot
id|sh_addr
comma
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
)paren
suffix:semicolon
)brace
multiline_comment|/* Module has been moved. */
id|mod
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|modindex
)braket
dot
id|sh_addr
suffix:semicolon
multiline_comment|/* Now we&squot;ve moved module, initialize linked lists, etc. */
id|module_unload_init
c_func
(paren
id|mod
)paren
suffix:semicolon
multiline_comment|/* Set up license info based on the info section */
id|set_license
c_func
(paren
id|mod
comma
id|get_modinfo
c_func
(paren
id|sechdrs
comma
id|infoindex
comma
l_string|&quot;license&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Fix up syms, so that st_value is a pointer to location. */
id|err
op_assign
id|simplify_symbols
c_func
(paren
id|sechdrs
comma
id|symindex
comma
id|strtab
comma
id|versindex
comma
id|pcpuindex
comma
id|mod
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|cleanup
suffix:semicolon
multiline_comment|/* Set up EXPORTed &amp; EXPORT_GPLed symbols (section 0 is 0 length) */
id|mod-&gt;num_syms
op_assign
id|sechdrs
(braket
id|exportindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
op_star
id|mod-&gt;syms
)paren
suffix:semicolon
id|mod-&gt;syms
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|exportindex
)braket
dot
id|sh_addr
suffix:semicolon
r_if
c_cond
(paren
id|crcindex
)paren
id|mod-&gt;crcs
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|crcindex
)braket
dot
id|sh_addr
suffix:semicolon
id|mod-&gt;num_gpl_syms
op_assign
id|sechdrs
(braket
id|gplindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
op_star
id|mod-&gt;gpl_syms
)paren
suffix:semicolon
id|mod-&gt;gpl_syms
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|gplindex
)braket
dot
id|sh_addr
suffix:semicolon
r_if
c_cond
(paren
id|gplcrcindex
)paren
id|mod-&gt;gpl_crcs
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|gplcrcindex
)braket
dot
id|sh_addr
suffix:semicolon
macro_line|#ifdef CONFIG_MODVERSIONS
r_if
c_cond
(paren
(paren
id|mod-&gt;num_syms
op_logical_and
op_logical_neg
id|crcindex
)paren
op_logical_or
(paren
id|mod-&gt;num_gpl_syms
op_logical_and
op_logical_neg
id|gplcrcindex
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: No versions for exported symbols.&quot;
l_string|&quot; Tainting kernel.&bslash;n&quot;
comma
id|mod-&gt;name
)paren
suffix:semicolon
id|tainted
op_or_assign
id|TAINT_FORCED_MODULE
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Set up exception table */
id|mod-&gt;num_exentries
op_assign
id|sechdrs
(braket
id|exindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
op_star
id|mod-&gt;extable
)paren
suffix:semicolon
id|mod-&gt;extable
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|exindex
)braket
dot
id|sh_addr
suffix:semicolon
multiline_comment|/* Now do relocations. */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|hdr-&gt;e_shnum
suffix:semicolon
id|i
op_increment
)paren
(brace
r_const
r_char
op_star
id|strtab
op_assign
(paren
r_char
op_star
)paren
id|sechdrs
(braket
id|strindex
)braket
dot
id|sh_addr
suffix:semicolon
r_if
c_cond
(paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_REL
)paren
id|err
op_assign
id|apply_relocate
c_func
(paren
id|sechdrs
comma
id|strtab
comma
id|symindex
comma
id|i
comma
id|mod
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_RELA
)paren
id|err
op_assign
id|apply_relocate_add
c_func
(paren
id|sechdrs
comma
id|strtab
comma
id|symindex
comma
id|i
comma
id|mod
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/* Finally, copy percpu area over. */
id|percpu_modcopy
c_func
(paren
id|mod-&gt;percpu
comma
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|pcpuindex
)braket
dot
id|sh_addr
comma
id|sechdrs
(braket
id|pcpuindex
)braket
dot
id|sh_size
)paren
suffix:semicolon
id|err
op_assign
id|module_finalize
c_func
(paren
id|hdr
comma
id|sechdrs
comma
id|mod
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|cleanup
suffix:semicolon
macro_line|#ifdef CONFIG_KALLSYMS
id|add_kallsyms
c_func
(paren
id|mod
comma
id|sechdrs
comma
id|symindex
comma
id|strindex
comma
id|secstrings
)paren
suffix:semicolon
macro_line|#endif
id|mod-&gt;args
op_assign
id|args
suffix:semicolon
r_if
c_cond
(paren
id|obsparmindex
)paren
(brace
id|err
op_assign
id|obsolete_params
c_func
(paren
id|mod-&gt;name
comma
id|mod-&gt;args
comma
(paren
r_struct
id|obsolete_modparm
op_star
)paren
id|sechdrs
(braket
id|obsparmindex
)braket
dot
id|sh_addr
comma
id|sechdrs
(braket
id|obsparmindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
r_struct
id|obsolete_modparm
)paren
comma
id|sechdrs
comma
id|symindex
comma
(paren
r_char
op_star
)paren
id|sechdrs
(braket
id|strindex
)braket
dot
id|sh_addr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Size of section 0 is 0, so this works well if no params */
id|err
op_assign
id|parse_args
c_func
(paren
id|mod-&gt;name
comma
id|mod-&gt;args
comma
(paren
r_struct
id|kernel_param
op_star
)paren
id|sechdrs
(braket
id|setupindex
)braket
dot
id|sh_addr
comma
id|sechdrs
(braket
id|setupindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
r_struct
id|kernel_param
)paren
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|cleanup
suffix:semicolon
multiline_comment|/* Get rid of temporary copy */
id|vfree
c_func
(paren
id|hdr
)paren
suffix:semicolon
multiline_comment|/* Done! */
r_return
id|mod
suffix:semicolon
id|cleanup
suffix:colon
id|module_unload_free
c_func
(paren
id|mod
)paren
suffix:semicolon
id|module_free
c_func
(paren
id|mod
comma
id|mod-&gt;module_init
)paren
suffix:semicolon
id|free_core
suffix:colon
id|module_free
c_func
(paren
id|mod
comma
id|mod-&gt;module_core
)paren
suffix:semicolon
id|free_percpu
suffix:colon
r_if
c_cond
(paren
id|percpu
)paren
id|percpu_modfree
c_func
(paren
id|percpu
)paren
suffix:semicolon
id|free_mod
suffix:colon
id|kfree
c_func
(paren
id|args
)paren
suffix:semicolon
id|free_hdr
suffix:colon
id|vfree
c_func
(paren
id|hdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
r_else
r_return
id|ptr
suffix:semicolon
)brace
multiline_comment|/* This is where the real work happens */
id|asmlinkage
r_int
DECL|function|sys_init_module
id|sys_init_module
c_func
(paren
r_void
id|__user
op_star
id|umod
comma
r_int
r_int
id|len
comma
r_const
r_char
id|__user
op_star
id|uargs
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* Must have permission */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_MODULE
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* Only one module load at a time, please */
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|module_mutex
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
multiline_comment|/* Do all the hard work */
id|mod
op_assign
id|load_module
c_func
(paren
id|umod
comma
id|len
comma
id|uargs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|mod
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|mod
)paren
suffix:semicolon
)brace
multiline_comment|/* Flush the instruction cache, since we&squot;ve played with text */
r_if
c_cond
(paren
id|mod-&gt;module_init
)paren
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|mod-&gt;module_init
comma
(paren
r_int
r_int
)paren
id|mod-&gt;module_init
op_plus
id|mod-&gt;init_size
)paren
suffix:semicolon
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|mod-&gt;module_core
comma
(paren
r_int
r_int
)paren
id|mod-&gt;module_core
op_plus
id|mod-&gt;core_size
)paren
suffix:semicolon
multiline_comment|/* Now sew it into the lists.  They won&squot;t access us, since&n;           strong_try_module_get() will fail. */
id|spin_lock_irq
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|mod-&gt;list
comma
op_amp
id|modules
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
multiline_comment|/* Drop lock so they can recurse */
id|up
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|notify_mutex
)paren
suffix:semicolon
id|notifier_call_chain
c_func
(paren
op_amp
id|module_notify_list
comma
id|MODULE_STATE_COMING
comma
id|mod
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|notify_mutex
)paren
suffix:semicolon
multiline_comment|/* Start the module */
id|ret
op_assign
id|mod
op_member_access_from_pointer
id|init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
multiline_comment|/* Init routine failed: abort.  Try to protect us from&n;                   buggy refcounters. */
id|mod-&gt;state
op_assign
id|MODULE_STATE_GOING
suffix:semicolon
id|synchronize_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;unsafe
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: module is now stuck!&bslash;n&quot;
comma
id|mod-&gt;name
)paren
suffix:semicolon
r_else
(brace
id|module_put
c_func
(paren
id|mod
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
id|free_module
c_func
(paren
id|mod
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Now it&squot;s a first class citizen! */
id|down
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
id|mod-&gt;state
op_assign
id|MODULE_STATE_LIVE
suffix:semicolon
multiline_comment|/* Drop initial reference. */
id|module_put
c_func
(paren
id|mod
)paren
suffix:semicolon
id|module_free
c_func
(paren
id|mod
comma
id|mod-&gt;module_init
)paren
suffix:semicolon
id|mod-&gt;module_init
op_assign
l_int|NULL
suffix:semicolon
id|mod-&gt;init_size
op_assign
l_int|0
suffix:semicolon
id|mod-&gt;init_text_size
op_assign
l_int|0
suffix:semicolon
id|up
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|within
r_static
r_inline
r_int
id|within
c_func
(paren
r_int
r_int
id|addr
comma
r_void
op_star
id|start
comma
r_int
r_int
id|size
)paren
(brace
r_return
(paren
(paren
r_void
op_star
)paren
id|addr
op_ge
id|start
op_logical_and
(paren
r_void
op_star
)paren
id|addr
OL
id|start
op_plus
id|size
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_KALLSYMS
DECL|function|get_ksymbol
r_static
r_const
r_char
op_star
id|get_ksymbol
c_func
(paren
r_struct
id|module
op_star
id|mod
comma
r_int
r_int
id|addr
comma
r_int
r_int
op_star
id|size
comma
r_int
r_int
op_star
id|offset
)paren
(brace
r_int
r_int
id|i
comma
id|best
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|nextval
suffix:semicolon
multiline_comment|/* At worse, next value is at end of module */
r_if
c_cond
(paren
id|within
c_func
(paren
id|addr
comma
id|mod-&gt;module_init
comma
id|mod-&gt;init_size
)paren
)paren
id|nextval
op_assign
(paren
r_int
r_int
)paren
id|mod-&gt;module_init
op_plus
id|mod-&gt;init_text_size
suffix:semicolon
r_else
id|nextval
op_assign
(paren
r_int
r_int
)paren
id|mod-&gt;module_core
op_plus
id|mod-&gt;core_text_size
suffix:semicolon
multiline_comment|/* Scan for closest preceeding symbol, and next symbol. (ELF&n;           starts real symbols at 1). */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|mod-&gt;num_symtab
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mod-&gt;symtab
(braket
id|i
)braket
dot
id|st_shndx
op_eq
id|SHN_UNDEF
)paren
r_continue
suffix:semicolon
multiline_comment|/* We ignore unnamed symbols: they&squot;re uninformative&n;&t;&t; * and inserted at a whim. */
r_if
c_cond
(paren
id|mod-&gt;symtab
(braket
id|i
)braket
dot
id|st_value
op_le
id|addr
op_logical_and
id|mod-&gt;symtab
(braket
id|i
)braket
dot
id|st_value
OG
id|mod-&gt;symtab
(braket
id|best
)braket
dot
id|st_value
op_logical_and
op_star
(paren
id|mod-&gt;strtab
op_plus
id|mod-&gt;symtab
(braket
id|i
)braket
dot
id|st_name
)paren
op_ne
l_char|&squot;&bslash;0&squot;
)paren
id|best
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;symtab
(braket
id|i
)braket
dot
id|st_value
OG
id|addr
op_logical_and
id|mod-&gt;symtab
(braket
id|i
)braket
dot
id|st_value
OL
id|nextval
op_logical_and
op_star
(paren
id|mod-&gt;strtab
op_plus
id|mod-&gt;symtab
(braket
id|i
)braket
dot
id|st_name
)paren
op_ne
l_char|&squot;&bslash;0&squot;
)paren
id|nextval
op_assign
id|mod-&gt;symtab
(braket
id|i
)braket
dot
id|st_value
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|best
)paren
r_return
l_int|NULL
suffix:semicolon
op_star
id|size
op_assign
id|nextval
op_minus
id|mod-&gt;symtab
(braket
id|best
)braket
dot
id|st_value
suffix:semicolon
op_star
id|offset
op_assign
id|addr
op_minus
id|mod-&gt;symtab
(braket
id|best
)braket
dot
id|st_value
suffix:semicolon
r_return
id|mod-&gt;strtab
op_plus
id|mod-&gt;symtab
(braket
id|best
)braket
dot
id|st_name
suffix:semicolon
)brace
multiline_comment|/* For kallsyms to ask for address resolution.  NULL means not found.&n;   We don&squot;t lock, as this is used for oops resolution and races are a&n;   lesser concern. */
DECL|function|module_address_lookup
r_const
r_char
op_star
id|module_address_lookup
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
op_star
id|size
comma
r_int
r_int
op_star
id|offset
comma
r_char
op_star
op_star
id|modname
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|mod
comma
op_amp
id|modules
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|within
c_func
(paren
id|addr
comma
id|mod-&gt;module_init
comma
id|mod-&gt;init_size
)paren
op_logical_or
id|within
c_func
(paren
id|addr
comma
id|mod-&gt;module_core
comma
id|mod-&gt;core_size
)paren
)paren
(brace
op_star
id|modname
op_assign
id|mod-&gt;name
suffix:semicolon
r_return
id|get_ksymbol
c_func
(paren
id|mod
comma
id|addr
comma
id|size
comma
id|offset
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|module_get_kallsym
r_struct
id|module
op_star
id|module_get_kallsym
c_func
(paren
r_int
r_int
id|symnum
comma
r_int
r_int
op_star
id|value
comma
r_char
op_star
id|type
comma
r_char
id|namebuf
(braket
l_int|128
)braket
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
id|down
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|mod
comma
op_amp
id|modules
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|symnum
OL
id|mod-&gt;num_symtab
)paren
(brace
op_star
id|value
op_assign
id|mod-&gt;symtab
(braket
id|symnum
)braket
dot
id|st_value
suffix:semicolon
op_star
id|type
op_assign
id|mod-&gt;symtab
(braket
id|symnum
)braket
dot
id|st_info
suffix:semicolon
id|strncpy
c_func
(paren
id|namebuf
comma
id|mod-&gt;strtab
op_plus
id|mod-&gt;symtab
(braket
id|symnum
)braket
dot
id|st_name
comma
l_int|127
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
r_return
id|mod
suffix:semicolon
)brace
id|symnum
op_sub_assign
id|mod-&gt;num_symtab
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_KALLSYMS */
multiline_comment|/* Called by the /proc file system to return a list of modules. */
DECL|function|m_start
r_static
r_void
op_star
id|m_start
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|list_head
op_star
id|i
suffix:semicolon
id|loff_t
id|n
op_assign
l_int|0
suffix:semicolon
id|down
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|i
comma
op_amp
id|modules
)paren
(brace
r_if
c_cond
(paren
id|n
op_increment
op_eq
op_star
id|pos
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
op_amp
id|modules
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|m_next
r_static
r_void
op_star
id|m_next
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|p
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|list_head
op_star
id|i
op_assign
id|p
suffix:semicolon
(paren
op_star
id|pos
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i-&gt;next
op_eq
op_amp
id|modules
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|i-&gt;next
suffix:semicolon
)brace
DECL|function|m_stop
r_static
r_void
id|m_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|p
)paren
(brace
id|up
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
)brace
DECL|function|m_show
r_static
r_int
id|m_show
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|p
)paren
(brace
r_struct
id|module
op_star
id|mod
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|module
comma
id|list
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;%s %lu&quot;
comma
id|mod-&gt;name
comma
id|mod-&gt;init_size
op_plus
id|mod-&gt;core_size
)paren
suffix:semicolon
id|print_unload_info
c_func
(paren
id|m
comma
id|mod
)paren
suffix:semicolon
multiline_comment|/* Informative for users. */
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot; %s&quot;
comma
id|mod-&gt;state
op_eq
id|MODULE_STATE_GOING
ques
c_cond
l_string|&quot;Unloading&quot;
suffix:colon
id|mod-&gt;state
op_eq
id|MODULE_STATE_COMING
ques
c_cond
l_string|&quot;Loading&quot;
suffix:colon
l_string|&quot;Live&quot;
)paren
suffix:semicolon
multiline_comment|/* Used by oprofile and other similar tools. */
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot; 0x%p&quot;
comma
id|mod-&gt;module_core
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Format: modulename size refcount deps address&n;&n;   Where refcount is a number or -, and deps is a comma-separated list&n;   of depends or -.&n;*/
DECL|variable|modules_op
r_struct
id|seq_operations
id|modules_op
op_assign
(brace
dot
id|start
op_assign
id|m_start
comma
dot
id|next
op_assign
id|m_next
comma
dot
id|stop
op_assign
id|m_stop
comma
dot
id|show
op_assign
id|m_show
)brace
suffix:semicolon
multiline_comment|/* Given an address, look for it in the module exception tables. */
DECL|function|search_module_extables
r_const
r_struct
id|exception_table_entry
op_star
id|search_module_extables
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_const
r_struct
id|exception_table_entry
op_star
id|e
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|module
op_star
id|mod
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|mod
comma
op_amp
id|modules
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|mod-&gt;num_exentries
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|e
op_assign
id|search_extable
c_func
(paren
id|mod-&gt;extable
comma
id|mod-&gt;extable
op_plus
id|mod-&gt;num_exentries
op_minus
l_int|1
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
)paren
r_break
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Now, if we found one, we are running inside it now, hence&n;           we cannot unload the module, hence no refcnt needed. */
r_return
id|e
suffix:semicolon
)brace
multiline_comment|/* Is this a valid kernel address?  We don&squot;t grab the lock: we are oopsing. */
DECL|function|module_text_address
r_struct
id|module
op_star
id|module_text_address
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|mod
comma
op_amp
id|modules
comma
id|list
)paren
r_if
c_cond
(paren
id|within
c_func
(paren
id|addr
comma
id|mod-&gt;module_init
comma
id|mod-&gt;init_text_size
)paren
op_logical_or
id|within
c_func
(paren
id|addr
comma
id|mod-&gt;module_core
comma
id|mod-&gt;core_text_size
)paren
)paren
r_return
id|mod
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MODVERSIONS
multiline_comment|/* Generate the signature for struct module here, too, for modversions. */
DECL|function|struct_module
r_void
id|struct_module
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
r_return
suffix:semicolon
)brace
DECL|variable|struct_module
id|EXPORT_SYMBOL
c_func
(paren
id|struct_module
)paren
suffix:semicolon
macro_line|#endif
eof
