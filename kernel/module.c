multiline_comment|/* Rewritten by Rusty Russell, on the backs of many others...&n;   Copyright (C) 2002 Richard Henderson&n;   Copyright (C) 2001 Rusty Russell, 2002 Rusty Russell IBM.&n;&n;    This program is free software; you can redistribute it and/or modify&n;    it under the terms of the GNU General Public License as published by&n;    the Free Software Foundation; either version 2 of the License, or&n;    (at your option) any later version.&n;&n;    This program is distributed in the hope that it will be useful,&n;    but WITHOUT ANY WARRANTY; without even the implied warranty of&n;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;    GNU General Public License for more details.&n;&n;    You should have received a copy of the GNU General Public License&n;    along with this program; if not, write to the Free Software&n;    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n;*/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleloader.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/elf.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/rcupdate.h&gt;
macro_line|#include &lt;linux/cpu.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/err.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/cacheflush.h&gt;
macro_line|#if 0
mdefine_line|#define DEBUGP printk
macro_line|#else
DECL|macro|DEBUGP
mdefine_line|#define DEBUGP(fmt , a...)
macro_line|#endif
macro_line|#ifndef ARCH_SHF_SMALL
DECL|macro|ARCH_SHF_SMALL
mdefine_line|#define ARCH_SHF_SMALL 0
macro_line|#endif
multiline_comment|/* If this is set, the section belongs in the init part of the module */
DECL|macro|INIT_OFFSET_MASK
mdefine_line|#define INIT_OFFSET_MASK (1UL &lt;&lt; (BITS_PER_LONG-1))
DECL|macro|symbol_is
mdefine_line|#define symbol_is(literal, string)&t;&t;&t;&t;&bslash;&n;&t;(strcmp(MODULE_SYMBOL_PREFIX literal, (string)) == 0)
multiline_comment|/* Protects extables and symbols lists */
DECL|variable|modlist_lock
r_static
id|spinlock_t
id|modlist_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* List of modules, protected by module_mutex AND modlist_lock */
r_static
id|DECLARE_MUTEX
c_func
(paren
id|module_mutex
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|modules
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|symbols
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|extables
)paren
suffix:semicolon
multiline_comment|/* We require a truly strong try_module_get() */
DECL|function|strong_try_module_get
r_static
r_inline
r_int
id|strong_try_module_get
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
r_if
c_cond
(paren
id|mod
op_logical_and
id|mod-&gt;state
op_eq
id|MODULE_STATE_COMING
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|try_module_get
c_func
(paren
id|mod
)paren
suffix:semicolon
)brace
multiline_comment|/* Stub function for modules which don&squot;t have an initfn */
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|init_module
id|EXPORT_SYMBOL
c_func
(paren
id|init_module
)paren
suffix:semicolon
multiline_comment|/* Find a symbol, return value and the symbol group */
DECL|function|__find_symbol
r_static
r_int
r_int
id|__find_symbol
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|kernel_symbol_group
op_star
op_star
id|group
comma
r_int
id|gplok
)paren
(brace
r_struct
id|kernel_symbol_group
op_star
id|ks
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|ks
comma
op_amp
id|symbols
comma
id|list
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|ks-&gt;gplonly
op_logical_and
op_logical_neg
id|gplok
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ks-&gt;num_syms
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|ks-&gt;syms
(braket
id|i
)braket
dot
id|name
comma
id|name
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|group
op_assign
id|ks
suffix:semicolon
r_return
id|ks-&gt;syms
(braket
id|i
)braket
dot
id|value
suffix:semicolon
)brace
)brace
)brace
id|DEBUGP
c_func
(paren
l_string|&quot;Failed to find symbol %s&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Find a symbol in this elf symbol table */
DECL|function|find_local_symbol
r_static
r_int
r_int
id|find_local_symbol
c_func
(paren
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|symindex
comma
r_const
r_char
op_star
id|strtab
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|Elf_Sym
op_star
id|sym
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_addr
suffix:semicolon
multiline_comment|/* Search (defined) internal symbols first. */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
op_star
id|sym
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sym
(braket
id|i
)braket
dot
id|st_shndx
op_ne
id|SHN_UNDEF
op_logical_and
id|strcmp
c_func
(paren
id|name
comma
id|strtab
op_plus
id|sym
(braket
id|i
)braket
dot
id|st_name
)paren
op_eq
l_int|0
)paren
r_return
id|sym
(braket
id|i
)braket
dot
id|st_value
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Search for module by name: must hold module_mutex. */
DECL|function|find_module
r_static
r_struct
id|module
op_star
id|find_module
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|mod
comma
op_amp
id|modules
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|mod-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
r_return
id|mod
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MODULE_UNLOAD
multiline_comment|/* Init the unload section of the module. */
DECL|function|module_unload_init
r_static
r_void
id|module_unload_init
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|mod-&gt;modules_which_use_me
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|atomic_set
c_func
(paren
op_amp
id|mod-&gt;ref
(braket
id|i
)braket
dot
id|count
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Backwards compatibility macros put refcount during init. */
id|mod-&gt;waiter
op_assign
id|current
suffix:semicolon
)brace
multiline_comment|/* modules using other modules */
DECL|struct|module_use
r_struct
id|module_use
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|module_which_uses
r_struct
id|module
op_star
id|module_which_uses
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Does a already use b? */
DECL|function|already_uses
r_static
r_int
id|already_uses
c_func
(paren
r_struct
id|module
op_star
id|a
comma
r_struct
id|module
op_star
id|b
)paren
(brace
r_struct
id|module_use
op_star
id|use
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|use
comma
op_amp
id|b-&gt;modules_which_use_me
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|use-&gt;module_which_uses
op_eq
id|a
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;%s uses %s!&bslash;n&quot;
comma
id|a-&gt;name
comma
id|b-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|DEBUGP
c_func
(paren
l_string|&quot;%s does not use %s!&bslash;n&quot;
comma
id|a-&gt;name
comma
id|b-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Module a uses b */
DECL|function|use_module
r_static
r_int
id|use_module
c_func
(paren
r_struct
id|module
op_star
id|a
comma
r_struct
id|module
op_star
id|b
)paren
(brace
r_struct
id|module_use
op_star
id|use
suffix:semicolon
r_if
c_cond
(paren
id|b
op_eq
l_int|NULL
op_logical_or
id|already_uses
c_func
(paren
id|a
comma
id|b
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;Allocating new usage for %s.&bslash;n&quot;
comma
id|a-&gt;name
)paren
suffix:semicolon
id|use
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|use
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: out of memory loading&bslash;n&quot;
comma
id|a-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|use-&gt;module_which_uses
op_assign
id|a
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|use-&gt;list
comma
op_amp
id|b-&gt;modules_which_use_me
)paren
suffix:semicolon
id|try_module_get
c_func
(paren
id|b
)paren
suffix:semicolon
multiline_comment|/* Can&squot;t fail */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Clear the unload stuff of the module. */
DECL|function|module_unload_free
r_static
r_void
id|module_unload_free
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
r_struct
id|module
op_star
id|i
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|i
comma
op_amp
id|modules
comma
id|list
)paren
(brace
r_struct
id|module_use
op_star
id|use
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|use
comma
op_amp
id|i-&gt;modules_which_use_me
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|use-&gt;module_which_uses
op_eq
id|mod
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;%s unusing %s&bslash;n&quot;
comma
id|mod-&gt;name
comma
id|i-&gt;name
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|i
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|use-&gt;list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|use
)paren
suffix:semicolon
multiline_comment|/* There can be at most one match. */
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* Thread to stop each CPU in user context. */
DECL|enum|stopref_state
r_enum
id|stopref_state
(brace
DECL|enumerator|STOPREF_WAIT
id|STOPREF_WAIT
comma
DECL|enumerator|STOPREF_PREPARE
id|STOPREF_PREPARE
comma
DECL|enumerator|STOPREF_DISABLE_IRQ
id|STOPREF_DISABLE_IRQ
comma
DECL|enumerator|STOPREF_EXIT
id|STOPREF_EXIT
comma
)brace
suffix:semicolon
DECL|variable|stopref_state
r_static
r_enum
id|stopref_state
id|stopref_state
suffix:semicolon
DECL|variable|stopref_num_threads
r_static
r_int
r_int
id|stopref_num_threads
suffix:semicolon
DECL|variable|stopref_thread_ack
r_static
id|atomic_t
id|stopref_thread_ack
suffix:semicolon
DECL|function|stopref
r_static
r_int
id|stopref
c_func
(paren
r_void
op_star
id|cpu
)paren
(brace
r_int
id|irqs_disabled
op_assign
l_int|0
suffix:semicolon
r_int
id|prepared
op_assign
l_int|0
suffix:semicolon
id|sprintf
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;kmodule%lu&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|cpu
)paren
suffix:semicolon
multiline_comment|/* Highest priority we can manage, and move to right CPU. */
macro_line|#if 0 /* FIXME */
r_struct
id|sched_param
id|param
op_assign
(brace
dot
id|sched_priority
op_assign
id|MAX_RT_PRIO
op_minus
l_int|1
)brace
suffix:semicolon
id|setscheduler
c_func
(paren
id|current-&gt;pid
comma
id|SCHED_FIFO
comma
op_amp
id|param
)paren
suffix:semicolon
macro_line|#endif
id|set_cpus_allowed
c_func
(paren
id|current
comma
l_int|1UL
op_lshift
(paren
r_int
r_int
)paren
id|cpu
)paren
suffix:semicolon
multiline_comment|/* Ack: we are alive */
id|atomic_inc
c_func
(paren
op_amp
id|stopref_thread_ack
)paren
suffix:semicolon
multiline_comment|/* Simple state machine */
r_while
c_loop
(paren
id|stopref_state
op_ne
id|STOPREF_EXIT
)paren
(brace
r_if
c_cond
(paren
id|stopref_state
op_eq
id|STOPREF_DISABLE_IRQ
op_logical_and
op_logical_neg
id|irqs_disabled
)paren
(brace
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|irqs_disabled
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Ack: irqs disabled. */
id|atomic_inc
c_func
(paren
op_amp
id|stopref_thread_ack
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|stopref_state
op_eq
id|STOPREF_PREPARE
op_logical_and
op_logical_neg
id|prepared
)paren
(brace
multiline_comment|/* Everyone is in place, hold CPU. */
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
id|prepared
op_assign
l_int|1
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|stopref_thread_ack
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irqs_disabled
op_logical_or
id|prepared
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
r_else
id|yield
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Ack: we are exiting. */
id|atomic_inc
c_func
(paren
op_amp
id|stopref_thread_ack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irqs_disabled
)paren
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prepared
)paren
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Change the thread state */
DECL|function|stopref_set_state
r_static
r_void
id|stopref_set_state
c_func
(paren
r_enum
id|stopref_state
id|state
comma
r_int
id|sleep
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|stopref_thread_ack
comma
l_int|0
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|stopref_state
op_assign
id|state
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|stopref_thread_ack
)paren
op_ne
id|stopref_num_threads
)paren
(brace
r_if
c_cond
(paren
id|sleep
)paren
id|yield
c_func
(paren
)paren
suffix:semicolon
r_else
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Stop the machine.  Disables irqs. */
DECL|function|stop_refcounts
r_static
r_int
id|stop_refcounts
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
comma
id|cpu
suffix:semicolon
r_int
r_int
id|old_allowed
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* One thread per cpu.  We&squot;ll do our own. */
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: racy with set_cpus_allowed. */
id|old_allowed
op_assign
id|current-&gt;cpus_allowed
suffix:semicolon
id|set_cpus_allowed
c_func
(paren
id|current
comma
l_int|1UL
op_lshift
(paren
r_int
r_int
)paren
id|cpu
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|stopref_thread_ack
comma
l_int|0
)paren
suffix:semicolon
id|stopref_num_threads
op_assign
l_int|0
suffix:semicolon
id|stopref_state
op_assign
id|STOPREF_WAIT
suffix:semicolon
multiline_comment|/* No CPUs can come up or down during this. */
id|down
c_func
(paren
op_amp
id|cpucontrol
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|cpu
op_logical_or
op_logical_neg
id|cpu_online
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
id|ret
op_assign
id|kernel_thread
c_func
(paren
id|stopref
comma
(paren
r_void
op_star
)paren
(paren
r_int
)paren
id|i
comma
id|CLONE_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_break
suffix:semicolon
id|stopref_num_threads
op_increment
suffix:semicolon
)brace
multiline_comment|/* Wait for them all to come to life. */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|stopref_thread_ack
)paren
op_ne
id|stopref_num_threads
)paren
id|yield
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If some failed, kill them all. */
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|stopref_set_state
c_func
(paren
id|STOPREF_EXIT
comma
l_int|1
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cpucontrol
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t schedule us away at this point, please. */
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Now they are all scheduled, make them hold the CPUs, ready. */
id|stopref_set_state
c_func
(paren
id|STOPREF_PREPARE
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Make them disable irqs. */
id|stopref_set_state
c_func
(paren
id|STOPREF_DISABLE_IRQ
comma
l_int|0
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Restart the machine.  Re-enables irqs. */
DECL|function|restart_refcounts
r_static
r_void
id|restart_refcounts
c_func
(paren
r_void
)paren
(brace
id|stopref_set_state
c_func
(paren
id|STOPREF_EXIT
comma
l_int|0
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cpucontrol
)paren
suffix:semicolon
)brace
macro_line|#else /* ...!SMP */
DECL|function|stop_refcounts
r_static
r_inline
r_int
id|stop_refcounts
c_func
(paren
r_void
)paren
(brace
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|restart_refcounts
r_static
r_inline
r_void
id|restart_refcounts
c_func
(paren
r_void
)paren
(brace
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|module_refcount
r_static
r_int
r_int
id|module_refcount
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
r_int
r_int
id|i
comma
id|total
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|total
op_add_assign
id|atomic_read
c_func
(paren
op_amp
id|mod-&gt;ref
(braket
id|i
)braket
dot
id|count
)paren
suffix:semicolon
r_return
id|total
suffix:semicolon
)brace
multiline_comment|/* This exists whether we can unload or not */
r_static
r_void
id|free_module
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MODULE_FORCE_UNLOAD
DECL|function|try_force
r_static
r_inline
r_int
id|try_force
c_func
(paren
r_int
r_int
id|flags
)paren
(brace
r_return
(paren
id|flags
op_amp
id|O_TRUNC
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|function|try_force
r_static
r_inline
r_int
id|try_force
c_func
(paren
r_int
r_int
id|flags
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_MODULE_FORCE_UNLOAD */
multiline_comment|/* Stub function for modules which don&squot;t have an exitfn */
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
)brace
DECL|variable|cleanup_module
id|EXPORT_SYMBOL
c_func
(paren
id|cleanup_module
)paren
suffix:semicolon
id|asmlinkage
r_int
DECL|function|sys_delete_module
id|sys_delete_module
c_func
(paren
r_const
r_char
op_star
id|name_user
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_char
id|name
(braket
id|MODULE_NAME_LEN
)braket
suffix:semicolon
r_int
id|ret
comma
id|forced
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_MODULE
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|strncpy_from_user
c_func
(paren
id|name
comma
id|name_user
comma
id|MODULE_NAME_LEN
op_minus
l_int|1
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|name
(braket
id|MODULE_NAME_LEN
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|module_mutex
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
id|mod
op_assign
id|find_module
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mod
)paren
(brace
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mod-&gt;modules_which_use_me
)paren
)paren
(brace
multiline_comment|/* Other modules depend on us: get rid of them first. */
id|ret
op_assign
op_minus
id|EWOULDBLOCK
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Already dying? */
r_if
c_cond
(paren
id|mod-&gt;state
op_eq
id|MODULE_STATE_GOING
)paren
(brace
multiline_comment|/* FIXME: if (force), slam module count and wake up&n;                   waiter --RR */
id|DEBUGP
c_func
(paren
l_string|&quot;%s already dying&bslash;n&quot;
comma
id|mod-&gt;name
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Coming up?  Allow force on stuck modules. */
r_if
c_cond
(paren
id|mod-&gt;state
op_eq
id|MODULE_STATE_COMING
)paren
(brace
id|forced
op_assign
id|try_force
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|forced
)paren
(brace
multiline_comment|/* This module can&squot;t be removed */
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/* If it has an init func, it must have an exit func to unload */
r_if
c_cond
(paren
(paren
id|mod-&gt;init
op_ne
id|init_module
op_logical_and
id|mod
op_member_access_from_pointer
m_exit
op_eq
id|cleanup_module
)paren
op_logical_or
id|mod-&gt;unsafe
)paren
(brace
id|forced
op_assign
id|try_force
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|forced
)paren
(brace
multiline_comment|/* This module can&squot;t be removed */
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/* Stop the machine so refcounts can&squot;t move: irqs disabled. */
id|DEBUGP
c_func
(paren
l_string|&quot;Stopping refcounts...&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|stop_refcounts
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* If it&squot;s not unused, quit unless we are told to block. */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|O_NONBLOCK
)paren
op_logical_and
id|module_refcount
c_func
(paren
id|mod
)paren
op_ne
l_int|0
)paren
(brace
id|forced
op_assign
id|try_force
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|forced
)paren
id|ret
op_assign
op_minus
id|EWOULDBLOCK
suffix:semicolon
)brace
r_else
(brace
id|mod-&gt;waiter
op_assign
id|current
suffix:semicolon
id|mod-&gt;state
op_assign
id|MODULE_STATE_GOING
suffix:semicolon
)brace
id|restart_refcounts
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|forced
)paren
r_goto
id|destroy
suffix:semicolon
multiline_comment|/* Since we might sleep for some time, drop the semaphore first */
id|up
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;Looking at refcount...&bslash;n&quot;
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|module_refcount
c_func
(paren
id|mod
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;Regrabbing mutex...&bslash;n&quot;
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
id|destroy
suffix:colon
multiline_comment|/* Final destruction now noone is using it. */
id|mod
op_member_access_from_pointer
m_exit
(paren
)paren
suffix:semicolon
id|free_module
c_func
(paren
id|mod
)paren
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|print_unload_info
r_static
r_void
id|print_unload_info
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_struct
id|module
op_star
id|mod
)paren
(brace
r_struct
id|module_use
op_star
id|use
suffix:semicolon
r_int
id|printed_something
op_assign
l_int|0
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot; %u &quot;
comma
id|module_refcount
c_func
(paren
id|mod
)paren
)paren
suffix:semicolon
multiline_comment|/* Always include a trailing , so userspace can differentiate&n;           between this and the old multi-field proc format. */
id|list_for_each_entry
c_func
(paren
id|use
comma
op_amp
id|mod-&gt;modules_which_use_me
comma
id|list
)paren
(brace
id|printed_something
op_assign
l_int|1
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;%s,&quot;
comma
id|use-&gt;module_which_uses-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod-&gt;unsafe
)paren
(brace
id|printed_something
op_assign
l_int|1
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;[unsafe],&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod-&gt;init
op_ne
id|init_module
op_logical_and
id|mod
op_member_access_from_pointer
m_exit
op_eq
id|cleanup_module
)paren
(brace
id|printed_something
op_assign
l_int|1
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;[permanent],&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|printed_something
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;-&quot;
)paren
suffix:semicolon
)brace
DECL|function|__symbol_put
r_void
id|__symbol_put
c_func
(paren
r_const
r_char
op_star
id|symbol
)paren
(brace
r_struct
id|kernel_symbol_group
op_star
id|ksg
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|__find_symbol
c_func
(paren
id|symbol
comma
op_amp
id|ksg
comma
l_int|1
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|ksg-&gt;owner
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|__symbol_put
id|EXPORT_SYMBOL
c_func
(paren
id|__symbol_put
)paren
suffix:semicolon
DECL|function|symbol_put_addr
r_void
id|symbol_put_addr
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
r_struct
id|kernel_symbol_group
op_star
id|ks
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|ks
comma
op_amp
id|symbols
comma
id|list
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ks-&gt;num_syms
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ks-&gt;syms
(braket
id|i
)braket
dot
id|value
op_eq
(paren
r_int
r_int
)paren
id|addr
)paren
(brace
id|module_put
c_func
(paren
id|ks-&gt;owner
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|symbol_put_addr
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|symbol_put_addr
)paren
suffix:semicolon
macro_line|#else /* !CONFIG_MODULE_UNLOAD */
DECL|function|print_unload_info
r_static
r_void
id|print_unload_info
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_struct
id|module
op_star
id|mod
)paren
(brace
multiline_comment|/* We don&squot;t know the usage count, or what modules are using. */
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot; - -&quot;
)paren
suffix:semicolon
)brace
DECL|function|module_unload_free
r_static
r_inline
r_void
id|module_unload_free
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
)brace
DECL|function|use_module
r_static
r_inline
r_int
id|use_module
c_func
(paren
r_struct
id|module
op_star
id|a
comma
r_struct
id|module
op_star
id|b
)paren
(brace
r_return
id|strong_try_module_get
c_func
(paren
id|b
)paren
suffix:semicolon
)brace
DECL|function|module_unload_init
r_static
r_inline
r_void
id|module_unload_init
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
)brace
id|asmlinkage
r_int
DECL|function|sys_delete_module
id|sys_delete_module
c_func
(paren
r_const
r_char
op_star
id|name_user
comma
r_int
r_int
id|flags
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_MODULE_UNLOAD */
macro_line|#ifdef CONFIG_OBSOLETE_MODPARM
DECL|function|param_set_byte
r_static
r_int
id|param_set_byte
c_func
(paren
r_const
r_char
op_star
id|val
comma
r_struct
id|kernel_param
op_star
id|kp
)paren
(brace
r_char
op_star
id|endp
suffix:semicolon
r_int
id|l
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|val
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|l
op_assign
id|simple_strtol
c_func
(paren
id|val
comma
op_amp
id|endp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|endp
op_eq
id|val
op_logical_or
op_star
id|endp
op_logical_or
(paren
(paren
r_char
)paren
id|l
op_ne
id|l
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
op_star
(paren
(paren
r_char
op_star
)paren
id|kp-&gt;arg
)paren
op_assign
id|l
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Bounds checking done below */
DECL|function|obsparm_copy_string
r_static
r_int
id|obsparm_copy_string
c_func
(paren
r_const
r_char
op_star
id|val
comma
r_struct
id|kernel_param
op_star
id|kp
)paren
(brace
id|strcpy
c_func
(paren
id|kp-&gt;arg
comma
id|val
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|set_obsolete
r_extern
r_int
id|set_obsolete
c_func
(paren
r_const
r_char
op_star
id|val
comma
r_struct
id|kernel_param
op_star
id|kp
)paren
(brace
r_int
r_int
id|min
comma
id|max
suffix:semicolon
r_int
r_int
id|size
comma
id|maxsize
suffix:semicolon
r_char
op_star
id|endp
suffix:semicolon
r_const
r_char
op_star
id|p
suffix:semicolon
r_struct
id|obsolete_modparm
op_star
id|obsparm
op_assign
id|kp-&gt;arg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|val
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Parameter %s needs an argument&bslash;n&quot;
comma
id|kp-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* type is: [min[-max]]{b,h,i,l,s} */
id|p
op_assign
id|obsparm-&gt;type
suffix:semicolon
id|min
op_assign
id|simple_strtol
c_func
(paren
id|p
comma
op_amp
id|endp
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|endp
op_eq
id|obsparm-&gt;type
)paren
id|min
op_assign
id|max
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|endp
op_eq
l_char|&squot;-&squot;
)paren
(brace
id|p
op_assign
id|endp
op_plus
l_int|1
suffix:semicolon
id|max
op_assign
id|simple_strtol
c_func
(paren
id|p
comma
op_amp
id|endp
comma
l_int|10
)paren
suffix:semicolon
)brace
r_else
id|max
op_assign
id|min
suffix:semicolon
r_switch
c_cond
(paren
op_star
id|endp
)paren
(brace
r_case
l_char|&squot;b&squot;
suffix:colon
r_return
id|param_array
c_func
(paren
id|kp-&gt;name
comma
id|val
comma
id|min
comma
id|max
comma
id|obsparm-&gt;addr
comma
l_int|1
comma
id|param_set_byte
)paren
suffix:semicolon
r_case
l_char|&squot;h&squot;
suffix:colon
r_return
id|param_array
c_func
(paren
id|kp-&gt;name
comma
id|val
comma
id|min
comma
id|max
comma
id|obsparm-&gt;addr
comma
r_sizeof
(paren
r_int
)paren
comma
id|param_set_short
)paren
suffix:semicolon
r_case
l_char|&squot;i&squot;
suffix:colon
r_return
id|param_array
c_func
(paren
id|kp-&gt;name
comma
id|val
comma
id|min
comma
id|max
comma
id|obsparm-&gt;addr
comma
r_sizeof
(paren
r_int
)paren
comma
id|param_set_int
)paren
suffix:semicolon
r_case
l_char|&squot;l&squot;
suffix:colon
r_return
id|param_array
c_func
(paren
id|kp-&gt;name
comma
id|val
comma
id|min
comma
id|max
comma
id|obsparm-&gt;addr
comma
r_sizeof
(paren
r_int
)paren
comma
id|param_set_long
)paren
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
r_return
id|param_array
c_func
(paren
id|kp-&gt;name
comma
id|val
comma
id|min
comma
id|max
comma
id|obsparm-&gt;addr
comma
r_sizeof
(paren
r_char
op_star
)paren
comma
id|param_set_charp
)paren
suffix:semicolon
r_case
l_char|&squot;c&squot;
suffix:colon
multiline_comment|/* Undocumented: 1-5c50 means 1-5 strings of up to 49 chars,&n;&t;&t;   and the decl is &quot;char xxx[5][50];&quot; */
id|p
op_assign
id|endp
op_plus
l_int|1
suffix:semicolon
id|maxsize
op_assign
id|simple_strtol
c_func
(paren
id|p
comma
op_amp
id|endp
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/* We check lengths here (yes, this is a hack). */
id|p
op_assign
id|val
suffix:semicolon
r_while
c_loop
(paren
id|p
(braket
id|size
op_assign
id|strcspn
c_func
(paren
id|p
comma
l_string|&quot;,&quot;
)paren
)braket
)paren
(brace
r_if
c_cond
(paren
id|size
op_ge
id|maxsize
)paren
r_goto
id|oversize
suffix:semicolon
id|p
op_add_assign
id|size
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
op_ge
id|maxsize
)paren
r_goto
id|oversize
suffix:semicolon
r_return
id|param_array
c_func
(paren
id|kp-&gt;name
comma
id|val
comma
id|min
comma
id|max
comma
id|obsparm-&gt;addr
comma
id|maxsize
comma
id|obsparm_copy_string
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unknown obsolete parameter type %s&bslash;n&quot;
comma
id|obsparm-&gt;type
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
id|oversize
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Parameter %s doesn&squot;t fit in %u chars.&bslash;n&quot;
comma
id|kp-&gt;name
comma
id|maxsize
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|obsolete_params
r_static
r_int
id|obsolete_params
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_char
op_star
id|args
comma
r_struct
id|obsolete_modparm
id|obsparm
(braket
)braket
comma
r_int
r_int
id|num
comma
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|symindex
comma
r_const
r_char
op_star
id|strtab
)paren
(brace
r_struct
id|kernel_param
op_star
id|kp
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|kp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|kp
(braket
l_int|0
)braket
)paren
op_star
id|num
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kp
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
id|sym_name
(braket
l_int|128
op_plus
r_sizeof
(paren
id|MODULE_SYMBOL_PREFIX
)paren
)braket
suffix:semicolon
id|snprintf
c_func
(paren
id|sym_name
comma
r_sizeof
(paren
id|sym_name
)paren
comma
l_string|&quot;%s%s&quot;
comma
id|MODULE_SYMBOL_PREFIX
comma
id|obsparm
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|kp
(braket
id|i
)braket
dot
id|name
op_assign
id|obsparm
(braket
id|i
)braket
dot
id|name
suffix:semicolon
id|kp
(braket
id|i
)braket
dot
id|perm
op_assign
l_int|000
suffix:semicolon
id|kp
(braket
id|i
)braket
dot
id|set
op_assign
id|set_obsolete
suffix:semicolon
id|kp
(braket
id|i
)braket
dot
id|get
op_assign
l_int|NULL
suffix:semicolon
id|obsparm
(braket
id|i
)braket
dot
id|addr
op_assign
(paren
r_void
op_star
)paren
id|find_local_symbol
c_func
(paren
id|sechdrs
comma
id|symindex
comma
id|strtab
comma
id|sym_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obsparm
(braket
id|i
)braket
dot
id|addr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: falsely claims to have parameter %s&bslash;n&quot;
comma
id|name
comma
id|obsparm
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|kp
(braket
id|i
)braket
dot
id|arg
op_assign
op_amp
id|obsparm
(braket
id|i
)braket
suffix:semicolon
)brace
id|ret
op_assign
id|parse_args
c_func
(paren
id|name
comma
id|args
comma
id|kp
comma
id|num
comma
l_int|NULL
)paren
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
id|kp
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#else
DECL|function|obsolete_params
r_static
r_int
id|obsolete_params
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_char
op_star
id|args
comma
r_struct
id|obsolete_modparm
id|obsparm
(braket
)braket
comma
r_int
r_int
id|num
comma
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|symindex
comma
r_const
r_char
op_star
id|strtab
)paren
(brace
r_if
c_cond
(paren
id|num
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Ignoring obsolete parameters&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_OBSOLETE_MODPARM */
multiline_comment|/* Resolve a symbol for this module.  I.e. if we find one, record usage.&n;   Must be holding module_mutex. */
DECL|function|resolve_symbol
r_static
r_int
r_int
id|resolve_symbol
c_func
(paren
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|symindex
comma
r_const
r_char
op_star
id|strtab
comma
r_const
r_char
op_star
id|name
comma
r_struct
id|module
op_star
id|mod
)paren
(brace
r_struct
id|kernel_symbol_group
op_star
id|ksg
suffix:semicolon
r_int
r_int
id|ret
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
id|ret
op_assign
id|__find_symbol
c_func
(paren
id|name
comma
op_amp
id|ksg
comma
id|mod-&gt;license_gplok
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/* This can fail due to OOM, or module unloading */
r_if
c_cond
(paren
op_logical_neg
id|use_module
c_func
(paren
id|mod
comma
id|ksg-&gt;owner
)paren
)paren
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Free a module, remove from lists, etc (must hold module mutex). */
DECL|function|free_module
r_static
r_void
id|free_module
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
multiline_comment|/* Delete from various lists */
id|spin_lock_irq
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|mod-&gt;list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|mod-&gt;symbols.list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|mod-&gt;gpl_symbols.list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|mod-&gt;extable.list
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
multiline_comment|/* Module unload stuff */
id|module_unload_free
c_func
(paren
id|mod
)paren
suffix:semicolon
multiline_comment|/* This may be NULL, but that&squot;s OK */
id|module_free
c_func
(paren
id|mod
comma
id|mod-&gt;module_init
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mod-&gt;args
)paren
suffix:semicolon
multiline_comment|/* Finally, free the core (containing the module structure) */
id|module_free
c_func
(paren
id|mod
comma
id|mod-&gt;module_core
)paren
suffix:semicolon
)brace
DECL|function|__symbol_get
r_void
op_star
id|__symbol_get
c_func
(paren
r_const
r_char
op_star
id|symbol
)paren
(brace
r_struct
id|kernel_symbol_group
op_star
id|ksg
suffix:semicolon
r_int
r_int
id|value
comma
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
id|value
op_assign
id|__find_symbol
c_func
(paren
id|symbol
comma
op_amp
id|ksg
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_logical_and
op_logical_neg
id|strong_try_module_get
c_func
(paren
id|ksg-&gt;owner
)paren
)paren
id|value
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|value
suffix:semicolon
)brace
DECL|variable|__symbol_get
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|__symbol_get
)paren
suffix:semicolon
multiline_comment|/* Deal with the given section */
DECL|function|handle_section
r_static
r_int
id|handle_section
c_func
(paren
r_const
r_char
op_star
id|name
comma
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|strindex
comma
r_int
r_int
id|symindex
comma
r_int
r_int
id|i
comma
r_struct
id|module
op_star
id|mod
)paren
(brace
r_int
id|ret
suffix:semicolon
r_const
r_char
op_star
id|strtab
op_assign
(paren
r_char
op_star
)paren
id|sechdrs
(braket
id|strindex
)braket
dot
id|sh_addr
suffix:semicolon
r_switch
c_cond
(paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
)paren
(brace
r_case
id|SHT_REL
suffix:colon
id|ret
op_assign
id|apply_relocate
c_func
(paren
id|sechdrs
comma
id|strtab
comma
id|symindex
comma
id|i
comma
id|mod
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SHT_RELA
suffix:colon
id|ret
op_assign
id|apply_relocate_add
c_func
(paren
id|sechdrs
comma
id|strtab
comma
id|symindex
comma
id|i
comma
id|mod
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUGP
c_func
(paren
l_string|&quot;Ignoring section %u: %s&bslash;n&quot;
comma
id|i
comma
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_NULL
ques
c_cond
l_string|&quot;NULL&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_PROGBITS
ques
c_cond
l_string|&quot;PROGBITS&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_SYMTAB
ques
c_cond
l_string|&quot;SYMTAB&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_STRTAB
ques
c_cond
l_string|&quot;STRTAB&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_RELA
ques
c_cond
l_string|&quot;RELA&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_HASH
ques
c_cond
l_string|&quot;HASH&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_DYNAMIC
ques
c_cond
l_string|&quot;DYNAMIC&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_NOTE
ques
c_cond
l_string|&quot;NOTE&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_NOBITS
ques
c_cond
l_string|&quot;NOBITS&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_REL
ques
c_cond
l_string|&quot;REL&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_SHLIB
ques
c_cond
l_string|&quot;SHLIB&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_DYNSYM
ques
c_cond
l_string|&quot;DYNSYM&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_NUM
ques
c_cond
l_string|&quot;NUM&quot;
suffix:colon
l_string|&quot;UNKNOWN&quot;
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Change all symbols so that sh_value encodes the pointer directly. */
DECL|function|simplify_symbols
r_static
r_int
id|simplify_symbols
c_func
(paren
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|symindex
comma
r_int
r_int
id|strindex
comma
r_struct
id|module
op_star
id|mod
)paren
(brace
id|Elf_Sym
op_star
id|sym
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_addr
suffix:semicolon
r_const
r_char
op_star
id|strtab
op_assign
(paren
r_char
op_star
)paren
id|sechdrs
(braket
id|strindex
)braket
dot
id|sh_addr
suffix:semicolon
r_int
r_int
id|i
comma
id|n
op_assign
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
id|Elf_Sym
)paren
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|sym
(braket
id|i
)braket
dot
id|st_shndx
)paren
(brace
r_case
id|SHN_COMMON
suffix:colon
multiline_comment|/* We compiled with -fno-common.  These are not&n;&t;&t;&t;   supposed to happen.  */
id|DEBUGP
c_func
(paren
l_string|&quot;Common symbol: %s&bslash;n&quot;
comma
id|strtab
op_plus
id|sym
(braket
id|i
)braket
dot
id|st_name
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOEXEC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SHN_ABS
suffix:colon
multiline_comment|/* Don&squot;t need to do anything */
id|DEBUGP
c_func
(paren
l_string|&quot;Absolute symbol: 0x%08lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|sym
(braket
id|i
)braket
dot
id|st_value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SHN_UNDEF
suffix:colon
id|sym
(braket
id|i
)braket
dot
id|st_value
op_assign
id|resolve_symbol
c_func
(paren
id|sechdrs
comma
id|symindex
comma
id|strtab
comma
id|strtab
op_plus
id|sym
(braket
id|i
)braket
dot
id|st_name
comma
id|mod
)paren
suffix:semicolon
multiline_comment|/* Ok if resolved.  */
r_if
c_cond
(paren
id|sym
(braket
id|i
)braket
dot
id|st_value
op_ne
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* Ok if weak.  */
r_if
c_cond
(paren
id|ELF_ST_BIND
c_func
(paren
id|sym
(braket
id|i
)braket
dot
id|st_info
)paren
op_eq
id|STB_WEAK
)paren
r_break
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Unknown symbol %s&bslash;n&quot;
comma
id|mod-&gt;name
comma
id|strtab
op_plus
id|sym
(braket
id|i
)braket
dot
id|st_name
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|sym
(braket
id|i
)braket
dot
id|st_value
op_assign
(paren
r_int
r_int
)paren
(paren
id|sechdrs
(braket
id|sym
(braket
id|i
)braket
dot
id|st_shndx
)braket
dot
id|sh_addr
op_plus
id|sym
(braket
id|i
)braket
dot
id|st_value
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Update size with this section: return offset. */
DECL|function|get_offset
r_static
r_int
id|get_offset
c_func
(paren
r_int
r_int
op_star
id|size
comma
id|Elf_Shdr
op_star
id|sechdr
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|ALIGN
c_func
(paren
op_star
id|size
comma
id|sechdr-&gt;sh_addralign
ques
c_cond
suffix:colon
l_int|1
)paren
suffix:semicolon
op_star
id|size
op_assign
id|ret
op_plus
id|sechdr-&gt;sh_size
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Lay out the SHF_ALLOC sections in a way not dissimilar to how ld&n;   might -- code, read-only data, read-write data, small data.  Tally&n;   sizes, and place the offsets into sh_entsize fields: high bit means it&n;   belongs in init. */
DECL|function|layout_sections
r_static
r_void
id|layout_sections
c_func
(paren
r_struct
id|module
op_star
id|mod
comma
r_const
id|Elf_Ehdr
op_star
id|hdr
comma
id|Elf_Shdr
op_star
id|sechdrs
comma
r_const
r_char
op_star
id|secstrings
)paren
(brace
r_static
r_int
r_int
r_const
id|masks
(braket
)braket
(braket
l_int|2
)braket
op_assign
(brace
(brace
id|SHF_EXECINSTR
op_or
id|SHF_ALLOC
comma
id|ARCH_SHF_SMALL
)brace
comma
(brace
id|SHF_ALLOC
comma
id|SHF_WRITE
op_or
id|ARCH_SHF_SMALL
)brace
comma
(brace
id|SHF_WRITE
op_or
id|SHF_ALLOC
comma
id|ARCH_SHF_SMALL
)brace
comma
(brace
id|ARCH_SHF_SMALL
op_or
id|SHF_ALLOC
comma
l_int|0
)brace
)brace
suffix:semicolon
r_int
r_int
id|m
comma
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hdr-&gt;e_shnum
suffix:semicolon
id|i
op_increment
)paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_entsize
op_assign
op_complement
l_int|0UL
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;Core section allocation order:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|ARRAY_SIZE
c_func
(paren
id|masks
)paren
suffix:semicolon
op_increment
id|m
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hdr-&gt;e_shnum
suffix:semicolon
op_increment
id|i
)paren
(brace
id|Elf_Shdr
op_star
id|s
op_assign
op_amp
id|sechdrs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s-&gt;sh_flags
op_amp
id|masks
(braket
id|m
)braket
(braket
l_int|0
)braket
)paren
op_ne
id|masks
(braket
id|m
)braket
(braket
l_int|0
)braket
op_logical_or
(paren
id|s-&gt;sh_flags
op_amp
id|masks
(braket
id|m
)braket
(braket
l_int|1
)braket
)paren
op_logical_or
id|s-&gt;sh_entsize
op_ne
op_complement
l_int|0UL
op_logical_or
id|strstr
c_func
(paren
id|secstrings
op_plus
id|s-&gt;sh_name
comma
l_string|&quot;.init&quot;
)paren
)paren
r_continue
suffix:semicolon
id|s-&gt;sh_entsize
op_assign
id|get_offset
c_func
(paren
op_amp
id|mod-&gt;core_size
comma
id|s
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;&bslash;t%s&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
)brace
)brace
id|DEBUGP
c_func
(paren
l_string|&quot;Init section allocation order:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|ARRAY_SIZE
c_func
(paren
id|masks
)paren
suffix:semicolon
op_increment
id|m
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hdr-&gt;e_shnum
suffix:semicolon
op_increment
id|i
)paren
(brace
id|Elf_Shdr
op_star
id|s
op_assign
op_amp
id|sechdrs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s-&gt;sh_flags
op_amp
id|masks
(braket
id|m
)braket
(braket
l_int|0
)braket
)paren
op_ne
id|masks
(braket
id|m
)braket
(braket
l_int|0
)braket
op_logical_or
(paren
id|s-&gt;sh_flags
op_amp
id|masks
(braket
id|m
)braket
(braket
l_int|1
)braket
)paren
op_logical_or
id|s-&gt;sh_entsize
op_ne
op_complement
l_int|0UL
op_logical_or
op_logical_neg
id|strstr
c_func
(paren
id|secstrings
op_plus
id|s-&gt;sh_name
comma
l_string|&quot;.init&quot;
)paren
)paren
r_continue
suffix:semicolon
id|s-&gt;sh_entsize
op_assign
(paren
id|get_offset
c_func
(paren
op_amp
id|mod-&gt;init_size
comma
id|s
)paren
op_or
id|INIT_OFFSET_MASK
)paren
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;&bslash;t%s&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|license_is_gpl_compatible
r_static
r_inline
r_int
id|license_is_gpl_compatible
c_func
(paren
r_const
r_char
op_star
id|license
)paren
(brace
r_return
(paren
id|strcmp
c_func
(paren
id|license
comma
l_string|&quot;GPL&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
c_func
(paren
id|license
comma
l_string|&quot;GPL v2&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
c_func
(paren
id|license
comma
l_string|&quot;GPL and additional rights&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
c_func
(paren
id|license
comma
l_string|&quot;Dual BSD/GPL&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
c_func
(paren
id|license
comma
l_string|&quot;Dual MPL/GPL&quot;
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|set_license
r_static
r_void
id|set_license
c_func
(paren
r_struct
id|module
op_star
id|mod
comma
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
id|licenseidx
)paren
(brace
r_char
op_star
id|license
suffix:semicolon
r_if
c_cond
(paren
id|licenseidx
)paren
id|license
op_assign
(paren
r_char
op_star
)paren
id|sechdrs
(braket
id|licenseidx
)braket
dot
id|sh_addr
suffix:semicolon
r_else
id|license
op_assign
l_string|&quot;unspecified&quot;
suffix:semicolon
id|mod-&gt;license_gplok
op_assign
id|license_is_gpl_compatible
c_func
(paren
id|license
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mod-&gt;license_gplok
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: module license &squot;%s&squot; taints kernel.&bslash;n&quot;
comma
id|mod-&gt;name
comma
id|license
)paren
suffix:semicolon
id|tainted
op_or_assign
id|TAINT_PROPRIETARY_MODULE
suffix:semicolon
)brace
)brace
multiline_comment|/* From init/vermagic.o */
r_extern
r_char
id|vermagic
(braket
)braket
suffix:semicolon
multiline_comment|/* Allocate and load the module: note that size of section 0 is always&n;   zero, and we rely on this for optional sections. */
DECL|function|load_module
r_static
r_struct
id|module
op_star
id|load_module
c_func
(paren
r_void
op_star
id|umod
comma
r_int
r_int
id|len
comma
r_const
r_char
op_star
id|uargs
)paren
(brace
id|Elf_Ehdr
op_star
id|hdr
suffix:semicolon
id|Elf_Shdr
op_star
id|sechdrs
suffix:semicolon
r_char
op_star
id|secstrings
comma
op_star
id|args
suffix:semicolon
r_int
r_int
id|i
comma
id|symindex
comma
id|exportindex
comma
id|strindex
comma
id|setupindex
comma
id|exindex
comma
id|modindex
comma
id|obsparmindex
comma
id|licenseindex
comma
id|gplindex
comma
id|vmagindex
suffix:semicolon
r_int
id|arglen
suffix:semicolon
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_void
op_star
id|ptr
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Stops spurious gcc uninitialized warning */
id|DEBUGP
c_func
(paren
l_string|&quot;load_module: umod=%p, len=%lu, uargs=%p&bslash;n&quot;
comma
id|umod
comma
id|len
comma
id|uargs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
op_star
id|hdr
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOEXEC
)paren
suffix:semicolon
multiline_comment|/* Suck in entire file: we&squot;ll want most of it. */
multiline_comment|/* vmalloc barfs on &quot;unusual&quot; numbers.  Check here */
r_if
c_cond
(paren
id|len
OG
l_int|64
op_star
l_int|1024
op_star
l_int|1024
op_logical_or
(paren
id|hdr
op_assign
id|vmalloc
c_func
(paren
id|len
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|hdr
comma
id|umod
comma
id|len
)paren
op_ne
l_int|0
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|free_hdr
suffix:semicolon
)brace
multiline_comment|/* Sanity checks against insmoding binaries or wrong arch,&n;           weird elf version */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|hdr-&gt;e_ident
comma
id|ELFMAG
comma
l_int|4
)paren
op_ne
l_int|0
op_logical_or
id|hdr-&gt;e_type
op_ne
id|ET_REL
op_logical_or
op_logical_neg
id|elf_check_arch
c_func
(paren
id|hdr
)paren
op_logical_or
id|hdr-&gt;e_shentsize
op_ne
r_sizeof
(paren
op_star
id|sechdrs
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOEXEC
suffix:semicolon
r_goto
id|free_hdr
suffix:semicolon
)brace
multiline_comment|/* Convenience variables */
id|sechdrs
op_assign
(paren
r_void
op_star
)paren
id|hdr
op_plus
id|hdr-&gt;e_shoff
suffix:semicolon
id|secstrings
op_assign
(paren
r_void
op_star
)paren
id|hdr
op_plus
id|sechdrs
(braket
id|hdr-&gt;e_shstrndx
)braket
dot
id|sh_offset
suffix:semicolon
multiline_comment|/* May not export symbols, or have setup params, so these may&n;           not exist */
id|exportindex
op_assign
id|setupindex
op_assign
id|obsparmindex
op_assign
id|gplindex
op_assign
id|licenseindex
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* And these should exist, but gcc whinges if we don&squot;t init them */
id|symindex
op_assign
id|strindex
op_assign
id|exindex
op_assign
id|modindex
op_assign
id|vmagindex
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Find where important sections are */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|hdr-&gt;e_shnum
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Mark all sections sh_addr with their address in the&n;&t;&t;   temporary image. */
id|sechdrs
(braket
id|i
)braket
dot
id|sh_addr
op_assign
(paren
r_int
)paren
id|hdr
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_offset
suffix:semicolon
r_if
c_cond
(paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_SYMTAB
)paren
(brace
multiline_comment|/* Internal symbols */
id|DEBUGP
c_func
(paren
l_string|&quot;Symbol table in section %u&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|symindex
op_assign
id|i
suffix:semicolon
multiline_comment|/* Strings */
id|strindex
op_assign
id|sechdrs
(braket
id|i
)braket
dot
id|sh_link
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;String table found in section %u&bslash;n&quot;
comma
id|strindex
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
comma
l_string|&quot;.gnu.linkonce.this_module&quot;
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* The module struct */
id|DEBUGP
c_func
(paren
l_string|&quot;Module in section %u&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|modindex
op_assign
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
comma
l_string|&quot;__ksymtab&quot;
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Exported symbols. */
id|DEBUGP
c_func
(paren
l_string|&quot;EXPORT table in section %u&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|exportindex
op_assign
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
comma
l_string|&quot;__param&quot;
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Setup parameter info */
id|DEBUGP
c_func
(paren
l_string|&quot;Setup table found in section %u&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|setupindex
op_assign
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
comma
l_string|&quot;__ex_table&quot;
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Exception table */
id|DEBUGP
c_func
(paren
l_string|&quot;Exception table found in section %u&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|exindex
op_assign
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
comma
l_string|&quot;__obsparm&quot;
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Obsolete MODULE_PARM() table */
id|DEBUGP
c_func
(paren
l_string|&quot;Obsolete param found in section %u&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|obsparmindex
op_assign
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
comma
l_string|&quot;.init.license&quot;
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* MODULE_LICENSE() */
id|DEBUGP
c_func
(paren
l_string|&quot;Licence found in section %u&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|licenseindex
op_assign
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
comma
l_string|&quot;__gpl_ksymtab&quot;
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* EXPORT_SYMBOL_GPL() */
id|DEBUGP
c_func
(paren
l_string|&quot;GPL symbols found in section %u&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|gplindex
op_assign
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
comma
l_string|&quot;__vermagic&quot;
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Version magic. */
id|DEBUGP
c_func
(paren
l_string|&quot;Version magic found in section %u&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|vmagindex
op_assign
id|i
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_KALLSYMS
multiline_comment|/* symbol and string tables for decoding later. */
r_if
c_cond
(paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_SYMTAB
op_logical_or
id|i
op_eq
id|strindex
)paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_flags
op_or_assign
id|SHF_ALLOC
suffix:semicolon
macro_line|#endif
macro_line|#ifndef CONFIG_MODULE_UNLOAD
multiline_comment|/* Don&squot;t load .exit sections */
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
comma
l_string|&quot;.exit&quot;
)paren
)paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_flags
op_and_assign
op_complement
(paren
r_int
r_int
)paren
id|SHF_ALLOC
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
op_logical_neg
id|modindex
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;No module found in object&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOEXEC
suffix:semicolon
r_goto
id|free_hdr
suffix:semicolon
)brace
id|mod
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|modindex
)braket
dot
id|sh_addr
suffix:semicolon
multiline_comment|/* This is allowed: modprobe --force will strip it. */
r_if
c_cond
(paren
op_logical_neg
id|vmagindex
)paren
(brace
id|tainted
op_or_assign
id|TAINT_FORCED_MODULE
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: no version magic, tainting kernel.&bslash;n&quot;
comma
id|mod-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
(paren
r_char
op_star
)paren
id|sechdrs
(braket
id|vmagindex
)braket
dot
id|sh_addr
comma
id|vermagic
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: version magic &squot;%s&squot; should be &squot;%s&squot;&bslash;n&quot;
comma
id|mod-&gt;name
comma
(paren
r_char
op_star
)paren
id|sechdrs
(braket
id|vmagindex
)braket
dot
id|sh_addr
comma
id|vermagic
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOEXEC
suffix:semicolon
r_goto
id|free_hdr
suffix:semicolon
)brace
multiline_comment|/* Now copy in args */
id|arglen
op_assign
id|strlen_user
c_func
(paren
id|uargs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arglen
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|free_hdr
suffix:semicolon
)brace
id|args
op_assign
id|kmalloc
c_func
(paren
id|arglen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|args
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|free_hdr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|args
comma
id|uargs
comma
id|arglen
)paren
op_ne
l_int|0
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|free_mod
suffix:semicolon
)brace
r_if
c_cond
(paren
id|find_module
c_func
(paren
id|mod-&gt;name
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
id|free_mod
suffix:semicolon
)brace
id|mod-&gt;state
op_assign
id|MODULE_STATE_COMING
suffix:semicolon
multiline_comment|/* Allow arches to frob section contents and sizes.  */
id|err
op_assign
id|module_frob_arch_sections
c_func
(paren
id|hdr
comma
id|sechdrs
comma
id|secstrings
comma
id|mod
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|free_mod
suffix:semicolon
multiline_comment|/* Determine total sizes, and put offsets in sh_entsize.  For now&n;&t;   this is done generically; there doesn&squot;t appear to be any&n;&t;   special cases for the architectures. */
id|layout_sections
c_func
(paren
id|mod
comma
id|hdr
comma
id|sechdrs
comma
id|secstrings
)paren
suffix:semicolon
multiline_comment|/* Do the allocs. */
id|ptr
op_assign
id|module_alloc
c_func
(paren
id|mod-&gt;core_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|free_mod
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ptr
comma
l_int|0
comma
id|mod-&gt;core_size
)paren
suffix:semicolon
id|mod-&gt;module_core
op_assign
id|ptr
suffix:semicolon
id|ptr
op_assign
id|module_alloc
c_func
(paren
id|mod-&gt;init_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
op_logical_and
id|mod-&gt;init_size
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|free_core
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ptr
comma
l_int|0
comma
id|mod-&gt;init_size
)paren
suffix:semicolon
id|mod-&gt;module_init
op_assign
id|ptr
suffix:semicolon
multiline_comment|/* Transfer each section which specifies SHF_ALLOC */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hdr-&gt;e_shnum
suffix:semicolon
id|i
op_increment
)paren
(brace
r_void
op_star
id|dest
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_flags
op_amp
id|SHF_ALLOC
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_entsize
op_amp
id|INIT_OFFSET_MASK
)paren
id|dest
op_assign
id|mod-&gt;module_init
op_plus
(paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_entsize
op_amp
op_complement
id|INIT_OFFSET_MASK
)paren
suffix:semicolon
r_else
id|dest
op_assign
id|mod-&gt;module_core
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_entsize
suffix:semicolon
r_if
c_cond
(paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_ne
id|SHT_NOBITS
)paren
id|memcpy
c_func
(paren
id|dest
comma
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_addr
comma
id|sechdrs
(braket
id|i
)braket
dot
id|sh_size
)paren
suffix:semicolon
multiline_comment|/* Update sh_addr to point to copy in image. */
id|sechdrs
(braket
id|i
)braket
dot
id|sh_addr
op_assign
(paren
r_int
r_int
)paren
id|dest
suffix:semicolon
)brace
multiline_comment|/* Module has been moved. */
id|mod
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|modindex
)braket
dot
id|sh_addr
suffix:semicolon
multiline_comment|/* Now we&squot;ve moved module, initialize linked lists, etc. */
id|module_unload_init
c_func
(paren
id|mod
)paren
suffix:semicolon
multiline_comment|/* Set up license info based on contents of section */
id|set_license
c_func
(paren
id|mod
comma
id|sechdrs
comma
id|licenseindex
)paren
suffix:semicolon
multiline_comment|/* Fix up syms, so that st_value is a pointer to location. */
id|err
op_assign
id|simplify_symbols
c_func
(paren
id|sechdrs
comma
id|symindex
comma
id|strindex
comma
id|mod
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|cleanup
suffix:semicolon
multiline_comment|/* Set up EXPORTed &amp; EXPORT_GPLed symbols (section 0 is 0 length) */
id|mod-&gt;symbols.num_syms
op_assign
(paren
id|sechdrs
(braket
id|exportindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
op_star
id|mod-&gt;symbols.syms
)paren
)paren
suffix:semicolon
id|mod-&gt;symbols.syms
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|exportindex
)braket
dot
id|sh_addr
suffix:semicolon
id|mod-&gt;gpl_symbols.num_syms
op_assign
(paren
id|sechdrs
(braket
id|gplindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
op_star
id|mod-&gt;symbols.syms
)paren
)paren
suffix:semicolon
id|mod-&gt;gpl_symbols.syms
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|gplindex
)braket
dot
id|sh_addr
suffix:semicolon
multiline_comment|/* Set up exception table */
r_if
c_cond
(paren
id|exindex
)paren
(brace
multiline_comment|/* FIXME: Sort exception table. */
id|mod-&gt;extable.num_entries
op_assign
(paren
id|sechdrs
(braket
id|exindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
r_struct
id|exception_table_entry
)paren
)paren
suffix:semicolon
id|mod-&gt;extable.entry
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|exindex
)braket
dot
id|sh_addr
suffix:semicolon
)brace
multiline_comment|/* Now handle each section. */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|hdr-&gt;e_shnum
suffix:semicolon
id|i
op_increment
)paren
(brace
id|err
op_assign
id|handle_section
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
comma
id|sechdrs
comma
id|strindex
comma
id|symindex
comma
id|i
comma
id|mod
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|cleanup
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_KALLSYMS
id|mod-&gt;symtab
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_addr
suffix:semicolon
id|mod-&gt;num_syms
op_assign
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
id|Elf_Sym
)paren
suffix:semicolon
id|mod-&gt;strtab
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|strindex
)braket
dot
id|sh_addr
suffix:semicolon
macro_line|#endif
id|err
op_assign
id|module_finalize
c_func
(paren
id|hdr
comma
id|sechdrs
comma
id|mod
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|cleanup
suffix:semicolon
id|mod-&gt;args
op_assign
id|args
suffix:semicolon
r_if
c_cond
(paren
id|obsparmindex
)paren
(brace
id|err
op_assign
id|obsolete_params
c_func
(paren
id|mod-&gt;name
comma
id|mod-&gt;args
comma
(paren
r_struct
id|obsolete_modparm
op_star
)paren
id|sechdrs
(braket
id|obsparmindex
)braket
dot
id|sh_addr
comma
id|sechdrs
(braket
id|obsparmindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
r_struct
id|obsolete_modparm
)paren
comma
id|sechdrs
comma
id|symindex
comma
(paren
r_char
op_star
)paren
id|sechdrs
(braket
id|strindex
)braket
dot
id|sh_addr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Size of section 0 is 0, so this works well if no params */
id|err
op_assign
id|parse_args
c_func
(paren
id|mod-&gt;name
comma
id|mod-&gt;args
comma
(paren
r_struct
id|kernel_param
op_star
)paren
id|sechdrs
(braket
id|setupindex
)braket
dot
id|sh_addr
comma
id|sechdrs
(braket
id|setupindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
r_struct
id|kernel_param
)paren
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|cleanup
suffix:semicolon
multiline_comment|/* Get rid of temporary copy */
id|vfree
c_func
(paren
id|hdr
)paren
suffix:semicolon
multiline_comment|/* Done! */
r_return
id|mod
suffix:semicolon
id|cleanup
suffix:colon
id|module_unload_free
c_func
(paren
id|mod
)paren
suffix:semicolon
id|module_free
c_func
(paren
id|mod
comma
id|mod-&gt;module_init
)paren
suffix:semicolon
id|free_core
suffix:colon
id|module_free
c_func
(paren
id|mod
comma
id|mod-&gt;module_core
)paren
suffix:semicolon
id|free_mod
suffix:colon
id|kfree
c_func
(paren
id|args
)paren
suffix:semicolon
id|free_hdr
suffix:colon
id|vfree
c_func
(paren
id|hdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
r_else
r_return
id|ptr
suffix:semicolon
)brace
multiline_comment|/* This is where the real work happens */
id|asmlinkage
r_int
DECL|function|sys_init_module
id|sys_init_module
c_func
(paren
r_void
op_star
id|umod
comma
r_int
r_int
id|len
comma
r_const
r_char
op_star
id|uargs
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* Must have permission */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_MODULE
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* Only one module load at a time, please */
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|module_mutex
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
multiline_comment|/* Do all the hard work */
id|mod
op_assign
id|load_module
c_func
(paren
id|umod
comma
id|len
comma
id|uargs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|mod
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|mod
)paren
suffix:semicolon
)brace
multiline_comment|/* Flush the instruction cache, since we&squot;ve played with text */
r_if
c_cond
(paren
id|mod-&gt;module_init
)paren
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|mod-&gt;module_init
comma
(paren
r_int
r_int
)paren
id|mod-&gt;module_init
op_plus
id|mod-&gt;init_size
)paren
suffix:semicolon
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|mod-&gt;module_core
comma
(paren
r_int
r_int
)paren
id|mod-&gt;module_core
op_plus
id|mod-&gt;core_size
)paren
suffix:semicolon
multiline_comment|/* Now sew it into the lists.  They won&squot;t access us, since&n;           strong_try_module_get() will fail. */
id|spin_lock_irq
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|mod-&gt;extable.list
comma
op_amp
id|extables
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|mod-&gt;symbols.list
comma
op_amp
id|symbols
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|mod-&gt;gpl_symbols.list
comma
op_amp
id|symbols
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|mod-&gt;list
comma
op_amp
id|modules
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
multiline_comment|/* Drop lock so they can recurse */
id|up
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
multiline_comment|/* Start the module */
id|ret
op_assign
id|mod
op_member_access_from_pointer
id|init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
multiline_comment|/* Init routine failed: abort.  Try to protect us from&n;                   buggy refcounters. */
id|mod-&gt;state
op_assign
id|MODULE_STATE_GOING
suffix:semicolon
id|synchronize_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;unsafe
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: module is now stuck!&bslash;n&quot;
comma
id|mod-&gt;name
)paren
suffix:semicolon
r_else
(brace
id|down
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
id|free_module
c_func
(paren
id|mod
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Now it&squot;s a first class citizen! */
id|mod-&gt;state
op_assign
id|MODULE_STATE_LIVE
suffix:semicolon
id|module_free
c_func
(paren
id|mod
comma
id|mod-&gt;module_init
)paren
suffix:semicolon
id|mod-&gt;module_init
op_assign
l_int|NULL
suffix:semicolon
id|mod-&gt;init_size
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|within
r_static
r_inline
r_int
id|within
c_func
(paren
r_int
r_int
id|addr
comma
r_void
op_star
id|start
comma
r_int
r_int
id|size
)paren
(brace
r_return
(paren
(paren
r_void
op_star
)paren
id|addr
op_ge
id|start
op_logical_and
(paren
r_void
op_star
)paren
id|addr
OL
id|start
op_plus
id|size
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_KALLSYMS
DECL|function|get_ksymbol
r_static
r_const
r_char
op_star
id|get_ksymbol
c_func
(paren
r_struct
id|module
op_star
id|mod
comma
r_int
r_int
id|addr
comma
r_int
r_int
op_star
id|size
comma
r_int
r_int
op_star
id|offset
)paren
(brace
r_int
r_int
id|i
comma
id|best
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|nextval
suffix:semicolon
multiline_comment|/* At worse, next value is at end of module */
r_if
c_cond
(paren
id|within
c_func
(paren
id|addr
comma
id|mod-&gt;module_init
comma
id|mod-&gt;init_size
)paren
)paren
id|nextval
op_assign
(paren
r_int
r_int
)paren
id|mod-&gt;module_core
op_plus
id|mod-&gt;core_size
suffix:semicolon
r_else
id|nextval
op_assign
(paren
r_int
r_int
)paren
id|mod-&gt;module_init
op_plus
id|mod-&gt;init_size
suffix:semicolon
multiline_comment|/* Scan for closest preceeding symbol, and next symbol. (ELF&n;           starts real symbols at 1). */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|mod-&gt;num_syms
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mod-&gt;symtab
(braket
id|i
)braket
dot
id|st_shndx
op_eq
id|SHN_UNDEF
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;symtab
(braket
id|i
)braket
dot
id|st_value
op_le
id|addr
op_logical_and
id|mod-&gt;symtab
(braket
id|i
)braket
dot
id|st_value
OG
id|mod-&gt;symtab
(braket
id|best
)braket
dot
id|st_value
)paren
id|best
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;symtab
(braket
id|i
)braket
dot
id|st_value
OG
id|addr
op_logical_and
id|mod-&gt;symtab
(braket
id|i
)braket
dot
id|st_value
OL
id|nextval
)paren
id|nextval
op_assign
id|mod-&gt;symtab
(braket
id|i
)braket
dot
id|st_value
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|best
)paren
r_return
l_int|NULL
suffix:semicolon
op_star
id|size
op_assign
id|nextval
op_minus
id|mod-&gt;symtab
(braket
id|best
)braket
dot
id|st_value
suffix:semicolon
op_star
id|offset
op_assign
id|addr
op_minus
id|mod-&gt;symtab
(braket
id|best
)braket
dot
id|st_value
suffix:semicolon
r_return
id|mod-&gt;strtab
op_plus
id|mod-&gt;symtab
(braket
id|best
)braket
dot
id|st_name
suffix:semicolon
)brace
multiline_comment|/* For kallsyms to ask for address resolution.  NULL means not found.&n;   We don&squot;t lock, as this is used for oops resolution and races are a&n;   lesser concern. */
DECL|function|module_address_lookup
r_const
r_char
op_star
id|module_address_lookup
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
op_star
id|size
comma
r_int
r_int
op_star
id|offset
comma
r_char
op_star
op_star
id|modname
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|mod
comma
op_amp
id|modules
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|within
c_func
(paren
id|addr
comma
id|mod-&gt;module_init
comma
id|mod-&gt;init_size
)paren
op_logical_or
id|within
c_func
(paren
id|addr
comma
id|mod-&gt;module_core
comma
id|mod-&gt;core_size
)paren
)paren
(brace
op_star
id|modname
op_assign
id|mod-&gt;name
suffix:semicolon
r_return
id|get_ksymbol
c_func
(paren
id|mod
comma
id|addr
comma
id|size
comma
id|offset
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_KALLSYMS */
multiline_comment|/* Called by the /proc file system to return a list of modules. */
DECL|function|m_start
r_static
r_void
op_star
id|m_start
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|list_head
op_star
id|i
suffix:semicolon
id|loff_t
id|n
op_assign
l_int|0
suffix:semicolon
id|down
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|i
comma
op_amp
id|modules
)paren
(brace
r_if
c_cond
(paren
id|n
op_increment
op_eq
op_star
id|pos
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
op_amp
id|modules
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|m_next
r_static
r_void
op_star
id|m_next
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|p
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|list_head
op_star
id|i
op_assign
id|p
suffix:semicolon
(paren
op_star
id|pos
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i-&gt;next
op_eq
op_amp
id|modules
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|i-&gt;next
suffix:semicolon
)brace
DECL|function|m_stop
r_static
r_void
id|m_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|p
)paren
(brace
id|up
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
)brace
DECL|function|m_show
r_static
r_int
id|m_show
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|p
)paren
(brace
r_struct
id|module
op_star
id|mod
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|module
comma
id|list
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;%s %lu&quot;
comma
id|mod-&gt;name
comma
id|mod-&gt;init_size
op_plus
id|mod-&gt;core_size
)paren
suffix:semicolon
id|print_unload_info
c_func
(paren
id|m
comma
id|mod
)paren
suffix:semicolon
multiline_comment|/* Informative for users. */
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot; %s&quot;
comma
id|mod-&gt;state
op_eq
id|MODULE_STATE_GOING
ques
c_cond
l_string|&quot;Unloading&quot;
suffix:colon
id|mod-&gt;state
op_eq
id|MODULE_STATE_COMING
ques
c_cond
l_string|&quot;Loading&quot;
suffix:colon
l_string|&quot;Live&quot;
)paren
suffix:semicolon
multiline_comment|/* Used by oprofile and other similar tools. */
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot; 0x%p&quot;
comma
id|mod-&gt;module_core
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Format: modulename size refcount deps&n;&n;   Where refcount is a number or -, and deps is a comma-separated list&n;   of depends or -.&n;*/
DECL|variable|modules_op
r_struct
id|seq_operations
id|modules_op
op_assign
(brace
dot
id|start
op_assign
id|m_start
comma
dot
id|next
op_assign
id|m_next
comma
dot
id|stop
op_assign
id|m_stop
comma
dot
id|show
op_assign
id|m_show
)brace
suffix:semicolon
multiline_comment|/* Given an address, look for it in the module exception tables. */
DECL|function|search_module_extables
r_const
r_struct
id|exception_table_entry
op_star
id|search_module_extables
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_const
r_struct
id|exception_table_entry
op_star
id|e
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|exception_table
op_star
id|i
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|i
comma
op_amp
id|extables
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|i-&gt;num_entries
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|e
op_assign
id|search_extable
c_func
(paren
id|i-&gt;entry
comma
id|i-&gt;entry
op_plus
id|i-&gt;num_entries
op_minus
l_int|1
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
)paren
r_break
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Now, if we found one, we are running inside it now, hence&n;           we cannot unload the module, hence no refcnt needed. */
r_return
id|e
suffix:semicolon
)brace
multiline_comment|/* Is this a valid kernel address?  We don&squot;t grab the lock: we are oopsing. */
DECL|function|module_text_address
r_int
id|module_text_address
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|mod
comma
op_amp
id|modules
comma
id|list
)paren
r_if
c_cond
(paren
id|within
c_func
(paren
id|addr
comma
id|mod-&gt;module_init
comma
id|mod-&gt;init_size
)paren
op_logical_or
id|within
c_func
(paren
id|addr
comma
id|mod-&gt;module_core
comma
id|mod-&gt;core_size
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Provided by the linker */
r_extern
r_const
r_struct
id|kernel_symbol
id|__start___ksymtab
(braket
)braket
suffix:semicolon
r_extern
r_const
r_struct
id|kernel_symbol
id|__stop___ksymtab
(braket
)braket
suffix:semicolon
r_extern
r_const
r_struct
id|kernel_symbol
id|__start___gpl_ksymtab
(braket
)braket
suffix:semicolon
r_extern
r_const
r_struct
id|kernel_symbol
id|__stop___gpl_ksymtab
(braket
)braket
suffix:semicolon
DECL|variable|kernel_symbols
DECL|variable|kernel_gpl_symbols
r_static
r_struct
id|kernel_symbol_group
id|kernel_symbols
comma
id|kernel_gpl_symbols
suffix:semicolon
DECL|function|symbols_init
r_static
r_int
id|__init
id|symbols_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Add kernel symbols to symbol table */
id|kernel_symbols.num_syms
op_assign
(paren
id|__stop___ksymtab
op_minus
id|__start___ksymtab
)paren
suffix:semicolon
id|kernel_symbols.syms
op_assign
id|__start___ksymtab
suffix:semicolon
id|kernel_symbols.gplonly
op_assign
l_int|0
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|kernel_symbols.list
comma
op_amp
id|symbols
)paren
suffix:semicolon
id|kernel_gpl_symbols.num_syms
op_assign
(paren
id|__stop___gpl_ksymtab
op_minus
id|__start___gpl_ksymtab
)paren
suffix:semicolon
id|kernel_gpl_symbols.syms
op_assign
id|__start___gpl_ksymtab
suffix:semicolon
id|kernel_gpl_symbols.gplonly
op_assign
l_int|1
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|kernel_gpl_symbols.list
comma
op_amp
id|symbols
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|symbols_init
id|__initcall
c_func
(paren
id|symbols_init
)paren
suffix:semicolon
multiline_comment|/* Obsolete lvalue for broken code which asks about usage */
DECL|variable|module_dummy_usage
r_int
id|module_dummy_usage
op_assign
l_int|1
suffix:semicolon
DECL|variable|module_dummy_usage
id|EXPORT_SYMBOL
c_func
(paren
id|module_dummy_usage
)paren
suffix:semicolon
eof
