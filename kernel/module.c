multiline_comment|/* Rewritten by Rusty Russell, on the backs of many others...&n;   Copyright (C) 2001 Rusty Russell, 2002 Rusty Russell IBM.&n;&n;    This program is free software; you can redistribute it and/or modify&n;    it under the terms of the GNU General Public License as published by&n;    the Free Software Foundation; either version 2 of the License, or&n;    (at your option) any later version.&n;&n;    This program is distributed in the hope that it will be useful,&n;    but WITHOUT ANY WARRANTY; without even the implied warranty of&n;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;    GNU General Public License for more details.&n;&n;    You should have received a copy of the GNU General Public License&n;    along with this program; if not, write to the Free Software&n;    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n;*/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleloader.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/elf.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/rcupdate.h&gt;
macro_line|#include &lt;linux/cpu.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/cacheflush.h&gt;
macro_line|#if 0
mdefine_line|#define DEBUGP printk
macro_line|#else
DECL|macro|DEBUGP
mdefine_line|#define DEBUGP(fmt , a...)
macro_line|#endif
r_extern
r_const
r_struct
id|exception_table_entry
id|__start___ex_table
(braket
)braket
suffix:semicolon
r_extern
r_const
r_struct
id|exception_table_entry
id|__stop___ex_table
(braket
)braket
suffix:semicolon
r_extern
r_const
r_struct
id|kernel_symbol
id|__start___ksymtab
(braket
)braket
suffix:semicolon
r_extern
r_const
r_struct
id|kernel_symbol
id|__stop___ksymtab
(braket
)braket
suffix:semicolon
multiline_comment|/* Protects extables and symbol tables */
DECL|variable|modlist_lock
id|spinlock_t
id|modlist_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* The exception and symbol tables: start with kernel only. */
DECL|variable|extables
id|LIST_HEAD
c_func
(paren
id|extables
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|symbols
)paren
suffix:semicolon
DECL|variable|kernel_extable
r_static
r_struct
id|exception_table
id|kernel_extable
suffix:semicolon
DECL|variable|kernel_symbols
r_static
r_struct
id|kernel_symbol_group
id|kernel_symbols
suffix:semicolon
multiline_comment|/* List of modules, protected by module_mutex */
r_static
id|DECLARE_MUTEX
c_func
(paren
id|module_mutex
)paren
suffix:semicolon
DECL|variable|modules
id|LIST_HEAD
c_func
(paren
id|modules
)paren
suffix:semicolon
multiline_comment|/* FIXME: Accessed w/o lock on oops by some archs */
multiline_comment|/* Convenient structure for holding init and core sizes */
DECL|struct|sizes
r_struct
id|sizes
(brace
DECL|member|init_size
r_int
r_int
id|init_size
suffix:semicolon
DECL|member|core_size
r_int
r_int
id|core_size
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Find a symbol, return value and the symbol group */
DECL|function|__find_symbol
r_static
r_int
r_int
id|__find_symbol
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|kernel_symbol_group
op_star
op_star
id|group
)paren
(brace
r_struct
id|kernel_symbol_group
op_star
id|ks
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|ks
comma
op_amp
id|symbols
comma
id|list
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ks-&gt;num_syms
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|ks-&gt;syms
(braket
id|i
)braket
dot
id|name
comma
id|name
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|group
op_assign
id|ks
suffix:semicolon
r_return
id|ks-&gt;syms
(braket
id|i
)braket
dot
id|value
suffix:semicolon
)brace
)brace
)brace
id|DEBUGP
c_func
(paren
l_string|&quot;Failed to find symbol %s&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Find a symbol in this elf symbol table */
DECL|function|find_local_symbol
r_static
r_int
r_int
id|find_local_symbol
c_func
(paren
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|symindex
comma
r_const
r_char
op_star
id|strtab
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|Elf_Sym
op_star
id|sym
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_offset
suffix:semicolon
multiline_comment|/* Search (defined) internal symbols first. */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
op_star
id|sym
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sym
(braket
id|i
)braket
dot
id|st_shndx
op_ne
id|SHN_UNDEF
op_logical_and
id|strcmp
c_func
(paren
id|name
comma
id|strtab
op_plus
id|sym
(braket
id|i
)braket
dot
id|st_name
)paren
op_eq
l_int|0
)paren
r_return
id|sym
(braket
id|i
)braket
dot
id|st_value
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Search for module by name: must hold module_mutex. */
DECL|function|find_module
r_static
r_struct
id|module
op_star
id|find_module
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|mod
comma
op_amp
id|modules
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|mod-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
r_return
id|mod
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MODULE_UNLOAD
multiline_comment|/* Init the unload section of the module. */
DECL|function|module_unload_init
r_static
r_void
id|module_unload_init
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|mod-&gt;modules_which_use_me
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|atomic_set
c_func
(paren
op_amp
id|mod-&gt;ref
(braket
id|i
)braket
dot
id|count
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Backwards compatibility macros put refcount during init. */
id|mod-&gt;waiter
op_assign
id|current
suffix:semicolon
)brace
multiline_comment|/* modules using other modules */
DECL|struct|module_use
r_struct
id|module_use
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|module_which_uses
r_struct
id|module
op_star
id|module_which_uses
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Does a already use b? */
DECL|function|already_uses
r_static
r_int
id|already_uses
c_func
(paren
r_struct
id|module
op_star
id|a
comma
r_struct
id|module
op_star
id|b
)paren
(brace
r_struct
id|module_use
op_star
id|use
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|use
comma
op_amp
id|b-&gt;modules_which_use_me
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|use-&gt;module_which_uses
op_eq
id|a
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;%s uses %s!&bslash;n&quot;
comma
id|a-&gt;name
comma
id|b-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|DEBUGP
c_func
(paren
l_string|&quot;%s does not use %s!&bslash;n&quot;
comma
id|a-&gt;name
comma
id|b-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Module a uses b */
DECL|function|use_module
r_static
r_int
id|use_module
c_func
(paren
r_struct
id|module
op_star
id|a
comma
r_struct
id|module
op_star
id|b
)paren
(brace
r_struct
id|module_use
op_star
id|use
suffix:semicolon
r_if
c_cond
(paren
id|b
op_eq
l_int|NULL
op_logical_or
id|already_uses
c_func
(paren
id|a
comma
id|b
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;Allocating new usage for %s.&bslash;n&quot;
comma
id|a-&gt;name
)paren
suffix:semicolon
id|use
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|use
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: out of memory loading&bslash;n&quot;
comma
id|a-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|use-&gt;module_which_uses
op_assign
id|a
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|use-&gt;list
comma
op_amp
id|b-&gt;modules_which_use_me
)paren
suffix:semicolon
id|try_module_get
c_func
(paren
id|b
)paren
suffix:semicolon
multiline_comment|/* Can&squot;t fail */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Clear the unload stuff of the module. */
DECL|function|module_unload_free
r_static
r_void
id|module_unload_free
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
r_struct
id|module
op_star
id|i
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|i
comma
op_amp
id|modules
comma
id|list
)paren
(brace
r_struct
id|module_use
op_star
id|use
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|use
comma
op_amp
id|i-&gt;modules_which_use_me
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|use-&gt;module_which_uses
op_eq
id|mod
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;%s unusing %s&bslash;n&quot;
comma
id|mod-&gt;name
comma
id|i-&gt;name
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|i
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|use-&gt;list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|use
)paren
suffix:semicolon
multiline_comment|/* There can be at most one match. */
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* Thread to stop each CPU in user context. */
DECL|enum|stopref_state
r_enum
id|stopref_state
(brace
DECL|enumerator|STOPREF_WAIT
id|STOPREF_WAIT
comma
DECL|enumerator|STOPREF_PREPARE
id|STOPREF_PREPARE
comma
DECL|enumerator|STOPREF_DISABLE_IRQ
id|STOPREF_DISABLE_IRQ
comma
DECL|enumerator|STOPREF_EXIT
id|STOPREF_EXIT
comma
)brace
suffix:semicolon
DECL|variable|stopref_state
r_static
r_enum
id|stopref_state
id|stopref_state
suffix:semicolon
DECL|variable|stopref_num_threads
r_static
r_int
r_int
id|stopref_num_threads
suffix:semicolon
DECL|variable|stopref_thread_ack
r_static
id|atomic_t
id|stopref_thread_ack
suffix:semicolon
DECL|function|stopref
r_static
r_int
id|stopref
c_func
(paren
r_void
op_star
id|cpu
)paren
(brace
r_int
id|irqs_disabled
op_assign
l_int|0
suffix:semicolon
r_int
id|prepared
op_assign
l_int|0
suffix:semicolon
id|sprintf
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;kmodule%lu&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|cpu
)paren
suffix:semicolon
multiline_comment|/* Highest priority we can manage, and move to right CPU. */
macro_line|#if 0 /* FIXME */
r_struct
id|sched_param
id|param
op_assign
(brace
dot
id|sched_priority
op_assign
id|MAX_RT_PRIO
op_minus
l_int|1
)brace
suffix:semicolon
id|setscheduler
c_func
(paren
id|current-&gt;pid
comma
id|SCHED_FIFO
comma
op_amp
id|param
)paren
suffix:semicolon
macro_line|#endif
id|set_cpus_allowed
c_func
(paren
id|current
comma
l_int|1
op_lshift
(paren
r_int
r_int
)paren
id|cpu
)paren
suffix:semicolon
multiline_comment|/* Ack: we are alive */
id|atomic_inc
c_func
(paren
op_amp
id|stopref_thread_ack
)paren
suffix:semicolon
multiline_comment|/* Simple state machine */
r_while
c_loop
(paren
id|stopref_state
op_ne
id|STOPREF_EXIT
)paren
(brace
r_if
c_cond
(paren
id|stopref_state
op_eq
id|STOPREF_DISABLE_IRQ
op_logical_and
op_logical_neg
id|irqs_disabled
)paren
(brace
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|irqs_disabled
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Ack: irqs disabled. */
id|atomic_inc
c_func
(paren
op_amp
id|stopref_thread_ack
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|stopref_state
op_eq
id|STOPREF_PREPARE
op_logical_and
op_logical_neg
id|prepared
)paren
(brace
multiline_comment|/* Everyone is in place, hold CPU. */
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
id|prepared
op_assign
l_int|1
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|stopref_thread_ack
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irqs_disabled
op_logical_or
id|prepared
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
r_else
id|yield
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Ack: we are exiting. */
id|atomic_inc
c_func
(paren
op_amp
id|stopref_thread_ack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irqs_disabled
)paren
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prepared
)paren
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Change the thread state */
DECL|function|stopref_set_state
r_static
r_void
id|stopref_set_state
c_func
(paren
r_enum
id|stopref_state
id|state
comma
r_int
id|sleep
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|stopref_thread_ack
comma
l_int|0
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|stopref_state
op_assign
id|state
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|stopref_thread_ack
)paren
op_ne
id|stopref_num_threads
)paren
(brace
r_if
c_cond
(paren
id|sleep
)paren
id|yield
c_func
(paren
)paren
suffix:semicolon
r_else
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Stop the machine.  Disables irqs. */
DECL|function|stop_refcounts
r_static
r_int
id|stop_refcounts
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
comma
id|cpu
suffix:semicolon
r_int
r_int
id|old_allowed
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* One thread per cpu.  We&squot;ll do our own. */
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: racy with set_cpus_allowed. */
id|old_allowed
op_assign
id|current-&gt;cpus_allowed
suffix:semicolon
id|set_cpus_allowed
c_func
(paren
id|current
comma
l_int|1
op_lshift
(paren
r_int
r_int
)paren
id|cpu
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|stopref_thread_ack
comma
l_int|0
)paren
suffix:semicolon
id|stopref_num_threads
op_assign
l_int|0
suffix:semicolon
id|stopref_state
op_assign
id|STOPREF_WAIT
suffix:semicolon
multiline_comment|/* No CPUs can come up or down during this. */
id|down
c_func
(paren
op_amp
id|cpucontrol
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|cpu
op_logical_or
op_logical_neg
id|cpu_online
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
id|ret
op_assign
id|kernel_thread
c_func
(paren
id|stopref
comma
(paren
r_void
op_star
)paren
(paren
r_int
)paren
id|i
comma
id|CLONE_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_break
suffix:semicolon
id|stopref_num_threads
op_increment
suffix:semicolon
)brace
multiline_comment|/* Wait for them all to come to life. */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|stopref_thread_ack
)paren
op_ne
id|stopref_num_threads
)paren
id|yield
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If some failed, kill them all. */
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|stopref_set_state
c_func
(paren
id|STOPREF_EXIT
comma
l_int|1
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cpucontrol
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t schedule us away at this point, please. */
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Now they are all scheduled, make them hold the CPUs, ready. */
id|stopref_set_state
c_func
(paren
id|STOPREF_PREPARE
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Make them disable irqs. */
id|stopref_set_state
c_func
(paren
id|STOPREF_DISABLE_IRQ
comma
l_int|0
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Restart the machine.  Re-enables irqs. */
DECL|function|restart_refcounts
r_static
r_void
id|restart_refcounts
c_func
(paren
r_void
)paren
(brace
id|stopref_set_state
c_func
(paren
id|STOPREF_EXIT
comma
l_int|0
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|cpucontrol
)paren
suffix:semicolon
)brace
macro_line|#else /* ...!SMP */
DECL|function|stop_refcounts
r_static
r_inline
r_int
id|stop_refcounts
c_func
(paren
r_void
)paren
(brace
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|restart_refcounts
r_static
r_inline
r_void
id|restart_refcounts
c_func
(paren
r_void
)paren
(brace
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|module_refcount
r_static
r_int
r_int
id|module_refcount
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
r_int
r_int
id|i
comma
id|total
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|total
op_add_assign
id|atomic_read
c_func
(paren
op_amp
id|mod-&gt;ref
(braket
id|i
)braket
dot
id|count
)paren
suffix:semicolon
r_return
id|total
suffix:semicolon
)brace
multiline_comment|/* This exists whether we can unload or not */
r_static
r_void
id|free_module
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MODULE_FORCE_UNLOAD
DECL|function|try_force
r_static
r_inline
r_int
id|try_force
c_func
(paren
r_int
r_int
id|flags
)paren
(brace
r_return
(paren
id|flags
op_amp
id|O_TRUNC
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|function|try_force
r_static
r_inline
r_int
id|try_force
c_func
(paren
r_int
r_int
id|flags
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_MODULE_FORCE_UNLOAD */
id|asmlinkage
r_int
DECL|function|sys_delete_module
id|sys_delete_module
c_func
(paren
r_const
r_char
op_star
id|name_user
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_char
id|name
(braket
id|MODULE_NAME_LEN
)braket
suffix:semicolon
r_int
id|ret
comma
id|forced
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_MODULE
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|strncpy_from_user
c_func
(paren
id|name
comma
id|name_user
comma
id|MODULE_NAME_LEN
op_minus
l_int|1
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|name
(braket
id|MODULE_NAME_LEN
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|module_mutex
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
id|mod
op_assign
id|find_module
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mod
)paren
(brace
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mod-&gt;modules_which_use_me
)paren
)paren
(brace
multiline_comment|/* Other modules depend on us: get rid of them first. */
id|ret
op_assign
op_minus
id|EWOULDBLOCK
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Already dying? */
r_if
c_cond
(paren
op_logical_neg
id|mod-&gt;live
)paren
(brace
multiline_comment|/* FIXME: if (force), slam module count and wake up&n;                   waiter --RR */
id|DEBUGP
c_func
(paren
l_string|&quot;%s already dying&bslash;n&quot;
comma
id|mod-&gt;name
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mod
op_member_access_from_pointer
m_exit
op_logical_or
id|mod-&gt;unsafe
)paren
(brace
id|forced
op_assign
id|try_force
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|forced
)paren
(brace
multiline_comment|/* This module can&squot;t be removed */
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/* Stop the machine so refcounts can&squot;t move: irqs disabled. */
id|DEBUGP
c_func
(paren
l_string|&quot;Stopping refcounts...&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|stop_refcounts
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* If it&squot;s not unused, quit unless we are told to block. */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|O_NONBLOCK
)paren
op_logical_and
id|module_refcount
c_func
(paren
id|mod
)paren
op_ne
l_int|0
)paren
(brace
id|forced
op_assign
id|try_force
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|forced
)paren
id|ret
op_assign
op_minus
id|EWOULDBLOCK
suffix:semicolon
)brace
r_else
(brace
id|mod-&gt;waiter
op_assign
id|current
suffix:semicolon
id|mod-&gt;live
op_assign
l_int|0
suffix:semicolon
)brace
id|restart_refcounts
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|forced
)paren
r_goto
id|destroy
suffix:semicolon
multiline_comment|/* Since we might sleep for some time, drop the semaphore first */
id|up
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;Looking at refcount...&bslash;n&quot;
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|module_refcount
c_func
(paren
id|mod
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|DEBUGP
c_func
(paren
l_string|&quot;Regrabbing mutex...&bslash;n&quot;
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
id|destroy
suffix:colon
multiline_comment|/* Final destruction now noone is using it. */
r_if
c_cond
(paren
id|mod
op_member_access_from_pointer
m_exit
)paren
id|mod
op_member_access_from_pointer
m_exit
(paren
)paren
suffix:semicolon
id|free_module
c_func
(paren
id|mod
)paren
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|print_unload_info
r_static
r_void
id|print_unload_info
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_struct
id|module
op_star
id|mod
)paren
(brace
r_struct
id|module_use
op_star
id|use
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot; %u&quot;
comma
id|module_refcount
c_func
(paren
id|mod
)paren
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|use
comma
op_amp
id|mod-&gt;modules_which_use_me
comma
id|list
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot; %s&quot;
comma
id|use-&gt;module_which_uses-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;unsafe
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot; [unsafe]&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mod
op_member_access_from_pointer
m_exit
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot; [permanent]&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|__symbol_put
r_void
id|__symbol_put
c_func
(paren
r_const
r_char
op_star
id|symbol
)paren
(brace
r_struct
id|kernel_symbol_group
op_star
id|ksg
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|__find_symbol
c_func
(paren
id|symbol
comma
op_amp
id|ksg
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|ksg-&gt;owner
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|__symbol_put
id|EXPORT_SYMBOL
c_func
(paren
id|__symbol_put
)paren
suffix:semicolon
DECL|function|symbol_put_addr
r_void
id|symbol_put_addr
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
r_struct
id|kernel_symbol_group
op_star
id|ks
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|ks
comma
op_amp
id|symbols
comma
id|list
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ks-&gt;num_syms
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ks-&gt;syms
(braket
id|i
)braket
dot
id|value
op_eq
(paren
r_int
r_int
)paren
id|addr
)paren
(brace
id|module_put
c_func
(paren
id|ks-&gt;owner
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|symbol_put_addr
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|symbol_put_addr
)paren
suffix:semicolon
macro_line|#else /* !CONFIG_MODULE_UNLOAD */
DECL|function|print_unload_info
r_static
r_void
id|print_unload_info
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_struct
id|module
op_star
id|mod
)paren
(brace
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|module_unload_free
r_static
r_inline
r_void
id|module_unload_free
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
)brace
DECL|function|use_module
r_static
r_inline
r_int
id|use_module
c_func
(paren
r_struct
id|module
op_star
id|a
comma
r_struct
id|module
op_star
id|b
)paren
(brace
r_return
id|try_module_get
c_func
(paren
id|b
)paren
suffix:semicolon
)brace
DECL|function|module_unload_init
r_static
r_inline
r_void
id|module_unload_init
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
)brace
id|asmlinkage
r_int
DECL|function|sys_delete_module
id|sys_delete_module
c_func
(paren
r_const
r_char
op_star
id|name_user
comma
r_int
r_int
id|flags
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_MODULE_UNLOAD */
multiline_comment|/* Find an symbol for this module (ie. resolve internals first).&n;   It we find one, record usage.  Must be holding module_mutex. */
DECL|function|find_symbol_internal
r_int
r_int
id|find_symbol_internal
c_func
(paren
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|symindex
comma
r_const
r_char
op_star
id|strtab
comma
r_const
r_char
op_star
id|name
comma
r_struct
id|module
op_star
id|mod
comma
r_struct
id|kernel_symbol_group
op_star
op_star
id|ksg
)paren
(brace
r_int
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|find_local_symbol
c_func
(paren
id|sechdrs
comma
id|symindex
comma
id|strtab
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
op_star
id|ksg
op_assign
l_int|NULL
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Look in other modules... */
id|spin_lock_irq
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
id|ret
op_assign
id|__find_symbol
c_func
(paren
id|name
comma
id|ksg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/* This can fail due to OOM, or module unloading */
r_if
c_cond
(paren
op_logical_neg
id|use_module
c_func
(paren
id|mod
comma
(paren
op_star
id|ksg
)paren
op_member_access_from_pointer
id|owner
)paren
)paren
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Free a module, remove from lists, etc (must hold module mutex). */
DECL|function|free_module
r_static
r_void
id|free_module
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
multiline_comment|/* Delete from various lists */
id|list_del
c_func
(paren
op_amp
id|mod-&gt;list
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|mod-&gt;symbols.list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|mod-&gt;extable.list
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
multiline_comment|/* These may be NULL, but that&squot;s OK */
id|module_free
c_func
(paren
id|mod
comma
id|mod-&gt;module_init
)paren
suffix:semicolon
id|module_free
c_func
(paren
id|mod
comma
id|mod-&gt;module_core
)paren
suffix:semicolon
multiline_comment|/* Module unload stuff */
id|module_unload_free
c_func
(paren
id|mod
)paren
suffix:semicolon
multiline_comment|/* Finally, free the module structure */
id|module_free
c_func
(paren
id|mod
comma
id|mod
)paren
suffix:semicolon
)brace
DECL|function|__symbol_get
r_void
op_star
id|__symbol_get
c_func
(paren
r_const
r_char
op_star
id|symbol
)paren
(brace
r_struct
id|kernel_symbol_group
op_star
id|ksg
suffix:semicolon
r_int
r_int
id|value
comma
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
id|value
op_assign
id|__find_symbol
c_func
(paren
id|symbol
comma
op_amp
id|ksg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_logical_and
op_logical_neg
id|try_module_get
c_func
(paren
id|ksg-&gt;owner
)paren
)paren
id|value
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|modlist_lock
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|value
suffix:semicolon
)brace
DECL|variable|__symbol_get
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|__symbol_get
)paren
suffix:semicolon
multiline_comment|/* Transfer one ELF section to the correct (init or core) area. */
DECL|function|copy_section
r_static
r_void
op_star
id|copy_section
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_void
op_star
id|base
comma
id|Elf_Shdr
op_star
id|sechdr
comma
r_struct
id|module
op_star
id|mod
comma
r_struct
id|sizes
op_star
id|used
)paren
(brace
r_void
op_star
id|dest
suffix:semicolon
r_int
r_int
op_star
id|use
suffix:semicolon
multiline_comment|/* Only copy to init section if there is one */
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|name
comma
l_string|&quot;.init&quot;
)paren
op_logical_and
id|mod-&gt;module_init
)paren
(brace
id|dest
op_assign
id|mod-&gt;module_init
suffix:semicolon
id|use
op_assign
op_amp
id|used-&gt;init_size
suffix:semicolon
)brace
r_else
(brace
id|dest
op_assign
id|mod-&gt;module_core
suffix:semicolon
id|use
op_assign
op_amp
id|used-&gt;core_size
suffix:semicolon
)brace
multiline_comment|/* Align up */
op_star
id|use
op_assign
id|ALIGN
c_func
(paren
op_star
id|use
comma
id|sechdr-&gt;sh_addralign
)paren
suffix:semicolon
id|dest
op_add_assign
op_star
id|use
suffix:semicolon
op_star
id|use
op_add_assign
id|sechdr-&gt;sh_size
suffix:semicolon
multiline_comment|/* May not actually be in the file (eg. bss). */
r_if
c_cond
(paren
id|sechdr-&gt;sh_type
op_ne
id|SHT_NOBITS
)paren
id|memcpy
c_func
(paren
id|dest
comma
id|base
op_plus
id|sechdr-&gt;sh_offset
comma
id|sechdr-&gt;sh_size
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
multiline_comment|/* Look for the special symbols */
DECL|function|grab_private_symbols
r_static
r_int
id|grab_private_symbols
c_func
(paren
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|symbolsec
comma
r_const
r_char
op_star
id|strtab
comma
r_struct
id|module
op_star
id|mod
)paren
(brace
id|Elf_Sym
op_star
id|sym
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|symbolsec
)braket
dot
id|sh_offset
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|sechdrs
(braket
id|symbolsec
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
op_star
id|sym
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
l_string|&quot;__initfn&quot;
comma
id|strtab
op_plus
id|sym
(braket
id|i
)braket
dot
id|st_name
)paren
op_eq
l_int|0
)paren
id|mod-&gt;init
op_assign
(paren
r_void
op_star
)paren
id|sym
(braket
id|i
)braket
dot
id|st_value
suffix:semicolon
macro_line|#ifdef CONFIG_MODULE_UNLOAD
r_if
c_cond
(paren
id|strcmp
c_func
(paren
l_string|&quot;__exitfn&quot;
comma
id|strtab
op_plus
id|sym
(braket
id|i
)braket
dot
id|st_name
)paren
op_eq
l_int|0
)paren
id|mod
op_member_access_from_pointer
m_exit
op_assign
(paren
r_void
op_star
)paren
id|sym
(braket
id|i
)braket
dot
id|st_value
suffix:semicolon
macro_line|#endif
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Deal with the given section */
DECL|function|handle_section
r_static
r_int
id|handle_section
c_func
(paren
r_const
r_char
op_star
id|name
comma
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|strindex
comma
r_int
r_int
id|symindex
comma
r_int
r_int
id|i
comma
r_struct
id|module
op_star
id|mod
)paren
(brace
r_int
id|ret
suffix:semicolon
r_const
r_char
op_star
id|strtab
op_assign
(paren
r_char
op_star
)paren
id|sechdrs
(braket
id|strindex
)braket
dot
id|sh_offset
suffix:semicolon
r_switch
c_cond
(paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
)paren
(brace
r_case
id|SHT_REL
suffix:colon
id|ret
op_assign
id|apply_relocate
c_func
(paren
id|sechdrs
comma
id|strtab
comma
id|symindex
comma
id|i
comma
id|mod
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SHT_RELA
suffix:colon
id|ret
op_assign
id|apply_relocate_add
c_func
(paren
id|sechdrs
comma
id|strtab
comma
id|symindex
comma
id|i
comma
id|mod
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SHT_SYMTAB
suffix:colon
id|ret
op_assign
id|grab_private_symbols
c_func
(paren
id|sechdrs
comma
id|i
comma
id|strtab
comma
id|mod
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEBUGP
c_func
(paren
l_string|&quot;Ignoring section %u: %s&bslash;n&quot;
comma
id|i
comma
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_NULL
ques
c_cond
l_string|&quot;NULL&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_PROGBITS
ques
c_cond
l_string|&quot;PROGBITS&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_SYMTAB
ques
c_cond
l_string|&quot;SYMTAB&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_STRTAB
ques
c_cond
l_string|&quot;STRTAB&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_RELA
ques
c_cond
l_string|&quot;RELA&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_HASH
ques
c_cond
l_string|&quot;HASH&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_DYNAMIC
ques
c_cond
l_string|&quot;DYNAMIC&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_NOTE
ques
c_cond
l_string|&quot;NOTE&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_NOBITS
ques
c_cond
l_string|&quot;NOBITS&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_REL
ques
c_cond
l_string|&quot;REL&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_SHLIB
ques
c_cond
l_string|&quot;SHLIB&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_DYNSYM
ques
c_cond
l_string|&quot;DYNSYM&quot;
suffix:colon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_NUM
ques
c_cond
l_string|&quot;NUM&quot;
suffix:colon
l_string|&quot;UNKNOWN&quot;
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Figure out total size desired for the common vars */
DECL|function|read_commons
r_static
r_int
r_int
id|read_commons
c_func
(paren
r_void
op_star
id|start
comma
id|Elf_Shdr
op_star
id|sechdr
)paren
(brace
r_int
r_int
id|size
comma
id|i
comma
id|max_align
suffix:semicolon
id|Elf_Sym
op_star
id|sym
suffix:semicolon
id|size
op_assign
id|max_align
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|sym
op_assign
id|start
op_plus
id|sechdr-&gt;sh_offset
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sechdr-&gt;sh_size
op_div
r_sizeof
(paren
id|Elf_Sym
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sym
(braket
id|i
)braket
dot
id|st_shndx
op_eq
id|SHN_COMMON
)paren
(brace
multiline_comment|/* Value encodes alignment. */
r_if
c_cond
(paren
id|sym
(braket
id|i
)braket
dot
id|st_value
OG
id|max_align
)paren
id|max_align
op_assign
id|sym
(braket
id|i
)braket
dot
id|st_value
suffix:semicolon
multiline_comment|/* Pad to required alignment */
id|size
op_assign
id|ALIGN
c_func
(paren
id|size
comma
id|sym
(braket
id|i
)braket
dot
id|st_value
)paren
op_plus
id|sym
(braket
id|i
)braket
dot
id|st_size
suffix:semicolon
)brace
)brace
multiline_comment|/* Now, add in max alignment requirement (with align&n;&t;   attribute, this could be large), so we know we have space&n;&t;   whatever the start alignment is */
r_return
id|size
op_plus
id|max_align
suffix:semicolon
)brace
multiline_comment|/* Change all symbols so that sh_value encodes the pointer directly. */
DECL|function|simplify_symbols
r_static
r_void
id|simplify_symbols
c_func
(paren
id|Elf_Shdr
op_star
id|sechdrs
comma
r_int
r_int
id|symindex
comma
r_int
r_int
id|strindex
comma
r_void
op_star
id|common
comma
r_struct
id|module
op_star
id|mod
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|Elf_Sym
op_star
id|sym
suffix:semicolon
multiline_comment|/* First simplify defined symbols, so if they become the&n;           &quot;answer&quot; to undefined symbols, copying their st_value us&n;           correct. */
r_for
c_loop
(paren
id|sym
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_offset
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
id|Elf_Sym
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|sym
(braket
id|i
)braket
dot
id|st_shndx
)paren
(brace
r_case
id|SHN_COMMON
suffix:colon
multiline_comment|/* Value encodes alignment. */
id|common
op_assign
(paren
r_void
op_star
)paren
id|ALIGN
c_func
(paren
(paren
r_int
r_int
)paren
id|common
comma
id|sym
(braket
id|i
)braket
dot
id|st_value
)paren
suffix:semicolon
multiline_comment|/* Change it to encode pointer */
id|sym
(braket
id|i
)braket
dot
id|st_value
op_assign
(paren
r_int
r_int
)paren
id|common
suffix:semicolon
id|common
op_add_assign
id|sym
(braket
id|i
)braket
dot
id|st_size
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SHN_ABS
suffix:colon
multiline_comment|/* Don&squot;t need to do anything */
id|DEBUGP
c_func
(paren
l_string|&quot;Absolute symbol: 0x%08lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|sym
(braket
id|i
)braket
dot
id|st_value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SHN_UNDEF
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|sym
(braket
id|i
)braket
dot
id|st_value
op_assign
(paren
r_int
r_int
)paren
(paren
id|sechdrs
(braket
id|sym
(braket
id|i
)braket
dot
id|st_shndx
)braket
dot
id|sh_offset
op_plus
id|sym
(braket
id|i
)braket
dot
id|st_value
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Now try to resolve undefined symbols */
r_for
c_loop
(paren
id|sym
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_offset
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
id|Elf_Sym
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sym
(braket
id|i
)braket
dot
id|st_shndx
op_eq
id|SHN_UNDEF
)paren
(brace
multiline_comment|/* Look for symbol */
r_struct
id|kernel_symbol_group
op_star
id|ksg
op_assign
l_int|NULL
suffix:semicolon
r_const
r_char
op_star
id|strtab
op_assign
(paren
r_char
op_star
)paren
id|sechdrs
(braket
id|strindex
)braket
dot
id|sh_offset
suffix:semicolon
id|sym
(braket
id|i
)braket
dot
id|st_value
op_assign
id|find_symbol_internal
c_func
(paren
id|sechdrs
comma
id|symindex
comma
id|strtab
comma
id|strtab
op_plus
id|sym
(braket
id|i
)braket
dot
id|st_name
comma
id|mod
comma
op_amp
id|ksg
)paren
suffix:semicolon
multiline_comment|/* We fake up &quot;__this_module&quot; */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|strtab
op_plus
id|sym
(braket
id|i
)braket
dot
id|st_name
comma
l_string|&quot;__this_module&quot;
)paren
op_eq
l_int|0
)paren
id|sym
(braket
id|i
)braket
dot
id|st_value
op_assign
(paren
r_int
r_int
)paren
id|mod
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Get the total allocation size of the init and non-init sections */
DECL|function|get_sizes
r_static
r_struct
id|sizes
id|get_sizes
c_func
(paren
r_const
id|Elf_Ehdr
op_star
id|hdr
comma
r_const
id|Elf_Shdr
op_star
id|sechdrs
comma
r_const
r_char
op_star
id|secstrings
)paren
(brace
r_struct
id|sizes
id|ret
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Everything marked ALLOC (this includes the exported&n;           symbols) */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|hdr-&gt;e_shnum
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
op_star
id|add
suffix:semicolon
multiline_comment|/* If it&squot;s called *.init*, and we&squot;re init, we&squot;re interested */
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
comma
l_string|&quot;.init&quot;
)paren
op_ne
l_int|0
)paren
id|add
op_assign
op_amp
id|ret.init_size
suffix:semicolon
r_else
id|add
op_assign
op_amp
id|ret.core_size
suffix:semicolon
r_if
c_cond
(paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_flags
op_amp
id|SHF_ALLOC
)paren
(brace
multiline_comment|/* Pad up to required alignment */
op_star
id|add
op_assign
id|ALIGN
c_func
(paren
op_star
id|add
comma
id|sechdrs
(braket
id|i
)braket
dot
id|sh_addralign
ques
c_cond
suffix:colon
l_int|1
)paren
suffix:semicolon
op_star
id|add
op_add_assign
id|sechdrs
(braket
id|i
)braket
dot
id|sh_size
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Allocate and load the module */
DECL|function|load_module
r_static
r_struct
id|module
op_star
id|load_module
c_func
(paren
r_void
op_star
id|umod
comma
r_int
r_int
id|len
comma
r_const
r_char
op_star
id|uargs
)paren
(brace
id|Elf_Ehdr
op_star
id|hdr
suffix:semicolon
id|Elf_Shdr
op_star
id|sechdrs
suffix:semicolon
r_char
op_star
id|secstrings
suffix:semicolon
r_int
r_int
id|i
comma
id|symindex
comma
id|exportindex
comma
id|strindex
comma
id|setupindex
comma
id|exindex
comma
id|modnameindex
suffix:semicolon
r_int
id|arglen
suffix:semicolon
r_int
r_int
id|common_length
suffix:semicolon
r_struct
id|sizes
id|sizes
comma
id|used
suffix:semicolon
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_void
op_star
id|ptr
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Stops spurious gcc uninitialized warning */
id|DEBUGP
c_func
(paren
l_string|&quot;load_module: umod=%p, len=%lu, uargs=%p&bslash;n&quot;
comma
id|umod
comma
id|len
comma
id|uargs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
op_star
id|hdr
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOEXEC
)paren
suffix:semicolon
multiline_comment|/* Suck in entire file: we&squot;ll want most of it. */
multiline_comment|/* vmalloc barfs on &quot;unusual&quot; numbers.  Check here */
r_if
c_cond
(paren
id|len
OG
l_int|64
op_star
l_int|1024
op_star
l_int|1024
op_logical_or
(paren
id|hdr
op_assign
id|vmalloc
c_func
(paren
id|len
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|hdr
comma
id|umod
comma
id|len
)paren
op_ne
l_int|0
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|free_hdr
suffix:semicolon
)brace
multiline_comment|/* Sanity checks against insmoding binaries or wrong arch,&n;           weird elf version */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|hdr-&gt;e_ident
comma
id|ELFMAG
comma
l_int|4
)paren
op_ne
l_int|0
op_logical_or
id|hdr-&gt;e_type
op_ne
id|ET_REL
op_logical_or
op_logical_neg
id|elf_check_arch
c_func
(paren
id|hdr
)paren
op_logical_or
id|hdr-&gt;e_shentsize
op_ne
r_sizeof
(paren
op_star
id|sechdrs
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOEXEC
suffix:semicolon
r_goto
id|free_hdr
suffix:semicolon
)brace
multiline_comment|/* Convenience variables */
id|sechdrs
op_assign
(paren
r_void
op_star
)paren
id|hdr
op_plus
id|hdr-&gt;e_shoff
suffix:semicolon
id|secstrings
op_assign
(paren
r_void
op_star
)paren
id|hdr
op_plus
id|sechdrs
(braket
id|hdr-&gt;e_shstrndx
)braket
dot
id|sh_offset
suffix:semicolon
multiline_comment|/* May not export symbols, or have setup params, so these may&n;           not exist */
id|exportindex
op_assign
id|setupindex
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* And these should exist, but gcc whinges if we don&squot;t init them */
id|symindex
op_assign
id|strindex
op_assign
id|exindex
op_assign
id|modnameindex
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Find where important sections are */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|hdr-&gt;e_shnum
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_SYMTAB
)paren
(brace
multiline_comment|/* Internal symbols */
id|DEBUGP
c_func
(paren
l_string|&quot;Symbol table in section %u&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|symindex
op_assign
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
comma
l_string|&quot;.modulename&quot;
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* This module&squot;s name */
id|DEBUGP
c_func
(paren
l_string|&quot;Module name in section %u&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|modnameindex
op_assign
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
comma
l_string|&quot;__ksymtab&quot;
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Exported symbols. */
id|DEBUGP
c_func
(paren
l_string|&quot;EXPORT table in section %u&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|exportindex
op_assign
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
comma
l_string|&quot;.strtab&quot;
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Strings */
id|DEBUGP
c_func
(paren
l_string|&quot;String table found in section %u&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|strindex
op_assign
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
comma
l_string|&quot;.setup.init&quot;
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Setup parameter info */
id|DEBUGP
c_func
(paren
l_string|&quot;Setup table found in section %u&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|setupindex
op_assign
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
comma
l_string|&quot;__ex_table&quot;
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Exception table */
id|DEBUGP
c_func
(paren
l_string|&quot;Exception table found in section %u&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|exindex
op_assign
id|i
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_KALLSYMS
multiline_comment|/* symbol and string tables for decoding later. */
r_if
c_cond
(paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_type
op_eq
id|SHT_SYMTAB
op_logical_or
id|i
op_eq
id|hdr-&gt;e_shstrndx
)paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_flags
op_or_assign
id|SHF_ALLOC
suffix:semicolon
macro_line|#endif
macro_line|#ifndef CONFIG_MODULE_UNLOAD
multiline_comment|/* Don&squot;t load .exit sections */
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
comma
l_string|&quot;.exit&quot;
)paren
)paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_flags
op_and_assign
op_complement
(paren
r_int
r_int
)paren
id|SHF_ALLOC
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
op_logical_neg
id|modnameindex
)paren
(brace
id|DEBUGP
c_func
(paren
l_string|&quot;Module has no name!&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOEXEC
suffix:semicolon
r_goto
id|free_hdr
suffix:semicolon
)brace
multiline_comment|/* Now allocate space for the module proper, and copy name and args. */
id|err
op_assign
id|strlen_user
c_func
(paren
id|uargs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|free_hdr
suffix:semicolon
id|arglen
op_assign
id|err
suffix:semicolon
id|mod
op_assign
id|module_alloc
c_func
(paren
r_sizeof
(paren
op_star
id|mod
)paren
op_plus
id|arglen
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mod
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|free_hdr
suffix:semicolon
)brace
id|memset
c_func
(paren
id|mod
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|mod
)paren
op_plus
id|arglen
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|mod-&gt;args
comma
id|uargs
comma
id|arglen
)paren
op_ne
l_int|0
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|free_mod
suffix:semicolon
)brace
id|strncpy
c_func
(paren
id|mod-&gt;name
comma
(paren
r_char
op_star
)paren
id|hdr
op_plus
id|sechdrs
(braket
id|modnameindex
)braket
dot
id|sh_offset
comma
r_sizeof
(paren
id|mod-&gt;name
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|find_module
c_func
(paren
id|mod-&gt;name
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
id|free_mod
suffix:semicolon
)brace
multiline_comment|/* Initialize the lists, since they will be list_del&squot;d if init fails */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|mod-&gt;extable.list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|mod-&gt;list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|mod-&gt;symbols.list
)paren
suffix:semicolon
id|mod-&gt;symbols.owner
op_assign
id|mod
suffix:semicolon
id|mod-&gt;live
op_assign
l_int|0
suffix:semicolon
id|module_unload_init
c_func
(paren
id|mod
)paren
suffix:semicolon
multiline_comment|/* How much space will we need?  (Common area in core) */
id|sizes
op_assign
id|get_sizes
c_func
(paren
id|hdr
comma
id|sechdrs
comma
id|secstrings
)paren
suffix:semicolon
id|common_length
op_assign
id|read_commons
c_func
(paren
id|hdr
comma
op_amp
id|sechdrs
(braket
id|symindex
)braket
)paren
suffix:semicolon
id|sizes.core_size
op_add_assign
id|common_length
suffix:semicolon
multiline_comment|/* Set these up, and allow archs to manipulate them. */
id|mod-&gt;core_size
op_assign
id|sizes.core_size
suffix:semicolon
id|mod-&gt;init_size
op_assign
id|sizes.init_size
suffix:semicolon
multiline_comment|/* Allow archs to add to them. */
id|err
op_assign
id|module_init_size
c_func
(paren
id|hdr
comma
id|sechdrs
comma
id|secstrings
comma
id|mod
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|free_mod
suffix:semicolon
id|mod-&gt;init_size
op_assign
id|err
suffix:semicolon
id|err
op_assign
id|module_core_size
c_func
(paren
id|hdr
comma
id|sechdrs
comma
id|secstrings
comma
id|mod
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|free_mod
suffix:semicolon
id|mod-&gt;core_size
op_assign
id|err
suffix:semicolon
multiline_comment|/* Do the allocs. */
id|ptr
op_assign
id|module_alloc
c_func
(paren
id|mod-&gt;core_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|free_mod
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ptr
comma
l_int|0
comma
id|mod-&gt;core_size
)paren
suffix:semicolon
id|mod-&gt;module_core
op_assign
id|ptr
suffix:semicolon
id|ptr
op_assign
id|module_alloc
c_func
(paren
id|mod-&gt;init_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|free_core
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ptr
comma
l_int|0
comma
id|mod-&gt;init_size
)paren
suffix:semicolon
id|mod-&gt;module_init
op_assign
id|ptr
suffix:semicolon
multiline_comment|/* Transfer each section which requires ALLOC, and set sh_offset&n;&t;   fields to absolute addresses. */
id|used.core_size
op_assign
id|common_length
suffix:semicolon
id|used.init_size
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|hdr-&gt;e_shnum
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sechdrs
(braket
id|i
)braket
dot
id|sh_flags
op_amp
id|SHF_ALLOC
)paren
(brace
id|ptr
op_assign
id|copy_section
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
comma
id|hdr
comma
op_amp
id|sechdrs
(braket
id|i
)braket
comma
id|mod
comma
op_amp
id|used
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ptr
)paren
)paren
r_goto
id|cleanup
suffix:semicolon
id|sechdrs
(braket
id|i
)braket
dot
id|sh_offset
op_assign
(paren
r_int
r_int
)paren
id|ptr
suffix:semicolon
)brace
r_else
(brace
id|sechdrs
(braket
id|i
)braket
dot
id|sh_offset
op_add_assign
(paren
r_int
r_int
)paren
id|hdr
suffix:semicolon
)brace
)brace
multiline_comment|/* Don&squot;t use more than we allocated! */
r_if
c_cond
(paren
id|used.init_size
OG
id|mod-&gt;init_size
op_logical_or
id|used.core_size
OG
id|mod-&gt;core_size
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Fix up syms, so that st_value is a pointer to location. */
id|simplify_symbols
c_func
(paren
id|sechdrs
comma
id|symindex
comma
id|strindex
comma
id|mod-&gt;module_core
comma
id|mod
)paren
suffix:semicolon
multiline_comment|/* Set up EXPORTed symbols */
r_if
c_cond
(paren
id|exportindex
)paren
(brace
id|mod-&gt;symbols.num_syms
op_assign
(paren
id|sechdrs
(braket
id|exportindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
op_star
id|mod-&gt;symbols.syms
)paren
)paren
suffix:semicolon
id|mod-&gt;symbols.syms
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|exportindex
)braket
dot
id|sh_offset
suffix:semicolon
)brace
multiline_comment|/* Set up exception table */
r_if
c_cond
(paren
id|exindex
)paren
(brace
multiline_comment|/* FIXME: Sort exception table. */
id|mod-&gt;extable.num_entries
op_assign
(paren
id|sechdrs
(braket
id|exindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
r_struct
id|exception_table_entry
)paren
)paren
suffix:semicolon
id|mod-&gt;extable.entry
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|exindex
)braket
dot
id|sh_offset
suffix:semicolon
)brace
multiline_comment|/* Now handle each section. */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|hdr-&gt;e_shnum
suffix:semicolon
id|i
op_increment
)paren
(brace
id|err
op_assign
id|handle_section
c_func
(paren
id|secstrings
op_plus
id|sechdrs
(braket
id|i
)braket
dot
id|sh_name
comma
id|sechdrs
comma
id|strindex
comma
id|symindex
comma
id|i
comma
id|mod
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|cleanup
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_KALLSYMS
id|mod-&gt;symtab
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_offset
suffix:semicolon
id|mod-&gt;num_syms
op_assign
id|sechdrs
(braket
id|symindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
id|Elf_Sym
)paren
suffix:semicolon
id|mod-&gt;strtab
op_assign
(paren
r_void
op_star
)paren
id|sechdrs
(braket
id|strindex
)braket
dot
id|sh_offset
suffix:semicolon
macro_line|#endif
id|err
op_assign
id|module_finalize
c_func
(paren
id|hdr
comma
id|sechdrs
comma
id|mod
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|cleanup
suffix:semicolon
macro_line|#if 0 /* Needs param support */
multiline_comment|/* Size of section 0 is 0, so this works well */
id|err
op_assign
id|parse_args
c_func
(paren
id|mod-&gt;args
comma
(paren
r_struct
id|kernel_param
op_star
)paren
id|sechdrs
(braket
id|setupindex
)braket
dot
id|sh_offset
comma
id|sechdrs
(braket
id|setupindex
)braket
dot
id|sh_size
op_div
r_sizeof
(paren
r_struct
id|kernel_param
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|cleanup
suffix:semicolon
macro_line|#endif
multiline_comment|/* Get rid of temporary copy */
id|vfree
c_func
(paren
id|hdr
)paren
suffix:semicolon
multiline_comment|/* Done! */
r_return
id|mod
suffix:semicolon
id|cleanup
suffix:colon
id|module_unload_free
c_func
(paren
id|mod
)paren
suffix:semicolon
id|module_free
c_func
(paren
id|mod
comma
id|mod-&gt;module_init
)paren
suffix:semicolon
id|free_core
suffix:colon
id|module_free
c_func
(paren
id|mod
comma
id|mod-&gt;module_core
)paren
suffix:semicolon
id|free_mod
suffix:colon
id|module_free
c_func
(paren
id|mod
comma
id|mod
)paren
suffix:semicolon
id|free_hdr
suffix:colon
id|vfree
c_func
(paren
id|hdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
r_else
r_return
id|ptr
suffix:semicolon
)brace
multiline_comment|/* This is where the real work happens */
id|asmlinkage
r_int
DECL|function|sys_init_module
id|sys_init_module
c_func
(paren
r_void
op_star
id|umod
comma
r_int
r_int
id|len
comma
r_const
r_char
op_star
id|uargs
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* Must have permission */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_MODULE
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* Only one module load at a time, please */
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|module_mutex
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
multiline_comment|/* Do all the hard work */
id|mod
op_assign
id|load_module
c_func
(paren
id|umod
comma
id|len
comma
id|uargs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|mod
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|mod
)paren
suffix:semicolon
)brace
multiline_comment|/* Flush the instruction cache, since we&squot;ve played with text */
r_if
c_cond
(paren
id|mod-&gt;module_init
)paren
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|mod-&gt;module_init
comma
(paren
r_int
r_int
)paren
id|mod-&gt;module_init
op_plus
id|mod-&gt;init_size
)paren
suffix:semicolon
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|mod-&gt;module_core
comma
(paren
r_int
r_int
)paren
id|mod-&gt;module_core
op_plus
id|mod-&gt;core_size
)paren
suffix:semicolon
multiline_comment|/* Now sew it into exception list (just in case...). */
id|spin_lock_irq
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|mod-&gt;extable.list
comma
op_amp
id|extables
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
multiline_comment|/* Note, setting the mod-&gt;live to 1 here is safe because we haven&squot;t&n;&t; * linked the module into the system&squot;s kernel symbol table yet,&n;&t; * which means that the only way any other kernel code can call&n;&t; * into this module right now is if this module hands out entry&n;&t; * pointers to the other code.  We assume that no module hands out&n;&t; * entry pointers to the rest of the kernel unless it is ready to&n;&t; * have them used.&n;&t; */
id|mod-&gt;live
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Start the module */
id|ret
op_assign
id|mod-&gt;init
ques
c_cond
id|mod
op_member_access_from_pointer
id|init
c_func
(paren
)paren
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
multiline_comment|/* Init routine failed: abort.  Try to protect us from&n;                   buggy refcounters. */
id|synchronize_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;unsafe
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: module is now stuck!&bslash;n&quot;
comma
id|mod-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Mark it &quot;live&quot; so that they can force&n;&t;&t;&t;   deletion later, and we don&squot;t keep getting&n;&t;&t;&t;   woken on every decrement. */
)brace
r_else
(brace
id|mod-&gt;live
op_assign
l_int|0
suffix:semicolon
id|free_module
c_func
(paren
id|mod
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Now it&squot;s a first class citizen! */
id|spin_lock_irq
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|mod-&gt;symbols.list
comma
op_amp
id|kernel_symbols.list
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|mod-&gt;list
comma
op_amp
id|modules
)paren
suffix:semicolon
id|module_free
c_func
(paren
id|mod
comma
id|mod-&gt;module_init
)paren
suffix:semicolon
id|mod-&gt;module_init
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* All ok! */
id|up
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_KALLSYMS
DECL|function|inside_init
r_static
r_inline
r_int
id|inside_init
c_func
(paren
r_struct
id|module
op_star
id|mod
comma
r_int
r_int
id|addr
)paren
(brace
r_if
c_cond
(paren
id|mod-&gt;module_init
op_logical_and
(paren
r_int
r_int
)paren
id|mod-&gt;module_init
op_le
id|addr
op_logical_and
(paren
r_int
r_int
)paren
id|mod-&gt;module_init
op_plus
id|mod-&gt;init_size
OG
id|addr
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|inside_core
r_static
r_inline
r_int
id|inside_core
c_func
(paren
r_struct
id|module
op_star
id|mod
comma
r_int
r_int
id|addr
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|mod-&gt;module_core
op_le
id|addr
op_logical_and
(paren
r_int
r_int
)paren
id|mod-&gt;module_core
op_plus
id|mod-&gt;core_size
OG
id|addr
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_ksymbol
r_static
r_const
r_char
op_star
id|get_ksymbol
c_func
(paren
r_struct
id|module
op_star
id|mod
comma
r_int
r_int
id|addr
comma
r_int
r_int
op_star
id|size
comma
r_int
r_int
op_star
id|offset
)paren
(brace
r_int
r_int
id|i
comma
id|next
op_assign
l_int|0
comma
id|best
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Scan for closest preceeding symbol, and next symbol. (ELF&n;           starts real symbols at 1). */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|mod-&gt;num_syms
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mod-&gt;symtab
(braket
id|i
)braket
dot
id|st_shndx
op_eq
id|SHN_UNDEF
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;symtab
(braket
id|i
)braket
dot
id|st_value
op_le
id|addr
op_logical_and
id|mod-&gt;symtab
(braket
id|i
)braket
dot
id|st_value
OG
id|mod-&gt;symtab
(braket
id|best
)braket
dot
id|st_value
)paren
id|best
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;symtab
(braket
id|i
)braket
dot
id|st_value
OG
id|addr
op_logical_and
id|mod-&gt;symtab
(braket
id|i
)braket
dot
id|st_value
OL
id|mod-&gt;symtab
(braket
id|next
)braket
dot
id|st_value
)paren
id|next
op_assign
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|best
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|next
)paren
(brace
multiline_comment|/* Last symbol?  It ends at the end of the module then. */
r_if
c_cond
(paren
id|inside_core
c_func
(paren
id|mod
comma
id|addr
)paren
)paren
op_star
id|size
op_assign
id|mod-&gt;module_core
op_plus
id|mod-&gt;core_size
op_minus
(paren
r_void
op_star
)paren
id|addr
suffix:semicolon
r_else
op_star
id|size
op_assign
id|mod-&gt;module_init
op_plus
id|mod-&gt;init_size
op_minus
(paren
r_void
op_star
)paren
id|addr
suffix:semicolon
)brace
r_else
op_star
id|size
op_assign
id|mod-&gt;symtab
(braket
id|next
)braket
dot
id|st_value
op_minus
id|addr
suffix:semicolon
op_star
id|offset
op_assign
id|addr
op_minus
id|mod-&gt;symtab
(braket
id|best
)braket
dot
id|st_value
suffix:semicolon
r_return
id|mod-&gt;strtab
op_plus
id|mod-&gt;symtab
(braket
id|best
)braket
dot
id|st_name
suffix:semicolon
)brace
multiline_comment|/* For kallsyms to ask for address resolution.  NULL means not found.&n;   We don&squot;t lock, as this is used for oops resolution and races are a&n;   lesser concern. */
DECL|function|module_address_lookup
r_const
r_char
op_star
id|module_address_lookup
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
op_star
id|size
comma
r_int
r_int
op_star
id|offset
comma
r_char
op_star
op_star
id|modname
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|mod
comma
op_amp
id|modules
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|inside_core
c_func
(paren
id|mod
comma
id|addr
)paren
op_logical_or
id|inside_init
c_func
(paren
id|mod
comma
id|addr
)paren
)paren
(brace
op_star
id|modname
op_assign
id|mod-&gt;name
suffix:semicolon
r_return
id|get_ksymbol
c_func
(paren
id|mod
comma
id|addr
comma
id|size
comma
id|offset
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_KALLSYMS */
multiline_comment|/* Called by the /proc file system to return a list of modules. */
DECL|function|m_start
r_static
r_void
op_star
id|m_start
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|list_head
op_star
id|i
suffix:semicolon
id|loff_t
id|n
op_assign
l_int|0
suffix:semicolon
id|down
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|i
comma
op_amp
id|modules
)paren
(brace
r_if
c_cond
(paren
id|n
op_increment
op_eq
op_star
id|pos
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
op_amp
id|modules
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|m_next
r_static
r_void
op_star
id|m_next
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|p
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|list_head
op_star
id|i
op_assign
id|p
suffix:semicolon
(paren
op_star
id|pos
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i-&gt;next
op_eq
op_amp
id|modules
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|i-&gt;next
suffix:semicolon
)brace
DECL|function|m_stop
r_static
r_void
id|m_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|p
)paren
(brace
id|up
c_func
(paren
op_amp
id|module_mutex
)paren
suffix:semicolon
)brace
DECL|function|m_show
r_static
r_int
id|m_show
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|p
)paren
(brace
r_struct
id|module
op_star
id|mod
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|module
comma
id|list
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;%s %lu&quot;
comma
id|mod-&gt;name
comma
id|mod-&gt;init_size
op_plus
id|mod-&gt;core_size
)paren
suffix:semicolon
id|print_unload_info
c_func
(paren
id|m
comma
id|mod
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|modules_op
r_struct
id|seq_operations
id|modules_op
op_assign
(brace
dot
id|start
op_assign
id|m_start
comma
dot
id|next
op_assign
id|m_next
comma
dot
id|stop
op_assign
id|m_stop
comma
dot
id|show
op_assign
id|m_show
)brace
suffix:semicolon
DECL|function|extable_init
r_void
id|__init
id|extable_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Add kernel symbols to symbol table */
id|kernel_symbols.num_syms
op_assign
(paren
id|__stop___ksymtab
op_minus
id|__start___ksymtab
)paren
suffix:semicolon
id|kernel_symbols.syms
op_assign
id|__start___ksymtab
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|kernel_symbols.list
comma
op_amp
id|symbols
)paren
suffix:semicolon
multiline_comment|/* Add kernel exception table to exception tables */
id|kernel_extable.num_entries
op_assign
(paren
id|__stop___ex_table
op_minus
id|__start___ex_table
)paren
suffix:semicolon
id|kernel_extable.entry
op_assign
id|__start___ex_table
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|kernel_extable.list
comma
op_amp
id|extables
)paren
suffix:semicolon
)brace
multiline_comment|/* Obsolete lvalue for broken code which asks about usage */
DECL|variable|module_dummy_usage
r_int
id|module_dummy_usage
op_assign
l_int|1
suffix:semicolon
DECL|variable|module_dummy_usage
id|EXPORT_SYMBOL
c_func
(paren
id|module_dummy_usage
)paren
suffix:semicolon
eof
