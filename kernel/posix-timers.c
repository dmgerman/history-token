multiline_comment|/*&n; * linux/kernel/posix_timers.c&n; *&n; *&n; * 2002-10-15  Posix Clocks &amp; timers&n; *                           by George Anzinger george@mvista.com&n; *&n; *&t;&t;&t;     Copyright (C) 2002 2003 by MontaVista Software.&n; *&n; * 2004-06-01  Fix CLOCK_REALTIME clock/timer TIMER_ABSTIME bug.&n; *&t;&t;&t;     Copyright (C) 2004 Boris Hu&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or (at&n; * your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU&n; * General Public License for more details.&n;&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * MontaVista Software | 1237 East Arques Avenue | Sunnyvale | CA 94085 | USA&n; */
multiline_comment|/* These are all the functions necessary to implement&n; * POSIX clocks &amp; timers&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;linux/idr.h&gt;
macro_line|#include &lt;linux/posix-timers.h&gt;
macro_line|#include &lt;linux/syscalls.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#ifndef div_long_long_rem
macro_line|#include &lt;asm/div64.h&gt;
DECL|macro|div_long_long_rem
mdefine_line|#define div_long_long_rem(dividend,divisor,remainder) ({ &bslash;&n;&t;&t;       u64 result = dividend;&t;&t;&bslash;&n;&t;&t;       *remainder = do_div(result,divisor); &bslash;&n;&t;&t;       result; })
macro_line|#endif
DECL|macro|CLOCK_REALTIME_RES
mdefine_line|#define CLOCK_REALTIME_RES TICK_NSEC  /* In nano seconds. */
DECL|function|mpy_l_X_l_ll
r_static
r_inline
id|u64
id|mpy_l_X_l_ll
c_func
(paren
r_int
r_int
id|mpy1
comma
r_int
r_int
id|mpy2
)paren
(brace
r_return
(paren
id|u64
)paren
id|mpy1
op_star
id|mpy2
suffix:semicolon
)brace
multiline_comment|/*&n; * Management arrays for POSIX timers.&t; Timers are kept in slab memory&n; * Timer ids are allocated by an external routine that keeps track of the&n; * id and the timer.  The external interface is:&n; *&n; * void *idr_find(struct idr *idp, int id);           to find timer_id &lt;id&gt;&n; * int idr_get_new(struct idr *idp, void *ptr);       to get a new id and&n; *                                                    related it to &lt;ptr&gt;&n; * void idr_remove(struct idr *idp, int id);          to release &lt;id&gt;&n; * void idr_init(struct idr *idp);                    to initialize &lt;idp&gt;&n; *                                                    which we supply.&n; * The idr_get_new *may* call slab for more memory so it must not be&n; * called under a spin lock.  Likewise idr_remore may release memory&n; * (but it may be ok to do this under a lock...).&n; * idr_find is just a memory look up and is quite fast.  A -1 return&n; * indicates that the requested id does not exist.&n; */
multiline_comment|/*&n; * Lets keep our timers in a slab cache :-)&n; */
DECL|variable|posix_timers_cache
r_static
id|kmem_cache_t
op_star
id|posix_timers_cache
suffix:semicolon
DECL|variable|posix_timers_id
r_static
r_struct
id|idr
id|posix_timers_id
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|idr_lock
)paren
suffix:semicolon
multiline_comment|/*&n; * Just because the timer is not in the timer list does NOT mean it is&n; * inactive.  It could be in the &quot;fire&quot; routine getting a new expire time.&n; */
DECL|macro|TIMER_INACTIVE
mdefine_line|#define TIMER_INACTIVE 1
DECL|macro|TIMER_RETRY
mdefine_line|#define TIMER_RETRY 1
macro_line|#ifdef CONFIG_SMP
DECL|macro|timer_active
macro_line|# define timer_active(tmr) &bslash;&n;&t;&t;((tmr)-&gt;it_timer.entry.prev != (void *)TIMER_INACTIVE)
DECL|macro|set_timer_inactive
macro_line|# define set_timer_inactive(tmr) &bslash;&n;&t;&t;do { &bslash;&n;&t;&t;&t;(tmr)-&gt;it_timer.entry.prev = (void *)TIMER_INACTIVE; &bslash;&n;&t;&t;} while (0)
macro_line|#else
DECL|macro|timer_active
macro_line|# define timer_active(tmr) BARFY&t;
singleline_comment|// error to use outside of SMP
DECL|macro|set_timer_inactive
macro_line|# define set_timer_inactive(tmr) do { } while (0)
macro_line|#endif
multiline_comment|/*&n; * we assume that the new SIGEV_THREAD_ID shares no bits with the other&n; * SIGEV values.  Here we put out an error if this assumption fails.&n; */
macro_line|#if SIGEV_THREAD_ID != (SIGEV_THREAD_ID &amp; &bslash;&n;                       ~(SIGEV_SIGNAL | SIGEV_NONE | SIGEV_THREAD))
macro_line|#error &quot;SIGEV_THREAD_ID must not share bit with other SIGEV values!&quot;
macro_line|#endif
DECL|macro|REQUEUE_PENDING
mdefine_line|#define REQUEUE_PENDING 1
multiline_comment|/*&n; * The timer ID is turned into a timer address by idr_find().&n; * Verifying a valid ID consists of:&n; *&n; * a) checking that idr_find() returns other than -1.&n; * b) checking that the timer id matches the one in the timer itself.&n; * c) that the timer owner is in the callers thread group.&n; */
multiline_comment|/*&n; * CLOCKs: The POSIX standard calls for a couple of clocks and allows us&n; *&t;    to implement others.  This structure defines the various&n; *&t;    clocks and allows the possibility of adding others.&t; We&n; *&t;    provide an interface to add clocks to the table and expect&n; *&t;    the &quot;arch&quot; code to add at least one clock that is high&n; *&t;    resolution.&t; Here we define the standard CLOCK_REALTIME as a&n; *&t;    1/HZ resolution clock.&n; *&n; * RESOLUTION: Clock resolution is used to round up timer and interval&n; *&t;    times, NOT to report clock times, which are reported with as&n; *&t;    much resolution as the system can muster.  In some cases this&n; *&t;    resolution may depend on the underlying clock hardware and&n; *&t;    may not be quantifiable until run time, and only then is the&n; *&t;    necessary code is written.&t;The standard says we should say&n; *&t;    something about this issue in the documentation...&n; *&n; * FUNCTIONS: The CLOCKs structure defines possible functions to handle&n; *&t;    various clock functions.  For clocks that use the standard&n; *&t;    system timer code these entries should be NULL.  This will&n; *&t;    allow dispatch without the overhead of indirect function&n; *&t;    calls.  CLOCKS that depend on other sources (e.g. WWV or GPS)&n; *&t;    must supply functions here, even if the function just returns&n; *&t;    ENOSYS.  The standard POSIX timer management code assumes the&n; *&t;    following: 1.) The k_itimer struct (sched.h) is used for the&n; *&t;    timer.  2.) The list, it_lock, it_clock, it_id and it_process&n; *&t;    fields are not modified by timer code.&n; *&n; *          At this time all functions EXCEPT clock_nanosleep can be&n; *          redirected by the CLOCKS structure.  Clock_nanosleep is in&n; *          there, but the code ignores it.&n; *&n; * Permissions: It is assumed that the clock_settime() function defined&n; *&t;    for each clock will take care of permission checks.&t; Some&n; *&t;    clocks may be set able by any user (i.e. local process&n; *&t;    clocks) others not.&t; Currently the only set able clock we&n; *&t;    have is CLOCK_REALTIME and its high res counter part, both of&n; *&t;    which we beg off on and pass to do_sys_settimeofday().&n; */
DECL|variable|posix_clocks
r_static
r_struct
id|k_clock
id|posix_clocks
(braket
id|MAX_CLOCKS
)braket
suffix:semicolon
multiline_comment|/*&n; * We only have one real clock that can be set so we need only one abs list,&n; * even if we should want to have several clocks with differing resolutions.&n; */
DECL|variable|abs_list
r_static
r_struct
id|k_clock_abs
id|abs_list
op_assign
(brace
dot
id|list
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|abs_list.list
)paren
comma
dot
id|lock
op_assign
id|SPIN_LOCK_UNLOCKED
)brace
suffix:semicolon
r_static
r_void
id|posix_timer_fn
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
id|u64
id|do_posix_clock_monotonic_gettime_parts
c_func
(paren
r_struct
id|timespec
op_star
id|tp
comma
r_struct
id|timespec
op_star
id|mo
)paren
suffix:semicolon
r_int
id|do_posix_clock_monotonic_gettime
c_func
(paren
r_struct
id|timespec
op_star
id|tp
)paren
suffix:semicolon
r_static
r_int
id|do_posix_clock_monotonic_get
c_func
(paren
id|clockid_t
comma
r_struct
id|timespec
op_star
id|tp
)paren
suffix:semicolon
r_static
r_struct
id|k_itimer
op_star
id|lock_timer
c_func
(paren
id|timer_t
id|timer_id
comma
r_int
r_int
op_star
id|flags
)paren
suffix:semicolon
DECL|function|unlock_timer
r_static
r_inline
r_void
id|unlock_timer
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
comma
r_int
r_int
id|flags
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|timr-&gt;it_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Define this to initialize every k_clock function table so all its&n; * function pointers are non-null, and always do indirect calls through the&n; * table.  Leave it undefined to instead leave null function pointers and&n; * decide at the call sites between a direct call (maybe inlined) to the&n; * default function and an indirect call through the table when it&squot;s filled&n; * in.  Which style is preferable is whichever performs better in the&n; * common case of using the default functions.&n; *&n;#define CLOCK_DISPATCH_DIRECT&n; */
macro_line|#ifdef CLOCK_DISPATCH_DIRECT
DECL|macro|CLOCK_DISPATCH
mdefine_line|#define CLOCK_DISPATCH(clock, call, arglist) &bslash;&n;&t;((clock) &lt; 0 ? posix_cpu_##call arglist : &bslash;&n;&t; (*posix_clocks[clock].call) arglist)
DECL|macro|DEFHOOK
mdefine_line|#define DEFHOOK(name)&t;if (clock-&gt;name == NULL) clock-&gt;name = common_##name
DECL|macro|COMMONDEFN
mdefine_line|#define COMMONDEFN&t;static
macro_line|#else
DECL|macro|CLOCK_DISPATCH
mdefine_line|#define CLOCK_DISPATCH(clock, call, arglist) &bslash;&n;&t;((clock) &lt; 0 ? posix_cpu_##call arglist : &bslash;&n;&t; (posix_clocks[clock].call != NULL &bslash;&n;&t;  ? (*posix_clocks[clock].call) arglist : common_##call arglist))
DECL|macro|DEFHOOK
mdefine_line|#define DEFHOOK(name)&t;&t;(void) 0 /* Nothing here.  */
DECL|macro|COMMONDEFN
mdefine_line|#define COMMONDEFN&t;static inline
macro_line|#endif
multiline_comment|/*&n; * Default clock hook functions when the struct k_clock passed&n; * to register_posix_clock leaves a function pointer null.&n; *&n; * The function common_CALL is the default implementation for&n; * the function pointer CALL in struct k_clock.&n; */
DECL|function|common_clock_getres
id|COMMONDEFN
r_int
id|common_clock_getres
c_func
(paren
id|clockid_t
id|which_clock
comma
r_struct
id|timespec
op_star
id|tp
)paren
(brace
id|tp-&gt;tv_sec
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;tv_nsec
op_assign
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|res
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|common_clock_get
id|COMMONDEFN
r_int
id|common_clock_get
c_func
(paren
id|clockid_t
id|which_clock
comma
r_struct
id|timespec
op_star
id|tp
)paren
(brace
id|getnstimeofday
c_func
(paren
id|tp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|common_clock_set
id|COMMONDEFN
r_int
id|common_clock_set
c_func
(paren
id|clockid_t
id|which_clock
comma
r_struct
id|timespec
op_star
id|tp
)paren
(brace
r_return
id|do_sys_settimeofday
c_func
(paren
id|tp
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|common_timer_create
id|COMMONDEFN
r_int
id|common_timer_create
c_func
(paren
r_struct
id|k_itimer
op_star
id|new_timer
)paren
(brace
id|init_timer
c_func
(paren
op_amp
id|new_timer-&gt;it_timer
)paren
suffix:semicolon
id|new_timer-&gt;it_timer.expires
op_assign
l_int|0
suffix:semicolon
id|new_timer-&gt;it_timer.data
op_assign
(paren
r_int
r_int
)paren
id|new_timer
suffix:semicolon
id|new_timer-&gt;it_timer.function
op_assign
id|posix_timer_fn
suffix:semicolon
id|set_timer_inactive
c_func
(paren
id|new_timer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * These ones are defined below.&n; */
r_static
r_int
id|common_nsleep
c_func
(paren
id|clockid_t
comma
r_int
id|flags
comma
r_struct
id|timespec
op_star
id|t
)paren
suffix:semicolon
r_static
r_void
id|common_timer_get
c_func
(paren
r_struct
id|k_itimer
op_star
comma
r_struct
id|itimerspec
op_star
)paren
suffix:semicolon
r_static
r_int
id|common_timer_set
c_func
(paren
r_struct
id|k_itimer
op_star
comma
r_int
comma
r_struct
id|itimerspec
op_star
comma
r_struct
id|itimerspec
op_star
)paren
suffix:semicolon
r_static
r_int
id|common_timer_del
c_func
(paren
r_struct
id|k_itimer
op_star
id|timer
)paren
suffix:semicolon
multiline_comment|/*&n; * Install default functions for hooks not filled in.&n; */
DECL|function|common_default_hooks
r_static
r_inline
r_void
id|common_default_hooks
c_func
(paren
r_struct
id|k_clock
op_star
id|clock
)paren
(brace
id|DEFHOOK
c_func
(paren
id|clock_getres
)paren
suffix:semicolon
id|DEFHOOK
c_func
(paren
id|clock_get
)paren
suffix:semicolon
id|DEFHOOK
c_func
(paren
id|clock_set
)paren
suffix:semicolon
id|DEFHOOK
c_func
(paren
id|timer_create
)paren
suffix:semicolon
id|DEFHOOK
c_func
(paren
id|timer_set
)paren
suffix:semicolon
id|DEFHOOK
c_func
(paren
id|timer_get
)paren
suffix:semicolon
id|DEFHOOK
c_func
(paren
id|timer_del
)paren
suffix:semicolon
id|DEFHOOK
c_func
(paren
id|nsleep
)paren
suffix:semicolon
)brace
DECL|macro|DEFHOOK
macro_line|#undef&t;DEFHOOK
multiline_comment|/*&n; * Return nonzero iff we know a priori this clockid_t value is bogus.&n; */
DECL|function|invalid_clockid
r_static
r_inline
r_int
id|invalid_clockid
c_func
(paren
id|clockid_t
id|which_clock
)paren
(brace
r_if
c_cond
(paren
id|which_clock
OL
l_int|0
)paren
multiline_comment|/* CPU clock, posix_cpu_* will check it */
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|which_clock
op_ge
id|MAX_CLOCKS
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|clock_getres
op_ne
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#ifndef CLOCK_DISPATCH_DIRECT
r_if
c_cond
(paren
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|res
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize everything, well, just everything in Posix clocks/timers ;)&n; */
DECL|function|init_posix_timers
r_static
id|__init
r_int
id|init_posix_timers
c_func
(paren
r_void
)paren
(brace
r_struct
id|k_clock
id|clock_realtime
op_assign
(brace
dot
id|res
op_assign
id|CLOCK_REALTIME_RES
comma
dot
id|abs_struct
op_assign
op_amp
id|abs_list
)brace
suffix:semicolon
r_struct
id|k_clock
id|clock_monotonic
op_assign
(brace
dot
id|res
op_assign
id|CLOCK_REALTIME_RES
comma
dot
id|abs_struct
op_assign
l_int|NULL
comma
dot
id|clock_get
op_assign
id|do_posix_clock_monotonic_get
comma
dot
id|clock_set
op_assign
id|do_posix_clock_nosettime
)brace
suffix:semicolon
id|register_posix_clock
c_func
(paren
id|CLOCK_REALTIME
comma
op_amp
id|clock_realtime
)paren
suffix:semicolon
id|register_posix_clock
c_func
(paren
id|CLOCK_MONOTONIC
comma
op_amp
id|clock_monotonic
)paren
suffix:semicolon
id|posix_timers_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;posix_timers_cache&quot;
comma
r_sizeof
(paren
r_struct
id|k_itimer
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|idr_init
c_func
(paren
op_amp
id|posix_timers_id
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|init_posix_timers
id|__initcall
c_func
(paren
id|init_posix_timers
)paren
suffix:semicolon
DECL|function|tstojiffie
r_static
r_void
id|tstojiffie
c_func
(paren
r_struct
id|timespec
op_star
id|tp
comma
r_int
id|res
comma
id|u64
op_star
id|jiff
)paren
(brace
r_int
id|sec
op_assign
id|tp-&gt;tv_sec
suffix:semicolon
r_int
id|nsec
op_assign
id|tp-&gt;tv_nsec
op_plus
id|res
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|nsec
OG
id|NSEC_PER_SEC
)paren
(brace
id|sec
op_increment
suffix:semicolon
id|nsec
op_sub_assign
id|NSEC_PER_SEC
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The scaling constants are defined in &lt;linux/time.h&gt;&n;&t; * The difference between there and here is that we do the&n;&t; * res rounding and compute a 64-bit result (well so does that&n;&t; * but it then throws away the high bits).&n;  &t; */
op_star
id|jiff
op_assign
(paren
id|mpy_l_X_l_ll
c_func
(paren
id|sec
comma
id|SEC_CONVERSION
)paren
op_plus
(paren
id|mpy_l_X_l_ll
c_func
(paren
id|nsec
comma
id|NSEC_CONVERSION
)paren
op_rshift
(paren
id|NSEC_JIFFIE_SC
op_minus
id|SEC_JIFFIE_SC
)paren
)paren
)paren
op_rshift
id|SEC_JIFFIE_SC
suffix:semicolon
)brace
multiline_comment|/*&n; * This function adjusts the timer as needed as a result of the clock&n; * being set.  It should only be called for absolute timers, and then&n; * under the abs_list lock.  It computes the time difference and sets&n; * the new jiffies value in the timer.  It also updates the timers&n; * reference wall_to_monotonic value.  It is complicated by the fact&n; * that tstojiffies() only handles positive times and it needs to work&n; * with both positive and negative times.  Also, for negative offsets,&n; * we need to defeat the res round up.&n; *&n; * Return is true if there is a new time, else false.&n; */
DECL|function|add_clockset_delta
r_static
r_int
id|add_clockset_delta
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
comma
r_struct
id|timespec
op_star
id|new_wall_to
)paren
(brace
r_struct
id|timespec
id|delta
suffix:semicolon
r_int
id|sign
op_assign
l_int|0
suffix:semicolon
id|u64
id|exp
suffix:semicolon
id|set_normalized_timespec
c_func
(paren
op_amp
id|delta
comma
id|new_wall_to-&gt;tv_sec
op_minus
id|timr-&gt;wall_to_prev.tv_sec
comma
id|new_wall_to-&gt;tv_nsec
op_minus
id|timr-&gt;wall_to_prev.tv_nsec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
(paren
id|delta.tv_sec
op_or
id|delta.tv_nsec
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|delta.tv_sec
OL
l_int|0
)paren
(brace
id|set_normalized_timespec
c_func
(paren
op_amp
id|delta
comma
op_minus
id|delta.tv_sec
comma
l_int|1
op_minus
id|delta.tv_nsec
op_minus
id|posix_clocks
(braket
id|timr-&gt;it_clock
)braket
dot
id|res
)paren
suffix:semicolon
id|sign
op_increment
suffix:semicolon
)brace
id|tstojiffie
c_func
(paren
op_amp
id|delta
comma
id|posix_clocks
(braket
id|timr-&gt;it_clock
)braket
dot
id|res
comma
op_amp
id|exp
)paren
suffix:semicolon
id|timr-&gt;wall_to_prev
op_assign
op_star
id|new_wall_to
suffix:semicolon
id|timr-&gt;it_timer.expires
op_add_assign
(paren
id|sign
ques
c_cond
op_minus
id|exp
suffix:colon
id|exp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|remove_from_abslist
r_static
r_void
id|remove_from_abslist
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|timr-&gt;abs_timer_entry
)paren
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|abs_list.lock
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|timr-&gt;abs_timer_entry
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|abs_list.lock
)paren
suffix:semicolon
)brace
)brace
DECL|function|schedule_next_timer
r_static
r_void
id|schedule_next_timer
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
)paren
(brace
r_struct
id|timespec
id|new_wall_to
suffix:semicolon
r_struct
id|now_struct
id|now
suffix:semicolon
r_int
r_int
id|seq
suffix:semicolon
multiline_comment|/*&n;&t; * Set up the timer for the next interval (if there is one).&n;&t; * Note: this code uses the abs_timer_lock to protect&n;&t; * wall_to_prev and must hold it until exp is set, not exactly&n;&t; * obvious...&n;&n;&t; * This function is used for CLOCK_REALTIME* and&n;&t; * CLOCK_MONOTONIC* timers.  If we ever want to handle other&n;&t; * CLOCKs, the calling code (do_schedule_next_timer) would need&n;&t; * to pull the &quot;clock&quot; info from the timer and dispatch the&n;&t; * &quot;other&quot; CLOCKs &quot;next timer&quot; code (which, I suppose should&n;&t; * also be added to the k_clock structure).&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|timr-&gt;it_incr
)paren
r_return
suffix:semicolon
r_do
(brace
id|seq
op_assign
id|read_seqbegin
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
id|new_wall_to
op_assign
id|wall_to_monotonic
suffix:semicolon
id|posix_get_now
c_func
(paren
op_amp
id|now
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|read_seqretry
c_func
(paren
op_amp
id|xtime_lock
comma
id|seq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|timr-&gt;abs_timer_entry
)paren
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|abs_list.lock
)paren
suffix:semicolon
id|add_clockset_delta
c_func
(paren
id|timr
comma
op_amp
id|new_wall_to
)paren
suffix:semicolon
id|posix_bump_timer
c_func
(paren
id|timr
comma
id|now
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|abs_list.lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|posix_bump_timer
c_func
(paren
id|timr
comma
id|now
)paren
suffix:semicolon
)brace
id|timr-&gt;it_overrun_last
op_assign
id|timr-&gt;it_overrun
suffix:semicolon
id|timr-&gt;it_overrun
op_assign
op_minus
l_int|1
suffix:semicolon
op_increment
id|timr-&gt;it_requeue_pending
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is exported for use by the signal deliver code.  It is&n; * called just prior to the info block being released and passes that&n; * block to us.  It&squot;s function is to update the overrun entry AND to&n; * restart the timer.  It should only be called if the timer is to be&n; * restarted (i.e. we have flagged this in the sys_private entry of the&n; * info block).&n; *&n; * To protect aginst the timer going away while the interrupt is queued,&n; * we require that the it_requeue_pending flag be set.&n; */
DECL|function|do_schedule_next_timer
r_void
id|do_schedule_next_timer
c_func
(paren
r_struct
id|siginfo
op_star
id|info
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|timr
op_assign
id|lock_timer
c_func
(paren
id|info-&gt;si_tid
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timr
op_logical_or
id|timr-&gt;it_requeue_pending
op_ne
id|info-&gt;si_sys_private
)paren
r_goto
m_exit
suffix:semicolon
id|schedule_next_timer
c_func
(paren
id|timr
)paren
suffix:semicolon
id|info-&gt;si_overrun
op_assign
id|timr-&gt;it_overrun_last
suffix:semicolon
m_exit
suffix:colon
r_if
c_cond
(paren
id|timr
)paren
id|unlock_timer
c_func
(paren
id|timr
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|posix_timer_event
r_int
id|posix_timer_event
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
comma
r_int
id|si_private
)paren
(brace
id|memset
c_func
(paren
op_amp
id|timr-&gt;sigq-&gt;info
comma
l_int|0
comma
r_sizeof
(paren
id|siginfo_t
)paren
)paren
suffix:semicolon
id|timr-&gt;sigq-&gt;info.si_sys_private
op_assign
id|si_private
suffix:semicolon
multiline_comment|/*&n;&t; * Send signal to the process that owns this timer.&n;&n;&t; * This code assumes that all the possible abs_lists share the&n;&t; * same lock (there is only one list at this time). If this is&n;&t; * not the case, the CLOCK info would need to be used to find&n;&t; * the proper abs list lock.&n;&t; */
id|timr-&gt;sigq-&gt;info.si_signo
op_assign
id|timr-&gt;it_sigev_signo
suffix:semicolon
id|timr-&gt;sigq-&gt;info.si_errno
op_assign
l_int|0
suffix:semicolon
id|timr-&gt;sigq-&gt;info.si_code
op_assign
id|SI_TIMER
suffix:semicolon
id|timr-&gt;sigq-&gt;info.si_tid
op_assign
id|timr-&gt;it_id
suffix:semicolon
id|timr-&gt;sigq-&gt;info.si_value
op_assign
id|timr-&gt;it_sigev_value
suffix:semicolon
r_if
c_cond
(paren
id|timr-&gt;it_sigev_notify
op_amp
id|SIGEV_THREAD_ID
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|timr-&gt;it_process-&gt;flags
op_amp
id|PF_EXITING
)paren
)paren
(brace
id|timr-&gt;it_sigev_notify
op_assign
id|SIGEV_SIGNAL
suffix:semicolon
id|put_task_struct
c_func
(paren
id|timr-&gt;it_process
)paren
suffix:semicolon
id|timr-&gt;it_process
op_assign
id|timr-&gt;it_process-&gt;group_leader
suffix:semicolon
r_goto
id|group
suffix:semicolon
)brace
r_return
id|send_sigqueue
c_func
(paren
id|timr-&gt;it_sigev_signo
comma
id|timr-&gt;sigq
comma
id|timr-&gt;it_process
)paren
suffix:semicolon
)brace
r_else
(brace
id|group
suffix:colon
r_return
id|send_group_sigqueue
c_func
(paren
id|timr-&gt;it_sigev_signo
comma
id|timr-&gt;sigq
comma
id|timr-&gt;it_process
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This function gets called when a POSIX.1b interval timer expires.  It&n; * is used as a callback from the kernel internal timer.  The&n; * run_timer_list code ALWAYS calls with interrupts on.&n;&n; * This code is for CLOCK_REALTIME* and CLOCK_MONOTONIC* timers.&n; */
DECL|function|posix_timer_fn
r_static
r_void
id|posix_timer_fn
c_func
(paren
r_int
r_int
id|__data
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
op_assign
(paren
r_struct
id|k_itimer
op_star
)paren
id|__data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|seq
suffix:semicolon
r_struct
id|timespec
id|delta
comma
id|new_wall_to
suffix:semicolon
id|u64
id|exp
op_assign
l_int|0
suffix:semicolon
r_int
id|do_notify
op_assign
l_int|1
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|timr-&gt;it_lock
comma
id|flags
)paren
suffix:semicolon
id|set_timer_inactive
c_func
(paren
id|timr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|timr-&gt;abs_timer_entry
)paren
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|abs_list.lock
)paren
suffix:semicolon
r_do
(brace
id|seq
op_assign
id|read_seqbegin
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
id|new_wall_to
op_assign
id|wall_to_monotonic
suffix:semicolon
)brace
r_while
c_loop
(paren
id|read_seqretry
c_func
(paren
op_amp
id|xtime_lock
comma
id|seq
)paren
)paren
suffix:semicolon
id|set_normalized_timespec
c_func
(paren
op_amp
id|delta
comma
id|new_wall_to.tv_sec
op_minus
id|timr-&gt;wall_to_prev.tv_sec
comma
id|new_wall_to.tv_nsec
op_minus
id|timr-&gt;wall_to_prev.tv_nsec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
(paren
id|delta.tv_sec
op_or
id|delta.tv_nsec
)paren
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* do nothing, timer is on time */
)brace
r_else
r_if
c_cond
(paren
id|delta.tv_sec
OL
l_int|0
)paren
(brace
multiline_comment|/* do nothing, timer is already late */
)brace
r_else
(brace
multiline_comment|/* timer is early due to a clock set */
id|tstojiffie
c_func
(paren
op_amp
id|delta
comma
id|posix_clocks
(braket
id|timr-&gt;it_clock
)braket
dot
id|res
comma
op_amp
id|exp
)paren
suffix:semicolon
id|timr-&gt;wall_to_prev
op_assign
id|new_wall_to
suffix:semicolon
id|timr-&gt;it_timer.expires
op_add_assign
id|exp
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
suffix:semicolon
id|do_notify
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|abs_list.lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_notify
)paren
(brace
r_int
id|si_private
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|timr-&gt;it_incr
)paren
id|si_private
op_assign
op_increment
id|timr-&gt;it_requeue_pending
suffix:semicolon
r_else
(brace
id|remove_from_abslist
c_func
(paren
id|timr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|posix_timer_event
c_func
(paren
id|timr
comma
id|si_private
)paren
)paren
multiline_comment|/*&n;&t;&t;&t; * signal was not sent because of sig_ignor&n;&t;&t;&t; * we will not get a call back to restart it AND&n;&t;&t;&t; * it should be restarted.&n;&t;&t;&t; */
id|schedule_next_timer
c_func
(paren
id|timr
)paren
suffix:semicolon
)brace
id|unlock_timer
c_func
(paren
id|timr
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* hold thru abs lock to keep irq off */
)brace
DECL|function|good_sigevent
r_static
r_inline
r_struct
id|task_struct
op_star
id|good_sigevent
c_func
(paren
id|sigevent_t
op_star
id|event
)paren
(brace
r_struct
id|task_struct
op_star
id|rtn
op_assign
id|current-&gt;group_leader
suffix:semicolon
r_if
c_cond
(paren
(paren
id|event-&gt;sigev_notify
op_amp
id|SIGEV_THREAD_ID
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|rtn
op_assign
id|find_task_by_pid
c_func
(paren
id|event-&gt;sigev_notify_thread_id
)paren
)paren
op_logical_or
id|rtn-&gt;tgid
op_ne
id|current-&gt;tgid
op_logical_or
(paren
id|event-&gt;sigev_notify
op_amp
op_complement
id|SIGEV_THREAD_ID
)paren
op_ne
id|SIGEV_SIGNAL
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|event-&gt;sigev_notify
op_amp
op_complement
id|SIGEV_THREAD_ID
)paren
op_ne
id|SIGEV_NONE
)paren
op_logical_and
(paren
(paren
id|event-&gt;sigev_signo
op_le
l_int|0
)paren
op_logical_or
(paren
id|event-&gt;sigev_signo
OG
id|SIGRTMAX
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|rtn
suffix:semicolon
)brace
DECL|function|register_posix_clock
r_void
id|register_posix_clock
c_func
(paren
id|clockid_t
id|clock_id
comma
r_struct
id|k_clock
op_star
id|new_clock
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|clock_id
op_ge
id|MAX_CLOCKS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;POSIX clock register failed for clock_id %d&bslash;n&quot;
comma
id|clock_id
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|posix_clocks
(braket
id|clock_id
)braket
op_assign
op_star
id|new_clock
suffix:semicolon
id|common_default_hooks
c_func
(paren
op_amp
id|posix_clocks
(braket
id|clock_id
)braket
)paren
suffix:semicolon
)brace
DECL|function|alloc_posix_timer
r_static
r_struct
id|k_itimer
op_star
id|alloc_posix_timer
c_func
(paren
r_void
)paren
(brace
r_struct
id|k_itimer
op_star
id|tmr
suffix:semicolon
id|tmr
op_assign
id|kmem_cache_alloc
c_func
(paren
id|posix_timers_cache
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmr
)paren
r_return
id|tmr
suffix:semicolon
id|memset
c_func
(paren
id|tmr
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|k_itimer
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|tmr-&gt;abs_timer_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
(paren
id|tmr-&gt;sigq
op_assign
id|sigqueue_alloc
c_func
(paren
)paren
)paren
)paren
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|posix_timers_cache
comma
id|tmr
)paren
suffix:semicolon
id|tmr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|tmr
suffix:semicolon
)brace
DECL|macro|IT_ID_SET
mdefine_line|#define IT_ID_SET&t;1
DECL|macro|IT_ID_NOT_SET
mdefine_line|#define IT_ID_NOT_SET&t;0
DECL|function|release_posix_timer
r_static
r_void
id|release_posix_timer
c_func
(paren
r_struct
id|k_itimer
op_star
id|tmr
comma
r_int
id|it_id_set
)paren
(brace
r_if
c_cond
(paren
id|it_id_set
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|idr_lock
comma
id|flags
)paren
suffix:semicolon
id|idr_remove
c_func
(paren
op_amp
id|posix_timers_id
comma
id|tmr-&gt;it_id
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|idr_lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|sigqueue_free
c_func
(paren
id|tmr-&gt;sigq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|tmr-&gt;it_process
)paren
op_logical_and
id|tmr-&gt;it_sigev_notify
op_eq
(paren
id|SIGEV_SIGNAL
op_or
id|SIGEV_THREAD_ID
)paren
)paren
id|put_task_struct
c_func
(paren
id|tmr-&gt;it_process
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|posix_timers_cache
comma
id|tmr
)paren
suffix:semicolon
)brace
multiline_comment|/* Create a POSIX.1b interval timer. */
id|asmlinkage
r_int
DECL|function|sys_timer_create
id|sys_timer_create
c_func
(paren
id|clockid_t
id|which_clock
comma
r_struct
id|sigevent
id|__user
op_star
id|timer_event_spec
comma
id|timer_t
id|__user
op_star
id|created_timer_id
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_struct
id|k_itimer
op_star
id|new_timer
op_assign
l_int|NULL
suffix:semicolon
r_int
id|new_timer_id
suffix:semicolon
r_struct
id|task_struct
op_star
id|process
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|sigevent_t
id|event
suffix:semicolon
r_int
id|it_id_set
op_assign
id|IT_ID_NOT_SET
suffix:semicolon
r_if
c_cond
(paren
id|invalid_clockid
c_func
(paren
id|which_clock
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|new_timer
op_assign
id|alloc_posix_timer
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|new_timer
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|new_timer-&gt;it_lock
)paren
suffix:semicolon
id|retry
suffix:colon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|idr_pre_get
c_func
(paren
op_amp
id|posix_timers_id
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|spin_lock_irq
c_func
(paren
op_amp
id|idr_lock
)paren
suffix:semicolon
id|error
op_assign
id|idr_get_new
c_func
(paren
op_amp
id|posix_timers_id
comma
(paren
r_void
op_star
)paren
id|new_timer
comma
op_amp
id|new_timer_id
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|idr_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|EAGAIN
)paren
r_goto
id|retry
suffix:semicolon
r_else
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/*&n;&t;&t; * Wierd looking, but we return EAGAIN if the IDR is&n;&t;&t; * full (proper POSIX return value for this)&n;&t;&t; */
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|it_id_set
op_assign
id|IT_ID_SET
suffix:semicolon
id|new_timer-&gt;it_id
op_assign
(paren
id|timer_t
)paren
id|new_timer_id
suffix:semicolon
id|new_timer-&gt;it_clock
op_assign
id|which_clock
suffix:semicolon
id|new_timer-&gt;it_incr
op_assign
l_int|0
suffix:semicolon
id|new_timer-&gt;it_overrun
op_assign
op_minus
l_int|1
suffix:semicolon
id|error
op_assign
id|CLOCK_DISPATCH
c_func
(paren
id|which_clock
comma
id|timer_create
comma
(paren
id|new_timer
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * return the timer_id now.  The next step is hard to&n;&t; * back out if there is an error.&n;&t; */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|created_timer_id
comma
op_amp
id|new_timer_id
comma
r_sizeof
(paren
id|new_timer_id
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|timer_event_spec
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|event
comma
id|timer_event_spec
comma
r_sizeof
(paren
id|event
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|new_timer-&gt;it_sigev_notify
op_assign
id|event.sigev_notify
suffix:semicolon
id|new_timer-&gt;it_sigev_signo
op_assign
id|event.sigev_signo
suffix:semicolon
id|new_timer-&gt;it_sigev_value
op_assign
id|event.sigev_value
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|process
op_assign
id|good_sigevent
c_func
(paren
op_amp
id|event
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We may be setting up this process for another&n;&t;&t;&t; * thread.  It may be exiting.  To catch this&n;&t;&t;&t; * case the we check the PF_EXITING flag.  If&n;&t;&t;&t; * the flag is not set, the siglock will catch&n;&t;&t;&t; * him before it is too late (in exit_itimers).&n;&t;&t;&t; *&n;&t;&t;&t; * The exec case is a bit more invloved but easy&n;&t;&t;&t; * to code.  If the process is in our thread&n;&t;&t;&t; * group (and it must be or we would not allow&n;&t;&t;&t; * it here) and is doing an exec, it will cause&n;&t;&t;&t; * us to be killed.  In this case it will wait&n;&t;&t;&t; * for us to die which means we can finish this&n;&t;&t;&t; * linkage with our last gasp. I.e. no code :)&n;&t;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|process-&gt;sighand-&gt;siglock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|process-&gt;flags
op_amp
id|PF_EXITING
)paren
)paren
(brace
id|new_timer-&gt;it_process
op_assign
id|process
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|new_timer-&gt;list
comma
op_amp
id|process-&gt;signal-&gt;posix_timers
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|process-&gt;sighand-&gt;siglock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_timer-&gt;it_sigev_notify
op_eq
(paren
id|SIGEV_SIGNAL
op_or
id|SIGEV_THREAD_ID
)paren
)paren
id|get_task_struct
c_func
(paren
id|process
)paren
suffix:semicolon
)brace
r_else
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|process-&gt;sighand-&gt;siglock
comma
id|flags
)paren
suffix:semicolon
id|process
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|process
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
(brace
id|new_timer-&gt;it_sigev_notify
op_assign
id|SIGEV_SIGNAL
suffix:semicolon
id|new_timer-&gt;it_sigev_signo
op_assign
id|SIGALRM
suffix:semicolon
id|new_timer-&gt;it_sigev_value.sival_int
op_assign
id|new_timer-&gt;it_id
suffix:semicolon
id|process
op_assign
id|current-&gt;group_leader
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|process-&gt;sighand-&gt;siglock
comma
id|flags
)paren
suffix:semicolon
id|new_timer-&gt;it_process
op_assign
id|process
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|new_timer-&gt;list
comma
op_amp
id|process-&gt;signal-&gt;posix_timers
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|process-&gt;sighand-&gt;siglock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * In the case of the timer belonging to another task, after&n;&t; * the task is unlocked, the timer is owned by the other task&n;&t; * and may cease to exist at any time.  Don&squot;t use or modify&n;&t; * new_timer after the unlock call.&n;&t; */
id|out
suffix:colon
r_if
c_cond
(paren
id|error
)paren
id|release_posix_timer
c_func
(paren
id|new_timer
comma
id|it_id_set
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * good_timespec&n; *&n; * This function checks the elements of a timespec structure.&n; *&n; * Arguments:&n; * ts&t;     : Pointer to the timespec structure to check&n; *&n; * Return value:&n; * If a NULL pointer was passed in, or the tv_nsec field was less than 0&n; * or greater than NSEC_PER_SEC, or the tv_sec field was less than 0,&n; * this function returns 0. Otherwise it returns 1.&n; */
DECL|function|good_timespec
r_static
r_int
id|good_timespec
c_func
(paren
r_const
r_struct
id|timespec
op_star
id|ts
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|ts
)paren
op_logical_or
(paren
id|ts-&gt;tv_sec
OL
l_int|0
)paren
op_logical_or
(paren
(paren
r_int
)paren
id|ts-&gt;tv_nsec
op_ge
id|NSEC_PER_SEC
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Locking issues: We need to protect the result of the id look up until&n; * we get the timer locked down so it is not deleted under us.  The&n; * removal is done under the idr spinlock so we use that here to bridge&n; * the find to the timer lock.  To avoid a dead lock, the timer id MUST&n; * be release with out holding the timer lock.&n; */
DECL|function|lock_timer
r_static
r_struct
id|k_itimer
op_star
id|lock_timer
c_func
(paren
id|timer_t
id|timer_id
comma
r_int
r_int
op_star
id|flags
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
suffix:semicolon
multiline_comment|/*&n;&t; * Watch out here.  We do a irqsave on the idr_lock and pass the&n;&t; * flags part over to the timer lock.  Must not let interrupts in&n;&t; * while we are moving the lock.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|idr_lock
comma
op_star
id|flags
)paren
suffix:semicolon
id|timr
op_assign
(paren
r_struct
id|k_itimer
op_star
)paren
id|idr_find
c_func
(paren
op_amp
id|posix_timers_id
comma
(paren
r_int
)paren
id|timer_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timr
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|timr-&gt;it_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|idr_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|timr-&gt;it_id
op_ne
id|timer_id
)paren
op_logical_or
op_logical_neg
(paren
id|timr-&gt;it_process
)paren
op_logical_or
id|timr-&gt;it_process-&gt;tgid
op_ne
id|current-&gt;tgid
)paren
(brace
id|unlock_timer
c_func
(paren
id|timr
comma
op_star
id|flags
)paren
suffix:semicolon
id|timr
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|idr_lock
comma
op_star
id|flags
)paren
suffix:semicolon
r_return
id|timr
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the time remaining on a POSIX.1b interval timer.  This function&n; * is ALWAYS called with spin_lock_irq on the timer, thus it must not&n; * mess with irq.&n; *&n; * We have a couple of messes to clean up here.  First there is the case&n; * of a timer that has a requeue pending.  These timers should appear to&n; * be in the timer list with an expiry as if we were to requeue them&n; * now.&n; *&n; * The second issue is the SIGEV_NONE timer which may be active but is&n; * not really ever put in the timer list (to save system resources).&n; * This timer may be expired, and if so, we will do it here.  Otherwise&n; * it is the same as a requeue pending timer WRT to what we should&n; * report.&n; */
r_static
r_void
DECL|function|common_timer_get
id|common_timer_get
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
comma
r_struct
id|itimerspec
op_star
id|cur_setting
)paren
(brace
r_int
r_int
id|expires
suffix:semicolon
r_struct
id|now_struct
id|now
suffix:semicolon
r_do
id|expires
op_assign
id|timr-&gt;it_timer.expires
suffix:semicolon
r_while
c_loop
(paren
(paren
r_volatile
r_int
)paren
(paren
id|timr-&gt;it_timer.expires
)paren
op_ne
id|expires
)paren
suffix:semicolon
id|posix_get_now
c_func
(paren
op_amp
id|now
)paren
suffix:semicolon
r_if
c_cond
(paren
id|expires
op_logical_and
(paren
(paren
id|timr-&gt;it_sigev_notify
op_amp
op_complement
id|SIGEV_THREAD_ID
)paren
op_eq
id|SIGEV_NONE
)paren
op_logical_and
op_logical_neg
id|timr-&gt;it_incr
op_logical_and
id|posix_time_before
c_func
(paren
op_amp
id|timr-&gt;it_timer
comma
op_amp
id|now
)paren
)paren
id|timr-&gt;it_timer.expires
op_assign
id|expires
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|expires
)paren
(brace
r_if
c_cond
(paren
id|timr-&gt;it_requeue_pending
op_amp
id|REQUEUE_PENDING
op_logical_or
(paren
id|timr-&gt;it_sigev_notify
op_amp
op_complement
id|SIGEV_THREAD_ID
)paren
op_eq
id|SIGEV_NONE
)paren
(brace
id|posix_bump_timer
c_func
(paren
id|timr
comma
id|now
)paren
suffix:semicolon
id|expires
op_assign
id|timr-&gt;it_timer.expires
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|timer_pending
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
)paren
id|expires
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|expires
)paren
id|expires
op_sub_assign
id|now.jiffies
suffix:semicolon
)brace
id|jiffies_to_timespec
c_func
(paren
id|expires
comma
op_amp
id|cur_setting-&gt;it_value
)paren
suffix:semicolon
id|jiffies_to_timespec
c_func
(paren
id|timr-&gt;it_incr
comma
op_amp
id|cur_setting-&gt;it_interval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_setting-&gt;it_value.tv_sec
OL
l_int|0
)paren
(brace
id|cur_setting-&gt;it_value.tv_nsec
op_assign
l_int|1
suffix:semicolon
id|cur_setting-&gt;it_value.tv_sec
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Get the time remaining on a POSIX.1b interval timer. */
id|asmlinkage
r_int
DECL|function|sys_timer_gettime
id|sys_timer_gettime
c_func
(paren
id|timer_t
id|timer_id
comma
r_struct
id|itimerspec
id|__user
op_star
id|setting
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
suffix:semicolon
r_struct
id|itimerspec
id|cur_setting
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|timr
op_assign
id|lock_timer
c_func
(paren
id|timer_id
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|CLOCK_DISPATCH
c_func
(paren
id|timr-&gt;it_clock
comma
id|timer_get
comma
(paren
id|timr
comma
op_amp
id|cur_setting
)paren
)paren
suffix:semicolon
id|unlock_timer
c_func
(paren
id|timr
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|setting
comma
op_amp
id|cur_setting
comma
r_sizeof
(paren
id|cur_setting
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the number of overruns of a POSIX.1b interval timer.  This is to&n; * be the overrun of the timer last delivered.  At the same time we are&n; * accumulating overruns on the next timer.  The overrun is frozen when&n; * the signal is delivered, either at the notify time (if the info block&n; * is not queued) or at the actual delivery time (as we are informed by&n; * the call back to do_schedule_next_timer().  So all we need to do is&n; * to pick up the frozen overrun.&n; */
id|asmlinkage
r_int
DECL|function|sys_timer_getoverrun
id|sys_timer_getoverrun
c_func
(paren
id|timer_t
id|timer_id
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
suffix:semicolon
r_int
id|overrun
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|timr
op_assign
id|lock_timer
c_func
(paren
id|timer_id
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|overrun
op_assign
id|timr-&gt;it_overrun_last
suffix:semicolon
id|unlock_timer
c_func
(paren
id|timr
comma
id|flags
)paren
suffix:semicolon
r_return
id|overrun
suffix:semicolon
)brace
multiline_comment|/*&n; * Adjust for absolute time&n; *&n; * If absolute time is given and it is not CLOCK_MONOTONIC, we need to&n; * adjust for the offset between the timer clock (CLOCK_MONOTONIC) and&n; * what ever clock he is using.&n; *&n; * If it is relative time, we need to add the current (CLOCK_MONOTONIC)&n; * time to it to get the proper time for the timer.&n; */
DECL|function|adjust_abs_time
r_static
r_int
id|adjust_abs_time
c_func
(paren
r_struct
id|k_clock
op_star
id|clock
comma
r_struct
id|timespec
op_star
id|tp
comma
r_int
id|abs
comma
id|u64
op_star
id|exp
comma
r_struct
id|timespec
op_star
id|wall_to
)paren
(brace
r_struct
id|timespec
id|now
suffix:semicolon
r_struct
id|timespec
id|oc
op_assign
op_star
id|tp
suffix:semicolon
id|u64
id|jiffies_64_f
suffix:semicolon
r_int
id|rtn
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|abs
)paren
(brace
multiline_comment|/*&n;&t;&t; * The mask pick up the 4 basic clocks &n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|clock
op_minus
op_amp
id|posix_clocks
(braket
l_int|0
)braket
)paren
op_amp
op_complement
id|CLOCKS_MASK
)paren
)paren
(brace
id|jiffies_64_f
op_assign
id|do_posix_clock_monotonic_gettime_parts
c_func
(paren
op_amp
id|now
comma
id|wall_to
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If we are doing a MONOTONIC clock&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|clock
op_minus
op_amp
id|posix_clocks
(braket
l_int|0
)braket
)paren
op_amp
id|CLOCKS_MONO
)paren
(brace
id|now.tv_sec
op_add_assign
id|wall_to-&gt;tv_sec
suffix:semicolon
id|now.tv_nsec
op_add_assign
id|wall_to-&gt;tv_nsec
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Not one of the basic clocks&n;&t;&t;&t; */
id|clock
op_member_access_from_pointer
id|clock_get
c_func
(paren
id|clock
op_minus
id|posix_clocks
comma
op_amp
id|now
)paren
suffix:semicolon
id|jiffies_64_f
op_assign
id|get_jiffies_64
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Take away now to get delta&n;&t;&t; */
id|oc.tv_sec
op_sub_assign
id|now.tv_sec
suffix:semicolon
id|oc.tv_nsec
op_sub_assign
id|now.tv_nsec
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Normalize...&n;&t;&t; */
r_while
c_loop
(paren
(paren
id|oc.tv_nsec
op_minus
id|NSEC_PER_SEC
)paren
op_ge
l_int|0
)paren
(brace
id|oc.tv_nsec
op_sub_assign
id|NSEC_PER_SEC
suffix:semicolon
id|oc.tv_sec
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|oc.tv_nsec
)paren
OL
l_int|0
)paren
(brace
id|oc.tv_nsec
op_add_assign
id|NSEC_PER_SEC
suffix:semicolon
id|oc.tv_sec
op_decrement
suffix:semicolon
)brace
)brace
r_else
(brace
id|jiffies_64_f
op_assign
id|get_jiffies_64
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check if the requested time is prior to now (if so set now)&n;&t; */
r_if
c_cond
(paren
id|oc.tv_sec
OL
l_int|0
)paren
id|oc.tv_sec
op_assign
id|oc.tv_nsec
op_assign
l_int|0
suffix:semicolon
id|tstojiffie
c_func
(paren
op_amp
id|oc
comma
id|clock-&gt;res
comma
id|exp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check if the requested time is more than the timer code&n;&t; * can handle (if so we error out but return the value too).&n;&t; */
r_if
c_cond
(paren
op_star
id|exp
OG
(paren
(paren
id|u64
)paren
id|MAX_JIFFY_OFFSET
)paren
)paren
multiline_comment|/*&n;&t;&t;&t; * This is a considered response, not exactly in&n;&t;&t;&t; * line with the standard (in fact it is silent on&n;&t;&t;&t; * possible overflows).  We assume such a large &n;&t;&t;&t; * value is ALMOST always a programming error and&n;&t;&t;&t; * try not to compound it by setting a really dumb&n;&t;&t;&t; * value.&n;&t;&t;&t; */
id|rtn
op_assign
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * return the actual jiffies expire time, full 64 bits&n;&t; */
op_star
id|exp
op_add_assign
id|jiffies_64_f
suffix:semicolon
r_return
id|rtn
suffix:semicolon
)brace
multiline_comment|/* Set a POSIX.1b interval timer. */
multiline_comment|/* timr-&gt;it_lock is taken. */
id|COMMONDEFN
r_int
DECL|function|common_timer_set
id|common_timer_set
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
comma
r_int
id|flags
comma
r_struct
id|itimerspec
op_star
id|new_setting
comma
r_struct
id|itimerspec
op_star
id|old_setting
)paren
(brace
r_struct
id|k_clock
op_star
id|clock
op_assign
op_amp
id|posix_clocks
(braket
id|timr-&gt;it_clock
)braket
suffix:semicolon
id|u64
id|expire_64
suffix:semicolon
r_if
c_cond
(paren
id|old_setting
)paren
id|common_timer_get
c_func
(paren
id|timr
comma
id|old_setting
)paren
suffix:semicolon
multiline_comment|/* disable the timer */
id|timr-&gt;it_incr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * careful here.  If smp we could be in the &quot;fire&quot; routine which will&n;&t; * be spinning as we hold the lock.  But this is ONLY an SMP issue.&n;&t; */
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|timer_active
c_func
(paren
id|timr
)paren
op_logical_and
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
)paren
multiline_comment|/*&n;&t;&t; * It can only be active if on an other cpu.  Since&n;&t;&t; * we have cleared the interval stuff above, it should&n;&t;&t; * clear once we release the spin lock.  Of course once&n;&t;&t; * we do that anything could happen, including the&n;&t;&t; * complete melt down of the timer.  So return with&n;&t;&t; * a &quot;retry&quot; exit status.&n;&t;&t; */
r_return
id|TIMER_RETRY
suffix:semicolon
id|set_timer_inactive
c_func
(paren
id|timr
)paren
suffix:semicolon
macro_line|#else
id|del_timer
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
suffix:semicolon
macro_line|#endif
id|remove_from_abslist
c_func
(paren
id|timr
)paren
suffix:semicolon
id|timr-&gt;it_requeue_pending
op_assign
(paren
id|timr-&gt;it_requeue_pending
op_plus
l_int|2
)paren
op_amp
op_complement
id|REQUEUE_PENDING
suffix:semicolon
id|timr-&gt;it_overrun_last
op_assign
l_int|0
suffix:semicolon
id|timr-&gt;it_overrun
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *switch off the timer when it_value is zero&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|new_setting-&gt;it_value.tv_sec
op_logical_and
op_logical_neg
id|new_setting-&gt;it_value.tv_nsec
)paren
(brace
id|timr-&gt;it_timer.expires
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|adjust_abs_time
c_func
(paren
id|clock
comma
op_amp
id|new_setting-&gt;it_value
comma
id|flags
op_amp
id|TIMER_ABSTIME
comma
op_amp
id|expire_64
comma
op_amp
(paren
id|timr-&gt;wall_to_prev
)paren
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|timr-&gt;it_timer.expires
op_assign
(paren
r_int
r_int
)paren
id|expire_64
suffix:semicolon
id|tstojiffie
c_func
(paren
op_amp
id|new_setting-&gt;it_interval
comma
id|clock-&gt;res
comma
op_amp
id|expire_64
)paren
suffix:semicolon
id|timr-&gt;it_incr
op_assign
(paren
r_int
r_int
)paren
id|expire_64
suffix:semicolon
multiline_comment|/*&n;&t; * We do not even queue SIGEV_NONE timers!  But we do put them&n;&t; * in the abs list so we can do that right.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|timr-&gt;it_sigev_notify
op_amp
op_complement
id|SIGEV_THREAD_ID
)paren
op_ne
id|SIGEV_NONE
)paren
)paren
id|add_timer
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|TIMER_ABSTIME
op_logical_and
id|clock-&gt;abs_struct
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|clock-&gt;abs_struct-&gt;lock
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
(paren
id|timr-&gt;abs_timer_entry
)paren
comma
op_amp
(paren
id|clock-&gt;abs_struct-&gt;list
)paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|clock-&gt;abs_struct-&gt;lock
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Set a POSIX.1b interval timer */
id|asmlinkage
r_int
DECL|function|sys_timer_settime
id|sys_timer_settime
c_func
(paren
id|timer_t
id|timer_id
comma
r_int
id|flags
comma
r_const
r_struct
id|itimerspec
id|__user
op_star
id|new_setting
comma
r_struct
id|itimerspec
id|__user
op_star
id|old_setting
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
suffix:semicolon
r_struct
id|itimerspec
id|new_spec
comma
id|old_spec
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|flag
suffix:semicolon
r_struct
id|itimerspec
op_star
id|rtn
op_assign
id|old_setting
ques
c_cond
op_amp
id|old_spec
suffix:colon
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_setting
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|new_spec
comma
id|new_setting
comma
r_sizeof
(paren
id|new_spec
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|good_timespec
c_func
(paren
op_amp
id|new_spec.it_interval
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|good_timespec
c_func
(paren
op_amp
id|new_spec.it_value
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|retry
suffix:colon
id|timr
op_assign
id|lock_timer
c_func
(paren
id|timer_id
comma
op_amp
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|error
op_assign
id|CLOCK_DISPATCH
c_func
(paren
id|timr-&gt;it_clock
comma
id|timer_set
comma
(paren
id|timr
comma
id|flags
comma
op_amp
id|new_spec
comma
id|rtn
)paren
)paren
suffix:semicolon
id|unlock_timer
c_func
(paren
id|timr
comma
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|TIMER_RETRY
)paren
(brace
id|rtn
op_assign
l_int|NULL
suffix:semicolon
singleline_comment|// We already got the old time...
r_goto
id|retry
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_setting
op_logical_and
op_logical_neg
id|error
op_logical_and
id|copy_to_user
c_func
(paren
id|old_setting
comma
op_amp
id|old_spec
comma
r_sizeof
(paren
id|old_spec
)paren
)paren
)paren
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|common_timer_del
id|COMMONDEFN
r_int
id|common_timer_del
c_func
(paren
r_struct
id|k_itimer
op_star
id|timer
)paren
(brace
id|timer-&gt;it_incr
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|timer_active
c_func
(paren
id|timer
)paren
op_logical_and
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|timer-&gt;it_timer
)paren
)paren
multiline_comment|/*&n;&t;&t; * It can only be active if on an other cpu.  Since&n;&t;&t; * we have cleared the interval stuff above, it should&n;&t;&t; * clear once we release the spin lock.  Of course once&n;&t;&t; * we do that anything could happen, including the&n;&t;&t; * complete melt down of the timer.  So return with&n;&t;&t; * a &quot;retry&quot; exit status.&n;&t;&t; */
r_return
id|TIMER_RETRY
suffix:semicolon
macro_line|#else
id|del_timer
c_func
(paren
op_amp
id|timer-&gt;it_timer
)paren
suffix:semicolon
macro_line|#endif
id|remove_from_abslist
c_func
(paren
id|timer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|timer_delete_hook
r_static
r_inline
r_int
id|timer_delete_hook
c_func
(paren
r_struct
id|k_itimer
op_star
id|timer
)paren
(brace
r_return
id|CLOCK_DISPATCH
c_func
(paren
id|timer-&gt;it_clock
comma
id|timer_del
comma
(paren
id|timer
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Delete a POSIX.1b interval timer. */
id|asmlinkage
r_int
DECL|function|sys_timer_delete
id|sys_timer_delete
c_func
(paren
id|timer_t
id|timer_id
)paren
(brace
r_struct
id|k_itimer
op_star
id|timer
suffix:semicolon
r_int
id|flags
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_int
id|error
suffix:semicolon
id|retry_delete
suffix:colon
macro_line|#endif
id|timer
op_assign
id|lock_timer
c_func
(paren
id|timer_id
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timer
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|error
op_assign
id|timer_delete_hook
c_func
(paren
id|timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|TIMER_RETRY
)paren
(brace
id|unlock_timer
c_func
(paren
id|timer
comma
id|flags
)paren
suffix:semicolon
r_goto
id|retry_delete
suffix:semicolon
)brace
macro_line|#else
id|timer_delete_hook
c_func
(paren
id|timer
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock
c_func
(paren
op_amp
id|current-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|timer-&gt;list
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|current-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This keeps any tasks waiting on the spin lock from thinking&n;&t; * they got something (see the lock code above).&n;&t; */
r_if
c_cond
(paren
id|timer-&gt;it_process
)paren
(brace
r_if
c_cond
(paren
id|timer-&gt;it_sigev_notify
op_eq
(paren
id|SIGEV_SIGNAL
op_or
id|SIGEV_THREAD_ID
)paren
)paren
id|put_task_struct
c_func
(paren
id|timer-&gt;it_process
)paren
suffix:semicolon
id|timer-&gt;it_process
op_assign
l_int|NULL
suffix:semicolon
)brace
id|unlock_timer
c_func
(paren
id|timer
comma
id|flags
)paren
suffix:semicolon
id|release_posix_timer
c_func
(paren
id|timer
comma
id|IT_ID_SET
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * return timer owned by the process, used by exit_itimers&n; */
DECL|function|itimer_delete
r_static
r_inline
r_void
id|itimer_delete
c_func
(paren
r_struct
id|k_itimer
op_star
id|timer
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_int
id|error
suffix:semicolon
id|retry_delete
suffix:colon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|timer-&gt;it_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|error
op_assign
id|timer_delete_hook
c_func
(paren
id|timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|TIMER_RETRY
)paren
(brace
id|unlock_timer
c_func
(paren
id|timer
comma
id|flags
)paren
suffix:semicolon
r_goto
id|retry_delete
suffix:semicolon
)brace
macro_line|#else
id|timer_delete_hook
c_func
(paren
id|timer
)paren
suffix:semicolon
macro_line|#endif
id|list_del
c_func
(paren
op_amp
id|timer-&gt;list
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This keeps any tasks waiting on the spin lock from thinking&n;&t; * they got something (see the lock code above).&n;&t; */
r_if
c_cond
(paren
id|timer-&gt;it_process
)paren
(brace
r_if
c_cond
(paren
id|timer-&gt;it_sigev_notify
op_eq
(paren
id|SIGEV_SIGNAL
op_or
id|SIGEV_THREAD_ID
)paren
)paren
id|put_task_struct
c_func
(paren
id|timer-&gt;it_process
)paren
suffix:semicolon
id|timer-&gt;it_process
op_assign
l_int|NULL
suffix:semicolon
)brace
id|unlock_timer
c_func
(paren
id|timer
comma
id|flags
)paren
suffix:semicolon
id|release_posix_timer
c_func
(paren
id|timer
comma
id|IT_ID_SET
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called by __exit_signal, only when there are no more&n; * references to the shared signal_struct.&n; */
DECL|function|exit_itimers
r_void
id|exit_itimers
c_func
(paren
r_struct
id|signal_struct
op_star
id|sig
)paren
(brace
r_struct
id|k_itimer
op_star
id|tmr
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|sig-&gt;posix_timers
)paren
)paren
(brace
id|tmr
op_assign
id|list_entry
c_func
(paren
id|sig-&gt;posix_timers.next
comma
r_struct
id|k_itimer
comma
id|list
)paren
suffix:semicolon
id|itimer_delete
c_func
(paren
id|tmr
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * And now for the &quot;clock&quot; calls&n; *&n; * These functions are called both from timer functions (with the timer&n; * spin_lock_irq() held and from clock calls with no locking.&t;They must&n; * use the save flags versions of locks.&n; */
multiline_comment|/*&n; * We do ticks here to avoid the irq lock ( they take sooo long).&n; * The seqlock is great here.  Since we a reader, we don&squot;t really care&n; * if we are interrupted since we don&squot;t take lock that will stall us or&n; * any other cpu. Voila, no irq lock is needed.&n; *&n; */
DECL|function|do_posix_clock_monotonic_gettime_parts
r_static
id|u64
id|do_posix_clock_monotonic_gettime_parts
c_func
(paren
r_struct
id|timespec
op_star
id|tp
comma
r_struct
id|timespec
op_star
id|mo
)paren
(brace
id|u64
id|jiff
suffix:semicolon
r_int
r_int
id|seq
suffix:semicolon
r_do
(brace
id|seq
op_assign
id|read_seqbegin
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
id|getnstimeofday
c_func
(paren
id|tp
)paren
suffix:semicolon
op_star
id|mo
op_assign
id|wall_to_monotonic
suffix:semicolon
id|jiff
op_assign
id|jiffies_64
suffix:semicolon
)brace
r_while
c_loop
(paren
id|read_seqretry
c_func
(paren
op_amp
id|xtime_lock
comma
id|seq
)paren
)paren
(brace
suffix:semicolon
)brace
r_return
id|jiff
suffix:semicolon
)brace
DECL|function|do_posix_clock_monotonic_get
r_static
r_int
id|do_posix_clock_monotonic_get
c_func
(paren
id|clockid_t
id|clock
comma
r_struct
id|timespec
op_star
id|tp
)paren
(brace
r_struct
id|timespec
id|wall_to_mono
suffix:semicolon
id|do_posix_clock_monotonic_gettime_parts
c_func
(paren
id|tp
comma
op_amp
id|wall_to_mono
)paren
suffix:semicolon
id|tp-&gt;tv_sec
op_add_assign
id|wall_to_mono.tv_sec
suffix:semicolon
id|tp-&gt;tv_nsec
op_add_assign
id|wall_to_mono.tv_nsec
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tp-&gt;tv_nsec
op_minus
id|NSEC_PER_SEC
)paren
OG
l_int|0
)paren
(brace
id|tp-&gt;tv_nsec
op_sub_assign
id|NSEC_PER_SEC
suffix:semicolon
id|tp-&gt;tv_sec
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|do_posix_clock_monotonic_gettime
r_int
id|do_posix_clock_monotonic_gettime
c_func
(paren
r_struct
id|timespec
op_star
id|tp
)paren
(brace
r_return
id|do_posix_clock_monotonic_get
c_func
(paren
id|CLOCK_MONOTONIC
comma
id|tp
)paren
suffix:semicolon
)brace
DECL|function|do_posix_clock_nosettime
r_int
id|do_posix_clock_nosettime
c_func
(paren
id|clockid_t
id|clockid
comma
r_struct
id|timespec
op_star
id|tp
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|do_posix_clock_notimer_create
r_int
id|do_posix_clock_notimer_create
c_func
(paren
r_struct
id|k_itimer
op_star
id|timer
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|do_posix_clock_nonanosleep
r_int
id|do_posix_clock_nonanosleep
c_func
(paren
id|clockid_t
id|clock
comma
r_int
id|flags
comma
r_struct
id|timespec
op_star
id|t
)paren
(brace
macro_line|#ifndef ENOTSUP
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
multiline_comment|/* aka ENOTSUP in userland for POSIX */
macro_line|#else  /*  parisc does define it separately.  */
r_return
op_minus
id|ENOTSUP
suffix:semicolon
macro_line|#endif
)brace
id|asmlinkage
r_int
DECL|function|sys_clock_settime
id|sys_clock_settime
c_func
(paren
id|clockid_t
id|which_clock
comma
r_const
r_struct
id|timespec
id|__user
op_star
id|tp
)paren
(brace
r_struct
id|timespec
id|new_tp
suffix:semicolon
r_if
c_cond
(paren
id|invalid_clockid
c_func
(paren
id|which_clock
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|new_tp
comma
id|tp
comma
r_sizeof
(paren
op_star
id|tp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|CLOCK_DISPATCH
c_func
(paren
id|which_clock
comma
id|clock_set
comma
(paren
id|which_clock
comma
op_amp
id|new_tp
)paren
)paren
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_clock_gettime
id|sys_clock_gettime
c_func
(paren
id|clockid_t
id|which_clock
comma
r_struct
id|timespec
id|__user
op_star
id|tp
)paren
(brace
r_struct
id|timespec
id|kernel_tp
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|invalid_clockid
c_func
(paren
id|which_clock
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|error
op_assign
id|CLOCK_DISPATCH
c_func
(paren
id|which_clock
comma
id|clock_get
comma
(paren
id|which_clock
comma
op_amp
id|kernel_tp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|copy_to_user
c_func
(paren
id|tp
comma
op_amp
id|kernel_tp
comma
r_sizeof
(paren
id|kernel_tp
)paren
)paren
)paren
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_clock_getres
id|sys_clock_getres
c_func
(paren
id|clockid_t
id|which_clock
comma
r_struct
id|timespec
id|__user
op_star
id|tp
)paren
(brace
r_struct
id|timespec
id|rtn_tp
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|invalid_clockid
c_func
(paren
id|which_clock
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|error
op_assign
id|CLOCK_DISPATCH
c_func
(paren
id|which_clock
comma
id|clock_getres
comma
(paren
id|which_clock
comma
op_amp
id|rtn_tp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|tp
op_logical_and
id|copy_to_user
c_func
(paren
id|tp
comma
op_amp
id|rtn_tp
comma
r_sizeof
(paren
id|rtn_tp
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|nanosleep_wake_up
r_static
r_void
id|nanosleep_wake_up
c_func
(paren
r_int
r_int
id|__data
)paren
(brace
r_struct
id|task_struct
op_star
id|p
op_assign
(paren
r_struct
id|task_struct
op_star
)paren
id|__data
suffix:semicolon
id|wake_up_process
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The standard says that an absolute nanosleep call MUST wake up at&n; * the requested time in spite of clock settings.  Here is what we do:&n; * For each nanosleep call that needs it (only absolute and not on&n; * CLOCK_MONOTONIC* (as it can not be set)) we thread a little structure&n; * into the &quot;nanosleep_abs_list&quot;.  All we need is the task_struct pointer.&n; * When ever the clock is set we just wake up all those tasks.&t; The rest&n; * is done by the while loop in clock_nanosleep().&n; *&n; * On locking, clock_was_set() is called from update_wall_clock which&n; * holds (or has held for it) a write_lock_irq( xtime_lock) and is&n; * called from the timer bh code.  Thus we need the irq save locks.&n; *&n; * Also, on the call from update_wall_clock, that is done as part of a&n; * softirq thing.  We don&squot;t want to delay the system that much (possibly&n; * long list of timers to fix), so we defer that work to keventd.&n; */
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|nanosleep_abs_wqueue
)paren
suffix:semicolon
r_static
id|DECLARE_WORK
c_func
(paren
id|clock_was_set_work
comma
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
id|clock_was_set
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|DECLARE_MUTEX
c_func
(paren
id|clock_was_set_lock
)paren
suffix:semicolon
DECL|function|clock_was_set
r_void
id|clock_was_set
c_func
(paren
r_void
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
suffix:semicolon
r_struct
id|timespec
id|new_wall_to
suffix:semicolon
id|LIST_HEAD
c_func
(paren
id|cws_list
)paren
suffix:semicolon
r_int
r_int
id|seq
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
)paren
(brace
id|schedule_work
c_func
(paren
op_amp
id|clock_was_set_work
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|wake_up_all
c_func
(paren
op_amp
id|nanosleep_abs_wqueue
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check if there exist TIMER_ABSTIME timers to correct.&n;&t; *&n;&t; * Notes on locking: This code is run in task context with irq&n;&t; * on.  We CAN be interrupted!  All other usage of the abs list&n;&t; * lock is under the timer lock which holds the irq lock as&n;&t; * well.  We REALLY don&squot;t want to scan the whole list with the&n;&t; * interrupt system off, AND we would like a sequence lock on&n;&t; * this code as well.  Since we assume that the clock will not&n;&t; * be set often, it seems ok to take and release the irq lock&n;&t; * for each timer.  In fact add_timer will do this, so this is&n;&t; * not an issue.  So we know when we are done, we will move the&n;&t; * whole list to a new location.  Then as we process each entry,&n;&t; * we will move it to the actual list again.  This way, when our&n;&t; * copy is empty, we are done.  We are not all that concerned&n;&t; * about preemption so we will use a semaphore lock to protect&n;&t; * aginst reentry.  This way we will not stall another&n;&t; * processor.  It is possible that this may delay some timers&n;&t; * that should have expired, given the new clock, but even this&n;&t; * will be minimal as we will always update to the current time,&n;&t; * even if it was set by a task that is waiting for entry to&n;&t; * this code.  Timers that expire too early will be caught by&n;&t; * the expire code and restarted.&n;&n;&t; * Absolute timers that repeat are left in the abs list while&n;&t; * waiting for the task to pick up the signal.  This means we&n;&t; * may find timers that are not in the &quot;add_timer&quot; list, but are&n;&t; * in the abs list.  We do the same thing for these, save&n;&t; * putting them back in the &quot;add_timer&quot; list.  (Note, these are&n;&t; * left in the abs list mainly to indicate that they are&n;&t; * ABSOLUTE timers, a fact that is used by the re-arm code, and&n;&t; * for which we have no other flag.)&n;&n;&t; */
id|down
c_func
(paren
op_amp
id|clock_was_set_lock
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|abs_list.lock
)paren
suffix:semicolon
id|list_splice_init
c_func
(paren
op_amp
id|abs_list.list
comma
op_amp
id|cws_list
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|abs_list.lock
)paren
suffix:semicolon
r_do
(brace
r_do
(brace
id|seq
op_assign
id|read_seqbegin
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
id|new_wall_to
op_assign
id|wall_to_monotonic
suffix:semicolon
)brace
r_while
c_loop
(paren
id|read_seqretry
c_func
(paren
op_amp
id|xtime_lock
comma
id|seq
)paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|abs_list.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|cws_list
)paren
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|abs_list.lock
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|timr
op_assign
id|list_entry
c_func
(paren
id|cws_list.next
comma
r_struct
id|k_itimer
comma
id|abs_timer_entry
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|timr-&gt;abs_timer_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add_clockset_delta
c_func
(paren
id|timr
comma
op_amp
id|new_wall_to
)paren
op_logical_and
id|del_timer
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
)paren
multiline_comment|/* timer run yet? */
id|add_timer
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|timr-&gt;abs_timer_entry
comma
op_amp
id|abs_list.list
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|abs_list.lock
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|clock_was_set_lock
)paren
suffix:semicolon
)brace
r_int
id|clock_nanosleep_restart
c_func
(paren
r_struct
id|restart_block
op_star
id|restart_block
)paren
suffix:semicolon
id|asmlinkage
r_int
DECL|function|sys_clock_nanosleep
id|sys_clock_nanosleep
c_func
(paren
id|clockid_t
id|which_clock
comma
r_int
id|flags
comma
r_const
r_struct
id|timespec
id|__user
op_star
id|rqtp
comma
r_struct
id|timespec
id|__user
op_star
id|rmtp
)paren
(brace
r_struct
id|timespec
id|t
suffix:semicolon
r_struct
id|restart_block
op_star
id|restart_block
op_assign
op_amp
(paren
id|current_thread_info
c_func
(paren
)paren
op_member_access_from_pointer
id|restart_block
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|invalid_clockid
c_func
(paren
id|which_clock
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|t
comma
id|rqtp
comma
r_sizeof
(paren
r_struct
id|timespec
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|t.tv_nsec
op_ge
id|NSEC_PER_SEC
op_logical_or
id|t.tv_sec
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ret
op_assign
id|CLOCK_DISPATCH
c_func
(paren
id|which_clock
comma
id|nsleep
comma
(paren
id|which_clock
comma
id|flags
comma
op_amp
id|t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do this here as common_nsleep does not have the real address&n;&t; */
id|restart_block-&gt;arg1
op_assign
(paren
r_int
r_int
)paren
id|rmtp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_eq
op_minus
id|ERESTART_RESTARTBLOCK
)paren
op_logical_and
id|rmtp
op_logical_and
id|copy_to_user
c_func
(paren
id|rmtp
comma
op_amp
id|t
comma
r_sizeof
(paren
id|t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|common_nsleep
r_static
r_int
id|common_nsleep
c_func
(paren
id|clockid_t
id|which_clock
comma
r_int
id|flags
comma
r_struct
id|timespec
op_star
id|tsave
)paren
(brace
r_struct
id|timespec
id|t
comma
id|dum
suffix:semicolon
r_struct
id|timer_list
id|new_timer
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|abs_wqueue
comma
id|current
)paren
suffix:semicolon
id|u64
id|rq_time
op_assign
(paren
id|u64
)paren
l_int|0
suffix:semicolon
id|s64
id|left
suffix:semicolon
r_int
id|abs
suffix:semicolon
r_struct
id|restart_block
op_star
id|restart_block
op_assign
op_amp
id|current_thread_info
c_func
(paren
)paren
op_member_access_from_pointer
id|restart_block
suffix:semicolon
id|abs_wqueue.flags
op_assign
l_int|0
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|new_timer
)paren
suffix:semicolon
id|new_timer.expires
op_assign
l_int|0
suffix:semicolon
id|new_timer.data
op_assign
(paren
r_int
r_int
)paren
id|current
suffix:semicolon
id|new_timer.function
op_assign
id|nanosleep_wake_up
suffix:semicolon
id|abs
op_assign
id|flags
op_amp
id|TIMER_ABSTIME
suffix:semicolon
r_if
c_cond
(paren
id|restart_block-&gt;fn
op_eq
id|clock_nanosleep_restart
)paren
(brace
multiline_comment|/*&n;&t;&t; * Interrupted by a non-delivered signal, pick up remaining&n;&t;&t; * time and continue.  Remaining time is in arg2 &amp; 3.&n;&t;&t; */
id|restart_block-&gt;fn
op_assign
id|do_no_restart_syscall
suffix:semicolon
id|rq_time
op_assign
id|restart_block-&gt;arg3
suffix:semicolon
id|rq_time
op_assign
(paren
id|rq_time
op_lshift
l_int|32
)paren
op_plus
id|restart_block-&gt;arg2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq_time
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
id|left
op_assign
id|rq_time
op_minus
id|get_jiffies_64
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|left
op_le
(paren
id|s64
)paren
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Already passed */
)brace
r_if
c_cond
(paren
id|abs
op_logical_and
(paren
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|clock_get
op_ne
id|posix_clocks
(braket
id|CLOCK_MONOTONIC
)braket
dot
id|clock_get
)paren
)paren
id|add_wait_queue
c_func
(paren
op_amp
id|nanosleep_abs_wqueue
comma
op_amp
id|abs_wqueue
)paren
suffix:semicolon
r_do
(brace
id|t
op_assign
op_star
id|tsave
suffix:semicolon
r_if
c_cond
(paren
id|abs
op_logical_or
op_logical_neg
id|rq_time
)paren
(brace
id|adjust_abs_time
c_func
(paren
op_amp
id|posix_clocks
(braket
id|which_clock
)braket
comma
op_amp
id|t
comma
id|abs
comma
op_amp
id|rq_time
comma
op_amp
id|dum
)paren
suffix:semicolon
id|rq_time
op_add_assign
(paren
id|t.tv_sec
op_logical_or
id|t.tv_nsec
)paren
suffix:semicolon
)brace
id|left
op_assign
id|rq_time
op_minus
id|get_jiffies_64
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|left
op_ge
(paren
id|s64
)paren
id|MAX_JIFFY_OFFSET
)paren
id|left
op_assign
(paren
id|s64
)paren
id|MAX_JIFFY_OFFSET
suffix:semicolon
r_if
c_cond
(paren
id|left
OL
(paren
id|s64
)paren
l_int|0
)paren
r_break
suffix:semicolon
id|new_timer.expires
op_assign
id|jiffies
op_plus
id|left
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|new_timer
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|new_timer
)paren
suffix:semicolon
id|left
op_assign
id|rq_time
op_minus
id|get_jiffies_64
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|left
OG
(paren
id|s64
)paren
l_int|0
op_logical_and
op_logical_neg
id|test_thread_flag
c_func
(paren
id|TIF_SIGPENDING
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|abs_wqueue.task_list.next
)paren
id|finish_wait
c_func
(paren
op_amp
id|nanosleep_abs_wqueue
comma
op_amp
id|abs_wqueue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|left
OG
(paren
id|s64
)paren
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Always restart abs calls from scratch to pick up any&n;&t;&t; * clock shifting that happened while we are away.&n;&t;&t; */
r_if
c_cond
(paren
id|abs
)paren
r_return
op_minus
id|ERESTARTNOHAND
suffix:semicolon
id|left
op_mul_assign
id|TICK_NSEC
suffix:semicolon
id|tsave-&gt;tv_sec
op_assign
id|div_long_long_rem
c_func
(paren
id|left
comma
id|NSEC_PER_SEC
comma
op_amp
id|tsave-&gt;tv_nsec
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Restart works by saving the time remaing in &n;&t;&t; * arg2 &amp; 3 (it is 64-bits of jiffies).  The other&n;&t;&t; * info we need is the clock_id (saved in arg0). &n;&t;&t; * The sys_call interface needs the users &n;&t;&t; * timespec return address which _it_ saves in arg1.&n;&t;&t; * Since we have cast the nanosleep call to a clock_nanosleep&n;&t;&t; * both can be restarted with the same code.&n;&t;&t; */
id|restart_block-&gt;fn
op_assign
id|clock_nanosleep_restart
suffix:semicolon
id|restart_block-&gt;arg0
op_assign
id|which_clock
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Caller sets arg1&n;&t;&t; */
id|restart_block-&gt;arg2
op_assign
id|rq_time
op_amp
l_int|0xffffffffLL
suffix:semicolon
id|restart_block-&gt;arg3
op_assign
id|rq_time
op_rshift
l_int|32
suffix:semicolon
r_return
op_minus
id|ERESTART_RESTARTBLOCK
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This will restart clock_nanosleep.&n; */
r_int
DECL|function|clock_nanosleep_restart
id|clock_nanosleep_restart
c_func
(paren
r_struct
id|restart_block
op_star
id|restart_block
)paren
(brace
r_struct
id|timespec
id|t
suffix:semicolon
r_int
id|ret
op_assign
id|common_nsleep
c_func
(paren
id|restart_block-&gt;arg0
comma
l_int|0
comma
op_amp
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_eq
op_minus
id|ERESTART_RESTARTBLOCK
)paren
op_logical_and
id|restart_block-&gt;arg1
op_logical_and
id|copy_to_user
c_func
(paren
(paren
r_struct
id|timespec
id|__user
op_star
)paren
(paren
id|restart_block-&gt;arg1
)paren
comma
op_amp
id|t
comma
r_sizeof
(paren
id|t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
eof
