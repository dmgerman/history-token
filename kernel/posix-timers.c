multiline_comment|/*&n; * linux/kernel/posix_timers.c&n; *&n; *&n; * 2002-10-15  Posix Clocks &amp; timers by George Anzinger&n; *&t;&t;&t;     Copyright (C) 2002 by MontaVista Software.&n; */
multiline_comment|/* These are all the functions necessary to implement&n; * POSIX clocks &amp; timers&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;linux/idr.h&gt;
macro_line|#include &lt;linux/posix-timers.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#ifndef div_long_long_rem
macro_line|#include &lt;asm/div64.h&gt;
DECL|macro|div_long_long_rem
mdefine_line|#define div_long_long_rem(dividend,divisor,remainder) ({ &bslash;&n;&t;&t;       u64 result = dividend;&t;&t;&bslash;&n;&t;&t;       *remainder = do_div(result,divisor); &bslash;&n;&t;&t;       result; })
macro_line|#endif
DECL|macro|CLOCK_REALTIME_RES
mdefine_line|#define CLOCK_REALTIME_RES TICK_NSEC(TICK_USEC)  
singleline_comment|// In nano seconds.
DECL|function|mpy_l_X_l_ll
r_static
r_inline
id|u64
id|mpy_l_X_l_ll
c_func
(paren
r_int
r_int
id|mpy1
comma
r_int
r_int
id|mpy2
)paren
(brace
r_return
(paren
id|u64
)paren
id|mpy1
op_star
id|mpy2
suffix:semicolon
)brace
multiline_comment|/*&n; * Management arrays for POSIX timers.&t; Timers are kept in slab memory&n; * Timer ids are allocated by an external routine that keeps track of the&n; * id and the timer.  The external interface is:&n; *&n; * void *idr_find(struct idr *idp, int id);           to find timer_id &lt;id&gt;&n; * int idr_get_new(struct idr *idp, void *ptr);       to get a new id and&n; *                                                    related it to &lt;ptr&gt;&n; * void idr_remove(struct idr *idp, int id);          to release &lt;id&gt;&n; * void idr_init(struct idr *idp);                    to initialize &lt;idp&gt;&n; *                                                    which we supply.&n; * The idr_get_new *may* call slab for more memory so it must not be&n; * called under a spin lock.  Likewise idr_remore may release memory&n; * (but it may be ok to do this under a lock...).&n; * idr_find is just a memory look up and is quite fast.  A -1 return&n; * indicates that the requested id does not exist.&n; */
multiline_comment|/*&n; * Lets keep our timers in a slab cache :-)&n; */
DECL|variable|posix_timers_cache
r_static
id|kmem_cache_t
op_star
id|posix_timers_cache
suffix:semicolon
DECL|variable|posix_timers_id
r_static
r_struct
id|idr
id|posix_timers_id
suffix:semicolon
DECL|variable|idr_lock
r_static
id|spinlock_t
id|idr_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * Just because the timer is not in the timer list does NOT mean it is&n; * inactive.  It could be in the &quot;fire&quot; routine getting a new expire time.&n; */
DECL|macro|TIMER_INACTIVE
mdefine_line|#define TIMER_INACTIVE 1
DECL|macro|TIMER_RETRY
mdefine_line|#define TIMER_RETRY 1
macro_line|#ifdef CONFIG_SMP
DECL|macro|timer_active
macro_line|# define timer_active(tmr) &bslash;&n;&t;&t;((tmr)-&gt;it_timer.entry.prev != (void *)TIMER_INACTIVE)
DECL|macro|set_timer_inactive
macro_line|# define set_timer_inactive(tmr) &bslash;&n;&t;&t;do { &bslash;&n;&t;&t;&t;(tmr)-&gt;it_timer.entry.prev = (void *)TIMER_INACTIVE; &bslash;&n;&t;&t;} while (0)
macro_line|#else
DECL|macro|timer_active
macro_line|# define timer_active(tmr) BARFY&t;
singleline_comment|// error to use outside of SMP
DECL|macro|set_timer_inactive
macro_line|# define set_timer_inactive(tmr) do { } while (0)
macro_line|#endif
multiline_comment|/*&n; * For some reason mips/mips64 define the SIGEV constants plus 128.&n; * Here we define a mask to get rid of the common bits.&t; The&n; * optimizer should make this costless to all but mips.&n; * Note that no common bits (the non-mips case) will give 0xffffffff.&n; */
DECL|macro|MIPS_SIGEV
mdefine_line|#define MIPS_SIGEV ~(SIGEV_NONE &amp; &bslash;&n;&t;&t;      SIGEV_SIGNAL &amp; &bslash;&n;&t;&t;      SIGEV_THREAD &amp;  &bslash;&n;&t;&t;      SIGEV_THREAD_ID)
DECL|macro|REQUEUE_PENDING
mdefine_line|#define REQUEUE_PENDING 1
multiline_comment|/*&n; * The timer ID is turned into a timer address by idr_find().&n; * Verifying a valid ID consists of:&n; *&n; * a) checking that idr_find() returns other than -1.&n; * b) checking that the timer id matches the one in the timer itself.&n; * c) that the timer owner is in the callers thread group.&n; */
multiline_comment|/*&n; * CLOCKs: The POSIX standard calls for a couple of clocks and allows us&n; *&t;    to implement others.  This structure defines the various&n; *&t;    clocks and allows the possibility of adding others.&t; We&n; *&t;    provide an interface to add clocks to the table and expect&n; *&t;    the &quot;arch&quot; code to add at least one clock that is high&n; *&t;    resolution.&t; Here we define the standard CLOCK_REALTIME as a&n; *&t;    1/HZ resolution clock.&n; *&n; * CPUTIME &amp; THREAD_CPUTIME: We are not, at this time, definding these&n; *&t;    two clocks (and the other process related clocks (Std&n; *&t;    1003.1d-1999).  The way these should be supported, we think,&n; *&t;    is to use large negative numbers for the two clocks that are&n; *&t;    pinned to the executing process and to use -pid for clocks&n; *&t;    pinned to particular pids.&t;Calls which supported these clock&n; *&t;    ids would split early in the function.&n; *&n; * RESOLUTION: Clock resolution is used to round up timer and interval&n; *&t;    times, NOT to report clock times, which are reported with as&n; *&t;    much resolution as the system can muster.  In some cases this&n; *&t;    resolution may depend on the underlaying clock hardware and&n; *&t;    may not be quantifiable until run time, and only then is the&n; *&t;    necessary code is written.&t;The standard says we should say&n; *&t;    something about this issue in the documentation...&n; *&n; * FUNCTIONS: The CLOCKs structure defines possible functions to handle&n; *&t;    various clock functions.  For clocks that use the standard&n; *&t;    system timer code these entries should be NULL.  This will&n; *&t;    allow dispatch without the overhead of indirect function&n; *&t;    calls.  CLOCKS that depend on other sources (e.g. WWV or GPS)&n; *&t;    must supply functions here, even if the function just returns&n; *&t;    ENOSYS.  The standard POSIX timer management code assumes the&n; *&t;    following: 1.) The k_itimer struct (sched.h) is used for the&n; *&t;    timer.  2.) The list, it_lock, it_clock, it_id and it_process&n; *&t;    fields are not modified by timer code.&n; *&n; *          At this time all functions EXCEPT clock_nanosleep can be&n; *          redirected by the CLOCKS structure.  Clock_nanosleep is in&n; *          there, but the code ignors it.&n; *&n; * Permissions: It is assumed that the clock_settime() function defined&n; *&t;    for each clock will take care of permission checks.&t; Some&n; *&t;    clocks may be set able by any user (i.e. local process&n; *&t;    clocks) others not.&t; Currently the only set able clock we&n; *&t;    have is CLOCK_REALTIME and its high res counter part, both of&n; *&t;    which we beg off on and pass to do_sys_settimeofday().&n; */
DECL|variable|posix_clocks
r_static
r_struct
id|k_clock
id|posix_clocks
(braket
id|MAX_CLOCKS
)braket
suffix:semicolon
DECL|macro|if_clock_do
mdefine_line|#define if_clock_do(clock_fun,alt_fun,parms) &bslash;&n;&t;&t;(!clock_fun) ? alt_fun parms : clock_fun parms
DECL|macro|p_timer_get
mdefine_line|#define p_timer_get(clock,a,b) &bslash;&n;&t;       &t;if_clock_do((clock)-&gt;timer_get,do_timer_gettime, (a,b))
DECL|macro|p_nsleep
mdefine_line|#define p_nsleep(clock,a,b,c) &bslash;&n;&t;&t;if_clock_do((clock)-&gt;nsleep, do_nsleep, (a,b,c))
DECL|macro|p_timer_del
mdefine_line|#define p_timer_del(clock,a) &bslash;&n;&t;&t;if_clock_do((clock)-&gt;timer_del, do_timer_delete, (a))
r_void
id|register_posix_clock
c_func
(paren
r_int
id|clock_id
comma
r_struct
id|k_clock
op_star
id|new_clock
)paren
suffix:semicolon
r_static
r_int
id|do_posix_gettime
c_func
(paren
r_struct
id|k_clock
op_star
id|clock
comma
r_struct
id|timespec
op_star
id|tp
)paren
suffix:semicolon
r_static
id|u64
id|do_posix_clock_monotonic_gettime_parts
c_func
(paren
r_struct
id|timespec
op_star
id|tp
comma
r_struct
id|timespec
op_star
id|mo
)paren
suffix:semicolon
r_int
id|do_posix_clock_monotonic_gettime
c_func
(paren
r_struct
id|timespec
op_star
id|tp
)paren
suffix:semicolon
r_int
id|do_posix_clock_monotonic_settime
c_func
(paren
r_struct
id|timespec
op_star
id|tp
)paren
suffix:semicolon
r_static
r_struct
id|k_itimer
op_star
id|lock_timer
c_func
(paren
id|timer_t
id|timer_id
comma
r_int
r_int
op_star
id|flags
)paren
suffix:semicolon
r_static
r_inline
r_void
id|unlock_timer
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
comma
r_int
r_int
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n; * Initialize everything, well, just everything in Posix clocks/timers ;)&n; */
DECL|function|init_posix_timers
r_static
id|__init
r_int
id|init_posix_timers
c_func
(paren
r_void
)paren
(brace
r_struct
id|k_clock
id|clock_realtime
op_assign
(brace
dot
id|res
op_assign
id|CLOCK_REALTIME_RES
)brace
suffix:semicolon
r_struct
id|k_clock
id|clock_monotonic
op_assign
(brace
dot
id|res
op_assign
id|CLOCK_REALTIME_RES
comma
dot
id|clock_get
op_assign
id|do_posix_clock_monotonic_gettime
comma
dot
id|clock_set
op_assign
id|do_posix_clock_monotonic_settime
)brace
suffix:semicolon
id|register_posix_clock
c_func
(paren
id|CLOCK_REALTIME
comma
op_amp
id|clock_realtime
)paren
suffix:semicolon
id|register_posix_clock
c_func
(paren
id|CLOCK_MONOTONIC
comma
op_amp
id|clock_monotonic
)paren
suffix:semicolon
id|posix_timers_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;posix_timers_cache&quot;
comma
r_sizeof
(paren
r_struct
id|k_itimer
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|idr_init
c_func
(paren
op_amp
id|posix_timers_id
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|init_posix_timers
id|__initcall
c_func
(paren
id|init_posix_timers
)paren
suffix:semicolon
DECL|function|tstojiffie
r_static
r_void
id|tstojiffie
c_func
(paren
r_struct
id|timespec
op_star
id|tp
comma
r_int
id|res
comma
id|u64
op_star
id|jiff
)paren
(brace
r_int
id|sec
op_assign
id|tp-&gt;tv_sec
suffix:semicolon
r_int
id|nsec
op_assign
id|tp-&gt;tv_nsec
op_plus
id|res
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|nsec
OG
id|NSEC_PER_SEC
)paren
(brace
id|sec
op_increment
suffix:semicolon
id|nsec
op_sub_assign
id|NSEC_PER_SEC
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The scaling constants are defined in &lt;linux/time.h&gt;&n;&t; * The difference between there and here is that we do the&n;&t; * res rounding and compute a 64-bit result (well so does that&n;&t; * but it then throws away the high bits).&n;  &t; */
op_star
id|jiff
op_assign
(paren
id|mpy_l_X_l_ll
c_func
(paren
id|sec
comma
id|SEC_CONVERSION
)paren
op_plus
(paren
id|mpy_l_X_l_ll
c_func
(paren
id|nsec
comma
id|NSEC_CONVERSION
)paren
op_rshift
(paren
id|NSEC_JIFFIE_SC
op_minus
id|SEC_JIFFIE_SC
)paren
)paren
)paren
op_rshift
id|SEC_JIFFIE_SC
suffix:semicolon
)brace
DECL|function|schedule_next_timer
r_static
r_void
id|schedule_next_timer
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
)paren
(brace
r_struct
id|now_struct
id|now
suffix:semicolon
multiline_comment|/* Set up the timer for the next interval (if there is one) */
r_if
c_cond
(paren
op_logical_neg
id|timr-&gt;it_incr
)paren
r_return
suffix:semicolon
id|posix_get_now
c_func
(paren
op_amp
id|now
)paren
suffix:semicolon
r_do
(brace
id|posix_bump_timer
c_func
(paren
id|timr
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|posix_time_before
c_func
(paren
op_amp
id|timr-&gt;it_timer
comma
op_amp
id|now
)paren
)paren
suffix:semicolon
id|timr-&gt;it_overrun_last
op_assign
id|timr-&gt;it_overrun
suffix:semicolon
id|timr-&gt;it_overrun
op_assign
op_minus
l_int|1
suffix:semicolon
op_increment
id|timr-&gt;it_requeue_pending
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is exported for use by the signal deliver code.  It is&n; * called just prior to the info block being released and passes that&n; * block to us.  It&squot;s function is to update the overrun entry AND to&n; * restart the timer.  It should only be called if the timer is to be&n; * restarted (i.e. we have flagged this in the sys_private entry of the&n; * info block).&n; *&n; * To protect aginst the timer going away while the interrupt is queued,&n; * we require that the it_requeue_pending flag be set.&n; */
DECL|function|do_schedule_next_timer
r_void
id|do_schedule_next_timer
c_func
(paren
r_struct
id|siginfo
op_star
id|info
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|timr
op_assign
id|lock_timer
c_func
(paren
id|info-&gt;si_tid
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timr
op_logical_or
id|timr-&gt;it_requeue_pending
op_ne
id|info-&gt;si_sys_private
)paren
r_goto
m_exit
suffix:semicolon
id|schedule_next_timer
c_func
(paren
id|timr
)paren
suffix:semicolon
id|info-&gt;si_overrun
op_assign
id|timr-&gt;it_overrun_last
suffix:semicolon
m_exit
suffix:colon
r_if
c_cond
(paren
id|timr
)paren
id|unlock_timer
c_func
(paren
id|timr
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Notify the task and set up the timer for the next expiration (if&n; * applicable).  This function requires that the k_itimer structure&n; * it_lock is taken.  This code will requeue the timer only if we get&n; * either an error return or a flag (ret &gt; 0) from send_seg_info&n; * indicating that the signal was either not queued or was queued&n; * without an info block.  In this case, we will not get a call back to&n; * do_schedule_next_timer() so we do it here.  This should be rare...&n;&n; * An interesting problem can occur if, while a signal, and thus a call&n; * back is pending, the timer is rearmed, i.e. stopped and restarted.&n; * We then need to sort out the call back and do the right thing.  What&n; * we do is to put a counter in the info block and match it with the&n; * timers copy on the call back.  If they don&squot;t match, we just ignore&n; * the call back.  The counter is local to the timer and we use odd to&n; * indicate a call back is pending.  Note that we do allow the timer to &n; * be deleted while a signal is pending.  The standard says we can&n; * allow that signal to be delivered, and we do. &n; */
DECL|function|timer_notify_task
r_static
r_void
id|timer_notify_task
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
)paren
(brace
r_int
id|ret
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|timr-&gt;sigq-&gt;info
comma
l_int|0
comma
r_sizeof
(paren
id|siginfo_t
)paren
)paren
suffix:semicolon
multiline_comment|/* Send signal to the process that owns this timer. */
id|timr-&gt;sigq-&gt;info.si_signo
op_assign
id|timr-&gt;it_sigev_signo
suffix:semicolon
id|timr-&gt;sigq-&gt;info.si_errno
op_assign
l_int|0
suffix:semicolon
id|timr-&gt;sigq-&gt;info.si_code
op_assign
id|SI_TIMER
suffix:semicolon
id|timr-&gt;sigq-&gt;info.si_tid
op_assign
id|timr-&gt;it_id
suffix:semicolon
id|timr-&gt;sigq-&gt;info.si_value
op_assign
id|timr-&gt;it_sigev_value
suffix:semicolon
r_if
c_cond
(paren
id|timr-&gt;it_incr
)paren
id|timr-&gt;sigq-&gt;info.si_sys_private
op_assign
op_increment
id|timr-&gt;it_requeue_pending
suffix:semicolon
r_if
c_cond
(paren
id|timr-&gt;it_sigev_notify
op_amp
id|SIGEV_THREAD_ID
op_amp
id|MIPS_SIGEV
)paren
id|ret
op_assign
id|send_sigqueue
c_func
(paren
id|timr-&gt;it_sigev_signo
comma
id|timr-&gt;sigq
comma
id|timr-&gt;it_process
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|send_group_sigqueue
c_func
(paren
id|timr-&gt;it_sigev_signo
comma
id|timr-&gt;sigq
comma
id|timr-&gt;it_process
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/*&n;&t;&t; * signal was not sent because of sig_ignor&n;&t;&t; * we will not get a call back to restart it AND&n;&t;&t; * it should be restarted.&n;&t;&t; */
id|schedule_next_timer
c_func
(paren
id|timr
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This function gets called when a POSIX.1b interval timer expires.  It&n; * is used as a callback from the kernel internal timer.  The&n; * run_timer_list code ALWAYS calls with interrutps on.&n; */
DECL|function|posix_timer_fn
r_static
r_void
id|posix_timer_fn
c_func
(paren
r_int
r_int
id|__data
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
op_assign
(paren
r_struct
id|k_itimer
op_star
)paren
id|__data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|timr-&gt;it_lock
comma
id|flags
)paren
suffix:semicolon
id|set_timer_inactive
c_func
(paren
id|timr
)paren
suffix:semicolon
id|timer_notify_task
c_func
(paren
id|timr
)paren
suffix:semicolon
id|unlock_timer
c_func
(paren
id|timr
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|good_sigevent
r_static
r_inline
r_struct
id|task_struct
op_star
id|good_sigevent
c_func
(paren
id|sigevent_t
op_star
id|event
)paren
(brace
r_struct
id|task_struct
op_star
id|rtn
op_assign
id|current
suffix:semicolon
r_if
c_cond
(paren
(paren
id|event-&gt;sigev_notify
op_amp
id|SIGEV_THREAD_ID
op_amp
id|MIPS_SIGEV
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|rtn
op_assign
id|find_task_by_pid
c_func
(paren
id|event-&gt;sigev_notify_thread_id
)paren
)paren
op_logical_or
id|rtn-&gt;tgid
op_ne
id|current-&gt;tgid
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|event-&gt;sigev_notify
op_amp
op_complement
id|SIGEV_NONE
op_amp
id|MIPS_SIGEV
)paren
op_logical_and
(paren
(paren
r_int
)paren
(paren
id|event-&gt;sigev_signo
OG
id|SIGRTMAX
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|rtn
suffix:semicolon
)brace
DECL|function|register_posix_clock
r_void
id|register_posix_clock
c_func
(paren
r_int
id|clock_id
comma
r_struct
id|k_clock
op_star
id|new_clock
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|clock_id
op_ge
id|MAX_CLOCKS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;POSIX clock register failed for clock_id %d&bslash;n&quot;
comma
id|clock_id
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|posix_clocks
(braket
id|clock_id
)braket
op_assign
op_star
id|new_clock
suffix:semicolon
)brace
DECL|function|alloc_posix_timer
r_static
r_struct
id|k_itimer
op_star
id|alloc_posix_timer
c_func
(paren
r_void
)paren
(brace
r_struct
id|k_itimer
op_star
id|tmr
suffix:semicolon
id|tmr
op_assign
id|kmem_cache_alloc
c_func
(paren
id|posix_timers_cache
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|tmr
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|k_itimer
)paren
)paren
suffix:semicolon
id|tmr-&gt;it_id
op_assign
(paren
id|timer_t
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
(paren
id|tmr-&gt;sigq
op_assign
id|sigqueue_alloc
c_func
(paren
)paren
)paren
)paren
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|posix_timers_cache
comma
id|tmr
)paren
suffix:semicolon
id|tmr
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|tmr
suffix:semicolon
)brace
DECL|function|release_posix_timer
r_static
r_void
id|release_posix_timer
c_func
(paren
r_struct
id|k_itimer
op_star
id|tmr
)paren
(brace
r_if
c_cond
(paren
id|tmr-&gt;it_id
op_ne
op_minus
l_int|1
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|idr_lock
)paren
suffix:semicolon
id|idr_remove
c_func
(paren
op_amp
id|posix_timers_id
comma
id|tmr-&gt;it_id
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|idr_lock
)paren
suffix:semicolon
)brace
id|sigqueue_free
c_func
(paren
id|tmr-&gt;sigq
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|posix_timers_cache
comma
id|tmr
)paren
suffix:semicolon
)brace
multiline_comment|/* Create a POSIX.1b interval timer. */
id|asmlinkage
r_int
DECL|function|sys_timer_create
id|sys_timer_create
c_func
(paren
id|clockid_t
id|which_clock
comma
r_struct
id|sigevent
id|__user
op_star
id|timer_event_spec
comma
id|timer_t
id|__user
op_star
id|created_timer_id
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_struct
id|k_itimer
op_star
id|new_timer
op_assign
l_int|NULL
suffix:semicolon
id|timer_t
id|new_timer_id
suffix:semicolon
r_struct
id|task_struct
op_star
id|process
op_assign
l_int|0
suffix:semicolon
id|sigevent_t
id|event
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|which_clock
op_ge
id|MAX_CLOCKS
op_logical_or
op_logical_neg
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|res
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|new_timer
op_assign
id|alloc_posix_timer
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|new_timer
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|new_timer-&gt;it_lock
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|idr_pre_get
c_func
(paren
op_amp
id|posix_timers_id
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
id|new_timer_id
op_assign
(paren
id|timer_t
)paren
op_minus
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|spin_lock_irq
c_func
(paren
op_amp
id|idr_lock
)paren
suffix:semicolon
id|new_timer_id
op_assign
(paren
id|timer_t
)paren
id|idr_get_new
c_func
(paren
op_amp
id|posix_timers_id
comma
(paren
r_void
op_star
)paren
id|new_timer
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|idr_lock
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|unlikely
c_func
(paren
id|new_timer_id
op_eq
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|new_timer-&gt;it_id
op_assign
id|new_timer_id
suffix:semicolon
multiline_comment|/*&n;&t; * return the timer_id now.  The next step is hard to&n;&t; * back out if there is an error.&n;&t; */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|created_timer_id
comma
op_amp
id|new_timer_id
comma
r_sizeof
(paren
id|new_timer_id
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|timer_event_spec
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|event
comma
id|timer_event_spec
comma
r_sizeof
(paren
id|event
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|process
op_assign
id|good_sigevent
c_func
(paren
op_amp
id|event
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We may be setting up this process for another&n;&t;&t;&t; * thread.  It may be exiting.  To catch this&n;&t;&t;&t; * case the we check the PF_EXITING flag.  If&n;&t;&t;&t; * the flag is not set, the task_lock will catch&n;&t;&t;&t; * him before it is too late (in exit_itimers).&n;&t;&t;&t; *&n;&t;&t;&t; * The exec case is a bit more invloved but easy&n;&t;&t;&t; * to code.  If the process is in our thread&n;&t;&t;&t; * group (and it must be or we would not allow&n;&t;&t;&t; * it here) and is doing an exec, it will cause&n;&t;&t;&t; * us to be killed.  In this case it will wait&n;&t;&t;&t; * for us to die which means we can finish this&n;&t;&t;&t; * linkage with our last gasp. I.e. no code :)&n;&t;&t;&t; */
id|task_lock
c_func
(paren
id|process
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|process-&gt;flags
op_amp
id|PF_EXITING
)paren
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|new_timer-&gt;list
comma
op_amp
id|process-&gt;posix_timers
)paren
suffix:semicolon
id|task_unlock
c_func
(paren
id|process
)paren
suffix:semicolon
)brace
r_else
(brace
id|task_unlock
c_func
(paren
id|process
)paren
suffix:semicolon
id|process
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|process
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|new_timer-&gt;it_sigev_notify
op_assign
id|event.sigev_notify
suffix:semicolon
id|new_timer-&gt;it_sigev_signo
op_assign
id|event.sigev_signo
suffix:semicolon
id|new_timer-&gt;it_sigev_value
op_assign
id|event.sigev_value
suffix:semicolon
)brace
r_else
(brace
id|new_timer-&gt;it_sigev_notify
op_assign
id|SIGEV_SIGNAL
suffix:semicolon
id|new_timer-&gt;it_sigev_signo
op_assign
id|SIGALRM
suffix:semicolon
id|new_timer-&gt;it_sigev_value.sival_int
op_assign
id|new_timer-&gt;it_id
suffix:semicolon
id|process
op_assign
id|current
suffix:semicolon
id|task_lock
c_func
(paren
id|process
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|new_timer-&gt;list
comma
op_amp
id|process-&gt;posix_timers
)paren
suffix:semicolon
id|task_unlock
c_func
(paren
id|process
)paren
suffix:semicolon
)brace
id|new_timer-&gt;it_clock
op_assign
id|which_clock
suffix:semicolon
id|new_timer-&gt;it_incr
op_assign
l_int|0
suffix:semicolon
id|new_timer-&gt;it_overrun
op_assign
op_minus
l_int|1
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|new_timer-&gt;it_timer
)paren
suffix:semicolon
id|new_timer-&gt;it_timer.expires
op_assign
l_int|0
suffix:semicolon
id|new_timer-&gt;it_timer.data
op_assign
(paren
r_int
r_int
)paren
id|new_timer
suffix:semicolon
id|new_timer-&gt;it_timer.function
op_assign
id|posix_timer_fn
suffix:semicolon
id|set_timer_inactive
c_func
(paren
id|new_timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Once we set the process, it can be found so do it last...&n;&t; */
id|new_timer-&gt;it_process
op_assign
id|process
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|error
)paren
id|release_posix_timer
c_func
(paren
id|new_timer
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * good_timespec&n; *&n; * This function checks the elements of a timespec structure.&n; *&n; * Arguments:&n; * ts&t;     : Pointer to the timespec structure to check&n; *&n; * Return value:&n; * If a NULL pointer was passed in, or the tv_nsec field was less than 0&n; * or greater than NSEC_PER_SEC, or the tv_sec field was less than 0,&n; * this function returns 0. Otherwise it returns 1.&n; */
DECL|function|good_timespec
r_static
r_int
id|good_timespec
c_func
(paren
r_const
r_struct
id|timespec
op_star
id|ts
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|ts
)paren
op_logical_or
(paren
id|ts-&gt;tv_sec
OL
l_int|0
)paren
op_logical_or
(paren
(paren
r_int
)paren
id|ts-&gt;tv_nsec
op_ge
id|NSEC_PER_SEC
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|unlock_timer
r_static
r_inline
r_void
id|unlock_timer
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
comma
r_int
r_int
id|flags
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|timr-&gt;it_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Locking issues: We need to protect the result of the id look up until&n; * we get the timer locked down so it is not deleted under us.  The&n; * removal is done under the idr spinlock so we use that here to bridge&n; * the find to the timer lock.  To avoid a dead lock, the timer id MUST&n; * be release with out holding the timer lock.&n; */
DECL|function|lock_timer
r_static
r_struct
id|k_itimer
op_star
id|lock_timer
c_func
(paren
id|timer_t
id|timer_id
comma
r_int
r_int
op_star
id|flags
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
suffix:semicolon
multiline_comment|/*&n;&t; * Watch out here.  We do a irqsave on the idr_lock and pass the&n;&t; * flags part over to the timer lock.  Must not let interrupts in&n;&t; * while we are moving the lock.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|idr_lock
comma
op_star
id|flags
)paren
suffix:semicolon
id|timr
op_assign
(paren
r_struct
id|k_itimer
op_star
)paren
id|idr_find
c_func
(paren
op_amp
id|posix_timers_id
comma
(paren
r_int
)paren
id|timer_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timr
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|timr-&gt;it_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|idr_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|timr-&gt;it_id
op_ne
id|timer_id
)paren
op_logical_or
op_logical_neg
(paren
id|timr-&gt;it_process
)paren
op_logical_or
id|timr-&gt;it_process-&gt;tgid
op_ne
id|current-&gt;tgid
)paren
(brace
id|unlock_timer
c_func
(paren
id|timr
comma
op_star
id|flags
)paren
suffix:semicolon
id|timr
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|idr_lock
comma
op_star
id|flags
)paren
suffix:semicolon
r_return
id|timr
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the time remaining on a POSIX.1b interval timer.  This function&n; * is ALWAYS called with spin_lock_irq on the timer, thus it must not&n; * mess with irq.&n; *&n; * We have a couple of messes to clean up here.  First there is the case&n; * of a timer that has a requeue pending.  These timers should appear to&n; * be in the timer list with an expiry as if we were to requeue them&n; * now.&n; *&n; * The second issue is the SIGEV_NONE timer which may be active but is&n; * not really ever put in the timer list (to save system resources).&n; * This timer may be expired, and if so, we will do it here.  Otherwise&n; * it is the same as a requeue pending timer WRT to what we should&n; * report.&n; */
r_void
r_inline
DECL|function|do_timer_gettime
id|do_timer_gettime
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
comma
r_struct
id|itimerspec
op_star
id|cur_setting
)paren
(brace
r_int
r_int
id|expires
suffix:semicolon
r_struct
id|now_struct
id|now
suffix:semicolon
r_do
id|expires
op_assign
id|timr-&gt;it_timer.expires
suffix:semicolon
r_while
c_loop
(paren
(paren
r_volatile
r_int
)paren
(paren
id|timr-&gt;it_timer.expires
)paren
op_ne
id|expires
)paren
suffix:semicolon
id|posix_get_now
c_func
(paren
op_amp
id|now
)paren
suffix:semicolon
r_if
c_cond
(paren
id|expires
op_logical_and
(paren
id|timr-&gt;it_sigev_notify
op_amp
id|SIGEV_NONE
)paren
op_logical_and
op_logical_neg
id|timr-&gt;it_incr
op_logical_and
id|posix_time_before
c_func
(paren
op_amp
id|timr-&gt;it_timer
comma
op_amp
id|now
)paren
)paren
id|timr-&gt;it_timer.expires
op_assign
id|expires
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|expires
)paren
(brace
r_if
c_cond
(paren
id|timr-&gt;it_requeue_pending
op_amp
id|REQUEUE_PENDING
op_logical_or
(paren
id|timr-&gt;it_sigev_notify
op_amp
id|SIGEV_NONE
)paren
)paren
r_while
c_loop
(paren
id|posix_time_before
c_func
(paren
op_amp
id|timr-&gt;it_timer
comma
op_amp
id|now
)paren
)paren
id|posix_bump_timer
c_func
(paren
id|timr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|timer_pending
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
)paren
id|expires
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|expires
)paren
id|expires
op_sub_assign
id|now.jiffies
suffix:semicolon
)brace
id|jiffies_to_timespec
c_func
(paren
id|expires
comma
op_amp
id|cur_setting-&gt;it_value
)paren
suffix:semicolon
id|jiffies_to_timespec
c_func
(paren
id|timr-&gt;it_incr
comma
op_amp
id|cur_setting-&gt;it_interval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_setting-&gt;it_value.tv_sec
OL
l_int|0
)paren
(brace
id|cur_setting-&gt;it_value.tv_nsec
op_assign
l_int|1
suffix:semicolon
id|cur_setting-&gt;it_value.tv_sec
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Get the time remaining on a POSIX.1b interval timer. */
id|asmlinkage
r_int
DECL|function|sys_timer_gettime
id|sys_timer_gettime
c_func
(paren
id|timer_t
id|timer_id
comma
r_struct
id|itimerspec
id|__user
op_star
id|setting
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
suffix:semicolon
r_struct
id|itimerspec
id|cur_setting
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|timr
op_assign
id|lock_timer
c_func
(paren
id|timer_id
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|p_timer_get
c_func
(paren
op_amp
id|posix_clocks
(braket
id|timr-&gt;it_clock
)braket
comma
id|timr
comma
op_amp
id|cur_setting
)paren
suffix:semicolon
id|unlock_timer
c_func
(paren
id|timr
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|setting
comma
op_amp
id|cur_setting
comma
r_sizeof
(paren
id|cur_setting
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the number of overruns of a POSIX.1b interval timer.  This is to&n; * be the overrun of the timer last delivered.  At the same time we are&n; * accumulating overruns on the next timer.  The overrun is frozen when&n; * the signal is delivered, either at the notify time (if the info block&n; * is not queued) or at the actual delivery time (as we are informed by&n; * the call back to do_schedule_next_timer().  So all we need to do is&n; * to pick up the frozen overrun.&n; */
id|asmlinkage
r_int
DECL|function|sys_timer_getoverrun
id|sys_timer_getoverrun
c_func
(paren
id|timer_t
id|timer_id
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
suffix:semicolon
r_int
id|overrun
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|timr
op_assign
id|lock_timer
c_func
(paren
id|timer_id
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|overrun
op_assign
id|timr-&gt;it_overrun_last
suffix:semicolon
id|unlock_timer
c_func
(paren
id|timr
comma
id|flags
)paren
suffix:semicolon
r_return
id|overrun
suffix:semicolon
)brace
multiline_comment|/*&n; * Adjust for absolute time&n; *&n; * If absolute time is given and it is not CLOCK_MONOTONIC, we need to&n; * adjust for the offset between the timer clock (CLOCK_MONOTONIC) and&n; * what ever clock he is using.&n; *&n; * If it is relative time, we need to add the current (CLOCK_MONOTONIC)&n; * time to it to get the proper time for the timer.&n; */
DECL|function|adjust_abs_time
r_static
r_int
id|adjust_abs_time
c_func
(paren
r_struct
id|k_clock
op_star
id|clock
comma
r_struct
id|timespec
op_star
id|tp
comma
r_int
id|abs
comma
id|u64
op_star
id|exp
)paren
(brace
r_struct
id|timespec
id|now
suffix:semicolon
r_struct
id|timespec
id|oc
op_assign
op_star
id|tp
suffix:semicolon
r_struct
id|timespec
id|wall_to_mono
suffix:semicolon
id|u64
id|jiffies_64_f
suffix:semicolon
r_int
id|rtn
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|abs
)paren
(brace
multiline_comment|/*&n;&t;&t; * The mask pick up the 4 basic clocks &n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|clock
op_minus
op_amp
id|posix_clocks
(braket
l_int|0
)braket
)paren
op_amp
op_complement
id|CLOCKS_MASK
)paren
(brace
id|jiffies_64_f
op_assign
id|do_posix_clock_monotonic_gettime_parts
c_func
(paren
op_amp
id|now
comma
op_amp
id|wall_to_mono
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If we are doing a MONOTONIC clock&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|clock
op_minus
op_amp
id|posix_clocks
(braket
l_int|0
)braket
)paren
op_amp
id|CLOCKS_MONO
)paren
(brace
id|now.tv_sec
op_add_assign
id|wall_to_mono.tv_sec
suffix:semicolon
id|now.tv_nsec
op_add_assign
id|wall_to_mono.tv_nsec
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Not one of the basic clocks&n;&t;&t;&t; */
id|do_posix_gettime
c_func
(paren
id|clock
comma
op_amp
id|now
)paren
suffix:semicolon
id|jiffies_64_f
op_assign
id|get_jiffies_64
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Take away now to get delta&n;&t;&t; */
id|oc.tv_sec
op_sub_assign
id|now.tv_sec
suffix:semicolon
id|oc.tv_nsec
op_sub_assign
id|now.tv_nsec
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Normalize...&n;&t;&t; */
r_while
c_loop
(paren
(paren
id|oc.tv_nsec
op_minus
id|NSEC_PER_SEC
)paren
op_ge
l_int|0
)paren
(brace
id|oc.tv_nsec
op_sub_assign
id|NSEC_PER_SEC
suffix:semicolon
id|oc.tv_sec
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|oc.tv_nsec
)paren
OL
l_int|0
)paren
(brace
id|oc.tv_nsec
op_add_assign
id|NSEC_PER_SEC
suffix:semicolon
id|oc.tv_sec
op_decrement
suffix:semicolon
)brace
)brace
r_else
(brace
id|jiffies_64_f
op_assign
id|get_jiffies_64
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check if the requested time is prior to now (if so set now)&n;&t; */
r_if
c_cond
(paren
id|oc.tv_sec
OL
l_int|0
)paren
id|oc.tv_sec
op_assign
id|oc.tv_nsec
op_assign
l_int|0
suffix:semicolon
id|tstojiffie
c_func
(paren
op_amp
id|oc
comma
id|clock-&gt;res
comma
id|exp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check if the requested time is more than the timer code&n;&t; * can handle (if so we error out but return the value too).&n;&t; */
r_if
c_cond
(paren
op_star
id|exp
OG
(paren
(paren
id|u64
)paren
id|MAX_JIFFY_OFFSET
)paren
)paren
multiline_comment|/*&n;&t;&t;&t; * This is a considered response, not exactly in&n;&t;&t;&t; * line with the standard (in fact it is silent on&n;&t;&t;&t; * possible overflows).  We assume such a large &n;&t;&t;&t; * value is ALMOST always a programming error and&n;&t;&t;&t; * try not to compound it by setting a really dumb&n;&t;&t;&t; * value.&n;&t;&t;&t; */
id|rtn
op_assign
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * return the actual jiffies expire time, full 64 bits&n;&t; */
op_star
id|exp
op_add_assign
id|jiffies_64_f
suffix:semicolon
r_return
id|rtn
suffix:semicolon
)brace
multiline_comment|/* Set a POSIX.1b interval timer. */
multiline_comment|/* timr-&gt;it_lock is taken. */
r_static
r_inline
r_int
DECL|function|do_timer_settime
id|do_timer_settime
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
comma
r_int
id|flags
comma
r_struct
id|itimerspec
op_star
id|new_setting
comma
r_struct
id|itimerspec
op_star
id|old_setting
)paren
(brace
r_struct
id|k_clock
op_star
id|clock
op_assign
op_amp
id|posix_clocks
(braket
id|timr-&gt;it_clock
)braket
suffix:semicolon
id|u64
id|expire_64
suffix:semicolon
r_if
c_cond
(paren
id|old_setting
)paren
id|do_timer_gettime
c_func
(paren
id|timr
comma
id|old_setting
)paren
suffix:semicolon
multiline_comment|/* disable the timer */
id|timr-&gt;it_incr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * careful here.  If smp we could be in the &quot;fire&quot; routine which will&n;&t; * be spinning as we hold the lock.  But this is ONLY an SMP issue.&n;&t; */
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|timer_active
c_func
(paren
id|timr
)paren
op_logical_and
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
)paren
multiline_comment|/*&n;&t;&t; * It can only be active if on an other cpu.  Since&n;&t;&t; * we have cleared the interval stuff above, it should&n;&t;&t; * clear once we release the spin lock.  Of course once&n;&t;&t; * we do that anything could happen, including the&n;&t;&t; * complete melt down of the timer.  So return with&n;&t;&t; * a &quot;retry&quot; exit status.&n;&t;&t; */
r_return
id|TIMER_RETRY
suffix:semicolon
id|set_timer_inactive
c_func
(paren
id|timr
)paren
suffix:semicolon
macro_line|#else
id|del_timer
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
suffix:semicolon
macro_line|#endif
id|timr-&gt;it_requeue_pending
op_assign
(paren
id|timr-&gt;it_requeue_pending
op_plus
l_int|2
)paren
op_amp
op_complement
id|REQUEUE_PENDING
suffix:semicolon
id|timr-&gt;it_overrun_last
op_assign
l_int|0
suffix:semicolon
id|timr-&gt;it_overrun
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *switch off the timer when it_value is zero&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|new_setting-&gt;it_value.tv_sec
op_logical_and
op_logical_neg
id|new_setting-&gt;it_value.tv_nsec
)paren
(brace
id|timr-&gt;it_timer.expires
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|adjust_abs_time
c_func
(paren
id|clock
comma
op_amp
id|new_setting-&gt;it_value
comma
id|flags
op_amp
id|TIMER_ABSTIME
comma
op_amp
id|expire_64
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|timr-&gt;it_timer.expires
op_assign
(paren
r_int
r_int
)paren
id|expire_64
suffix:semicolon
id|tstojiffie
c_func
(paren
op_amp
id|new_setting-&gt;it_interval
comma
id|clock-&gt;res
comma
op_amp
id|expire_64
)paren
suffix:semicolon
id|timr-&gt;it_incr
op_assign
(paren
r_int
r_int
)paren
id|expire_64
suffix:semicolon
multiline_comment|/*&n;&t; * For some reason the timer does not fire immediately if expires is&n;&t; * equal to jiffies, so the timer notify function is called directly.&n;&t; * We do not even queue SIGEV_NONE timers!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|timr-&gt;it_sigev_notify
op_amp
id|SIGEV_NONE
)paren
)paren
(brace
r_if
c_cond
(paren
id|timr-&gt;it_timer.expires
op_eq
id|jiffies
)paren
id|timer_notify_task
c_func
(paren
id|timr
)paren
suffix:semicolon
r_else
id|add_timer
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Set a POSIX.1b interval timer */
id|asmlinkage
r_int
DECL|function|sys_timer_settime
id|sys_timer_settime
c_func
(paren
id|timer_t
id|timer_id
comma
r_int
id|flags
comma
r_const
r_struct
id|itimerspec
id|__user
op_star
id|new_setting
comma
r_struct
id|itimerspec
id|__user
op_star
id|old_setting
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
suffix:semicolon
r_struct
id|itimerspec
id|new_spec
comma
id|old_spec
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|flag
suffix:semicolon
r_struct
id|itimerspec
op_star
id|rtn
op_assign
id|old_setting
ques
c_cond
op_amp
id|old_spec
suffix:colon
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_setting
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|new_spec
comma
id|new_setting
comma
r_sizeof
(paren
id|new_spec
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|good_timespec
c_func
(paren
op_amp
id|new_spec.it_interval
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|good_timespec
c_func
(paren
op_amp
id|new_spec.it_value
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|retry
suffix:colon
id|timr
op_assign
id|lock_timer
c_func
(paren
id|timer_id
comma
op_amp
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|posix_clocks
(braket
id|timr-&gt;it_clock
)braket
dot
id|timer_set
)paren
id|error
op_assign
id|do_timer_settime
c_func
(paren
id|timr
comma
id|flags
comma
op_amp
id|new_spec
comma
id|rtn
)paren
suffix:semicolon
r_else
id|error
op_assign
id|posix_clocks
(braket
id|timr-&gt;it_clock
)braket
dot
id|timer_set
c_func
(paren
id|timr
comma
id|flags
comma
op_amp
id|new_spec
comma
id|rtn
)paren
suffix:semicolon
id|unlock_timer
c_func
(paren
id|timr
comma
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|TIMER_RETRY
)paren
(brace
id|rtn
op_assign
l_int|NULL
suffix:semicolon
singleline_comment|// We already got the old time...
r_goto
id|retry
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_setting
op_logical_and
op_logical_neg
id|error
op_logical_and
id|copy_to_user
c_func
(paren
id|old_setting
comma
op_amp
id|old_spec
comma
r_sizeof
(paren
id|old_spec
)paren
)paren
)paren
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|do_timer_delete
r_static
r_inline
r_int
id|do_timer_delete
c_func
(paren
r_struct
id|k_itimer
op_star
id|timer
)paren
(brace
id|timer-&gt;it_incr
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|timer_active
c_func
(paren
id|timer
)paren
op_logical_and
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|timer-&gt;it_timer
)paren
)paren
multiline_comment|/*&n;&t;&t; * It can only be active if on an other cpu.  Since&n;&t;&t; * we have cleared the interval stuff above, it should&n;&t;&t; * clear once we release the spin lock.  Of course once&n;&t;&t; * we do that anything could happen, including the&n;&t;&t; * complete melt down of the timer.  So return with&n;&t;&t; * a &quot;retry&quot; exit status.&n;&t;&t; */
r_return
id|TIMER_RETRY
suffix:semicolon
macro_line|#else
id|del_timer
c_func
(paren
op_amp
id|timer-&gt;it_timer
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Delete a POSIX.1b interval timer. */
id|asmlinkage
r_int
DECL|function|sys_timer_delete
id|sys_timer_delete
c_func
(paren
id|timer_t
id|timer_id
)paren
(brace
r_struct
id|k_itimer
op_star
id|timer
suffix:semicolon
r_int
id|flags
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_int
id|error
suffix:semicolon
id|retry_delete
suffix:colon
macro_line|#endif
id|timer
op_assign
id|lock_timer
c_func
(paren
id|timer_id
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timer
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|error
op_assign
id|p_timer_del
c_func
(paren
op_amp
id|posix_clocks
(braket
id|timer-&gt;it_clock
)braket
comma
id|timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|TIMER_RETRY
)paren
(brace
id|unlock_timer
c_func
(paren
id|timer
comma
id|flags
)paren
suffix:semicolon
r_goto
id|retry_delete
suffix:semicolon
)brace
macro_line|#else
id|p_timer_del
c_func
(paren
op_amp
id|posix_clocks
(braket
id|timer-&gt;it_clock
)braket
comma
id|timer
)paren
suffix:semicolon
macro_line|#endif
id|task_lock
c_func
(paren
id|timer-&gt;it_process
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|timer-&gt;list
)paren
suffix:semicolon
id|task_unlock
c_func
(paren
id|timer-&gt;it_process
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This keeps any tasks waiting on the spin lock from thinking&n;&t; * they got something (see the lock code above).&n;&t; */
id|timer-&gt;it_process
op_assign
l_int|NULL
suffix:semicolon
id|unlock_timer
c_func
(paren
id|timer
comma
id|flags
)paren
suffix:semicolon
id|release_posix_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * return timer owned by the process, used by exit_itimers&n; */
DECL|function|itimer_delete
r_static
r_inline
r_void
id|itimer_delete
c_func
(paren
r_struct
id|k_itimer
op_star
id|timer
)paren
(brace
r_if
c_cond
(paren
id|sys_timer_delete
c_func
(paren
id|timer-&gt;it_id
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is exported to exit and exec&n; */
DECL|function|exit_itimers
r_void
id|exit_itimers
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_struct
id|k_itimer
op_star
id|tmr
suffix:semicolon
id|task_lock
c_func
(paren
id|tsk
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|tsk-&gt;posix_timers
)paren
)paren
(brace
id|tmr
op_assign
id|list_entry
c_func
(paren
id|tsk-&gt;posix_timers.next
comma
r_struct
id|k_itimer
comma
id|list
)paren
suffix:semicolon
id|task_unlock
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|itimer_delete
c_func
(paren
id|tmr
)paren
suffix:semicolon
id|task_lock
c_func
(paren
id|tsk
)paren
suffix:semicolon
)brace
id|task_unlock
c_func
(paren
id|tsk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * And now for the &quot;clock&quot; calls&n; *&n; * These functions are called both from timer functions (with the timer&n; * spin_lock_irq() held and from clock calls with no locking.&t;They must&n; * use the save flags versions of locks.&n; */
DECL|function|do_posix_gettime
r_static
r_int
id|do_posix_gettime
c_func
(paren
r_struct
id|k_clock
op_star
id|clock
comma
r_struct
id|timespec
op_star
id|tp
)paren
(brace
r_if
c_cond
(paren
id|clock-&gt;clock_get
)paren
r_return
id|clock
op_member_access_from_pointer
id|clock_get
c_func
(paren
id|tp
)paren
suffix:semicolon
id|do_gettimeofday
c_func
(paren
(paren
r_struct
id|timeval
op_star
)paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;tv_nsec
op_mul_assign
id|NSEC_PER_USEC
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We do ticks here to avoid the irq lock ( they take sooo long).&n; * The seqlock is great here.  Since we a reader, we don&squot;t really care&n; * if we are interrupted since we don&squot;t take lock that will stall us or&n; * any other cpu. Voila, no irq lock is needed.&n; *&n; * Note also that the while loop assures that the sub_jiff_offset&n; * will be less than a jiffie, thus no need to normalize the result.&n; * Well, not really, if called with ints off :(&n; */
DECL|function|do_posix_clock_monotonic_gettime_parts
r_static
id|u64
id|do_posix_clock_monotonic_gettime_parts
c_func
(paren
r_struct
id|timespec
op_star
id|tp
comma
r_struct
id|timespec
op_star
id|mo
)paren
(brace
id|u64
id|jiff
suffix:semicolon
r_struct
id|timeval
id|tpv
suffix:semicolon
r_int
r_int
id|seq
suffix:semicolon
r_do
(brace
id|seq
op_assign
id|read_seqbegin
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tpv
)paren
suffix:semicolon
op_star
id|mo
op_assign
id|wall_to_monotonic
suffix:semicolon
id|jiff
op_assign
id|jiffies_64
suffix:semicolon
)brace
r_while
c_loop
(paren
id|read_seqretry
c_func
(paren
op_amp
id|xtime_lock
comma
id|seq
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Love to get this before it is converted to usec.&n;&t; * It would save a div AND a mpy.&n;&t; */
id|tp-&gt;tv_sec
op_assign
id|tpv.tv_sec
suffix:semicolon
id|tp-&gt;tv_nsec
op_assign
id|tpv.tv_usec
op_star
id|NSEC_PER_USEC
suffix:semicolon
r_return
id|jiff
suffix:semicolon
)brace
DECL|function|do_posix_clock_monotonic_gettime
r_int
id|do_posix_clock_monotonic_gettime
c_func
(paren
r_struct
id|timespec
op_star
id|tp
)paren
(brace
r_struct
id|timespec
id|wall_to_mono
suffix:semicolon
id|do_posix_clock_monotonic_gettime_parts
c_func
(paren
id|tp
comma
op_amp
id|wall_to_mono
)paren
suffix:semicolon
id|tp-&gt;tv_sec
op_add_assign
id|wall_to_mono.tv_sec
suffix:semicolon
id|tp-&gt;tv_nsec
op_add_assign
id|wall_to_mono.tv_nsec
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tp-&gt;tv_nsec
op_minus
id|NSEC_PER_SEC
)paren
OG
l_int|0
)paren
(brace
id|tp-&gt;tv_nsec
op_sub_assign
id|NSEC_PER_SEC
suffix:semicolon
id|tp-&gt;tv_sec
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|do_posix_clock_monotonic_settime
r_int
id|do_posix_clock_monotonic_settime
c_func
(paren
r_struct
id|timespec
op_star
id|tp
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_clock_settime
id|sys_clock_settime
c_func
(paren
id|clockid_t
id|which_clock
comma
r_const
r_struct
id|timespec
id|__user
op_star
id|tp
)paren
(brace
r_struct
id|timespec
id|new_tp
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|which_clock
op_ge
id|MAX_CLOCKS
op_logical_or
op_logical_neg
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|res
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|new_tp
comma
id|tp
comma
r_sizeof
(paren
op_star
id|tp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|clock_set
)paren
r_return
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|clock_set
c_func
(paren
op_amp
id|new_tp
)paren
suffix:semicolon
id|new_tp.tv_nsec
op_div_assign
id|NSEC_PER_USEC
suffix:semicolon
r_return
id|do_sys_settimeofday
c_func
(paren
(paren
r_struct
id|timeval
op_star
)paren
op_amp
id|new_tp
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_clock_gettime
id|sys_clock_gettime
c_func
(paren
id|clockid_t
id|which_clock
comma
r_struct
id|timespec
id|__user
op_star
id|tp
)paren
(brace
r_struct
id|timespec
id|rtn_tp
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|which_clock
op_ge
id|MAX_CLOCKS
op_logical_or
op_logical_neg
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|res
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|error
op_assign
id|do_posix_gettime
c_func
(paren
op_amp
id|posix_clocks
(braket
id|which_clock
)braket
comma
op_amp
id|rtn_tp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|copy_to_user
c_func
(paren
id|tp
comma
op_amp
id|rtn_tp
comma
r_sizeof
(paren
id|rtn_tp
)paren
)paren
)paren
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_clock_getres
id|sys_clock_getres
c_func
(paren
id|clockid_t
id|which_clock
comma
r_struct
id|timespec
id|__user
op_star
id|tp
)paren
(brace
r_struct
id|timespec
id|rtn_tp
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|which_clock
op_ge
id|MAX_CLOCKS
op_logical_or
op_logical_neg
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|res
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|rtn_tp.tv_sec
op_assign
l_int|0
suffix:semicolon
id|rtn_tp.tv_nsec
op_assign
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|res
suffix:semicolon
r_if
c_cond
(paren
id|tp
op_logical_and
id|copy_to_user
c_func
(paren
id|tp
comma
op_amp
id|rtn_tp
comma
r_sizeof
(paren
id|rtn_tp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nanosleep_wake_up
r_static
r_void
id|nanosleep_wake_up
c_func
(paren
r_int
r_int
id|__data
)paren
(brace
r_struct
id|task_struct
op_star
id|p
op_assign
(paren
r_struct
id|task_struct
op_star
)paren
id|__data
suffix:semicolon
id|wake_up_process
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The standard says that an absolute nanosleep call MUST wake up at&n; * the requested time in spite of clock settings.  Here is what we do:&n; * For each nanosleep call that needs it (only absolute and not on&n; * CLOCK_MONOTONIC* (as it can not be set)) we thread a little structure&n; * into the &quot;nanosleep_abs_list&quot;.  All we need is the task_struct pointer.&n; * When ever the clock is set we just wake up all those tasks.&t; The rest&n; * is done by the while loop in clock_nanosleep().&n; *&n; * On locking, clock_was_set() is called from update_wall_clock which&n; * holds (or has held for it) a write_lock_irq( xtime_lock) and is&n; * called from the timer bh code.  Thus we need the irq save locks.&n; */
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|nanosleep_abs_wqueue
)paren
suffix:semicolon
DECL|function|clock_was_set
r_void
id|clock_was_set
c_func
(paren
r_void
)paren
(brace
id|wake_up_all
c_func
(paren
op_amp
id|nanosleep_abs_wqueue
)paren
suffix:semicolon
)brace
r_int
id|clock_nanosleep_restart
c_func
(paren
r_struct
id|restart_block
op_star
id|restart_block
)paren
suffix:semicolon
r_extern
r_int
id|do_clock_nanosleep
c_func
(paren
id|clockid_t
id|which_clock
comma
r_int
id|flags
comma
r_struct
id|timespec
op_star
id|t
)paren
suffix:semicolon
macro_line|#ifdef FOLD_NANO_SLEEP_INTO_CLOCK_NANO_SLEEP
id|asmlinkage
r_int
DECL|function|sys_nanosleep
id|sys_nanosleep
c_func
(paren
r_struct
id|timespec
id|__user
op_star
id|rqtp
comma
r_struct
id|timespec
id|__user
op_star
id|rmtp
)paren
(brace
r_struct
id|timespec
id|t
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|t
comma
id|rqtp
comma
r_sizeof
(paren
id|t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|t.tv_nsec
op_ge
id|NSEC_PER_SEC
op_logical_or
id|t.tv_sec
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ret
op_assign
id|do_clock_nanosleep
c_func
(paren
id|CLOCK_REALTIME
comma
l_int|0
comma
op_amp
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|ERESTART_RESTARTBLOCK
op_logical_and
id|rmtp
op_logical_and
id|copy_to_user
c_func
(paren
id|rmtp
comma
op_amp
id|t
comma
r_sizeof
(paren
id|t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;
singleline_comment|// ! FOLD_NANO_SLEEP_INTO_CLOCK_NANO_SLEEP
id|asmlinkage
r_int
DECL|function|sys_clock_nanosleep
id|sys_clock_nanosleep
c_func
(paren
id|clockid_t
id|which_clock
comma
r_int
id|flags
comma
r_const
r_struct
id|timespec
id|__user
op_star
id|rqtp
comma
r_struct
id|timespec
id|__user
op_star
id|rmtp
)paren
(brace
r_struct
id|timespec
id|t
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|which_clock
op_ge
id|MAX_CLOCKS
op_logical_or
op_logical_neg
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|res
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|t
comma
id|rqtp
comma
r_sizeof
(paren
r_struct
id|timespec
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|t.tv_nsec
op_ge
id|NSEC_PER_SEC
op_logical_or
id|t.tv_sec
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ret
op_assign
id|do_clock_nanosleep
c_func
(paren
id|which_clock
comma
id|flags
comma
op_amp
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_eq
op_minus
id|ERESTART_RESTARTBLOCK
)paren
op_logical_and
id|rmtp
op_logical_and
id|copy_to_user
c_func
(paren
id|rmtp
comma
op_amp
id|t
comma
r_sizeof
(paren
id|t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_int
DECL|function|do_clock_nanosleep
id|do_clock_nanosleep
c_func
(paren
id|clockid_t
id|which_clock
comma
r_int
id|flags
comma
r_struct
id|timespec
op_star
id|tsave
)paren
(brace
r_struct
id|timespec
id|t
suffix:semicolon
r_struct
id|timer_list
id|new_timer
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|abs_wqueue
comma
id|current
)paren
suffix:semicolon
id|u64
id|rq_time
op_assign
(paren
id|u64
)paren
l_int|0
suffix:semicolon
id|s64
id|left
suffix:semicolon
r_int
id|abs
suffix:semicolon
r_struct
id|restart_block
op_star
id|restart_block
op_assign
op_amp
id|current_thread_info
c_func
(paren
)paren
op_member_access_from_pointer
id|restart_block
suffix:semicolon
id|abs_wqueue.flags
op_assign
l_int|0
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|new_timer
)paren
suffix:semicolon
id|new_timer.expires
op_assign
l_int|0
suffix:semicolon
id|new_timer.data
op_assign
(paren
r_int
r_int
)paren
id|current
suffix:semicolon
id|new_timer.function
op_assign
id|nanosleep_wake_up
suffix:semicolon
id|abs
op_assign
id|flags
op_amp
id|TIMER_ABSTIME
suffix:semicolon
r_if
c_cond
(paren
id|restart_block-&gt;fn
op_eq
id|clock_nanosleep_restart
)paren
(brace
multiline_comment|/*&n;&t;&t; * Interrupted by a non-delivered signal, pick up remaining&n;&t;&t; * time and continue.&n;&t;&t; */
id|restart_block-&gt;fn
op_assign
id|do_no_restart_syscall
suffix:semicolon
id|rq_time
op_assign
id|restart_block-&gt;arg3
suffix:semicolon
id|rq_time
op_assign
(paren
id|rq_time
op_lshift
l_int|32
)paren
op_plus
id|restart_block-&gt;arg2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq_time
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
id|left
op_assign
id|rq_time
op_minus
id|get_jiffies_64
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|left
op_le
(paren
id|s64
)paren
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Already passed */
)brace
r_if
c_cond
(paren
id|abs
op_logical_and
(paren
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|clock_get
op_ne
id|posix_clocks
(braket
id|CLOCK_MONOTONIC
)braket
dot
id|clock_get
)paren
)paren
id|add_wait_queue
c_func
(paren
op_amp
id|nanosleep_abs_wqueue
comma
op_amp
id|abs_wqueue
)paren
suffix:semicolon
r_do
(brace
id|t
op_assign
op_star
id|tsave
suffix:semicolon
r_if
c_cond
(paren
id|abs
op_logical_or
op_logical_neg
id|rq_time
)paren
(brace
id|adjust_abs_time
c_func
(paren
op_amp
id|posix_clocks
(braket
id|which_clock
)braket
comma
op_amp
id|t
comma
id|abs
comma
op_amp
id|rq_time
)paren
suffix:semicolon
)brace
id|left
op_assign
id|rq_time
op_minus
id|get_jiffies_64
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|left
op_ge
(paren
id|s64
)paren
id|MAX_JIFFY_OFFSET
)paren
id|left
op_assign
(paren
id|s64
)paren
id|MAX_JIFFY_OFFSET
suffix:semicolon
r_if
c_cond
(paren
id|left
OL
(paren
id|s64
)paren
l_int|0
)paren
r_break
suffix:semicolon
id|new_timer.expires
op_assign
id|jiffies
op_plus
id|left
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|new_timer
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|new_timer
)paren
suffix:semicolon
id|left
op_assign
id|rq_time
op_minus
id|get_jiffies_64
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|left
OG
(paren
id|s64
)paren
l_int|0
op_logical_and
op_logical_neg
id|test_thread_flag
c_func
(paren
id|TIF_SIGPENDING
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|abs_wqueue.task_list.next
)paren
id|finish_wait
c_func
(paren
op_amp
id|nanosleep_abs_wqueue
comma
op_amp
id|abs_wqueue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|left
OG
(paren
id|s64
)paren
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Always restart abs calls from scratch to pick up any&n;&t;&t; * clock shifting that happened while we are away.&n;&t;&t; */
r_if
c_cond
(paren
id|abs
)paren
r_return
op_minus
id|ERESTARTNOHAND
suffix:semicolon
id|left
op_mul_assign
id|TICK_NSEC
c_func
(paren
id|TICK_USEC
)paren
suffix:semicolon
id|tsave-&gt;tv_sec
op_assign
id|div_long_long_rem
c_func
(paren
id|left
comma
id|NSEC_PER_SEC
comma
op_amp
id|tsave-&gt;tv_nsec
)paren
suffix:semicolon
id|restart_block-&gt;fn
op_assign
id|clock_nanosleep_restart
suffix:semicolon
id|restart_block-&gt;arg0
op_assign
id|which_clock
suffix:semicolon
id|restart_block-&gt;arg1
op_assign
(paren
r_int
r_int
)paren
id|tsave
suffix:semicolon
id|restart_block-&gt;arg2
op_assign
id|rq_time
op_amp
l_int|0xffffffffLL
suffix:semicolon
id|restart_block-&gt;arg3
op_assign
id|rq_time
op_rshift
l_int|32
suffix:semicolon
r_return
op_minus
id|ERESTART_RESTARTBLOCK
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This will restart either clock_nanosleep or clock_nanosleep&n; */
r_int
DECL|function|clock_nanosleep_restart
id|clock_nanosleep_restart
c_func
(paren
r_struct
id|restart_block
op_star
id|restart_block
)paren
(brace
r_struct
id|timespec
id|t
suffix:semicolon
r_int
id|ret
op_assign
id|do_clock_nanosleep
c_func
(paren
id|restart_block-&gt;arg0
comma
l_int|0
comma
op_amp
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_eq
op_minus
id|ERESTART_RESTARTBLOCK
)paren
op_logical_and
id|restart_block-&gt;arg1
op_logical_and
id|copy_to_user
c_func
(paren
(paren
r_struct
id|timespec
id|__user
op_star
)paren
(paren
id|restart_block-&gt;arg1
)paren
comma
op_amp
id|t
comma
r_sizeof
(paren
id|t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
eof
