multiline_comment|/*&n; * linux/kernel/posix_timers.c&n; *&n; * &n; * 2002-10-15  Posix Clocks &amp; timers by George Anzinger&n; *&t;&t;&t;     Copyright (C) 2002 by MontaVista Software.&n; */
multiline_comment|/* These are all the functions necessary to implement &n; * POSIX clocks &amp; timers&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;linux/idr.h&gt;
macro_line|#include &lt;linux/posix-timers.h&gt;
macro_line|#ifndef div_long_long_rem
macro_line|#include &lt;asm/div64.h&gt;
DECL|macro|div_long_long_rem
mdefine_line|#define div_long_long_rem(dividend,divisor,remainder) ({ &bslash;&n;&t;&t;       u64 result = dividend;&t;&t;&bslash;&n;&t;&t;       *remainder = do_div(result,divisor); &bslash;&n;&t;&t;       result; })
macro_line|#endif&t;&t;&t;&t;/* ifndef div_long_long_rem */
multiline_comment|/*&n; * Management arrays for POSIX timers.&t; Timers are kept in slab memory&n; * Timer ids are allocated by an external routine that keeps track of the&n; * id and the timer.  The external interface is:&n; *&n; *void *idr_find(struct idr *idp, int id);           to find timer_id &lt;id&gt;&n; *int idr_get_new(struct idr *idp, void *ptr);       to get a new id and &n; *                                                  related it to &lt;ptr&gt;&n; *void idr_remove(struct idr *idp, int id);          to release &lt;id&gt;&n; *void idr_init(struct idr *idp);                    to initialize &lt;idp&gt;&n; *                                                  which we supply.&n; * The idr_get_new *may* call slab for more memory so it must not be&n; * called under a spin lock.  Likewise idr_remore may release memory&n; * (but it may be ok to do this under a lock...).&n; * idr_find is just a memory look up and is quite fast.  A zero return&n; * indicates that the requested id does not exist.&n;&n; */
multiline_comment|/*&n;   * Lets keep our timers in a slab cache :-)&n; */
DECL|variable|posix_timers_cache
r_static
id|kmem_cache_t
op_star
id|posix_timers_cache
suffix:semicolon
DECL|variable|posix_timers_id
r_struct
id|idr
id|posix_timers_id
suffix:semicolon
DECL|variable|idr_lock
id|spinlock_t
id|idr_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * Just because the timer is not in the timer list does NOT mean it is&n; * inactive.  It could be in the &quot;fire&quot; routine getting a new expire time.&n; */
DECL|macro|TIMER_INACTIVE
mdefine_line|#define TIMER_INACTIVE 1
DECL|macro|TIMER_RETRY
mdefine_line|#define TIMER_RETRY 1
macro_line|#ifdef CONFIG_SMP
DECL|macro|timer_active
mdefine_line|#define timer_active(tmr) (tmr-&gt;it_timer.entry.prev != (void *)TIMER_INACTIVE)
DECL|macro|set_timer_inactive
mdefine_line|#define set_timer_inactive(tmr) tmr-&gt;it_timer.entry.prev = (void *)TIMER_INACTIVE
macro_line|#else
DECL|macro|timer_active
mdefine_line|#define timer_active(tmr) BARFY&t;
singleline_comment|// error to use outside of SMP
DECL|macro|set_timer_inactive
mdefine_line|#define set_timer_inactive(tmr)
macro_line|#endif
multiline_comment|/*&n; * The timer ID is turned into a timer address by idr_find().&n; * Verifying a valid ID consists of:&n; * &n; * a) checking that idr_find() returns other than zero.&n; * b) checking that the timer id matches the one in the timer itself.&n; * c) that the timer owner is in the callers thread group.&n; */
multiline_comment|/* &n; * CLOCKs: The POSIX standard calls for a couple of clocks and allows us&n; *&t;    to implement others.  This structure defines the various&n; *&t;    clocks and allows the possibility of adding others.&t; We&n; *&t;    provide an interface to add clocks to the table and expect&n; *&t;    the &quot;arch&quot; code to add at least one clock that is high&n; *&t;    resolution.&t; Here we define the standard CLOCK_REALTIME as a&n; *&t;    1/HZ resolution clock.&n;&n; * CPUTIME &amp; THREAD_CPUTIME: We are not, at this time, definding these&n; *&t;    two clocks (and the other process related clocks (Std&n; *&t;    1003.1d-1999).  The way these should be supported, we think,&n; *&t;    is to use large negative numbers for the two clocks that are&n; *&t;    pinned to the executing process and to use -pid for clocks&n; *&t;    pinned to particular pids.&t;Calls which supported these clock&n; *&t;    ids would split early in the function.&n; &n; * RESOLUTION: Clock resolution is used to round up timer and interval&n; *&t;    times, NOT to report clock times, which are reported with as&n; *&t;    much resolution as the system can muster.  In some cases this&n; *&t;    resolution may depend on the underlaying clock hardware and&n; *&t;    may not be quantifiable until run time, and only then is the&n; *&t;    necessary code is written.&t;The standard says we should say&n; *&t;    something about this issue in the documentation...&n;&n; * FUNCTIONS: The CLOCKs structure defines possible functions to handle&n; *&t;    various clock functions.  For clocks that use the standard&n; *&t;    system timer code these entries should be NULL.  This will&n; *&t;    allow dispatch without the overhead of indirect function&n; *&t;    calls.  CLOCKS that depend on other sources (e.g. WWV or GPS)&n; *&t;    must supply functions here, even if the function just returns&n; *&t;    ENOSYS.  The standard POSIX timer management code assumes the&n; *&t;    following: 1.) The k_itimer struct (sched.h) is used for the&n; *&t;    timer.  2.) The list, it_lock, it_clock, it_id and it_process&n; *&t;    fields are not modified by timer code. &n; *&n; *          At this time all functions EXCEPT clock_nanosleep can be&n; *          redirected by the CLOCKS structure.  Clock_nanosleep is in&n; *          there, but the code ignors it.&n; *&n; * Permissions: It is assumed that the clock_settime() function defined&n; *&t;    for each clock will take care of permission checks.&t; Some&n; *&t;    clocks may be set able by any user (i.e. local process&n; *&t;    clocks) others not.&t; Currently the only set able clock we&n; *&t;    have is CLOCK_REALTIME and its high res counter part, both of&n; *&t;    which we beg off on and pass to do_sys_settimeofday().&n; */
DECL|variable|posix_clocks
r_struct
id|k_clock
id|posix_clocks
(braket
id|MAX_CLOCKS
)braket
suffix:semicolon
DECL|macro|if_clock_do
mdefine_line|#define if_clock_do(clock_fun, alt_fun,parms)&t;(! clock_fun)? alt_fun parms :&bslash;&n;&t;&t;&t;&t;&t;&t;&t;      clock_fun parms
DECL|macro|p_timer_get
mdefine_line|#define p_timer_get( clock,a,b) if_clock_do((clock)-&gt;timer_get, &bslash;&n;&t;&t;&t;&t;&t;     do_timer_gettime,&t; &bslash;&n;&t;&t;&t;&t;&t;     (a,b))
DECL|macro|p_nsleep
mdefine_line|#define p_nsleep( clock,a,b,c) if_clock_do((clock)-&gt;nsleep,   &bslash;&n;&t;&t;&t;&t;&t;    do_nsleep,&t;       &bslash;&n;&t;&t;&t;&t;&t;    (a,b,c))
DECL|macro|p_timer_del
mdefine_line|#define p_timer_del( clock,a) if_clock_do((clock)-&gt;timer_del, &bslash;&n;&t;&t;&t;&t;&t;   do_timer_delete,    &bslash;&n;&t;&t;&t;&t;&t;   (a))
r_void
id|register_posix_clock
c_func
(paren
r_int
id|clock_id
comma
r_struct
id|k_clock
op_star
id|new_clock
)paren
suffix:semicolon
r_static
r_int
id|do_posix_gettime
c_func
(paren
r_struct
id|k_clock
op_star
id|clock
comma
r_struct
id|timespec
op_star
id|tp
)paren
suffix:semicolon
r_int
id|do_posix_clock_monotonic_gettime
c_func
(paren
r_struct
id|timespec
op_star
id|tp
)paren
suffix:semicolon
r_int
id|do_posix_clock_monotonic_settime
c_func
(paren
r_struct
id|timespec
op_star
id|tp
)paren
suffix:semicolon
r_static
r_struct
id|k_itimer
op_star
id|lock_timer
c_func
(paren
id|timer_t
id|timer_id
comma
r_int
r_int
op_star
id|flags
)paren
suffix:semicolon
r_static
r_inline
r_void
id|unlock_timer
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
comma
r_int
r_int
id|flags
)paren
suffix:semicolon
multiline_comment|/* &n; * Initialize everything, well, just everything in Posix clocks/timers ;)&n; */
r_static
id|__init
r_int
DECL|function|init_posix_timers
id|init_posix_timers
c_func
(paren
r_void
)paren
(brace
r_struct
id|k_clock
id|clock_realtime
op_assign
(brace
dot
id|res
op_assign
id|NSEC_PER_SEC
op_div
id|HZ
)brace
suffix:semicolon
r_struct
id|k_clock
id|clock_monotonic
op_assign
(brace
dot
id|res
op_assign
id|NSEC_PER_SEC
op_div
id|HZ
comma
dot
id|clock_get
op_assign
id|do_posix_clock_monotonic_gettime
comma
dot
id|clock_set
op_assign
id|do_posix_clock_monotonic_settime
)brace
suffix:semicolon
id|register_posix_clock
c_func
(paren
id|CLOCK_REALTIME
comma
op_amp
id|clock_realtime
)paren
suffix:semicolon
id|register_posix_clock
c_func
(paren
id|CLOCK_MONOTONIC
comma
op_amp
id|clock_monotonic
)paren
suffix:semicolon
id|posix_timers_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;posix_timers_cache&quot;
comma
r_sizeof
(paren
r_struct
id|k_itimer
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|idr_init
c_func
(paren
op_amp
id|posix_timers_id
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|init_posix_timers
id|__initcall
c_func
(paren
id|init_posix_timers
)paren
suffix:semicolon
r_static
r_inline
r_int
DECL|function|tstojiffie
id|tstojiffie
c_func
(paren
r_struct
id|timespec
op_star
id|tp
comma
r_int
id|res
comma
r_int
r_int
op_star
id|jiff
)paren
(brace
r_int
r_int
id|sec
op_assign
id|tp-&gt;tv_sec
suffix:semicolon
r_int
id|nsec
op_assign
id|tp-&gt;tv_nsec
op_plus
id|res
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|nsec
OG
id|NSEC_PER_SEC
)paren
(brace
id|sec
op_increment
suffix:semicolon
id|nsec
op_sub_assign
id|NSEC_PER_SEC
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * A note on jiffy overflow: It is possible for the system to&n;&t; * have been up long enough for the jiffies quanity to overflow.&n;&t; * In order for correct timer evaluations we require that the&n;&t; * specified time be somewhere between now and now + (max&n;&t; * unsigned int/2).  Times beyond this will be truncated back to&n;&t; * this value.   This is done in the absolute adjustment code,&n;&t; * below.  Here it is enough to just discard the high order&n;&t; * bits.  &n;&t; */
op_star
id|jiff
op_assign
id|HZ
op_star
id|sec
suffix:semicolon
multiline_comment|/*&n;&t; * Do the res thing. (Don&squot;t forget the add in the declaration of nsec) &n;&t; */
id|nsec
op_sub_assign
id|nsec
op_mod
id|res
suffix:semicolon
multiline_comment|/*&n;&t; * Split to jiffie and sub jiffie&n;&t; */
op_star
id|jiff
op_add_assign
id|nsec
op_div
(paren
id|NSEC_PER_SEC
op_div
id|HZ
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We trust that the optimizer will use the remainder from the &n;&t; * above div in the following operation as long as they are close. &n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|tstotimer
id|tstotimer
c_func
(paren
r_struct
id|itimerspec
op_star
id|time
comma
r_struct
id|k_itimer
op_star
id|timer
)paren
(brace
r_int
id|res
op_assign
id|posix_clocks
(braket
id|timer-&gt;it_clock
)braket
dot
id|res
suffix:semicolon
id|tstojiffie
c_func
(paren
op_amp
id|time-&gt;it_value
comma
id|res
comma
op_amp
id|timer-&gt;it_timer.expires
)paren
suffix:semicolon
id|tstojiffie
c_func
(paren
op_amp
id|time-&gt;it_interval
comma
id|res
comma
op_amp
id|timer-&gt;it_incr
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|schedule_next_timer
id|schedule_next_timer
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
)paren
(brace
r_struct
id|now_struct
id|now
suffix:semicolon
multiline_comment|/* Set up the timer for the next interval (if there is one) */
r_if
c_cond
(paren
id|timr-&gt;it_incr
op_eq
l_int|0
)paren
(brace
(brace
id|set_timer_inactive
c_func
(paren
id|timr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|posix_get_now
c_func
(paren
op_amp
id|now
)paren
suffix:semicolon
r_while
c_loop
(paren
id|posix_time_before
c_func
(paren
op_amp
id|timr-&gt;it_timer
comma
op_amp
id|now
)paren
)paren
(brace
id|posix_bump_timer
c_func
(paren
id|timr
)paren
suffix:semicolon
)brace
suffix:semicolon
id|timr-&gt;it_overrun_last
op_assign
id|timr-&gt;it_overrun
suffix:semicolon
id|timr-&gt;it_overrun
op_assign
op_minus
l_int|1
suffix:semicolon
id|timr-&gt;it_requeue_pending
op_assign
l_int|0
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&n; * This function is exported for use by the signal deliver code.  It is&n; * called just prior to the info block being released and passes that&n; * block to us.  It&squot;s function is to update the overrun entry AND to&n; * restart the timer.  It should only be called if the timer is to be&n; * restarted (i.e. we have flagged this in the sys_private entry of the&n; * info block).&n; *&n; * To protect aginst the timer going away while the interrupt is queued,&n; * we require that the it_requeue_pending flag be set.&n;&n; */
r_void
DECL|function|do_schedule_next_timer
id|do_schedule_next_timer
c_func
(paren
r_struct
id|siginfo
op_star
id|info
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|timr
op_assign
id|lock_timer
c_func
(paren
id|info-&gt;si_tid
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timr
op_logical_or
op_logical_neg
id|timr-&gt;it_requeue_pending
)paren
r_goto
m_exit
suffix:semicolon
id|schedule_next_timer
c_func
(paren
id|timr
)paren
suffix:semicolon
id|info-&gt;si_overrun
op_assign
id|timr-&gt;it_overrun_last
suffix:semicolon
m_exit
suffix:colon
r_if
c_cond
(paren
id|timr
)paren
id|unlock_timer
c_func
(paren
id|timr
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&n; * Notify the task and set up the timer for the next expiration (if&n; * applicable).  This function requires that the k_itimer structure&n; * it_lock is taken.  This code will requeue the timer only if we get&n; * either an error return or a flag (ret &gt; 0) from send_seg_info&n; * indicating that the signal was either not queued or was queued&n; * without an info block.  In this case, we will not get a call back to&n; * do_schedule_next_timer() so we do it here.  This should be rare...&n;&n; */
r_static
r_void
DECL|function|timer_notify_task
id|timer_notify_task
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
)paren
(brace
r_struct
id|siginfo
id|info
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|info
comma
l_int|0
comma
r_sizeof
(paren
id|info
)paren
)paren
suffix:semicolon
multiline_comment|/* Send signal to the process that owns this timer. */
id|info.si_signo
op_assign
id|timr-&gt;it_sigev_signo
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_code
op_assign
id|SI_TIMER
suffix:semicolon
id|info.si_tid
op_assign
id|timr-&gt;it_id
suffix:semicolon
id|info.si_value
op_assign
id|timr-&gt;it_sigev_value
suffix:semicolon
r_if
c_cond
(paren
id|timr-&gt;it_incr
op_eq
l_int|0
)paren
(brace
id|set_timer_inactive
c_func
(paren
id|timr
)paren
suffix:semicolon
)brace
r_else
(brace
id|timr-&gt;it_requeue_pending
op_assign
id|info.si_sys_private
op_assign
l_int|1
suffix:semicolon
)brace
id|ret
op_assign
id|send_sig_info
c_func
(paren
id|info.si_signo
comma
op_amp
id|info
comma
id|timr-&gt;it_process
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ret
)paren
(brace
r_default
suffix:colon
multiline_comment|/*&n;&t;&t; * Signal was not sent.  May or may not need to&n;&t;&t; * restart the timer.&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;sending signal failed: %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/*&n;&t;&t; * signal was not sent because of sig_ignor or,&n;&t;&t; * possibly no queue memory OR will be sent but,&n;&t;&t; * we will not get a call back to restart it AND&n;&t;&t; * it should be restarted. &n;&t;&t; */
id|schedule_next_timer
c_func
(paren
id|timr
)paren
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/* &n;&t;&t; * all&squot;s well new signal queued&n;&t;&t; */
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&n; * This function gets called when a POSIX.1b interval timer expires.  It&n; * is used as a callback from the kernel internal timer.  The&n; * run_timer_list code ALWAYS calls with interrutps on.&n;&n; */
r_static
r_void
DECL|function|posix_timer_fn
id|posix_timer_fn
c_func
(paren
r_int
r_int
id|__data
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
op_assign
(paren
r_struct
id|k_itimer
op_star
)paren
id|__data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|timr-&gt;it_lock
comma
id|flags
)paren
suffix:semicolon
id|timer_notify_task
c_func
(paren
id|timr
)paren
suffix:semicolon
id|unlock_timer
c_func
(paren
id|timr
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * For some reason mips/mips64 define the SIGEV constants plus 128.  &n; * Here we define a mask to get rid of the common bits.&t; The &n; * optimizer should make this costless to all but mips.&n; */
macro_line|#if (ARCH == mips) || (ARCH == mips64)
DECL|macro|MIPS_SIGEV
mdefine_line|#define MIPS_SIGEV ~(SIGEV_NONE &amp; &bslash;&n;&t;&t;      SIGEV_SIGNAL &amp; &bslash;&n;&t;&t;      SIGEV_THREAD &amp;  &bslash;&n;&t;&t;      SIGEV_THREAD_ID)
macro_line|#else
DECL|macro|MIPS_SIGEV
mdefine_line|#define MIPS_SIGEV (int)-1
macro_line|#endif
r_static
r_inline
r_struct
id|task_struct
op_star
DECL|function|good_sigevent
id|good_sigevent
c_func
(paren
id|sigevent_t
op_star
id|event
)paren
(brace
r_struct
id|task_struct
op_star
id|rtn
op_assign
id|current
suffix:semicolon
r_if
c_cond
(paren
id|event-&gt;sigev_notify
op_amp
id|SIGEV_THREAD_ID
op_amp
id|MIPS_SIGEV
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|rtn
op_assign
id|find_task_by_pid
c_func
(paren
id|event-&gt;sigev_notify_thread_id
)paren
)paren
op_logical_or
id|rtn-&gt;tgid
op_ne
id|current-&gt;tgid
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|event-&gt;sigev_notify
op_amp
id|SIGEV_SIGNAL
op_amp
id|MIPS_SIGEV
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|event-&gt;sigev_signo
OG
id|SIGRTMAX
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|event-&gt;sigev_notify
op_amp
op_complement
(paren
id|SIGEV_SIGNAL
op_or
id|SIGEV_THREAD_ID
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|rtn
suffix:semicolon
)brace
r_void
DECL|function|register_posix_clock
id|register_posix_clock
c_func
(paren
r_int
id|clock_id
comma
r_struct
id|k_clock
op_star
id|new_clock
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|clock_id
op_ge
id|MAX_CLOCKS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;POSIX clock register failed for clock_id %d&bslash;n&quot;
comma
id|clock_id
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|posix_clocks
(braket
id|clock_id
)braket
op_assign
op_star
id|new_clock
suffix:semicolon
)brace
r_static
r_struct
id|k_itimer
op_star
DECL|function|alloc_posix_timer
id|alloc_posix_timer
c_func
(paren
r_void
)paren
(brace
r_struct
id|k_itimer
op_star
id|tmr
suffix:semicolon
id|tmr
op_assign
id|kmem_cache_alloc
c_func
(paren
id|posix_timers_cache
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|tmr
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|k_itimer
)paren
)paren
suffix:semicolon
r_return
(paren
id|tmr
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|release_posix_timer
id|release_posix_timer
c_func
(paren
r_struct
id|k_itimer
op_star
id|tmr
)paren
(brace
r_if
c_cond
(paren
id|tmr-&gt;it_id
op_ne
op_minus
l_int|1
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|idr_lock
)paren
suffix:semicolon
id|idr_remove
c_func
(paren
op_amp
id|posix_timers_id
comma
id|tmr-&gt;it_id
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|idr_lock
)paren
suffix:semicolon
)brace
id|kmem_cache_free
c_func
(paren
id|posix_timers_cache
comma
id|tmr
)paren
suffix:semicolon
)brace
multiline_comment|/* Create a POSIX.1b interval timer. */
id|asmlinkage
r_int
DECL|function|sys_timer_create
id|sys_timer_create
c_func
(paren
id|clockid_t
id|which_clock
comma
r_struct
id|sigevent
op_star
id|timer_event_spec
comma
id|timer_t
op_star
id|created_timer_id
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_struct
id|k_itimer
op_star
id|new_timer
op_assign
l_int|NULL
suffix:semicolon
id|timer_t
id|new_timer_id
suffix:semicolon
r_struct
id|task_struct
op_star
id|process
op_assign
l_int|0
suffix:semicolon
id|sigevent_t
id|event
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|which_clock
op_ge
id|MAX_CLOCKS
op_logical_or
op_logical_neg
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|res
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|new_timer
op_assign
id|alloc_posix_timer
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|new_timer
op_eq
l_int|NULL
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|new_timer-&gt;it_lock
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|idr_pre_get
c_func
(paren
op_amp
id|posix_timers_id
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
id|new_timer_id
op_assign
(paren
id|timer_t
)paren
op_minus
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|spin_lock_irq
c_func
(paren
op_amp
id|idr_lock
)paren
suffix:semicolon
id|new_timer_id
op_assign
(paren
id|timer_t
)paren
id|idr_get_new
c_func
(paren
op_amp
id|posix_timers_id
comma
(paren
r_void
op_star
)paren
id|new_timer
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|idr_lock
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|unlikely
(paren
id|new_timer_id
op_eq
op_minus
l_int|1
)paren
)paren
(brace
suffix:semicolon
)brace
id|new_timer-&gt;it_id
op_assign
id|new_timer_id
suffix:semicolon
multiline_comment|/*&n;&t; * return the timer_id now.  The next step is hard to &n;&t; * back out if there is an error.&n;&t; */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|created_timer_id
comma
op_amp
id|new_timer_id
comma
r_sizeof
(paren
id|new_timer_id
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|timer_event_spec
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|event
comma
id|timer_event_spec
comma
r_sizeof
(paren
id|event
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|process
op_assign
id|good_sigevent
c_func
(paren
op_amp
id|event
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&n;&t;&t;&t; * We may be setting up this process for another&n;&t;&t;&t; * thread.  It may be exitiing.  To catch this&n;&t;&t;&t; * case the we check the PF_EXITING flag.  If&n;&t;&t;&t; * the flag is not set, the task_lock will catch&n;&t;&t;&t; * him before it is too late (in exit_itimers).&n;&n;&t;&t;&t; * The exec case is a bit more invloved but easy&n;&t;&t;&t; * to code.  If the process is in our thread&n;&t;&t;&t; * group (and it must be or we would not allow&n;&t;&t;&t; * it here) and is doing an exec, it will cause&n;&t;&t;&t; * us to be killed.  In this case it will wait&n;&t;&t;&t; * for us to die which means we can finish this&n;&t;&t;&t; * linkage with our last gasp. I.e. no code :)&n;&n;&t;&t;&t; */
id|task_lock
c_func
(paren
id|process
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|process-&gt;flags
op_amp
id|PF_EXITING
)paren
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|new_timer-&gt;list
comma
op_amp
id|process-&gt;posix_timers
)paren
suffix:semicolon
id|task_unlock
c_func
(paren
id|process
)paren
suffix:semicolon
)brace
r_else
(brace
id|task_unlock
c_func
(paren
id|process
)paren
suffix:semicolon
id|process
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|process
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|new_timer-&gt;it_sigev_notify
op_assign
id|event.sigev_notify
suffix:semicolon
id|new_timer-&gt;it_sigev_signo
op_assign
id|event.sigev_signo
suffix:semicolon
id|new_timer-&gt;it_sigev_value
op_assign
id|event.sigev_value
suffix:semicolon
)brace
r_else
(brace
id|new_timer-&gt;it_sigev_notify
op_assign
id|SIGEV_SIGNAL
suffix:semicolon
id|new_timer-&gt;it_sigev_signo
op_assign
id|SIGALRM
suffix:semicolon
id|new_timer-&gt;it_sigev_value.sival_int
op_assign
id|new_timer-&gt;it_id
suffix:semicolon
id|process
op_assign
id|current
suffix:semicolon
id|task_lock
c_func
(paren
id|process
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|new_timer-&gt;list
comma
op_amp
id|process-&gt;posix_timers
)paren
suffix:semicolon
id|task_unlock
c_func
(paren
id|process
)paren
suffix:semicolon
)brace
id|new_timer-&gt;it_clock
op_assign
id|which_clock
suffix:semicolon
id|new_timer-&gt;it_incr
op_assign
l_int|0
suffix:semicolon
id|new_timer-&gt;it_overrun
op_assign
op_minus
l_int|1
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|new_timer-&gt;it_timer
)paren
suffix:semicolon
id|new_timer-&gt;it_timer.expires
op_assign
l_int|0
suffix:semicolon
id|new_timer-&gt;it_timer.data
op_assign
(paren
r_int
r_int
)paren
id|new_timer
suffix:semicolon
id|new_timer-&gt;it_timer.function
op_assign
id|posix_timer_fn
suffix:semicolon
id|set_timer_inactive
c_func
(paren
id|new_timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Once we set the process, it can be found so do it last...&n;&t; */
id|new_timer-&gt;it_process
op_assign
id|process
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|error
)paren
(brace
id|release_posix_timer
c_func
(paren
id|new_timer
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * good_timespec&n; *&n; * This function checks the elements of a timespec structure.&n; *&n; * Arguments:&n; * ts&t;     : Pointer to the timespec structure to check&n; *&n; * Return value: &n; * If a NULL pointer was passed in, or the tv_nsec field was less than 0&n; * or greater than NSEC_PER_SEC, or the tv_sec field was less than 0,&n; * this function returns 0. Otherwise it returns 1.&n;&n; */
r_static
r_int
DECL|function|good_timespec
id|good_timespec
c_func
(paren
r_const
r_struct
id|timespec
op_star
id|ts
)paren
(brace
r_if
c_cond
(paren
(paren
id|ts
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|ts-&gt;tv_sec
OL
l_int|0
)paren
op_logical_or
(paren
(paren
r_int
)paren
id|ts-&gt;tv_nsec
op_ge
id|NSEC_PER_SEC
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|unlock_timer
id|unlock_timer
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
comma
r_int
r_int
id|flags
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|timr-&gt;it_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&n; * Locking issues: We need to protect the result of the id look up until&n; * we get the timer locked down so it is not deleted under us.  The&n; * removal is done under the idr spinlock so we use that here to bridge&n; * the find to the timer lock.  To avoid a dead lock, the timer id MUST&n; * be release with out holding the timer lock.&n;&n; */
r_static
r_struct
id|k_itimer
op_star
DECL|function|lock_timer
id|lock_timer
c_func
(paren
id|timer_t
id|timer_id
comma
r_int
r_int
op_star
id|flags
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
suffix:semicolon
multiline_comment|/*&n;&t; * Watch out here.  We do a irqsave on the idr_lock and pass the &n;&t; * flags part over to the timer lock.  Must not let interrupts in&n;&t; * while we are moving the lock.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|idr_lock
comma
op_star
id|flags
)paren
suffix:semicolon
id|timr
op_assign
(paren
r_struct
id|k_itimer
op_star
)paren
id|idr_find
c_func
(paren
op_amp
id|posix_timers_id
comma
(paren
r_int
)paren
id|timer_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timr
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|timr-&gt;it_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|idr_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|timr-&gt;it_id
op_ne
id|timer_id
)paren
op_logical_or
op_logical_neg
(paren
id|timr-&gt;it_process
)paren
op_logical_or
id|timr-&gt;it_process-&gt;tgid
op_ne
id|current-&gt;tgid
)paren
(brace
id|unlock_timer
c_func
(paren
id|timr
comma
op_star
id|flags
)paren
suffix:semicolon
id|timr
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|idr_lock
comma
op_star
id|flags
)paren
suffix:semicolon
)brace
r_return
id|timr
suffix:semicolon
)brace
multiline_comment|/* &n;&n; * Get the time remaining on a POSIX.1b interval timer.  This function&n; * is ALWAYS called with spin_lock_irq on the timer, thus it must not&n; * mess with irq.&n;&n; * We have a couple of messes to clean up here.  First there is the case&n; * of a timer that has a requeue pending.  These timers should appear to&n; * be in the timer list with an expiry as if we were to requeue them&n; * now.&n;&n; * The second issue is the SIGEV_NONE timer which may be active but is&n; * not really ever put in the timer list (to save system resources).&n; * This timer may be expired, and if so, we will do it here.  Otherwise&n; * it is the same as a requeue pending timer WRT to what we should&n; * report.&n;&n; */
r_void
r_inline
DECL|function|do_timer_gettime
id|do_timer_gettime
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
comma
r_struct
id|itimerspec
op_star
id|cur_setting
)paren
(brace
r_int
id|sub_expires
suffix:semicolon
r_int
r_int
id|expires
suffix:semicolon
r_struct
id|now_struct
id|now
suffix:semicolon
r_do
(brace
id|expires
op_assign
id|timr-&gt;it_timer.expires
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
r_volatile
r_int
)paren
(paren
id|timr-&gt;it_timer.expires
)paren
op_ne
id|expires
)paren
suffix:semicolon
id|posix_get_now
c_func
(paren
op_amp
id|now
)paren
suffix:semicolon
r_if
c_cond
(paren
id|expires
op_logical_and
(paren
id|timr-&gt;it_sigev_notify
op_amp
id|SIGEV_NONE
)paren
op_logical_and
op_logical_neg
id|timr-&gt;it_incr
)paren
(brace
r_if
c_cond
(paren
id|posix_time_before
c_func
(paren
op_amp
id|timr-&gt;it_timer
comma
op_amp
id|now
)paren
)paren
(brace
id|timr-&gt;it_timer.expires
op_assign
id|expires
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|expires
)paren
(brace
r_if
c_cond
(paren
id|timr-&gt;it_requeue_pending
op_logical_or
(paren
id|timr-&gt;it_sigev_notify
op_amp
id|SIGEV_NONE
)paren
)paren
(brace
r_while
c_loop
(paren
id|posix_time_before
c_func
(paren
op_amp
id|timr-&gt;it_timer
comma
op_amp
id|now
)paren
)paren
(brace
id|posix_bump_timer
c_func
(paren
id|timr
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|timer_pending
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
)paren
(brace
id|sub_expires
op_assign
id|expires
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|expires
)paren
(brace
id|expires
op_sub_assign
id|now.jiffies
suffix:semicolon
)brace
)brace
id|jiffies_to_timespec
c_func
(paren
id|expires
comma
op_amp
id|cur_setting-&gt;it_value
)paren
suffix:semicolon
id|jiffies_to_timespec
c_func
(paren
id|timr-&gt;it_incr
comma
op_amp
id|cur_setting-&gt;it_interval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_setting-&gt;it_value.tv_sec
OL
l_int|0
)paren
(brace
id|cur_setting-&gt;it_value.tv_nsec
op_assign
l_int|1
suffix:semicolon
id|cur_setting-&gt;it_value.tv_sec
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Get the time remaining on a POSIX.1b interval timer. */
id|asmlinkage
r_int
DECL|function|sys_timer_gettime
id|sys_timer_gettime
c_func
(paren
id|timer_t
id|timer_id
comma
r_struct
id|itimerspec
op_star
id|setting
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
suffix:semicolon
r_struct
id|itimerspec
id|cur_setting
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|timr
op_assign
id|lock_timer
c_func
(paren
id|timer_id
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|p_timer_get
c_func
(paren
op_amp
id|posix_clocks
(braket
id|timr-&gt;it_clock
)braket
comma
id|timr
comma
op_amp
id|cur_setting
)paren
suffix:semicolon
id|unlock_timer
c_func
(paren
id|timr
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|setting
comma
op_amp
id|cur_setting
comma
r_sizeof
(paren
id|cur_setting
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&n; * Get the number of overruns of a POSIX.1b interval timer.  This is to&n; * be the overrun of the timer last delivered.  At the same time we are&n; * accumulating overruns on the next timer.  The overrun is frozen when&n; * the signal is delivered, either at the notify time (if the info block&n; * is not queued) or at the actual delivery time (as we are informed by&n; * the call back to do_schedule_next_timer().  So all we need to do is&n; * to pick up the frozen overrun.&n;&n; */
id|asmlinkage
r_int
DECL|function|sys_timer_getoverrun
id|sys_timer_getoverrun
c_func
(paren
id|timer_t
id|timer_id
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
suffix:semicolon
r_int
id|overrun
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|timr
op_assign
id|lock_timer
c_func
(paren
id|timer_id
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|overrun
op_assign
id|timr-&gt;it_overrun_last
suffix:semicolon
id|unlock_timer
c_func
(paren
id|timr
comma
id|flags
)paren
suffix:semicolon
r_return
id|overrun
suffix:semicolon
)brace
multiline_comment|/* Adjust for absolute time */
multiline_comment|/*&n; * If absolute time is given and it is not CLOCK_MONOTONIC, we need to&n; * adjust for the offset between the timer clock (CLOCK_MONOTONIC) and&n; * what ever clock he is using.&n; *&n; * If it is relative time, we need to add the current (CLOCK_MONOTONIC)&n; * time to it to get the proper time for the timer.&n; */
r_static
r_int
DECL|function|adjust_abs_time
id|adjust_abs_time
c_func
(paren
r_struct
id|k_clock
op_star
id|clock
comma
r_struct
id|timespec
op_star
id|tp
comma
r_int
id|abs
)paren
(brace
r_struct
id|timespec
id|now
suffix:semicolon
r_struct
id|timespec
id|oc
suffix:semicolon
id|do_posix_clock_monotonic_gettime
c_func
(paren
op_amp
id|now
)paren
suffix:semicolon
r_if
c_cond
(paren
id|abs
op_logical_and
(paren
id|posix_clocks
(braket
id|CLOCK_MONOTONIC
)braket
dot
id|clock_get
op_eq
id|clock-&gt;clock_get
)paren
)paren
(brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|abs
)paren
(brace
id|do_posix_gettime
c_func
(paren
id|clock
comma
op_amp
id|oc
)paren
suffix:semicolon
)brace
r_else
(brace
id|oc.tv_nsec
op_assign
id|oc.tv_sec
op_assign
l_int|0
suffix:semicolon
)brace
id|tp-&gt;tv_sec
op_add_assign
id|now.tv_sec
op_minus
id|oc.tv_sec
suffix:semicolon
id|tp-&gt;tv_nsec
op_add_assign
id|now.tv_nsec
op_minus
id|oc.tv_nsec
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Normalize...&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|tp-&gt;tv_nsec
op_minus
id|NSEC_PER_SEC
)paren
op_ge
l_int|0
)paren
(brace
id|tp-&gt;tv_nsec
op_sub_assign
id|NSEC_PER_SEC
suffix:semicolon
id|tp-&gt;tv_sec
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|tp-&gt;tv_nsec
)paren
OL
l_int|0
)paren
(brace
id|tp-&gt;tv_nsec
op_add_assign
id|NSEC_PER_SEC
suffix:semicolon
id|tp-&gt;tv_sec
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Check if the requested time is prior to now (if so set now) or&n;&t; * is more than the timer code can handle (if so we error out).&n;&t; * The (unsigned) catches the case of prior to &quot;now&quot; with the same&n;&t; * test.  Only on failure do we sort out what happened, and then&n;&t; * we use the (unsigned) to error out negative seconds.&n;&t; */
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|tp-&gt;tv_sec
op_minus
id|now.tv_sec
)paren
OG
(paren
id|MAX_JIFFY_OFFSET
op_div
id|HZ
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|tp-&gt;tv_sec
OL
id|now.tv_sec
)paren
(brace
id|tp-&gt;tv_sec
op_assign
id|now.tv_sec
suffix:semicolon
id|tp-&gt;tv_nsec
op_assign
id|now.tv_nsec
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// tp-&gt;tv_sec = now.tv_sec + (MAX_JIFFY_OFFSET / HZ);
multiline_comment|/*&n;&t;&t;&t; * This is a considered response, not exactly in&n;&t;&t;&t; * line with the standard (in fact it is silent on&n;&t;&t;&t; * possible overflows).  We assume such a large &n;&t;&t;&t; * value is ALMOST always a programming error and&n;&t;&t;&t; * try not to compound it by setting a really dumb&n;&t;&t;&t; * value.&n;&t;&t;&t; */
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Set a POSIX.1b interval timer. */
multiline_comment|/* timr-&gt;it_lock is taken. */
r_static
r_inline
r_int
DECL|function|do_timer_settime
id|do_timer_settime
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
comma
r_int
id|flags
comma
r_struct
id|itimerspec
op_star
id|new_setting
comma
r_struct
id|itimerspec
op_star
id|old_setting
)paren
(brace
r_struct
id|k_clock
op_star
id|clock
op_assign
op_amp
id|posix_clocks
(braket
id|timr-&gt;it_clock
)braket
suffix:semicolon
r_if
c_cond
(paren
id|old_setting
)paren
(brace
id|do_timer_gettime
c_func
(paren
id|timr
comma
id|old_setting
)paren
suffix:semicolon
)brace
multiline_comment|/* disable the timer */
id|timr-&gt;it_incr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t; * careful here.  If smp we could be in the &quot;fire&quot; routine which will&n;&t; * be spinning as we hold the lock.  But this is ONLY an SMP issue.&n;&t; */
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|timer_active
c_func
(paren
id|timr
)paren
op_logical_and
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * It can only be active if on an other cpu.  Since&n;&t;&t; * we have cleared the interval stuff above, it should&n;&t;&t; * clear once we release the spin lock.  Of course once&n;&t;&t; * we do that anything could happen, including the &n;&t;&t; * complete melt down of the timer.  So return with &n;&t;&t; * a &quot;retry&quot; exit status.&n;&t;&t; */
r_return
id|TIMER_RETRY
suffix:semicolon
)brace
id|set_timer_inactive
c_func
(paren
id|timr
)paren
suffix:semicolon
macro_line|#else
id|del_timer
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
suffix:semicolon
macro_line|#endif
id|timr-&gt;it_requeue_pending
op_assign
l_int|0
suffix:semicolon
id|timr-&gt;it_overrun_last
op_assign
l_int|0
suffix:semicolon
id|timr-&gt;it_overrun
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* &n;&t; *switch off the timer when it_value is zero &n;&t; */
r_if
c_cond
(paren
(paren
id|new_setting-&gt;it_value.tv_sec
op_eq
l_int|0
)paren
op_logical_and
(paren
id|new_setting-&gt;it_value.tv_nsec
op_eq
l_int|0
)paren
)paren
(brace
id|timr-&gt;it_timer.expires
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|TIMER_ABSTIME
)paren
op_logical_and
(paren
id|clock-&gt;clock_get
op_ne
id|do_posix_clock_monotonic_gettime
)paren
)paren
(brace
)brace
r_if
c_cond
(paren
id|adjust_abs_time
c_func
(paren
id|clock
comma
op_amp
id|new_setting-&gt;it_value
comma
id|flags
op_amp
id|TIMER_ABSTIME
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|tstotimer
c_func
(paren
id|new_setting
comma
id|timr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * For some reason the timer does not fire immediately if expires is&n;&t; * equal to jiffies, so the timer notify function is called directly.&n;&t; * We do not even queue SIGEV_NONE timers!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|timr-&gt;it_sigev_notify
op_amp
id|SIGEV_NONE
)paren
)paren
(brace
r_if
c_cond
(paren
id|timr-&gt;it_timer.expires
op_eq
id|jiffies
)paren
(brace
id|timer_notify_task
c_func
(paren
id|timr
)paren
suffix:semicolon
)brace
r_else
id|add_timer
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Set a POSIX.1b interval timer */
id|asmlinkage
r_int
DECL|function|sys_timer_settime
id|sys_timer_settime
c_func
(paren
id|timer_t
id|timer_id
comma
r_int
id|flags
comma
r_const
r_struct
id|itimerspec
op_star
id|new_setting
comma
r_struct
id|itimerspec
op_star
id|old_setting
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
suffix:semicolon
r_struct
id|itimerspec
id|new_spec
comma
id|old_spec
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|flag
suffix:semicolon
r_struct
id|itimerspec
op_star
id|rtn
op_assign
id|old_setting
ques
c_cond
op_amp
id|old_spec
suffix:colon
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|new_setting
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|new_spec
comma
id|new_setting
comma
r_sizeof
(paren
id|new_spec
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|good_timespec
c_func
(paren
op_amp
id|new_spec.it_interval
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|good_timespec
c_func
(paren
op_amp
id|new_spec.it_value
)paren
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|retry
suffix:colon
id|timr
op_assign
id|lock_timer
c_func
(paren
id|timer_id
comma
op_amp
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|posix_clocks
(braket
id|timr-&gt;it_clock
)braket
dot
id|timer_set
)paren
(brace
id|error
op_assign
id|do_timer_settime
c_func
(paren
id|timr
comma
id|flags
comma
op_amp
id|new_spec
comma
id|rtn
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|posix_clocks
(braket
id|timr-&gt;it_clock
)braket
dot
id|timer_set
c_func
(paren
id|timr
comma
id|flags
comma
op_amp
id|new_spec
comma
id|rtn
)paren
suffix:semicolon
)brace
id|unlock_timer
c_func
(paren
id|timr
comma
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|TIMER_RETRY
)paren
(brace
id|rtn
op_assign
l_int|NULL
suffix:semicolon
singleline_comment|// We already got the old time...
r_goto
id|retry
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_setting
op_logical_and
op_logical_neg
id|error
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|old_setting
comma
op_amp
id|old_spec
comma
r_sizeof
(paren
id|old_spec
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_return
id|error
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|do_timer_delete
id|do_timer_delete
c_func
(paren
r_struct
id|k_itimer
op_star
id|timer
)paren
(brace
id|timer-&gt;it_incr
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|timer_active
c_func
(paren
id|timer
)paren
op_logical_and
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|timer-&gt;it_timer
)paren
op_logical_and
op_logical_neg
id|timer-&gt;it_requeue_pending
)paren
(brace
multiline_comment|/*&n;&t;&t; * It can only be active if on an other cpu.  Since&n;&t;&t; * we have cleared the interval stuff above, it should&n;&t;&t; * clear once we release the spin lock.  Of course once&n;&t;&t; * we do that anything could happen, including the &n;&t;&t; * complete melt down of the timer.  So return with &n;&t;&t; * a &quot;retry&quot; exit status.&n;&t;&t; */
r_return
id|TIMER_RETRY
suffix:semicolon
)brace
macro_line|#else
id|del_timer
c_func
(paren
op_amp
id|timer-&gt;it_timer
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Delete a POSIX.1b interval timer. */
id|asmlinkage
r_int
DECL|function|sys_timer_delete
id|sys_timer_delete
c_func
(paren
id|timer_t
id|timer_id
)paren
(brace
r_struct
id|k_itimer
op_star
id|timer
suffix:semicolon
r_int
id|flags
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_int
id|error
suffix:semicolon
id|retry_delete
suffix:colon
macro_line|#endif
id|timer
op_assign
id|lock_timer
c_func
(paren
id|timer_id
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timer
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|error
op_assign
id|p_timer_del
c_func
(paren
op_amp
id|posix_clocks
(braket
id|timer-&gt;it_clock
)braket
comma
id|timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|TIMER_RETRY
)paren
(brace
id|unlock_timer
c_func
(paren
id|timer
comma
id|flags
)paren
suffix:semicolon
r_goto
id|retry_delete
suffix:semicolon
)brace
macro_line|#else
id|p_timer_del
c_func
(paren
op_amp
id|posix_clocks
(braket
id|timer-&gt;it_clock
)braket
comma
id|timer
)paren
suffix:semicolon
macro_line|#endif
id|task_lock
c_func
(paren
id|timer-&gt;it_process
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|timer-&gt;list
)paren
suffix:semicolon
id|task_unlock
c_func
(paren
id|timer-&gt;it_process
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This keeps any tasks waiting on the spin lock from thinking&n;&t; * they got something (see the lock code above).&n;&t; */
id|timer-&gt;it_process
op_assign
l_int|NULL
suffix:semicolon
id|unlock_timer
c_func
(paren
id|timer
comma
id|flags
)paren
suffix:semicolon
id|release_posix_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * return  timer owned by the process, used by exit_itimers&n; */
r_static
r_inline
r_void
DECL|function|itimer_delete
id|itimer_delete
c_func
(paren
r_struct
id|k_itimer
op_star
id|timer
)paren
(brace
r_if
c_cond
(paren
id|sys_timer_delete
c_func
(paren
id|timer-&gt;it_id
)paren
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is exported to exit and exec&n; */
r_void
DECL|function|exit_itimers
id|exit_itimers
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_struct
id|k_itimer
op_star
id|tmr
suffix:semicolon
id|task_lock
c_func
(paren
id|tsk
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|tsk-&gt;posix_timers
)paren
)paren
(brace
id|tmr
op_assign
id|list_entry
c_func
(paren
id|tsk-&gt;posix_timers.next
comma
r_struct
id|k_itimer
comma
id|list
)paren
suffix:semicolon
id|task_unlock
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|itimer_delete
c_func
(paren
id|tmr
)paren
suffix:semicolon
id|task_lock
c_func
(paren
id|tsk
)paren
suffix:semicolon
)brace
id|task_unlock
c_func
(paren
id|tsk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * And now for the &quot;clock&quot; calls&n;&n; * These functions are called both from timer functions (with the timer&n; * spin_lock_irq() held and from clock calls with no locking.&t;They must&n; * use the save flags versions of locks.&n; */
r_static
r_int
DECL|function|do_posix_gettime
id|do_posix_gettime
c_func
(paren
r_struct
id|k_clock
op_star
id|clock
comma
r_struct
id|timespec
op_star
id|tp
)paren
(brace
r_if
c_cond
(paren
id|clock-&gt;clock_get
)paren
(brace
r_return
id|clock
op_member_access_from_pointer
id|clock_get
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
id|do_gettimeofday
c_func
(paren
(paren
r_struct
id|timeval
op_star
)paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;tv_nsec
op_mul_assign
id|NSEC_PER_USEC
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We do ticks here to avoid the irq lock ( they take sooo long).&n; * The seqlock is great here.  Since we a reader, we don&squot;t really care&n; * if we are interrupted since we don&squot;t take lock that will stall us or &n; * any other cpu. Voila, no irq lock is needed.&n;&n; * Note also that the while loop assures that the sub_jiff_offset&n; * will be less than a jiffie, thus no need to normalize the result.&n; * Well, not really, if called with ints off :(&n; */
r_int
DECL|function|do_posix_clock_monotonic_gettime
id|do_posix_clock_monotonic_gettime
c_func
(paren
r_struct
id|timespec
op_star
id|tp
)paren
(brace
r_int
id|sub_sec
suffix:semicolon
id|u64
id|jiffies_64_f
suffix:semicolon
macro_line|#if (BITS_PER_LONG &gt; 32)
id|jiffies_64_f
op_assign
id|jiffies_64
suffix:semicolon
macro_line|#else
r_int
r_int
id|seq
suffix:semicolon
r_do
(brace
id|seq
op_assign
id|read_seqbegin
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
id|jiffies_64_f
op_assign
id|jiffies_64
suffix:semicolon
)brace
r_while
c_loop
(paren
id|read_seqretry
c_func
(paren
op_amp
id|xtime_lock
comma
id|seq
)paren
)paren
(brace
suffix:semicolon
)brace
macro_line|#endif
id|tp-&gt;tv_sec
op_assign
id|div_long_long_rem
c_func
(paren
id|jiffies_64_f
comma
id|HZ
comma
op_amp
id|sub_sec
)paren
suffix:semicolon
id|tp-&gt;tv_nsec
op_assign
id|sub_sec
op_star
(paren
id|NSEC_PER_SEC
op_div
id|HZ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|do_posix_clock_monotonic_settime
id|do_posix_clock_monotonic_settime
c_func
(paren
r_struct
id|timespec
op_star
id|tp
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_clock_settime
id|sys_clock_settime
c_func
(paren
id|clockid_t
id|which_clock
comma
r_const
r_struct
id|timespec
op_star
id|tp
)paren
(brace
r_struct
id|timespec
id|new_tp
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|which_clock
op_ge
id|MAX_CLOCKS
op_logical_or
op_logical_neg
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|res
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|new_tp
comma
id|tp
comma
r_sizeof
(paren
op_star
id|tp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|clock_set
)paren
(brace
r_return
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|clock_set
c_func
(paren
op_amp
id|new_tp
)paren
suffix:semicolon
)brace
id|new_tp.tv_nsec
op_div_assign
id|NSEC_PER_USEC
suffix:semicolon
r_return
id|do_sys_settimeofday
c_func
(paren
(paren
r_struct
id|timeval
op_star
)paren
op_amp
id|new_tp
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_clock_gettime
id|sys_clock_gettime
c_func
(paren
id|clockid_t
id|which_clock
comma
r_struct
id|timespec
op_star
id|tp
)paren
(brace
r_struct
id|timespec
id|rtn_tp
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|which_clock
op_ge
id|MAX_CLOCKS
op_logical_or
op_logical_neg
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|res
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|error
op_assign
id|do_posix_gettime
c_func
(paren
op_amp
id|posix_clocks
(braket
id|which_clock
)braket
comma
op_amp
id|rtn_tp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|tp
comma
op_amp
id|rtn_tp
comma
r_sizeof
(paren
id|rtn_tp
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_return
id|error
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_clock_getres
id|sys_clock_getres
c_func
(paren
id|clockid_t
id|which_clock
comma
r_struct
id|timespec
op_star
id|tp
)paren
(brace
r_struct
id|timespec
id|rtn_tp
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|which_clock
op_ge
id|MAX_CLOCKS
op_logical_or
op_logical_neg
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|res
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|rtn_tp.tv_sec
op_assign
l_int|0
suffix:semicolon
id|rtn_tp.tv_nsec
op_assign
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|res
suffix:semicolon
r_if
c_cond
(paren
id|tp
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|tp
comma
op_amp
id|rtn_tp
comma
r_sizeof
(paren
id|rtn_tp
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|nanosleep_wake_up
id|nanosleep_wake_up
c_func
(paren
r_int
r_int
id|__data
)paren
(brace
r_struct
id|task_struct
op_star
id|p
op_assign
(paren
r_struct
id|task_struct
op_star
)paren
id|__data
suffix:semicolon
id|wake_up_process
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The standard says that an absolute nanosleep call MUST wake up at&n; * the requested time in spite of clock settings.  Here is what we do:&n; * For each nanosleep call that needs it (only absolute and not on &n; * CLOCK_MONOTONIC* (as it can not be set)) we thread a little structure&n; * into the &quot;nanosleep_abs_list&quot;.  All we need is the task_struct pointer.&n; * When ever the clock is set we just wake up all those tasks.&t; The rest&n; * is done by the while loop in clock_nanosleep().&n;&n; * On locking, clock_was_set() is called from update_wall_clock which &n; * holds (or has held for it) a write_lock_irq( xtime_lock) and is &n; * called from the timer bh code.  Thus we need the irq save locks.&n; */
DECL|variable|nanosleep_abs_list_lock
id|spinlock_t
id|nanosleep_abs_list_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|nanosleep_abs_list
r_struct
id|list_head
id|nanosleep_abs_list
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|nanosleep_abs_list
)paren
suffix:semicolon
DECL|struct|abs_struct
r_struct
id|abs_struct
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|t
r_struct
id|task_struct
op_star
id|t
suffix:semicolon
)brace
suffix:semicolon
r_void
DECL|function|clock_was_set
id|clock_was_set
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|nanosleep_abs_list_lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|nanosleep_abs_list
)paren
(brace
id|wake_up_process
c_func
(paren
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|abs_struct
comma
id|list
)paren
op_member_access_from_pointer
id|t
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|nanosleep_abs_list_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_int
id|clock_nanosleep_restart
c_func
(paren
r_struct
id|restart_block
op_star
id|restart_block
)paren
suffix:semicolon
r_extern
r_int
id|do_clock_nanosleep
c_func
(paren
id|clockid_t
id|which_clock
comma
r_int
id|flags
comma
r_struct
id|timespec
op_star
id|t
)paren
suffix:semicolon
macro_line|#ifdef FOLD_NANO_SLEEP_INTO_CLOCK_NANO_SLEEP
id|asmlinkage
r_int
DECL|function|sys_nanosleep
id|sys_nanosleep
c_func
(paren
r_struct
id|timespec
op_star
id|rqtp
comma
r_struct
id|timespec
op_star
id|rmtp
)paren
(brace
r_struct
id|timespec
id|t
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|t
comma
id|rqtp
comma
r_sizeof
(paren
id|t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|t.tv_nsec
op_ge
id|NSEC_PER_SEC
op_logical_or
id|t.tv_sec
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ret
op_assign
id|do_clock_nanosleep
c_func
(paren
id|CLOCK_REALTIME
comma
l_int|0
comma
op_amp
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|ERESTART_RESTARTBLOCK
op_logical_and
id|rmtp
op_logical_and
id|copy_to_user
c_func
(paren
id|rmtp
comma
op_amp
id|t
comma
r_sizeof
(paren
id|t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;
singleline_comment|// ! FOLD_NANO_SLEEP_INTO_CLOCK_NANO_SLEEP
id|asmlinkage
r_int
DECL|function|sys_clock_nanosleep
id|sys_clock_nanosleep
c_func
(paren
id|clockid_t
id|which_clock
comma
r_int
id|flags
comma
r_const
r_struct
id|timespec
op_star
id|rqtp
comma
r_struct
id|timespec
op_star
id|rmtp
)paren
(brace
r_struct
id|timespec
id|t
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|which_clock
op_ge
id|MAX_CLOCKS
op_logical_or
op_logical_neg
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|res
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|t
comma
id|rqtp
comma
r_sizeof
(paren
r_struct
id|timespec
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|t.tv_nsec
op_ge
id|NSEC_PER_SEC
op_logical_or
id|t.tv_sec
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ret
op_assign
id|do_clock_nanosleep
c_func
(paren
id|which_clock
comma
id|flags
comma
op_amp
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_eq
op_minus
id|ERESTART_RESTARTBLOCK
)paren
op_logical_and
id|rmtp
op_logical_and
id|copy_to_user
c_func
(paren
id|rmtp
comma
op_amp
id|t
comma
r_sizeof
(paren
id|t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_int
DECL|function|do_clock_nanosleep
id|do_clock_nanosleep
c_func
(paren
id|clockid_t
id|which_clock
comma
r_int
id|flags
comma
r_struct
id|timespec
op_star
id|tsave
)paren
(brace
r_struct
id|timespec
id|t
suffix:semicolon
r_struct
id|timer_list
id|new_timer
suffix:semicolon
r_struct
id|abs_struct
id|abs_struct
op_assign
(brace
id|list
suffix:colon
(brace
id|next
suffix:colon
l_int|0
)brace
)brace
suffix:semicolon
r_int
id|abs
suffix:semicolon
r_int
id|rtn
op_assign
l_int|0
suffix:semicolon
r_int
id|active
suffix:semicolon
r_struct
id|restart_block
op_star
id|restart_block
op_assign
op_amp
id|current_thread_info
c_func
(paren
)paren
op_member_access_from_pointer
id|restart_block
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|new_timer
)paren
suffix:semicolon
id|new_timer.expires
op_assign
l_int|0
suffix:semicolon
id|new_timer.data
op_assign
(paren
r_int
r_int
)paren
id|current
suffix:semicolon
id|new_timer.function
op_assign
id|nanosleep_wake_up
suffix:semicolon
id|abs
op_assign
id|flags
op_amp
id|TIMER_ABSTIME
suffix:semicolon
r_if
c_cond
(paren
id|restart_block-&gt;fn
op_eq
id|clock_nanosleep_restart
)paren
(brace
multiline_comment|/*&n;&t;&t; * Interrupted by a non-delivered signal, pick up remaining&n;&t;&t; * time and continue.&n;&t;&t; */
id|restart_block-&gt;fn
op_assign
id|do_no_restart_syscall
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|restart_block-&gt;arg2
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
id|new_timer.expires
op_assign
id|restart_block-&gt;arg2
suffix:semicolon
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|new_timer.expires
comma
id|jiffies
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|abs
op_logical_and
(paren
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|clock_get
op_ne
id|posix_clocks
(braket
id|CLOCK_MONOTONIC
)braket
dot
id|clock_get
)paren
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|nanosleep_abs_list_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|abs_struct.list
comma
op_amp
id|nanosleep_abs_list
)paren
suffix:semicolon
id|abs_struct.t
op_assign
id|current
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|nanosleep_abs_list_lock
)paren
suffix:semicolon
)brace
r_do
(brace
id|t
op_assign
op_star
id|tsave
suffix:semicolon
r_if
c_cond
(paren
(paren
id|abs
op_logical_or
op_logical_neg
id|new_timer.expires
)paren
op_logical_and
op_logical_neg
(paren
id|rtn
op_assign
id|adjust_abs_time
c_func
(paren
op_amp
id|posix_clocks
(braket
id|which_clock
)braket
comma
op_amp
id|t
comma
id|abs
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * On error, we don&squot;t set up the timer so&n;&t;&t;&t; * we don&squot;t arm the timer so&n;&t;&t;&t; * del_timer_sync() will return 0, thus&n;&t;&t;&t; * active is zero... and so it goes.&n;&t;&t;&t; */
id|tstojiffie
c_func
(paren
op_amp
id|t
comma
id|posix_clocks
(braket
id|which_clock
)braket
dot
id|res
comma
op_amp
id|new_timer.expires
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_timer.expires
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|new_timer
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|active
op_assign
id|del_timer_sync
c_func
(paren
op_amp
id|new_timer
)paren
)paren
op_logical_and
op_logical_neg
id|test_thread_flag
c_func
(paren
id|TIF_SIGPENDING
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|abs_struct.list.next
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|nanosleep_abs_list_lock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|abs_struct.list
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|nanosleep_abs_list_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|active
)paren
(brace
r_int
r_int
id|jiffies_f
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Always restart abs calls from scratch to pick up any&n;&t;&t; * clock shifting that happened while we are away.&n;&t;&t; */
r_if
c_cond
(paren
id|abs
)paren
r_return
op_minus
id|ERESTARTNOHAND
suffix:semicolon
id|jiffies_to_timespec
c_func
(paren
id|new_timer.expires
op_minus
id|jiffies_f
comma
id|tsave
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tsave-&gt;tv_nsec
OL
l_int|0
)paren
(brace
id|tsave-&gt;tv_nsec
op_add_assign
id|NSEC_PER_SEC
suffix:semicolon
id|tsave-&gt;tv_sec
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tsave-&gt;tv_sec
OL
l_int|0
)paren
(brace
id|tsave-&gt;tv_sec
op_assign
l_int|0
suffix:semicolon
id|tsave-&gt;tv_nsec
op_assign
l_int|1
suffix:semicolon
)brace
id|restart_block-&gt;fn
op_assign
id|clock_nanosleep_restart
suffix:semicolon
id|restart_block-&gt;arg0
op_assign
id|which_clock
suffix:semicolon
id|restart_block-&gt;arg1
op_assign
(paren
r_int
r_int
)paren
id|tsave
suffix:semicolon
id|restart_block-&gt;arg2
op_assign
id|new_timer.expires
suffix:semicolon
r_return
op_minus
id|ERESTART_RESTARTBLOCK
suffix:semicolon
)brace
r_return
id|rtn
suffix:semicolon
)brace
multiline_comment|/*&n; * This will restart either clock_nanosleep or clock_nanosleep&n; */
r_int
DECL|function|clock_nanosleep_restart
id|clock_nanosleep_restart
c_func
(paren
r_struct
id|restart_block
op_star
id|restart_block
)paren
(brace
r_struct
id|timespec
id|t
suffix:semicolon
r_int
id|ret
op_assign
id|do_clock_nanosleep
c_func
(paren
id|restart_block-&gt;arg0
comma
l_int|0
comma
op_amp
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_eq
op_minus
id|ERESTART_RESTARTBLOCK
)paren
op_logical_and
id|restart_block-&gt;arg1
op_logical_and
id|copy_to_user
c_func
(paren
(paren
r_struct
id|timespec
op_star
)paren
(paren
id|restart_block-&gt;arg1
)paren
comma
op_amp
id|t
comma
r_sizeof
(paren
id|t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
eof
