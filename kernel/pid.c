multiline_comment|/*&n; * Generic pidhash and scalable, time-bounded PID allocator&n; *&n; * (C) 2002 William Irwin, IBM&n; * (C) 2002 Ingo Molnar, Red Hat&n; *&n; * pid-structures are backing objects for tasks sharing a given ID to chain&n; * against. There is very little to them aside from hashing them and&n; * parking tasks using given ID&squot;s on a list.&n; *&n; * The hash is always changed with the tasklist_lock write-acquired,&n; * and the hash is only accessed with the tasklist_lock at least&n; * read-acquired, so there&squot;s no additional SMP locking needed here.&n; *&n; * We have a list of bitmap pages, which bitmaps represent the PID space.&n; * Allocating and freeing PIDs is completely lockless. The worst-case&n; * allocation scenario when all but one out of 1 million PIDs possible are&n; * allocated already: the scanning of 32 list entries and at most PAGE_SIZE&n; * bytes. The typical fastpath is a single successful setbit. Freeing is O(1).&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
DECL|macro|PIDHASH_SIZE
mdefine_line|#define PIDHASH_SIZE 4096
DECL|macro|pid_hashfn
mdefine_line|#define pid_hashfn(nr) ((nr &gt;&gt; 8) ^ nr) &amp; (PIDHASH_SIZE - 1)
DECL|variable|pid_hash
r_static
r_struct
id|list_head
id|pid_hash
(braket
id|PIDTYPE_MAX
)braket
(braket
id|PIDHASH_SIZE
)braket
suffix:semicolon
DECL|variable|pid_max
r_int
id|pid_max
op_assign
id|PID_MAX_DEFAULT
suffix:semicolon
DECL|variable|last_pid
r_int
id|last_pid
suffix:semicolon
DECL|macro|RESERVED_PIDS
mdefine_line|#define RESERVED_PIDS&t;&t;300
DECL|macro|PIDMAP_ENTRIES
mdefine_line|#define PIDMAP_ENTRIES&t;&t;(PID_MAX_LIMIT/PAGE_SIZE/8)
DECL|macro|BITS_PER_PAGE
mdefine_line|#define BITS_PER_PAGE&t;&t;(PAGE_SIZE*8)
DECL|macro|BITS_PER_PAGE_MASK
mdefine_line|#define BITS_PER_PAGE_MASK&t;(BITS_PER_PAGE-1)
multiline_comment|/*&n; * PID-map pages start out as NULL, they get allocated upon&n; * first use and are never deallocated. This way a low pid_max&n; * value does not cause lots of bitmaps to be allocated, but&n; * the scheme scales to up to 4 million PIDs, runtime.&n; */
DECL|struct|pidmap
r_typedef
r_struct
id|pidmap
(brace
DECL|member|nr_free
id|atomic_t
id|nr_free
suffix:semicolon
DECL|member|page
r_void
op_star
id|page
suffix:semicolon
DECL|typedef|pidmap_t
)brace
id|pidmap_t
suffix:semicolon
DECL|variable|pidmap_array
r_static
id|pidmap_t
id|pidmap_array
(braket
id|PIDMAP_ENTRIES
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|PIDMAP_ENTRIES
op_minus
l_int|1
)braket
op_assign
(brace
id|ATOMIC_INIT
c_func
(paren
id|BITS_PER_PAGE
)paren
comma
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|variable|map_limit
r_static
id|pidmap_t
op_star
id|map_limit
op_assign
id|pidmap_array
op_plus
id|PIDMAP_ENTRIES
suffix:semicolon
DECL|function|free_pidmap
r_inline
r_void
id|free_pidmap
c_func
(paren
r_int
id|pid
)paren
(brace
id|pidmap_t
op_star
id|map
op_assign
id|pidmap_array
op_plus
id|pid
op_div
id|BITS_PER_PAGE
suffix:semicolon
r_int
id|offset
op_assign
id|pid
op_amp
id|BITS_PER_PAGE_MASK
suffix:semicolon
id|clear_bit
c_func
(paren
id|offset
comma
id|map-&gt;page
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|map-&gt;nr_free
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Here we search for the next map that has free bits left.&n; * Normally the next map has free PIDs.&n; */
DECL|function|next_free_map
r_static
r_inline
id|pidmap_t
op_star
id|next_free_map
c_func
(paren
id|pidmap_t
op_star
id|map
comma
r_int
op_star
id|max_steps
)paren
(brace
r_while
c_loop
(paren
op_decrement
op_star
id|max_steps
)paren
(brace
r_if
c_cond
(paren
op_increment
id|map
op_eq
id|map_limit
)paren
id|map
op_assign
id|pidmap_array
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|map-&gt;page
)paren
)paren
(brace
r_int
r_int
id|page
op_assign
id|get_zeroed_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Free the page if someone raced with us&n;&t;&t;&t; * installing it:&n;&t;&t;&t; */
r_if
c_cond
(paren
id|cmpxchg
c_func
(paren
op_amp
id|map-&gt;page
comma
l_int|NULL
comma
(paren
r_void
op_star
)paren
id|page
)paren
)paren
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|map-&gt;page
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|map-&gt;nr_free
)paren
)paren
r_return
id|map
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|alloc_pidmap
r_int
id|alloc_pidmap
c_func
(paren
r_void
)paren
(brace
r_int
id|pid
comma
id|offset
comma
id|max_steps
op_assign
id|PIDMAP_ENTRIES
op_plus
l_int|1
suffix:semicolon
id|pidmap_t
op_star
id|map
suffix:semicolon
id|pid
op_assign
id|last_pid
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pid
op_ge
id|pid_max
)paren
id|pid
op_assign
id|RESERVED_PIDS
suffix:semicolon
id|offset
op_assign
id|pid
op_amp
id|BITS_PER_PAGE_MASK
suffix:semicolon
id|map
op_assign
id|pidmap_array
op_plus
id|pid
op_div
id|BITS_PER_PAGE
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|map-&gt;page
op_logical_and
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|offset
comma
id|map-&gt;page
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * There is a small window for last_pid updates to race,&n;&t;&t; * but in that case the next allocation will go into the&n;&t;&t; * slowpath and that fixes things up.&n;&t;&t; */
id|return_pid
suffix:colon
id|atomic_dec
c_func
(paren
op_amp
id|map-&gt;nr_free
)paren
suffix:semicolon
id|last_pid
op_assign
id|pid
suffix:semicolon
r_return
id|pid
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|offset
op_logical_or
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|map-&gt;nr_free
)paren
)paren
(brace
id|next_map
suffix:colon
id|map
op_assign
id|next_free_map
c_func
(paren
id|map
comma
op_amp
id|max_steps
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|map
)paren
r_goto
id|failure
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Find the next zero bit:&n;&t; */
id|scan_more
suffix:colon
id|offset
op_assign
id|find_next_zero_bit
c_func
(paren
id|map-&gt;page
comma
id|BITS_PER_PAGE
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
id|BITS_PER_PAGE
)paren
r_goto
id|next_map
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|offset
comma
id|map-&gt;page
)paren
)paren
r_goto
id|scan_more
suffix:semicolon
multiline_comment|/* we got the PID: */
id|pid
op_assign
(paren
id|map
op_minus
id|pidmap_array
)paren
op_star
id|BITS_PER_PAGE
op_plus
id|offset
suffix:semicolon
r_goto
id|return_pid
suffix:semicolon
id|failure
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|find_pid
r_inline
r_struct
id|pid
op_star
id|find_pid
c_func
(paren
r_enum
id|pid_type
id|type
comma
r_int
id|nr
)paren
(brace
r_struct
id|list_head
op_star
id|elem
comma
op_star
id|bucket
op_assign
op_amp
id|pid_hash
(braket
id|type
)braket
(braket
id|pid_hashfn
c_func
(paren
id|nr
)paren
)braket
suffix:semicolon
r_struct
id|pid
op_star
id|pid
suffix:semicolon
id|__list_for_each
c_func
(paren
id|elem
comma
id|bucket
)paren
(brace
id|pid
op_assign
id|list_entry
c_func
(paren
id|elem
comma
r_struct
id|pid
comma
id|hash_chain
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pid-&gt;nr
op_eq
id|nr
)paren
r_return
id|pid
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|link_pid
r_void
id|link_pid
c_func
(paren
id|task_t
op_star
id|task
comma
r_struct
id|pid_link
op_star
id|link
comma
r_struct
id|pid
op_star
id|pid
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|pid-&gt;count
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|link-&gt;pid_chain
comma
op_amp
id|pid-&gt;task_list
)paren
suffix:semicolon
id|link-&gt;pidptr
op_assign
id|pid
suffix:semicolon
)brace
DECL|function|attach_pid
r_int
id|attach_pid
c_func
(paren
id|task_t
op_star
id|task
comma
r_enum
id|pid_type
id|type
comma
r_int
id|nr
)paren
(brace
r_struct
id|pid
op_star
id|pid
op_assign
id|find_pid
c_func
(paren
id|type
comma
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pid
)paren
id|atomic_inc
c_func
(paren
op_amp
id|pid-&gt;count
)paren
suffix:semicolon
r_else
(brace
id|pid
op_assign
op_amp
id|task-&gt;pids
(braket
id|type
)braket
dot
id|pid
suffix:semicolon
id|pid-&gt;nr
op_assign
id|nr
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|pid-&gt;count
comma
l_int|1
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|pid-&gt;task_list
)paren
suffix:semicolon
id|pid-&gt;task
op_assign
id|task
suffix:semicolon
id|get_task_struct
c_func
(paren
id|task
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|pid-&gt;hash_chain
comma
op_amp
id|pid_hash
(braket
id|type
)braket
(braket
id|pid_hashfn
c_func
(paren
id|nr
)paren
)braket
)paren
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
op_amp
id|task-&gt;pids
(braket
id|type
)braket
dot
id|pid_chain
comma
op_amp
id|pid-&gt;task_list
)paren
suffix:semicolon
id|task-&gt;pids
(braket
id|type
)braket
dot
id|pidptr
op_assign
id|pid
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__detach_pid
r_static
r_inline
r_int
id|__detach_pid
c_func
(paren
id|task_t
op_star
id|task
comma
r_enum
id|pid_type
id|type
)paren
(brace
r_struct
id|pid_link
op_star
id|link
op_assign
id|task-&gt;pids
op_plus
id|type
suffix:semicolon
r_struct
id|pid
op_star
id|pid
op_assign
id|link-&gt;pidptr
suffix:semicolon
r_int
id|nr
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|link-&gt;pid_chain
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_dec_and_test
c_func
(paren
op_amp
id|pid-&gt;count
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|nr
op_assign
id|pid-&gt;nr
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|pid-&gt;hash_chain
)paren
suffix:semicolon
id|put_task_struct
c_func
(paren
id|pid-&gt;task
)paren
suffix:semicolon
r_return
id|nr
suffix:semicolon
)brace
DECL|function|_detach_pid
r_static
r_void
id|_detach_pid
c_func
(paren
id|task_t
op_star
id|task
comma
r_enum
id|pid_type
id|type
)paren
(brace
id|__detach_pid
c_func
(paren
id|task
comma
id|type
)paren
suffix:semicolon
)brace
DECL|function|detach_pid
r_void
id|detach_pid
c_func
(paren
id|task_t
op_star
id|task
comma
r_enum
id|pid_type
id|type
)paren
(brace
r_int
id|nr
op_assign
id|__detach_pid
c_func
(paren
id|task
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|type
op_assign
l_int|0
suffix:semicolon
id|type
OL
id|PIDTYPE_MAX
suffix:semicolon
op_increment
id|type
)paren
r_if
c_cond
(paren
id|find_pid
c_func
(paren
id|type
comma
id|nr
)paren
)paren
r_return
suffix:semicolon
id|free_pidmap
c_func
(paren
id|nr
)paren
suffix:semicolon
)brace
DECL|function|find_task_by_pid
id|task_t
op_star
id|find_task_by_pid
c_func
(paren
r_int
id|nr
)paren
(brace
r_struct
id|pid
op_star
id|pid
op_assign
id|find_pid
c_func
(paren
id|PIDTYPE_PID
comma
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pid
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|pid_task
c_func
(paren
id|pid-&gt;task_list.next
comma
id|PIDTYPE_PID
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function switches the PIDs if a non-leader thread calls&n; * sys_execve() - this must be done without releasing the PID.&n; * (which a detach_pid() would eventually do.)&n; */
DECL|function|switch_exec_pids
r_void
id|switch_exec_pids
c_func
(paren
id|task_t
op_star
id|leader
comma
id|task_t
op_star
id|thread
)paren
(brace
id|_detach_pid
c_func
(paren
id|leader
comma
id|PIDTYPE_PID
)paren
suffix:semicolon
id|_detach_pid
c_func
(paren
id|leader
comma
id|PIDTYPE_TGID
)paren
suffix:semicolon
id|_detach_pid
c_func
(paren
id|leader
comma
id|PIDTYPE_PGID
)paren
suffix:semicolon
id|_detach_pid
c_func
(paren
id|leader
comma
id|PIDTYPE_SID
)paren
suffix:semicolon
id|_detach_pid
c_func
(paren
id|thread
comma
id|PIDTYPE_PID
)paren
suffix:semicolon
id|_detach_pid
c_func
(paren
id|thread
comma
id|PIDTYPE_TGID
)paren
suffix:semicolon
id|leader-&gt;pid
op_assign
id|leader-&gt;tgid
op_assign
id|thread-&gt;pid
suffix:semicolon
id|thread-&gt;pid
op_assign
id|thread-&gt;tgid
suffix:semicolon
id|attach_pid
c_func
(paren
id|thread
comma
id|PIDTYPE_PID
comma
id|thread-&gt;pid
)paren
suffix:semicolon
id|attach_pid
c_func
(paren
id|thread
comma
id|PIDTYPE_TGID
comma
id|thread-&gt;tgid
)paren
suffix:semicolon
id|attach_pid
c_func
(paren
id|thread
comma
id|PIDTYPE_PGID
comma
id|thread-&gt;pgrp
)paren
suffix:semicolon
id|attach_pid
c_func
(paren
id|thread
comma
id|PIDTYPE_SID
comma
id|thread-&gt;session
)paren
suffix:semicolon
id|attach_pid
c_func
(paren
id|leader
comma
id|PIDTYPE_PID
comma
id|leader-&gt;pid
)paren
suffix:semicolon
id|attach_pid
c_func
(paren
id|leader
comma
id|PIDTYPE_TGID
comma
id|leader-&gt;tgid
)paren
suffix:semicolon
id|attach_pid
c_func
(paren
id|leader
comma
id|PIDTYPE_PGID
comma
id|leader-&gt;pgrp
)paren
suffix:semicolon
id|attach_pid
c_func
(paren
id|leader
comma
id|PIDTYPE_SID
comma
id|leader-&gt;session
)paren
suffix:semicolon
)brace
DECL|function|pidhash_init
r_void
id|__init
id|pidhash_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate PID 0, and hash it via all PID types:&n;&t; */
id|pidmap_array-&gt;page
op_assign
(paren
r_void
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
id|set_bit
c_func
(paren
l_int|0
comma
id|pidmap_array-&gt;page
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|pidmap_array-&gt;nr_free
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PIDTYPE_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|PIDHASH_SIZE
suffix:semicolon
id|j
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|pid_hash
(braket
id|i
)braket
(braket
id|j
)braket
)paren
suffix:semicolon
id|attach_pid
c_func
(paren
id|current
comma
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
eof
