multiline_comment|/*&n; * Generic pidhash and scalable, time-bounded PID allocator&n; *&n; * (C) 2002-2003 William Irwin, IBM&n; * (C) 2004 William Irwin, Oracle&n; * (C) 2002-2004 Ingo Molnar, Red Hat&n; *&n; * pid-structures are backing objects for tasks sharing a given ID to chain&n; * against. There is very little to them aside from hashing them and&n; * parking tasks using given ID&squot;s on a list.&n; *&n; * The hash is always changed with the tasklist_lock write-acquired,&n; * and the hash is only accessed with the tasklist_lock at least&n; * read-acquired, so there&squot;s no additional SMP locking needed here.&n; *&n; * We have a list of bitmap pages, which bitmaps represent the PID space.&n; * Allocating and freeing PIDs is completely lockless. The worst-case&n; * allocation scenario when all but one out of 1 million PIDs possible are&n; * allocated already: the scanning of 32 list entries and at most PAGE_SIZE&n; * bytes. The typical fastpath is a single successful setbit. Freeing is O(1).&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/hash.h&gt;
DECL|macro|pid_hashfn
mdefine_line|#define pid_hashfn(nr) hash_long((unsigned long)nr, pidhash_shift)
DECL|variable|pid_hash
r_static
r_struct
id|hlist_head
op_star
id|pid_hash
(braket
id|PIDTYPE_MAX
)braket
suffix:semicolon
DECL|variable|pidhash_shift
r_static
r_int
id|pidhash_shift
suffix:semicolon
DECL|variable|pid_max
r_int
id|pid_max
op_assign
id|PID_MAX_DEFAULT
suffix:semicolon
DECL|variable|last_pid
r_int
id|last_pid
suffix:semicolon
DECL|macro|RESERVED_PIDS
mdefine_line|#define RESERVED_PIDS&t;&t;300
DECL|variable|pid_max_min
r_int
id|pid_max_min
op_assign
id|RESERVED_PIDS
op_plus
l_int|1
suffix:semicolon
DECL|variable|pid_max_max
r_int
id|pid_max_max
op_assign
id|PID_MAX_LIMIT
suffix:semicolon
DECL|macro|PIDMAP_ENTRIES
mdefine_line|#define PIDMAP_ENTRIES&t;&t;((PID_MAX_LIMIT + 8*PAGE_SIZE - 1)/PAGE_SIZE/8)
DECL|macro|BITS_PER_PAGE
mdefine_line|#define BITS_PER_PAGE&t;&t;(PAGE_SIZE*8)
DECL|macro|BITS_PER_PAGE_MASK
mdefine_line|#define BITS_PER_PAGE_MASK&t;(BITS_PER_PAGE-1)
DECL|macro|mk_pid
mdefine_line|#define mk_pid(map, off)&t;(((map) - pidmap_array)*BITS_PER_PAGE + (off))
DECL|macro|find_next_offset
mdefine_line|#define find_next_offset(map, off)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;find_next_zero_bit((map)-&gt;page, BITS_PER_PAGE, off)
multiline_comment|/*&n; * PID-map pages start out as NULL, they get allocated upon&n; * first use and are never deallocated. This way a low pid_max&n; * value does not cause lots of bitmaps to be allocated, but&n; * the scheme scales to up to 4 million PIDs, runtime.&n; */
DECL|struct|pidmap
r_typedef
r_struct
id|pidmap
(brace
DECL|member|nr_free
id|atomic_t
id|nr_free
suffix:semicolon
DECL|member|page
r_void
op_star
id|page
suffix:semicolon
DECL|typedef|pidmap_t
)brace
id|pidmap_t
suffix:semicolon
DECL|variable|pidmap_array
r_static
id|pidmap_t
id|pidmap_array
(braket
id|PIDMAP_ENTRIES
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|PIDMAP_ENTRIES
op_minus
l_int|1
)braket
op_assign
(brace
id|ATOMIC_INIT
c_func
(paren
id|BITS_PER_PAGE
)paren
comma
l_int|NULL
)brace
)brace
suffix:semicolon
r_static
id|__cacheline_aligned_in_smp
id|DEFINE_SPINLOCK
c_func
(paren
id|pidmap_lock
)paren
suffix:semicolon
DECL|function|free_pidmap
id|fastcall
r_void
id|free_pidmap
c_func
(paren
r_int
id|pid
)paren
(brace
id|pidmap_t
op_star
id|map
op_assign
id|pidmap_array
op_plus
id|pid
op_div
id|BITS_PER_PAGE
suffix:semicolon
r_int
id|offset
op_assign
id|pid
op_amp
id|BITS_PER_PAGE_MASK
suffix:semicolon
id|clear_bit
c_func
(paren
id|offset
comma
id|map-&gt;page
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|map-&gt;nr_free
)paren
suffix:semicolon
)brace
DECL|function|alloc_pidmap
r_int
id|alloc_pidmap
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|offset
comma
id|max_scan
comma
id|pid
comma
id|last
op_assign
id|last_pid
suffix:semicolon
id|pidmap_t
op_star
id|map
suffix:semicolon
id|pid
op_assign
id|last
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pid
op_ge
id|pid_max
)paren
id|pid
op_assign
id|RESERVED_PIDS
suffix:semicolon
id|offset
op_assign
id|pid
op_amp
id|BITS_PER_PAGE_MASK
suffix:semicolon
id|map
op_assign
op_amp
id|pidmap_array
(braket
id|pid
op_div
id|BITS_PER_PAGE
)braket
suffix:semicolon
id|max_scan
op_assign
(paren
id|pid_max
op_plus
id|BITS_PER_PAGE
op_minus
l_int|1
)paren
op_div
id|BITS_PER_PAGE
op_minus
op_logical_neg
id|offset
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|max_scan
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|map-&gt;page
)paren
)paren
(brace
r_int
r_int
id|page
op_assign
id|get_zeroed_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Free the page if someone raced with us&n;&t;&t;&t; * installing it:&n;&t;&t;&t; */
id|spin_lock
c_func
(paren
op_amp
id|pidmap_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;page
)paren
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_else
id|map-&gt;page
op_assign
(paren
r_void
op_star
)paren
id|page
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pidmap_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|map-&gt;page
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|map-&gt;nr_free
)paren
)paren
)paren
(brace
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|offset
comma
id|map-&gt;page
)paren
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|map-&gt;nr_free
)paren
suffix:semicolon
id|last_pid
op_assign
id|pid
suffix:semicolon
r_return
id|pid
suffix:semicolon
)brace
id|offset
op_assign
id|find_next_offset
c_func
(paren
id|map
comma
id|offset
)paren
suffix:semicolon
id|pid
op_assign
id|mk_pid
c_func
(paren
id|map
comma
id|offset
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * find_next_offset() found a bit, the pid from it&n;&t;&t;&t; * is in-bounds, and if we fell back to the last&n;&t;&t;&t; * bitmap block and the final block was the same&n;&t;&t;&t; * as the starting point, pid is before last_pid.&n;&t;&t;&t; */
)brace
r_while
c_loop
(paren
id|offset
OL
id|BITS_PER_PAGE
op_logical_and
id|pid
OL
id|pid_max
op_logical_and
(paren
id|i
op_ne
id|max_scan
op_logical_or
id|pid
OL
id|last
op_logical_or
op_logical_neg
(paren
(paren
id|last
op_plus
l_int|1
)paren
op_amp
id|BITS_PER_PAGE_MASK
)paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|map
OL
op_amp
id|pidmap_array
(braket
(paren
id|pid_max
op_minus
l_int|1
)paren
op_div
id|BITS_PER_PAGE
)braket
)paren
(brace
op_increment
id|map
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|map
op_assign
op_amp
id|pidmap_array
(braket
l_int|0
)braket
suffix:semicolon
id|offset
op_assign
id|RESERVED_PIDS
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|last
op_eq
id|offset
)paren
)paren
r_break
suffix:semicolon
)brace
id|pid
op_assign
id|mk_pid
c_func
(paren
id|map
comma
id|offset
)paren
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|find_pid
r_struct
id|pid
op_star
id|fastcall
id|find_pid
c_func
(paren
r_enum
id|pid_type
id|type
comma
r_int
id|nr
)paren
(brace
r_struct
id|hlist_node
op_star
id|elem
suffix:semicolon
r_struct
id|pid
op_star
id|pid
suffix:semicolon
id|hlist_for_each_entry
c_func
(paren
id|pid
comma
id|elem
comma
op_amp
id|pid_hash
(braket
id|type
)braket
(braket
id|pid_hashfn
c_func
(paren
id|nr
)paren
)braket
comma
id|pid_chain
)paren
(brace
r_if
c_cond
(paren
id|pid-&gt;nr
op_eq
id|nr
)paren
r_return
id|pid
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|attach_pid
r_int
id|fastcall
id|attach_pid
c_func
(paren
id|task_t
op_star
id|task
comma
r_enum
id|pid_type
id|type
comma
r_int
id|nr
)paren
(brace
r_struct
id|pid
op_star
id|pid
comma
op_star
id|task_pid
suffix:semicolon
id|task_pid
op_assign
op_amp
id|task-&gt;pids
(braket
id|type
)braket
suffix:semicolon
id|pid
op_assign
id|find_pid
c_func
(paren
id|type
comma
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pid
op_eq
l_int|NULL
)paren
(brace
id|hlist_add_head
c_func
(paren
op_amp
id|task_pid-&gt;pid_chain
comma
op_amp
id|pid_hash
(braket
id|type
)braket
(braket
id|pid_hashfn
c_func
(paren
id|nr
)paren
)braket
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|task_pid-&gt;pid_list
)paren
suffix:semicolon
)brace
r_else
(brace
id|INIT_HLIST_NODE
c_func
(paren
op_amp
id|task_pid-&gt;pid_chain
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|task_pid-&gt;pid_list
comma
op_amp
id|pid-&gt;pid_list
)paren
suffix:semicolon
)brace
id|task_pid-&gt;nr
op_assign
id|nr
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__detach_pid
r_static
id|fastcall
r_int
id|__detach_pid
c_func
(paren
id|task_t
op_star
id|task
comma
r_enum
id|pid_type
id|type
)paren
(brace
r_struct
id|pid
op_star
id|pid
comma
op_star
id|pid_next
suffix:semicolon
r_int
id|nr
op_assign
l_int|0
suffix:semicolon
id|pid
op_assign
op_amp
id|task-&gt;pids
(braket
id|type
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hlist_unhashed
c_func
(paren
op_amp
id|pid-&gt;pid_chain
)paren
)paren
(brace
id|hlist_del
c_func
(paren
op_amp
id|pid-&gt;pid_chain
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|pid-&gt;pid_list
)paren
)paren
id|nr
op_assign
id|pid-&gt;nr
suffix:semicolon
r_else
(brace
id|pid_next
op_assign
id|list_entry
c_func
(paren
id|pid-&gt;pid_list.next
comma
r_struct
id|pid
comma
id|pid_list
)paren
suffix:semicolon
multiline_comment|/* insert next pid from pid_list to hash */
id|hlist_add_head
c_func
(paren
op_amp
id|pid_next-&gt;pid_chain
comma
op_amp
id|pid_hash
(braket
id|type
)braket
(braket
id|pid_hashfn
c_func
(paren
id|pid_next-&gt;nr
)paren
)braket
)paren
suffix:semicolon
)brace
)brace
id|list_del
c_func
(paren
op_amp
id|pid-&gt;pid_list
)paren
suffix:semicolon
id|pid-&gt;nr
op_assign
l_int|0
suffix:semicolon
r_return
id|nr
suffix:semicolon
)brace
DECL|function|detach_pid
r_void
id|fastcall
id|detach_pid
c_func
(paren
id|task_t
op_star
id|task
comma
r_enum
id|pid_type
id|type
)paren
(brace
r_int
id|tmp
comma
id|nr
suffix:semicolon
id|nr
op_assign
id|__detach_pid
c_func
(paren
id|task
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|PIDTYPE_MAX
suffix:semicolon
op_decrement
id|tmp
op_ge
l_int|0
suffix:semicolon
)paren
r_if
c_cond
(paren
id|tmp
op_ne
id|type
op_logical_and
id|find_pid
c_func
(paren
id|tmp
comma
id|nr
)paren
)paren
r_return
suffix:semicolon
id|free_pidmap
c_func
(paren
id|nr
)paren
suffix:semicolon
)brace
DECL|function|find_task_by_pid_type
id|task_t
op_star
id|find_task_by_pid_type
c_func
(paren
r_int
id|type
comma
r_int
id|nr
)paren
(brace
r_struct
id|pid
op_star
id|pid
suffix:semicolon
id|pid
op_assign
id|find_pid
c_func
(paren
id|type
comma
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pid
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|pid_task
c_func
(paren
op_amp
id|pid-&gt;pid_list
comma
id|type
)paren
suffix:semicolon
)brace
DECL|variable|find_task_by_pid_type
id|EXPORT_SYMBOL
c_func
(paren
id|find_task_by_pid_type
)paren
suffix:semicolon
multiline_comment|/*&n; * This function switches the PIDs if a non-leader thread calls&n; * sys_execve() - this must be done without releasing the PID.&n; * (which a detach_pid() would eventually do.)&n; */
DECL|function|switch_exec_pids
r_void
id|switch_exec_pids
c_func
(paren
id|task_t
op_star
id|leader
comma
id|task_t
op_star
id|thread
)paren
(brace
id|__detach_pid
c_func
(paren
id|leader
comma
id|PIDTYPE_PID
)paren
suffix:semicolon
id|__detach_pid
c_func
(paren
id|leader
comma
id|PIDTYPE_TGID
)paren
suffix:semicolon
id|__detach_pid
c_func
(paren
id|leader
comma
id|PIDTYPE_PGID
)paren
suffix:semicolon
id|__detach_pid
c_func
(paren
id|leader
comma
id|PIDTYPE_SID
)paren
suffix:semicolon
id|__detach_pid
c_func
(paren
id|thread
comma
id|PIDTYPE_PID
)paren
suffix:semicolon
id|__detach_pid
c_func
(paren
id|thread
comma
id|PIDTYPE_TGID
)paren
suffix:semicolon
id|leader-&gt;pid
op_assign
id|leader-&gt;tgid
op_assign
id|thread-&gt;pid
suffix:semicolon
id|thread-&gt;pid
op_assign
id|thread-&gt;tgid
suffix:semicolon
id|attach_pid
c_func
(paren
id|thread
comma
id|PIDTYPE_PID
comma
id|thread-&gt;pid
)paren
suffix:semicolon
id|attach_pid
c_func
(paren
id|thread
comma
id|PIDTYPE_TGID
comma
id|thread-&gt;tgid
)paren
suffix:semicolon
id|attach_pid
c_func
(paren
id|thread
comma
id|PIDTYPE_PGID
comma
id|thread-&gt;signal-&gt;pgrp
)paren
suffix:semicolon
id|attach_pid
c_func
(paren
id|thread
comma
id|PIDTYPE_SID
comma
id|thread-&gt;signal-&gt;session
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|thread-&gt;tasks
comma
op_amp
id|init_task.tasks
)paren
suffix:semicolon
id|attach_pid
c_func
(paren
id|leader
comma
id|PIDTYPE_PID
comma
id|leader-&gt;pid
)paren
suffix:semicolon
id|attach_pid
c_func
(paren
id|leader
comma
id|PIDTYPE_TGID
comma
id|leader-&gt;tgid
)paren
suffix:semicolon
id|attach_pid
c_func
(paren
id|leader
comma
id|PIDTYPE_PGID
comma
id|leader-&gt;signal-&gt;pgrp
)paren
suffix:semicolon
id|attach_pid
c_func
(paren
id|leader
comma
id|PIDTYPE_SID
comma
id|leader-&gt;signal-&gt;session
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The pid hash table is scaled according to the amount of memory in the&n; * machine.  From a minimum of 16 slots up to 4096 slots at one gigabyte or&n; * more.&n; */
DECL|function|pidhash_init
r_void
id|__init
id|pidhash_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
comma
id|pidhash_size
suffix:semicolon
r_int
r_int
id|megabytes
op_assign
id|nr_kernel_pages
op_rshift
(paren
l_int|20
op_minus
id|PAGE_SHIFT
)paren
suffix:semicolon
id|pidhash_shift
op_assign
id|max
c_func
(paren
l_int|4
comma
id|fls
c_func
(paren
id|megabytes
op_star
l_int|4
)paren
)paren
suffix:semicolon
id|pidhash_shift
op_assign
id|min
c_func
(paren
l_int|12
comma
id|pidhash_shift
)paren
suffix:semicolon
id|pidhash_size
op_assign
l_int|1
op_lshift
id|pidhash_shift
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PID hash table entries: %d (order: %d, %Zd bytes)&bslash;n&quot;
comma
id|pidhash_size
comma
id|pidhash_shift
comma
id|PIDTYPE_MAX
op_star
id|pidhash_size
op_star
r_sizeof
(paren
r_struct
id|hlist_head
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PIDTYPE_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pid_hash
(braket
id|i
)braket
op_assign
id|alloc_bootmem
c_func
(paren
id|pidhash_size
op_star
r_sizeof
(paren
op_star
(paren
id|pid_hash
(braket
id|i
)braket
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pid_hash
(braket
id|i
)braket
)paren
id|panic
c_func
(paren
l_string|&quot;Could not alloc pidhash!&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|pidhash_size
suffix:semicolon
id|j
op_increment
)paren
id|INIT_HLIST_HEAD
c_func
(paren
op_amp
id|pid_hash
(braket
id|i
)braket
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
)brace
DECL|function|pidmap_init
r_void
id|__init
id|pidmap_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|pidmap_array-&gt;page
op_assign
(paren
r_void
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
id|set_bit
c_func
(paren
l_int|0
comma
id|pidmap_array-&gt;page
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|pidmap_array-&gt;nr_free
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate PID 0, and hash it via all PID types:&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PIDTYPE_MAX
suffix:semicolon
id|i
op_increment
)paren
id|attach_pid
c_func
(paren
id|current
comma
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
eof
