multiline_comment|/*&n; * linux/kernel/suspend.c&n; *&n; * This file is to realize architecture-independent&n; * machine suspend feature using pretty near only high-level routines&n; *&n; * Copyright (C) 1998-2001 Gabor Kuti &lt;seasons@fornax.hu&gt;&n; * Copyright (C) 1998,2001,2002 Pavel Machek &lt;pavel@suse.cz&gt;&n; *&n; * I&squot;d like to thank the following people for their work:&n; * &n; * Pavel Machek &lt;pavel@ucw.cz&gt;:&n; * Modifications, defectiveness pointing, being with me at the very beginning,&n; * suspend to swap space, stop all tasks. Port to 2.4.18-ac and 2.5.17.&n; *&n; * Steve Doddi &lt;dirk@loth.demon.co.uk&gt;: &n; * Support the possibility of hardware state restoring.&n; *&n; * Raph &lt;grey.havens@earthling.net&gt;:&n; * Support for preserving states of network devices and virtual console&n; * (including X and svgatextmode)&n; *&n; * Kurt Garloff &lt;garloff@suse.de&gt;:&n; * Straightened the critical function in order to prevent compilers from&n; * playing tricks with local variables.&n; *&n; * Andreas Mohr &lt;a.mohr@mailto.de&gt;&n; *&n; * Alex Badea &lt;vampire@go.ro&gt;:&n; * Fixed runaway init&n; *&n; * More state savers are welcome. Especially for the scsi layer...&n; *&n; * For TODOs,FIXMEs also look in Documentation/swsusp.txt&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/utsname.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/vt_kern.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/kbd_kern.h&gt;
macro_line|#include &lt;linux/keyboard.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/pm.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/swapops.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/io.h&gt;
r_extern
r_int
id|sys_sync
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|software_suspend_enabled
r_int
r_char
id|software_suspend_enabled
op_assign
l_int|0
suffix:semicolon
DECL|macro|SUSPEND_CONSOLE
mdefine_line|#define SUSPEND_CONSOLE&t;(MAX_NR_CONSOLES-1)
multiline_comment|/* With SUSPEND_CONSOLE defined, it suspend looks *really* cool, but&n;   we probably do not take enough locks for switching consoles, etc,&n;   so bad things might happen.&n;*/
macro_line|#if !defined(CONFIG_VT) || !defined(CONFIG_VT_CONSOLE)
DECL|macro|SUSPEND_CONSOLE
macro_line|#undef SUSPEND_CONSOLE
macro_line|#endif
DECL|macro|TIMEOUT
mdefine_line|#define TIMEOUT&t;(6 * HZ)&t;&t;&t;/* Timeout for stopping processes */
DECL|macro|__ADDRESS
mdefine_line|#define __ADDRESS(x)  ((unsigned long) phys_to_virt(x))
DECL|macro|ADDRESS
mdefine_line|#define ADDRESS(x) __ADDRESS((x) &lt;&lt; PAGE_SHIFT)
DECL|macro|ADDRESS2
mdefine_line|#define ADDRESS2(x) __ADDRESS(__pa(x))&t;&t;/* Needed for x86-64 where some pages are in memory twice */
multiline_comment|/* References to section boundaries */
r_extern
r_char
id|__nosave_begin
comma
id|__nosave_end
suffix:semicolon
r_extern
r_int
id|is_head_of_free_region
c_func
(paren
r_struct
id|page
op_star
)paren
suffix:semicolon
multiline_comment|/* Locks */
DECL|variable|__nosavedata
id|spinlock_t
id|suspend_pagedir_lock
id|__nosavedata
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* Variables to be preserved over suspend */
DECL|variable|new_loglevel
r_static
r_int
id|new_loglevel
op_assign
l_int|7
suffix:semicolon
DECL|variable|orig_loglevel
r_static
r_int
id|orig_loglevel
suffix:semicolon
DECL|variable|orig_fgconsole
DECL|variable|orig_kmsg
r_static
r_int
id|orig_fgconsole
comma
id|orig_kmsg
suffix:semicolon
DECL|variable|pagedir_order_check
r_static
r_int
id|pagedir_order_check
suffix:semicolon
DECL|variable|nr_copy_pages_check
r_static
r_int
id|nr_copy_pages_check
suffix:semicolon
DECL|variable|resume_status
r_static
r_int
id|resume_status
suffix:semicolon
DECL|variable|resume_file
r_static
r_char
id|resume_file
(braket
l_int|256
)braket
op_assign
l_string|&quot;&quot;
suffix:semicolon
multiline_comment|/* For resume= kernel option */
DECL|variable|resume_device
r_static
id|dev_t
id|resume_device
suffix:semicolon
multiline_comment|/* Local variables that should not be affected by save */
DECL|variable|__nosavedata
r_int
r_int
id|nr_copy_pages
id|__nosavedata
op_assign
l_int|0
suffix:semicolon
DECL|variable|pm_suspend_state
r_static
r_int
id|pm_suspend_state
suffix:semicolon
multiline_comment|/* Suspend pagedir is allocated before final copy, therefore it&n;   must be freed after resume &n;&n;   Warning: this is evil. There are actually two pagedirs at time of&n;   resume. One is &quot;pagedir_save&quot;, which is empty frame allocated at&n;   time of suspend, that must be freed. Second is &quot;pagedir_nosave&quot;, &n;   allocated at time of resume, that travels through memory not to&n;   collide with anything.&n; */
DECL|variable|__nosavedata
id|suspend_pagedir_t
op_star
id|pagedir_nosave
id|__nosavedata
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|pagedir_save
r_static
id|suspend_pagedir_t
op_star
id|pagedir_save
suffix:semicolon
DECL|variable|__nosavedata
r_static
r_int
id|pagedir_order
id|__nosavedata
op_assign
l_int|0
suffix:semicolon
DECL|struct|link
r_struct
id|link
(brace
DECL|member|dummy
r_char
id|dummy
(braket
id|PAGE_SIZE
op_minus
r_sizeof
(paren
id|swp_entry_t
)paren
)braket
suffix:semicolon
DECL|member|next
id|swp_entry_t
id|next
suffix:semicolon
)brace
suffix:semicolon
DECL|union|diskpage
r_union
id|diskpage
(brace
DECL|member|swh
r_union
id|swap_header
id|swh
suffix:semicolon
DECL|member|link
r_struct
id|link
id|link
suffix:semicolon
DECL|member|sh
r_struct
id|suspend_header
id|sh
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * XXX: We try to keep some more pages free so that I/O operations succeed&n; * without paging. Might this be more?&n; */
DECL|macro|PAGES_FOR_IO
mdefine_line|#define PAGES_FOR_IO&t;512
DECL|variable|name_suspend
r_static
r_const
r_char
id|name_suspend
(braket
)braket
op_assign
l_string|&quot;Suspend Machine: &quot;
suffix:semicolon
DECL|variable|name_resume
r_static
r_const
r_char
id|name_resume
(braket
)braket
op_assign
l_string|&quot;Resume Machine: &quot;
suffix:semicolon
multiline_comment|/*&n; * Debug&n; */
DECL|macro|DEBUG_DEFAULT
mdefine_line|#define&t;DEBUG_DEFAULT
DECL|macro|DEBUG_PROCESS
macro_line|#undef&t;DEBUG_PROCESS
DECL|macro|DEBUG_SLOW
macro_line|#undef&t;DEBUG_SLOW
DECL|macro|TEST_SWSUSP
mdefine_line|#define TEST_SWSUSP 0&t;&t;/* Set to 1 to reboot instead of halt machine after suspension */
macro_line|#ifdef DEBUG_DEFAULT
DECL|macro|PRINTK
macro_line|# define PRINTK(f, a...)       printk(f, ## a)
macro_line|#else
DECL|macro|PRINTK
macro_line|# define PRINTK(f, a...)
macro_line|#endif
macro_line|#ifdef DEBUG_SLOW
DECL|macro|MDELAY
mdefine_line|#define MDELAY(a) mdelay(a)
macro_line|#else
DECL|macro|MDELAY
mdefine_line|#define MDELAY(a)
macro_line|#endif
multiline_comment|/*&n; * Refrigerator and related stuff&n; */
DECL|macro|INTERESTING
mdefine_line|#define INTERESTING(p) &bslash;&n;&t;&t;&t;/* We don&squot;t want to touch kernel_threads..*/ &bslash;&n;&t;&t;&t;if (p-&gt;flags &amp; PF_IOTHREAD) &bslash;&n;&t;&t;&t;&t;continue; &bslash;&n;&t;&t;&t;if (p == current) &bslash;&n;&t;&t;&t;&t;continue; &bslash;&n;&t;&t;&t;if (p-&gt;state == TASK_ZOMBIE) &bslash;&n;&t;&t;&t;&t;continue;
multiline_comment|/* Refrigerator is place where frozen processes are stored :-). */
DECL|function|refrigerator
r_void
id|refrigerator
c_func
(paren
r_int
r_int
id|flag
)paren
(brace
multiline_comment|/* You need correct to work with real-time processes.&n;&t;   OTOH, this way one process may see (via /proc/) some other&n;&t;   process in stopped state (and thereby discovered we were&n;&t;   suspended. We probably do not care. &n;&t; */
r_int
id|save
suffix:semicolon
id|save
op_assign
id|current-&gt;state
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_STOPPED
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;%s entered refrigerator&bslash;n&quot;
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;=&quot;
)paren
suffix:semicolon
id|current-&gt;flags
op_and_assign
op_complement
id|PF_FREEZE
suffix:semicolon
r_if
c_cond
(paren
id|flag
)paren
id|flush_signals
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/* We have signaled a kernel thread, which isn&squot;t normal behaviour&n;&t;&t;&t;&t;&t;   and that may lead to 100%CPU sucking because those threads&n;&t;&t;&t;&t;&t;   just don&squot;t manage signals. */
id|current-&gt;flags
op_or_assign
id|PF_FROZEN
suffix:semicolon
r_while
c_loop
(paren
id|current-&gt;flags
op_amp
id|PF_FROZEN
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;%s left refrigerator&bslash;n&quot;
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|save
suffix:semicolon
)brace
multiline_comment|/* 0 = success, else # of processes that we failed to stop */
DECL|function|freeze_processes
r_int
id|freeze_processes
c_func
(paren
r_void
)paren
(brace
r_int
id|todo
suffix:semicolon
r_int
r_int
id|start_time
suffix:semicolon
r_struct
id|task_struct
op_star
id|g
comma
op_star
id|p
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Stopping tasks: &quot;
)paren
suffix:semicolon
id|start_time
op_assign
id|jiffies
suffix:semicolon
r_do
(brace
id|todo
op_assign
l_int|0
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|do_each_thread
c_func
(paren
id|g
comma
id|p
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|INTERESTING
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|PF_FROZEN
)paren
r_continue
suffix:semicolon
multiline_comment|/* FIXME: smp problem here: we may not access other process&squot; flags&n;&t;&t;&t;   without locking */
id|p-&gt;flags
op_or_assign
id|PF_FREEZE
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|p-&gt;sighand-&gt;siglock
comma
id|flags
)paren
suffix:semicolon
id|signal_wake_up
c_func
(paren
id|p
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|p-&gt;sighand-&gt;siglock
comma
id|flags
)paren
suffix:semicolon
id|todo
op_increment
suffix:semicolon
)brace
id|while_each_thread
c_func
(paren
id|g
comma
id|p
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|yield
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Yield is okay here */
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|start_time
op_plus
id|TIMEOUT
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot; stopping tasks failed (%d tasks remaining)&bslash;n&quot;
comma
id|todo
)paren
suffix:semicolon
r_return
id|todo
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|todo
)paren
(brace
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;|&bslash;n&quot;
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|in_atomic
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|thaw_processes
r_void
id|thaw_processes
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
id|g
comma
op_star
id|p
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Restarting tasks...&quot;
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|do_each_thread
c_func
(paren
id|g
comma
id|p
)paren
(brace
id|INTERESTING
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;flags
op_amp
id|PF_FROZEN
)paren
id|p-&gt;flags
op_and_assign
op_complement
id|PF_FROZEN
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot; Strange, %s not stopped&bslash;n&quot;
comma
id|p-&gt;comm
)paren
suffix:semicolon
id|wake_up_process
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
id|while_each_thread
c_func
(paren
id|g
comma
id|p
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; done&bslash;n&quot;
)paren
suffix:semicolon
id|MDELAY
c_func
(paren
l_int|500
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Saving part...&n; */
DECL|function|fill_suspend_header
r_static
id|__inline__
r_int
id|fill_suspend_header
c_func
(paren
r_struct
id|suspend_header
op_star
id|sh
)paren
(brace
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|sh
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|sh
)paren
)paren
suffix:semicolon
id|sh-&gt;version_code
op_assign
id|LINUX_VERSION_CODE
suffix:semicolon
id|sh-&gt;num_physpages
op_assign
id|num_physpages
suffix:semicolon
id|strncpy
c_func
(paren
id|sh-&gt;machine
comma
id|system_utsname.machine
comma
l_int|8
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|sh-&gt;version
comma
id|system_utsname.version
comma
l_int|20
)paren
suffix:semicolon
multiline_comment|/* FIXME: Is this bogus? --RR */
id|sh-&gt;num_cpus
op_assign
id|num_online_cpus
c_func
(paren
)paren
suffix:semicolon
id|sh-&gt;page_size
op_assign
id|PAGE_SIZE
suffix:semicolon
id|sh-&gt;suspend_pagedir
op_assign
id|pagedir_nosave
suffix:semicolon
id|BUG_ON
(paren
id|pagedir_save
op_ne
id|pagedir_nosave
)paren
suffix:semicolon
id|sh-&gt;num_pbes
op_assign
id|nr_copy_pages
suffix:semicolon
multiline_comment|/* TODO: needed? mounted fs&squot; last mounted date comparison&n;&t; * [so they haven&squot;t been mounted since last suspend.&n;&t; * Maybe it isn&squot;t.] [we&squot;d need to do this for _all_ fs-es]&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This is our sync function. With this solution we probably won&squot;t sleep&n; * but that should not be a problem since tasks are stopped..&n; */
DECL|function|do_suspend_sync
r_static
r_inline
r_void
id|do_suspend_sync
c_func
(paren
r_void
)paren
(brace
id|blk_run_queues
c_func
(paren
)paren
suffix:semicolon
macro_line|#warning This might be broken. We need to somehow wait for data to reach the disk
)brace
multiline_comment|/* We memorize in swapfile_used what swap devices are used for suspension */
DECL|macro|SWAPFILE_UNUSED
mdefine_line|#define SWAPFILE_UNUSED    0
DECL|macro|SWAPFILE_SUSPEND
mdefine_line|#define SWAPFILE_SUSPEND   1&t;/* This is the suspending device */
DECL|macro|SWAPFILE_IGNORED
mdefine_line|#define SWAPFILE_IGNORED   2&t;/* Those are other swap devices ignored for suspension */
DECL|variable|swapfile_used
r_static
r_int
r_int
id|swapfile_used
(braket
id|MAX_SWAPFILES
)braket
suffix:semicolon
DECL|variable|root_swap
r_static
r_int
r_int
id|root_swap
suffix:semicolon
DECL|macro|MARK_SWAP_SUSPEND
mdefine_line|#define MARK_SWAP_SUSPEND 0
DECL|macro|MARK_SWAP_RESUME
mdefine_line|#define MARK_SWAP_RESUME 2
DECL|function|mark_swapfiles
r_static
r_void
id|mark_swapfiles
c_func
(paren
id|swp_entry_t
id|prev
comma
r_int
id|mode
)paren
(brace
id|swp_entry_t
id|entry
suffix:semicolon
r_union
id|diskpage
op_star
id|cur
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_if
c_cond
(paren
id|root_swap
op_eq
l_int|0xFFFF
)paren
multiline_comment|/* ignored */
r_return
suffix:semicolon
id|page
op_assign
id|alloc_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
id|panic
c_func
(paren
l_string|&quot;Out of memory in mark_swapfiles&quot;
)paren
suffix:semicolon
id|cur
op_assign
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* XXX: this is dirty hack to get first page of swap file */
id|entry
op_assign
id|swp_entry
c_func
(paren
id|root_swap
comma
l_int|0
)paren
suffix:semicolon
id|rw_swap_page_sync
c_func
(paren
id|READ
comma
id|entry
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|MARK_SWAP_RESUME
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;S1&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|2
)paren
)paren
id|memcpy
c_func
(paren
id|cur-&gt;swh.magic.magic
comma
l_string|&quot;SWAP-SPACE&quot;
comma
l_int|10
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;S2&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|2
)paren
)paren
id|memcpy
c_func
(paren
id|cur-&gt;swh.magic.magic
comma
l_string|&quot;SWAPSPACE2&quot;
comma
l_int|10
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%sUnable to find suspended-data signature (%.10s - misspelled?&bslash;n&quot;
comma
id|name_resume
comma
id|cur-&gt;swh.magic.magic
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;SWAP-SPACE&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|10
)paren
)paren
)paren
id|memcpy
c_func
(paren
id|cur-&gt;swh.magic.magic
comma
l_string|&quot;S1SUSP....&quot;
comma
l_int|10
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;SWAPSPACE2&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|10
)paren
)paren
)paren
id|memcpy
c_func
(paren
id|cur-&gt;swh.magic.magic
comma
l_string|&quot;S2SUSP....&quot;
comma
l_int|10
)paren
suffix:semicolon
r_else
id|panic
c_func
(paren
l_string|&quot;&bslash;nSwapspace is not swapspace (%.10s)&bslash;n&quot;
comma
id|cur-&gt;swh.magic.magic
)paren
suffix:semicolon
id|cur-&gt;link.next
op_assign
id|prev
suffix:semicolon
multiline_comment|/* prev is the first/last swap page of the resume area */
multiline_comment|/* link.next lies *no more* in last 4/8 bytes of magic */
)brace
id|rw_swap_page_sync
c_func
(paren
id|WRITE
comma
id|entry
comma
id|page
)paren
suffix:semicolon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|function|read_swapfiles
r_static
r_void
id|read_swapfiles
c_func
(paren
r_void
)paren
multiline_comment|/* This is called before saving image */
(brace
r_int
id|i
comma
id|len
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|resume_file
)paren
suffix:semicolon
id|root_swap
op_assign
l_int|0xFFFF
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SWAPFILES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|swap_info
(braket
id|i
)braket
dot
id|flags
op_eq
l_int|0
)paren
(brace
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_UNUSED
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;resume= option should be used to set suspend device&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root_swap
op_eq
l_int|0xFFFF
)paren
(brace
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_SUSPEND
suffix:semicolon
id|root_swap
op_assign
id|i
suffix:semicolon
)brace
r_else
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_IGNORED
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we ignore all swap devices that are not the resume_file */
r_if
c_cond
(paren
l_int|1
)paren
(brace
singleline_comment|// FIXME&t;&t;&t;&t;if(resume_device == swap_info[i].swap_device) {
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_SUSPEND
suffix:semicolon
id|root_swap
op_assign
id|i
suffix:semicolon
)brace
r_else
(brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;Resume: device %s (%x != %x) ignored&bslash;n&quot;
comma
id|swap_info
(braket
id|i
)braket
dot
id|swap_file-&gt;d_name.name
comma
id|swap_info
(braket
id|i
)braket
dot
id|swap_device
comma
id|resume_device
)paren
suffix:semicolon
macro_line|#endif
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_IGNORED
suffix:semicolon
)brace
)brace
)brace
)brace
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|lock_swapdevices
r_static
r_void
id|lock_swapdevices
c_func
(paren
r_void
)paren
multiline_comment|/* This is called after saving image so modification&n;&t;&t;&t;&t;      will be lost after resume... and that&squot;s what we want. */
(brace
r_int
id|i
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SWAPFILES
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|swapfile_used
(braket
id|i
)braket
op_eq
id|SWAPFILE_IGNORED
)paren
(brace
id|swap_info
(braket
id|i
)braket
dot
id|flags
op_xor_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/* we make the device unusable. A new call to&n;&t;&t;&t;&t;&t;&t;       lock_swapdevices can unlock the devices. */
)brace
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|write_suspend_image
r_static
r_int
id|write_suspend_image
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|swp_entry_t
id|entry
comma
id|prev
op_assign
(brace
l_int|0
)brace
suffix:semicolon
r_int
id|nr_pgdir_pages
op_assign
id|SUSPEND_PD_PAGES
c_func
(paren
id|nr_copy_pages
)paren
suffix:semicolon
r_union
id|diskpage
op_star
id|cur
comma
op_star
id|buffer
op_assign
(paren
r_union
id|diskpage
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Writing data to swap (%d pages): &quot;
comma
id|nr_copy_pages
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_copy_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_mod
l_int|100
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry
op_assign
id|get_swap_page
c_func
(paren
)paren
)paren
dot
id|val
)paren
id|panic
c_func
(paren
l_string|&quot;&bslash;nNot enough swapspace when writing data&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|swapfile_used
(braket
id|swp_type
c_func
(paren
id|entry
)paren
)braket
op_ne
id|SWAPFILE_SUSPEND
)paren
id|panic
c_func
(paren
l_string|&quot;&bslash;nPage %d: not enough swapspace on suspend device&quot;
comma
id|i
)paren
suffix:semicolon
id|address
op_assign
(paren
id|pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|address
suffix:semicolon
id|page
op_assign
id|virt_to_page
c_func
(paren
id|address
)paren
suffix:semicolon
id|rw_swap_page_sync
c_func
(paren
id|WRITE
comma
id|entry
comma
id|page
)paren
suffix:semicolon
(paren
id|pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|swap_address
op_assign
id|entry
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;|&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Writing pagedir (%d pages): &quot;
comma
id|nr_pgdir_pages
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_pgdir_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cur
op_assign
(paren
r_union
id|diskpage
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|pagedir_nosave
)paren
op_plus
id|i
suffix:semicolon
id|BUG_ON
(paren
(paren
r_char
op_star
)paren
id|cur
op_ne
(paren
(paren
(paren
r_char
op_star
)paren
id|pagedir_nosave
)paren
op_plus
id|i
op_star
id|PAGE_SIZE
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry
op_assign
id|get_swap_page
c_func
(paren
)paren
)paren
dot
id|val
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Not enough swapspace when writing pgdir&bslash;n&quot;
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Don&squot;t know how to recover&quot;
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|buffer
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_if
c_cond
(paren
id|swapfile_used
(braket
id|swp_type
c_func
(paren
id|entry
)paren
)braket
op_ne
id|SWAPFILE_SUSPEND
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;&bslash;nNot enough swapspace for pagedir on suspend device&quot;
)paren
suffix:semicolon
)brace
id|BUG_ON
(paren
r_sizeof
(paren
id|swp_entry_t
)paren
op_ne
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|BUG_ON
(paren
id|PAGE_SIZE
op_mod
r_sizeof
(paren
r_struct
id|pbe
)paren
)paren
suffix:semicolon
id|cur-&gt;link.next
op_assign
id|prev
suffix:semicolon
id|page
op_assign
id|virt_to_page
c_func
(paren
(paren
r_int
r_int
)paren
id|cur
)paren
suffix:semicolon
id|rw_swap_page_sync
c_func
(paren
id|WRITE
comma
id|entry
comma
id|page
)paren
suffix:semicolon
id|prev
op_assign
id|entry
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;H&quot;
)paren
suffix:semicolon
id|BUG_ON
(paren
r_sizeof
(paren
r_struct
id|suspend_header
)paren
OG
id|PAGE_SIZE
op_minus
r_sizeof
(paren
id|swp_entry_t
)paren
)paren
suffix:semicolon
id|BUG_ON
(paren
r_sizeof
(paren
r_union
id|diskpage
)paren
op_ne
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry
op_assign
id|get_swap_page
c_func
(paren
)paren
)paren
dot
id|val
)paren
id|panic
c_func
(paren
l_string|&quot;&bslash;nNot enough swapspace when writing header&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|swapfile_used
(braket
id|swp_type
c_func
(paren
id|entry
)paren
)braket
op_ne
id|SWAPFILE_SUSPEND
)paren
id|panic
c_func
(paren
l_string|&quot;&bslash;nNot enough swapspace for header on suspend device&quot;
)paren
suffix:semicolon
id|cur
op_assign
(paren
r_void
op_star
)paren
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|fill_suspend_header
c_func
(paren
op_amp
id|cur-&gt;sh
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;&bslash;nOut of memory while writing header&quot;
)paren
suffix:semicolon
id|cur-&gt;link.next
op_assign
id|prev
suffix:semicolon
id|page
op_assign
id|virt_to_page
c_func
(paren
(paren
r_int
r_int
)paren
id|cur
)paren
suffix:semicolon
id|rw_swap_page_sync
c_func
(paren
id|WRITE
comma
id|entry
comma
id|page
)paren
suffix:semicolon
id|prev
op_assign
id|entry
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;S&quot;
)paren
suffix:semicolon
id|mark_swapfiles
c_func
(paren
id|prev
comma
id|MARK_SWAP_SUSPEND
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;|&bslash;n&quot;
)paren
suffix:semicolon
id|MDELAY
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|buffer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if pagedir_p != NULL it also copies the counted pages */
DECL|function|count_and_copy_data_pages
r_static
r_int
id|count_and_copy_data_pages
c_func
(paren
r_struct
id|pbe
op_star
id|pagedir_p
)paren
(brace
r_int
id|chunk_size
suffix:semicolon
r_int
id|nr_copy_pages
op_assign
l_int|0
suffix:semicolon
r_int
id|pfn
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
macro_line|#ifdef CONFIG_DISCONTIGMEM
id|panic
c_func
(paren
l_string|&quot;Discontingmem not supported&quot;
)paren
suffix:semicolon
macro_line|#else
id|BUG_ON
(paren
id|max_pfn
op_ne
id|num_physpages
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|pfn
op_assign
l_int|0
suffix:semicolon
id|pfn
OL
id|max_pfn
suffix:semicolon
id|pfn
op_increment
)paren
(brace
id|page
op_assign
id|pfn_to_page
c_func
(paren
id|pfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageHighMem
c_func
(paren
id|page
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Swsusp not supported on highmem boxes. Send 1GB of RAM to &lt;pavel@ucw.cz&gt; and try again ;-).&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageReserved
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
id|PageNosave
c_func
(paren
id|page
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|chunk_size
op_assign
id|is_head_of_free_region
c_func
(paren
id|page
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|pfn
op_add_assign
id|chunk_size
op_minus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|page
)paren
)paren
(brace
id|BUG_ON
(paren
id|PageNosave
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Just copy whole code segment. Hopefully it is not that big.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|ADDRESS
c_func
(paren
id|pfn
)paren
op_ge
(paren
r_int
r_int
)paren
id|ADDRESS2
c_func
(paren
op_amp
id|__nosave_begin
)paren
)paren
op_logical_and
(paren
id|ADDRESS
c_func
(paren
id|pfn
)paren
OL
(paren
r_int
r_int
)paren
id|ADDRESS2
c_func
(paren
op_amp
id|__nosave_end
)paren
)paren
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;[nosave %lx]&quot;
comma
id|ADDRESS
c_func
(paren
id|pfn
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Hmm, perhaps copying all reserved pages is not too healthy as they may contain &n;&t;&t;&t;   critical bios data? */
)brace
r_else
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|nr_copy_pages
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pagedir_p
)paren
(brace
id|pagedir_p-&gt;orig_address
op_assign
id|ADDRESS
c_func
(paren
id|pfn
)paren
suffix:semicolon
id|copy_page
c_func
(paren
(paren
r_void
op_star
)paren
id|pagedir_p-&gt;address
comma
(paren
r_void
op_star
)paren
id|pagedir_p-&gt;orig_address
)paren
suffix:semicolon
id|pagedir_p
op_increment
suffix:semicolon
)brace
)brace
r_return
id|nr_copy_pages
suffix:semicolon
)brace
DECL|function|free_suspend_pagedir
r_static
r_void
id|free_suspend_pagedir
c_func
(paren
r_int
r_int
id|this_pagedir
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|pfn
suffix:semicolon
r_int
r_int
id|this_pagedir_end
op_assign
id|this_pagedir
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|pagedir_order
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pfn
op_assign
l_int|0
suffix:semicolon
id|pfn
OL
id|num_physpages
suffix:semicolon
id|pfn
op_increment
)paren
(brace
id|page
op_assign
id|pfn_to_page
c_func
(paren
id|pfn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TestClearPageNosave
c_func
(paren
id|page
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ADDRESS
c_func
(paren
id|pfn
)paren
op_ge
id|this_pagedir
op_logical_and
id|ADDRESS
c_func
(paren
id|pfn
)paren
OL
id|this_pagedir_end
)paren
r_continue
suffix:semicolon
multiline_comment|/* old pagedir gets freed in one */
id|free_page
c_func
(paren
id|ADDRESS
c_func
(paren
id|pfn
)paren
)paren
suffix:semicolon
)brace
id|free_pages
c_func
(paren
id|this_pagedir
comma
id|pagedir_order
)paren
suffix:semicolon
)brace
DECL|function|create_suspend_pagedir
r_static
id|suspend_pagedir_t
op_star
id|create_suspend_pagedir
c_func
(paren
r_int
id|nr_copy_pages
)paren
(brace
r_int
id|i
suffix:semicolon
id|suspend_pagedir_t
op_star
id|pagedir
suffix:semicolon
r_struct
id|pbe
op_star
id|p
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|pagedir_order
op_assign
id|get_bitmask_order
c_func
(paren
id|SUSPEND_PD_PAGES
c_func
(paren
id|nr_copy_pages
)paren
)paren
suffix:semicolon
id|p
op_assign
id|pagedir
op_assign
(paren
id|suspend_pagedir_t
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
op_or
id|__GFP_COLD
comma
id|pagedir_order
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagedir
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|page
op_assign
id|virt_to_page
c_func
(paren
id|pagedir
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1
op_lshift
id|pagedir_order
suffix:semicolon
id|i
op_increment
)paren
(brace
id|SetPageNosave
c_func
(paren
id|page
op_increment
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|nr_copy_pages
op_decrement
)paren
(brace
id|p-&gt;address
op_assign
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
op_or
id|__GFP_COLD
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;address
)paren
(brace
id|free_suspend_pagedir
c_func
(paren
(paren
r_int
r_int
)paren
id|pagedir
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
id|SetPageNosave
c_func
(paren
id|virt_to_page
c_func
(paren
id|p-&gt;address
)paren
)paren
suffix:semicolon
id|p-&gt;orig_address
op_assign
l_int|0
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
r_return
id|pagedir
suffix:semicolon
)brace
DECL|function|prepare_suspend_console
r_static
r_int
id|prepare_suspend_console
c_func
(paren
r_void
)paren
(brace
id|orig_loglevel
op_assign
id|console_loglevel
suffix:semicolon
id|console_loglevel
op_assign
id|new_loglevel
suffix:semicolon
macro_line|#ifdef CONFIG_VT
id|orig_fgconsole
op_assign
id|fg_console
suffix:semicolon
macro_line|#ifdef SUSPEND_CONSOLE
r_if
c_cond
(paren
id|vc_allocate
c_func
(paren
id|SUSPEND_CONSOLE
)paren
)paren
(brace
multiline_comment|/* we can&squot;t have a free VC for now. Too bad,&n;&t;   * we don&squot;t want to mess the screen for now. */
r_return
l_int|1
suffix:semicolon
)brace
id|set_console
(paren
id|SUSPEND_CONSOLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vt_waitactive
c_func
(paren
id|SUSPEND_CONSOLE
)paren
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;Bummer. Can&squot;t switch VCs.&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|orig_kmsg
op_assign
id|kmsg_redirect
suffix:semicolon
id|kmsg_redirect
op_assign
id|SUSPEND_CONSOLE
suffix:semicolon
macro_line|#endif
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|restore_console
r_static
r_void
id|restore_console
c_func
(paren
r_void
)paren
(brace
id|console_loglevel
op_assign
id|orig_loglevel
suffix:semicolon
macro_line|#ifdef SUSPEND_CONSOLE
id|set_console
(paren
id|orig_fgconsole
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
DECL|function|prepare_suspend_processes
r_static
r_int
id|prepare_suspend_processes
c_func
(paren
r_void
)paren
(brace
id|sys_sync
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Syncing needs pdflushd, so do it before stopping processes */
r_if
c_cond
(paren
id|freeze_processes
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Suspend failed: Not all processes stopped!&bslash;n&quot;
)paren
suffix:semicolon
id|thaw_processes
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to free as much memory as possible, but do not OOM-kill anyone&n; *&n; * Notice: all userland should be stopped at this point, or livelock is possible.&n; */
DECL|function|free_some_memory
r_static
r_void
id|free_some_memory
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Freeing memory: &quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|shrink_all_memory
c_func
(paren
l_int|10000
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;|&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Make disk drivers accept operations, again */
DECL|function|drivers_unsuspend
r_static
r_void
id|drivers_unsuspend
c_func
(paren
r_void
)paren
(brace
id|device_resume
c_func
(paren
id|RESUME_RESTORE_STATE
)paren
suffix:semicolon
id|device_resume
c_func
(paren
id|RESUME_ENABLE
)paren
suffix:semicolon
)brace
multiline_comment|/* Called from process context */
DECL|function|drivers_suspend
r_static
r_int
id|drivers_suspend
c_func
(paren
r_void
)paren
(brace
id|device_suspend
c_func
(paren
l_int|4
comma
id|SUSPEND_NOTIFY
)paren
suffix:semicolon
id|device_suspend
c_func
(paren
l_int|4
comma
id|SUSPEND_SAVE_STATE
)paren
suffix:semicolon
id|device_suspend
c_func
(paren
l_int|4
comma
id|SUSPEND_DISABLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pm_suspend_state
)paren
(brace
r_if
c_cond
(paren
id|pm_send_all
c_func
(paren
id|PM_SUSPEND
comma
(paren
r_void
op_star
)paren
l_int|3
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Problem while sending suspend event&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|pm_suspend_state
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;PM suspend state already raised&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|RESUME_PHASE1
mdefine_line|#define RESUME_PHASE1 1 /* Called from interrupts disabled */
DECL|macro|RESUME_PHASE2
mdefine_line|#define RESUME_PHASE2 2 /* Called with interrupts enabled */
DECL|macro|RESUME_ALL_PHASES
mdefine_line|#define RESUME_ALL_PHASES (RESUME_PHASE1 | RESUME_PHASE2)
DECL|function|drivers_resume
r_static
r_void
id|drivers_resume
c_func
(paren
r_int
id|flags
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|RESUME_PHASE1
)paren
(brace
id|device_resume
c_func
(paren
id|RESUME_RESTORE_STATE
)paren
suffix:semicolon
id|device_resume
c_func
(paren
id|RESUME_ENABLE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|RESUME_PHASE2
)paren
(brace
r_if
c_cond
(paren
id|pm_suspend_state
)paren
(brace
r_if
c_cond
(paren
id|pm_send_all
c_func
(paren
id|PM_RESUME
comma
(paren
r_void
op_star
)paren
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Problem while sending resume event&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|pm_suspend_state
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;PM suspend state wasn&squot;t raised&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef SUSPEND_CONSOLE
id|update_screen
c_func
(paren
id|fg_console
)paren
suffix:semicolon
multiline_comment|/* Hmm, is this the problem? */
macro_line|#endif
)brace
)brace
DECL|function|suspend_prepare_image
r_static
r_int
id|suspend_prepare_image
c_func
(paren
r_void
)paren
(brace
r_struct
id|sysinfo
id|i
suffix:semicolon
r_int
r_int
id|nr_needed_pages
op_assign
l_int|0
suffix:semicolon
id|drain_local_pages
c_func
(paren
)paren
suffix:semicolon
id|pagedir_nosave
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;/critical section: Counting pages to copy&quot;
)paren
suffix:semicolon
id|nr_copy_pages
op_assign
id|count_and_copy_data_pages
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|nr_needed_pages
op_assign
id|nr_copy_pages
op_plus
id|PAGES_FOR_IO
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; (pages needed: %d+%d=%d free: %d)&bslash;n&quot;
comma
id|nr_copy_pages
comma
id|PAGES_FOR_IO
comma
id|nr_needed_pages
comma
id|nr_free_pages
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_free_pages
c_func
(paren
)paren
OL
id|nr_needed_pages
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%sCouldn&squot;t get enough free pages, on %d pages short&bslash;n&quot;
comma
id|name_suspend
comma
id|nr_needed_pages
op_minus
id|nr_free_pages
c_func
(paren
)paren
)paren
suffix:semicolon
id|root_swap
op_assign
l_int|0xFFFF
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|si_swapinfo
c_func
(paren
op_amp
id|i
)paren
suffix:semicolon
multiline_comment|/* FIXME: si_swapinfo(&amp;i) returns all swap devices information.&n;&t;&t;&t;&t;   We should only consider resume_device. */
r_if
c_cond
(paren
id|i.freeswap
OL
id|nr_needed_pages
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%sThere&squot;s not enough swap space available, on %ld pages short&bslash;n&quot;
comma
id|name_suspend
comma
id|nr_needed_pages
op_minus
id|i.freeswap
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|PRINTK
c_func
(paren
l_string|&quot;Alloc pagedir&bslash;n&quot;
)paren
suffix:semicolon
id|pagedir_save
op_assign
id|pagedir_nosave
op_assign
id|create_suspend_pagedir
c_func
(paren
id|nr_copy_pages
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagedir_nosave
)paren
(brace
multiline_comment|/* Shouldn&squot;t happen */
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%sCouldn&squot;t allocate enough pages&bslash;n&quot;
comma
id|name_suspend
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Really should not happen&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|nr_copy_pages_check
op_assign
id|nr_copy_pages
suffix:semicolon
id|pagedir_order_check
op_assign
id|pagedir_order
suffix:semicolon
id|drain_local_pages
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* During allocating of suspend pagedir, new cold pages may appear. Kill them */
r_if
c_cond
(paren
id|nr_copy_pages
op_ne
id|count_and_copy_data_pages
c_func
(paren
id|pagedir_nosave
)paren
)paren
multiline_comment|/* copy */
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * End of critical section. From now on, we can write to memory,&n;&t; * but we should not touch disk. This specially means we must _not_&n;&t; * touch swap space! Except we must write out our image of course.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;critical section/: done (%d pages copied)&bslash;n&quot;
comma
id|nr_copy_pages
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|suspend_save_image
r_static
r_void
id|suspend_save_image
c_func
(paren
r_void
)paren
(brace
id|drivers_unsuspend
c_func
(paren
)paren
suffix:semicolon
id|lock_swapdevices
c_func
(paren
)paren
suffix:semicolon
id|write_suspend_image
c_func
(paren
)paren
suffix:semicolon
id|lock_swapdevices
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* This will unlock ignored swap devices since writing is finished */
multiline_comment|/* It is important _NOT_ to umount filesystems at this point. We want&n;&t; * them synced (in case something goes wrong) but we DO not want to mark&n;&t; * filesystem clean: it is not. (And it does not matter, if we resume&n;&t; * correctly, we&squot;ll mark system clean, anyway.)&n;&t; */
)brace
DECL|function|suspend_power_down
r_static
r_void
id|suspend_power_down
c_func
(paren
r_void
)paren
(brace
r_extern
r_int
id|C_A_D
suffix:semicolon
id|C_A_D
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;%s%s Trying to power down.&bslash;n&quot;
comma
id|name_suspend
comma
id|TEST_SWSUSP
ques
c_cond
l_string|&quot;Disable TEST_SWSUSP. NOT &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_VT
id|PRINTK
c_func
(paren
id|KERN_EMERG
l_string|&quot;shift_state: %04x&bslash;n&quot;
comma
id|shift_state
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TEST_SWSUSP
op_xor
(paren
op_logical_neg
op_logical_neg
(paren
id|shift_state
op_amp
(paren
l_int|1
op_lshift
id|KG_CTRL
)paren
)paren
)paren
)paren
id|machine_restart
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_else
macro_line|#endif
(brace
id|device_shutdown
c_func
(paren
)paren
suffix:semicolon
id|machine_power_off
c_func
(paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;%sProbably not capable for powerdown. System halted.&bslash;n&quot;
comma
id|name_suspend
)paren
suffix:semicolon
id|machine_halt
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
multiline_comment|/*&n; * Magic happens here&n; */
DECL|function|do_magic_resume_1
r_void
id|do_magic_resume_1
c_func
(paren
r_void
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|suspend_pagedir_lock
)paren
suffix:semicolon
multiline_comment|/* Done to disable interrupts */
id|PRINTK
c_func
(paren
l_string|&quot;Waiting for DMAs to settle down...&bslash;n&quot;
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* We do not want some readahead with DMA to corrupt our memory, right?&n;&t;&t;&t;   Do it with disabled interrupts for best effect. That way, if some&n;&t;&t;&t;   driver scheduled DMA, we have good chance for DMA to finish ;-). */
)brace
DECL|function|do_magic_resume_2
r_void
id|do_magic_resume_2
c_func
(paren
r_void
)paren
(brace
id|BUG_ON
(paren
id|nr_copy_pages_check
op_ne
id|nr_copy_pages
)paren
suffix:semicolon
id|BUG_ON
(paren
id|pagedir_order_check
op_ne
id|pagedir_order
)paren
suffix:semicolon
id|__flush_tlb_global
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Even mappings of &quot;global&quot; things (vmalloc) need to be fixed */
id|PRINTK
c_func
(paren
l_string|&quot;Freeing prev allocated pagedir&bslash;n&quot;
)paren
suffix:semicolon
id|free_suspend_pagedir
c_func
(paren
(paren
r_int
r_int
)paren
id|pagedir_save
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|suspend_pagedir_lock
)paren
suffix:semicolon
id|drivers_resume
c_func
(paren
id|RESUME_ALL_PHASES
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;Fixing swap signatures... &quot;
)paren
suffix:semicolon
id|mark_swapfiles
c_func
(paren
(paren
(paren
id|swp_entry_t
)paren
(brace
l_int|0
)brace
)paren
comma
id|MARK_SWAP_RESUME
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;ok&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef SUSPEND_CONSOLE
id|update_screen
c_func
(paren
id|fg_console
)paren
suffix:semicolon
multiline_comment|/* Hmm, is this the problem? */
macro_line|#endif
)brace
multiline_comment|/* do_magic() is implemented in arch/?/kernel/suspend_asm.S, and basically does:&n;&n;&t;if (!resume) {&n;&t;&t;do_magic_suspend_1();&n;&t;&t;save_processor_state();&n;&t;&t;SAVE_REGISTERS&n;&t;&t;do_magic_suspend_2();&n;&t;&t;return;&n;&t;}&n;&t;GO_TO_SWAPPER_PAGE_TABLES&n;&t;do_magic_resume_1();&n;&t;COPY_PAGES_BACK&n;&t;RESTORE_REGISTERS&n;&t;restore_processor_state();&n;&t;do_magic_resume_2();&n;&n; */
DECL|function|do_magic_suspend_1
r_void
id|do_magic_suspend_1
c_func
(paren
r_void
)paren
(brace
id|mb
c_func
(paren
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|in_atomic
c_func
(paren
)paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|suspend_pagedir_lock
)paren
suffix:semicolon
)brace
DECL|function|do_magic_suspend_2
r_void
id|do_magic_suspend_2
c_func
(paren
r_void
)paren
(brace
r_int
id|is_problem
suffix:semicolon
id|read_swapfiles
c_func
(paren
)paren
suffix:semicolon
id|is_problem
op_assign
id|suspend_prepare_image
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|suspend_pagedir_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_problem
)paren
(brace
id|kernel_fpu_end
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* save_processor_state() does kernel_fpu_begin, and we need to revert it in order to pass in_atomic() checks */
id|BUG_ON
c_func
(paren
id|in_atomic
c_func
(paren
)paren
)paren
suffix:semicolon
id|suspend_save_image
c_func
(paren
)paren
suffix:semicolon
id|suspend_power_down
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: if suspend_power_down is commented out, console is lost after few suspends ?! */
)brace
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;%sSuspend failed, trying to recover...&bslash;n&quot;
comma
id|name_suspend
)paren
suffix:semicolon
id|MDELAY
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* So user can wait and report us messages if armageddon comes :-) */
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|suspend_pagedir_lock
)paren
suffix:semicolon
multiline_comment|/* Done to disable interrupts */
id|mdelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|pagedir_nosave
comma
id|pagedir_order
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|suspend_pagedir_lock
)paren
suffix:semicolon
id|mark_swapfiles
c_func
(paren
(paren
(paren
id|swp_entry_t
)paren
(brace
l_int|0
)brace
)paren
comma
id|MARK_SWAP_RESUME
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
id|KERN_WARNING
l_string|&quot;%sLeaving do_magic_suspend_2...&bslash;n&quot;
comma
id|name_suspend
)paren
suffix:semicolon
)brace
DECL|function|do_software_suspend
r_static
r_void
id|do_software_suspend
c_func
(paren
r_void
)paren
(brace
id|arch_prepare_suspend
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prepare_suspend_console
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;%sCan&squot;t allocate a console... proceeding&bslash;n&quot;
comma
id|name_suspend
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prepare_suspend_processes
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* At this point, all user processes and &quot;dangerous&quot;&n;                   kernel threads are stopped. Free some memory, as we&n;                   need half of memory free. */
id|free_some_memory
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* No need to invalidate any vfsmnt list -- they will be valid after resume, anyway.&n;&t;&t; *&n;&t;&t; * We sync here -- so you have consistent filesystem state when things go wrong.&n;&t;&t; * -- so that noone writes to disk after we do atomic copy of data.&n;&t;&t; */
id|PRINTK
c_func
(paren
l_string|&quot;Syncing disks before copy&bslash;n&quot;
)paren
suffix:semicolon
id|do_suspend_sync
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Save state of all device drivers, and stop them. */
r_if
c_cond
(paren
id|drivers_suspend
c_func
(paren
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* If stopping device drivers worked, we proceed basically into&n;&t;&t;&t; * suspend_save_image.&n;&t;&t;&t; *&n;&t;&t;&t; * do_magic(0) returns after system is resumed.&n;&t;&t;&t; *&n;&t;&t;&t; * do_magic() copies all &quot;used&quot; memory to &quot;free&quot; memory, then&n;&t;&t;&t; * unsuspends all device drivers, and writes memory to disk&n;&t;&t;&t; * using normal kernel mechanism.&n;&t;&t;&t; */
id|do_magic
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|PRINTK
c_func
(paren
l_string|&quot;Restarting processes...&bslash;n&quot;
)paren
suffix:semicolon
id|thaw_processes
c_func
(paren
)paren
suffix:semicolon
)brace
id|software_suspend_enabled
op_assign
l_int|1
suffix:semicolon
id|MDELAY
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|restore_console
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is main interface to the outside world. It needs to be&n; * called from process context.&n; */
DECL|function|software_suspend
r_void
id|software_suspend
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|software_suspend_enabled
)paren
(brace
r_return
suffix:semicolon
)brace
id|software_suspend_enabled
op_assign
l_int|0
suffix:semicolon
id|BUG_ON
c_func
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
suffix:semicolon
id|do_software_suspend
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* More restore stuff */
multiline_comment|/* FIXME: Why not memcpy(to, from, 1&lt;&lt;pagedir_order*PAGE_SIZE)? */
DECL|function|copy_pagedir
r_static
r_void
id|copy_pagedir
c_func
(paren
id|suspend_pagedir_t
op_star
id|to
comma
id|suspend_pagedir_t
op_star
id|from
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|topointer
op_assign
(paren
r_char
op_star
)paren
id|to
comma
op_star
id|frompointer
op_assign
(paren
r_char
op_star
)paren
id|from
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1
op_lshift
id|pagedir_order
suffix:semicolon
id|i
op_increment
)paren
(brace
id|copy_page
c_func
(paren
id|topointer
comma
id|frompointer
)paren
suffix:semicolon
id|topointer
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|frompointer
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
DECL|macro|does_collide
mdefine_line|#define does_collide(addr) does_collide_order(pagedir_nosave, addr, 0)
multiline_comment|/*&n; * Returns true if given address/order collides with any orig_address &n; */
DECL|function|does_collide_order
r_static
r_int
id|does_collide_order
c_func
(paren
id|suspend_pagedir_t
op_star
id|pagedir
comma
r_int
r_int
id|addr
comma
r_int
id|order
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|addre
op_assign
id|addr
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_copy_pages
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|pagedir
op_plus
id|i
)paren
op_member_access_from_pointer
id|orig_address
op_ge
id|addr
op_logical_and
(paren
id|pagedir
op_plus
id|i
)paren
op_member_access_from_pointer
id|orig_address
OL
id|addre
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We check here that pagedir &amp; pages it points to won&squot;t collide with pages&n; * where we&squot;re going to restore from the loaded pages later&n; */
DECL|function|check_pagedir
r_static
r_int
id|check_pagedir
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_copy_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_do
(brace
id|addr
op_assign
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|does_collide
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
(paren
id|pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|address
op_assign
id|addr
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|relocate_pagedir
r_static
r_int
id|relocate_pagedir
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * We have to avoid recursion (not to overflow kernel stack),&n;&t; * and that&squot;s why code looks pretty cryptic &n;&t; */
id|suspend_pagedir_t
op_star
id|new_pagedir
comma
op_star
id|old_pagedir
op_assign
id|pagedir_nosave
suffix:semicolon
r_void
op_star
op_star
id|eaten_memory
op_assign
l_int|NULL
suffix:semicolon
r_void
op_star
op_star
id|c
op_assign
id|eaten_memory
comma
op_star
id|m
comma
op_star
id|f
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Relocating pagedir&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|does_collide_order
c_func
(paren
id|old_pagedir
comma
(paren
r_int
r_int
)paren
id|old_pagedir
comma
id|pagedir_order
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;not necessary&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|m
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|pagedir_order
)paren
)paren
)paren
(brace
id|memset
c_func
(paren
id|m
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|does_collide_order
c_func
(paren
id|old_pagedir
comma
(paren
r_int
r_int
)paren
id|m
comma
id|pagedir_order
)paren
)paren
r_break
suffix:semicolon
id|eaten_memory
op_assign
id|m
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
op_star
id|eaten_memory
op_assign
id|c
suffix:semicolon
id|c
op_assign
id|eaten_memory
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|m
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|pagedir_nosave
op_assign
id|new_pagedir
op_assign
id|m
suffix:semicolon
id|copy_pagedir
c_func
(paren
id|new_pagedir
comma
id|old_pagedir
)paren
suffix:semicolon
id|c
op_assign
id|eaten_memory
suffix:semicolon
r_while
c_loop
(paren
id|c
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;:&quot;
)paren
suffix:semicolon
id|f
op_assign
op_star
id|c
suffix:semicolon
id|c
op_assign
op_star
id|c
suffix:semicolon
r_if
c_cond
(paren
id|f
)paren
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|f
comma
id|pagedir_order
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;|&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Sanity check if this image makes sense with this kernel/swap context&n; * I really don&squot;t think that it&squot;s foolproof but more than nothing..&n; */
DECL|function|sanity_check_failed
r_static
r_int
id|sanity_check_failed
c_func
(paren
r_char
op_star
id|reason
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s%s&bslash;n&quot;
comma
id|name_resume
comma
id|reason
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
DECL|function|sanity_check
r_static
r_int
id|sanity_check
c_func
(paren
r_struct
id|suspend_header
op_star
id|sh
)paren
(brace
r_if
c_cond
(paren
id|sh-&gt;version_code
op_ne
id|LINUX_VERSION_CODE
)paren
(brace
r_return
id|sanity_check_failed
c_func
(paren
l_string|&quot;Incorrect kernel version&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sh-&gt;num_physpages
op_ne
id|num_physpages
)paren
(brace
r_return
id|sanity_check_failed
c_func
(paren
l_string|&quot;Incorrect memory size&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|sh-&gt;machine
comma
id|system_utsname.machine
comma
l_int|8
)paren
)paren
(brace
r_return
id|sanity_check_failed
c_func
(paren
l_string|&quot;Incorrect machine type&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|sh-&gt;version
comma
id|system_utsname.version
comma
l_int|20
)paren
)paren
(brace
r_return
id|sanity_check_failed
c_func
(paren
l_string|&quot;Incorrect version&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sh-&gt;num_cpus
op_ne
id|num_online_cpus
c_func
(paren
)paren
)paren
(brace
r_return
id|sanity_check_failed
c_func
(paren
l_string|&quot;Incorrect number of cpus&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sh-&gt;page_size
op_ne
id|PAGE_SIZE
)paren
(brace
r_return
id|sanity_check_failed
c_func
(paren
l_string|&quot;Incorrect PAGE_SIZE&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bdev_read_page
r_static
r_int
id|bdev_read_page
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
r_int
id|pos
comma
r_void
op_star
id|buf
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|BUG_ON
(paren
id|pos
op_mod
id|PAGE_SIZE
)paren
suffix:semicolon
id|bh
op_assign
id|__bread
c_func
(paren
id|bdev
comma
id|pos
op_div
id|PAGE_SIZE
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
op_logical_or
(paren
op_logical_neg
id|bh-&gt;b_data
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|buf
comma
id|bh-&gt;b_data
comma
id|PAGE_SIZE
)paren
suffix:semicolon
multiline_comment|/* FIXME: may need kmap() */
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bdev_write_page
r_static
r_int
id|bdev_write_page
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
r_int
id|pos
comma
r_void
op_star
id|buf
)paren
(brace
macro_line|#if 0
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|BUG_ON
(paren
id|pos
op_mod
id|PAGE_SIZE
)paren
suffix:semicolon
id|bh
op_assign
id|__bread
c_func
(paren
id|bdev
comma
id|pos
op_div
id|PAGE_SIZE
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
op_logical_or
(paren
op_logical_neg
id|bh-&gt;b_data
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|bh-&gt;b_data
comma
id|buf
comma
id|PAGE_SIZE
)paren
suffix:semicolon
multiline_comment|/* FIXME: may need kmap() */
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|generic_make_request
c_func
(paren
id|WRITE
comma
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%sWarning %s: Fixing swap signatures unsuccessful...&bslash;n&quot;
comma
id|name_resume
comma
id|resume_file
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%sWarning %s: Fixing swap signatures unimplemented...&bslash;n&quot;
comma
id|name_resume
comma
id|resume_file
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_extern
id|dev_t
id|__init
id|name_to_dev_t
c_func
(paren
r_const
r_char
op_star
id|line
)paren
suffix:semicolon
DECL|function|__read_suspend_image
r_static
r_int
id|__read_suspend_image
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
r_union
id|diskpage
op_star
id|cur
comma
r_int
id|noresume
)paren
(brace
id|swp_entry_t
id|next
suffix:semicolon
r_int
id|i
comma
id|nr_pgdir_pages
suffix:semicolon
DECL|macro|PREPARENEXT
mdefine_line|#define PREPARENEXT &bslash;&n;&t;{&t;next = cur-&gt;link.next; &bslash;&n;&t;&t;next.val = swp_offset(next) * PAGE_SIZE; &bslash;&n;        }
r_if
c_cond
(paren
id|bdev_read_page
c_func
(paren
id|bdev
comma
l_int|0
comma
id|cur
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;SWAP-SPACE&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|10
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;SWAPSPACE2&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|10
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%sThis is normal swap space&bslash;n&quot;
comma
id|name_resume
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|PREPARENEXT
suffix:semicolon
multiline_comment|/* We have to read next position before we overwrite it */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;S1&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|2
)paren
)paren
id|memcpy
c_func
(paren
id|cur-&gt;swh.magic.magic
comma
l_string|&quot;SWAP-SPACE&quot;
comma
l_int|10
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;S2&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|2
)paren
)paren
id|memcpy
c_func
(paren
id|cur-&gt;swh.magic.magic
comma
l_string|&quot;SWAPSPACE2&quot;
comma
l_int|10
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|noresume
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;%sUnable to find suspended-data signature (%.10s - misspelled?&bslash;n&quot;
comma
id|name_resume
comma
id|cur-&gt;swh.magic.magic
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|noresume
)paren
(brace
multiline_comment|/* We don&squot;t do a sanity check here: we want to restore the swap&n;&t;&t;   whatever version of kernel made the suspend image;&n;&t;&t;   We need to write swap, but swap is *not* enabled so&n;&t;&t;   we must write the device directly */
id|printk
c_func
(paren
l_string|&quot;%s: Fixing swap signatures %s...&bslash;n&quot;
comma
id|name_resume
comma
id|resume_file
)paren
suffix:semicolon
id|bdev_write_page
c_func
(paren
id|bdev
comma
l_int|0
comma
id|cur
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prepare_suspend_console
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;%sCan&squot;t allocate a console... proceeding&bslash;n&quot;
comma
id|name_resume
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%sSignature found, resuming&bslash;n&quot;
comma
id|name_resume
)paren
suffix:semicolon
id|MDELAY
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdev_read_page
c_func
(paren
id|bdev
comma
id|next.val
comma
id|cur
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|sanity_check
c_func
(paren
op_amp
id|cur-&gt;sh
)paren
)paren
multiline_comment|/* Is this same machine? */
r_return
op_minus
id|EPERM
suffix:semicolon
id|PREPARENEXT
suffix:semicolon
id|pagedir_save
op_assign
id|cur-&gt;sh.suspend_pagedir
suffix:semicolon
id|nr_copy_pages
op_assign
id|cur-&gt;sh.num_pbes
suffix:semicolon
id|nr_pgdir_pages
op_assign
id|SUSPEND_PD_PAGES
c_func
(paren
id|nr_copy_pages
)paren
suffix:semicolon
id|pagedir_order
op_assign
id|get_bitmask_order
c_func
(paren
id|nr_pgdir_pages
)paren
suffix:semicolon
id|pagedir_nosave
op_assign
(paren
id|suspend_pagedir_t
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|pagedir_order
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagedir_nosave
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;%sReading pagedir, &quot;
comma
id|name_resume
)paren
suffix:semicolon
multiline_comment|/* We get pages in reverse order of saving! */
r_for
c_loop
(paren
id|i
op_assign
id|nr_pgdir_pages
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|BUG_ON
(paren
op_logical_neg
id|next.val
)paren
suffix:semicolon
id|cur
op_assign
(paren
r_union
id|diskpage
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|pagedir_nosave
)paren
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|bdev_read_page
c_func
(paren
id|bdev
comma
id|next.val
comma
id|cur
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|PREPARENEXT
suffix:semicolon
)brace
id|BUG_ON
(paren
id|next.val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|relocate_pagedir
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|check_pagedir
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Reading image data (%d pages): &quot;
comma
id|nr_copy_pages
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_copy_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
id|swp_entry_t
id|swap_address
op_assign
(paren
id|pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|swap_address
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_mod
l_int|100
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
multiline_comment|/* You do not need to check for overlaps...&n;&t;&t;   ... check_pagedir already did this work */
r_if
c_cond
(paren
id|bdev_read_page
c_func
(paren
id|bdev
comma
id|swp_offset
c_func
(paren
id|swap_address
)paren
op_star
id|PAGE_SIZE
comma
(paren
r_char
op_star
)paren
(paren
(paren
id|pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|address
)paren
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;|&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_suspend_image
r_static
r_int
id|read_suspend_image
c_func
(paren
r_const
r_char
op_star
id|specialfile
comma
r_int
id|noresume
)paren
(brace
r_union
id|diskpage
op_star
id|cur
suffix:semicolon
r_int
r_int
id|scratch_page
op_assign
l_int|0
suffix:semicolon
r_int
id|error
suffix:semicolon
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|resume_device
op_assign
id|name_to_dev_t
c_func
(paren
id|specialfile
)paren
suffix:semicolon
id|scratch_page
op_assign
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
id|cur
op_assign
(paren
r_void
op_star
)paren
id|scratch_page
suffix:semicolon
r_if
c_cond
(paren
id|cur
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Resuming from device %s&bslash;n&quot;
comma
id|__bdevname
c_func
(paren
id|resume_device
comma
id|b
)paren
)paren
suffix:semicolon
id|bdev
op_assign
id|open_by_devnum
c_func
(paren
id|resume_device
comma
id|FMODE_READ
comma
id|BDEV_RAW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|bdev
)paren
)paren
(brace
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|bdev
)paren
suffix:semicolon
)brace
r_else
(brace
id|set_blocksize
c_func
(paren
id|bdev
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|error
op_assign
id|__read_suspend_image
c_func
(paren
id|bdev
comma
id|cur
comma
id|noresume
)paren
suffix:semicolon
id|blkdev_put
c_func
(paren
id|bdev
comma
id|BDEV_RAW
)paren
suffix:semicolon
)brace
)brace
r_else
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|scratch_page
)paren
id|free_page
c_func
(paren
id|scratch_page
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|error
)paren
(brace
r_case
l_int|0
suffix:colon
id|PRINTK
c_func
(paren
l_string|&quot;Reading resume file was successful&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EINVAL
suffix:colon
r_break
suffix:semicolon
r_case
op_minus
id|EIO
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%sI/O error&bslash;n&quot;
comma
id|name_resume
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ENOENT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s%s: No such file or directory&bslash;n&quot;
comma
id|name_resume
comma
id|specialfile
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ENOMEM
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%sNot enough memory&bslash;n&quot;
comma
id|name_resume
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%sError %d resuming&bslash;n&quot;
comma
id|name_resume
comma
id|error
)paren
suffix:semicolon
)brace
id|MDELAY
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Called from init kernel_thread.&n; * We check if we have an image and if so we try to resume&n; */
DECL|function|software_resume
r_void
id|software_resume
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|num_online_cpus
c_func
(paren
)paren
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Software Suspend has malfunctioning SMP support. Disabled :(&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* We enable the possibility of machine suspend */
id|software_suspend_enabled
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|resume_status
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|name_resume
)paren
suffix:semicolon
r_if
c_cond
(paren
id|resume_status
op_eq
id|NORESUME
)paren
(brace
r_if
c_cond
(paren
id|resume_file
(braket
l_int|0
)braket
)paren
(brace
id|read_suspend_image
c_func
(paren
id|resume_file
comma
l_int|1
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;disabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|MDELAY
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|orig_loglevel
op_assign
id|console_loglevel
suffix:semicolon
id|console_loglevel
op_assign
id|new_loglevel
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|resume_file
(braket
l_int|0
)braket
op_logical_and
id|resume_status
op_eq
id|RESUME_SPECIFIED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;suspension device unspecified&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;resuming from %s&bslash;n&quot;
comma
id|resume_file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_suspend_image
c_func
(paren
id|resume_file
comma
l_int|0
)paren
)paren
r_goto
id|read_failure
suffix:semicolon
id|do_magic
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;This never returns&quot;
)paren
suffix:semicolon
id|read_failure
suffix:colon
id|console_loglevel
op_assign
id|orig_loglevel
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|resume_setup
r_static
r_int
id|__init
id|resume_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_if
c_cond
(paren
id|resume_status
op_eq
id|NORESUME
)paren
r_return
l_int|1
suffix:semicolon
id|strncpy
c_func
(paren
id|resume_file
comma
id|str
comma
l_int|255
)paren
suffix:semicolon
id|resume_status
op_assign
id|RESUME_SPECIFIED
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|noresume_setup
r_static
r_int
id|__init
id|noresume_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|resume_status
op_assign
id|NORESUME
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;noresume&quot;
comma
id|noresume_setup
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;resume=&quot;
comma
id|resume_setup
)paren
suffix:semicolon
DECL|variable|software_suspend
id|EXPORT_SYMBOL
c_func
(paren
id|software_suspend
)paren
suffix:semicolon
DECL|variable|software_suspend_enabled
id|EXPORT_SYMBOL
c_func
(paren
id|software_suspend_enabled
)paren
suffix:semicolon
DECL|variable|refrigerator
id|EXPORT_SYMBOL
c_func
(paren
id|refrigerator
)paren
suffix:semicolon
eof
