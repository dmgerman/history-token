multiline_comment|/*&n; * linux/kernel/power/swsusp.c&n; *&n; * This file is to realize architecture-independent&n; * machine suspend feature using pretty near only high-level routines&n; *&n; * Copyright (C) 1998-2001 Gabor Kuti &lt;seasons@fornax.hu&gt;&n; * Copyright (C) 1998,2001-2004 Pavel Machek &lt;pavel@suse.cz&gt;&n; *&n; * This file is released under the GPLv2.&n; *&n; * I&squot;d like to thank the following people for their work:&n; * &n; * Pavel Machek &lt;pavel@ucw.cz&gt;:&n; * Modifications, defectiveness pointing, being with me at the very beginning,&n; * suspend to swap space, stop all tasks. Port to 2.4.18-ac and 2.5.17.&n; *&n; * Steve Doddi &lt;dirk@loth.demon.co.uk&gt;: &n; * Support the possibility of hardware state restoring.&n; *&n; * Raph &lt;grey.havens@earthling.net&gt;:&n; * Support for preserving states of network devices and virtual console&n; * (including X and svgatextmode)&n; *&n; * Kurt Garloff &lt;garloff@suse.de&gt;:&n; * Straightened the critical function in order to prevent compilers from&n; * playing tricks with local variables.&n; *&n; * Andreas Mohr &lt;a.mohr@mailto.de&gt;&n; *&n; * Alex Badea &lt;vampire@go.ro&gt;:&n; * Fixed runaway init&n; *&n; * More state savers are welcome. Especially for the scsi layer...&n; *&n; * For TODOs,FIXMEs also look in Documentation/power/swsusp.txt&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/utsname.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/vt_kern.h&gt;
macro_line|#include &lt;linux/kbd_kern.h&gt;
macro_line|#include &lt;linux/keyboard.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/pm.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/swapops.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/syscalls.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;power.h&quot;
DECL|variable|software_suspend_enabled
r_int
r_char
id|software_suspend_enabled
op_assign
l_int|0
suffix:semicolon
DECL|macro|NORESUME
mdefine_line|#define NORESUME&t;&t;1
DECL|macro|RESUME_SPECIFIED
mdefine_line|#define RESUME_SPECIFIED&t;2
multiline_comment|/* References to section boundaries */
r_extern
r_char
id|__nosave_begin
comma
id|__nosave_end
suffix:semicolon
r_extern
r_int
id|is_head_of_free_region
c_func
(paren
r_struct
id|page
op_star
)paren
suffix:semicolon
multiline_comment|/* Locks */
DECL|variable|__nosavedata
id|spinlock_t
id|suspend_pagedir_lock
id|__nosavedata
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* Variables to be preserved over suspend */
DECL|variable|pagedir_order_check
r_static
r_int
id|pagedir_order_check
suffix:semicolon
DECL|variable|nr_copy_pages_check
r_static
r_int
id|nr_copy_pages_check
suffix:semicolon
DECL|variable|resume_status
r_static
r_int
id|resume_status
suffix:semicolon
DECL|variable|resume_file
r_static
r_char
id|resume_file
(braket
l_int|256
)braket
op_assign
l_string|&quot;&quot;
suffix:semicolon
multiline_comment|/* For resume= kernel option */
DECL|variable|resume_device
r_static
id|dev_t
id|resume_device
suffix:semicolon
multiline_comment|/* Local variables that should not be affected by save */
DECL|variable|__nosavedata
r_int
r_int
id|nr_copy_pages
id|__nosavedata
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Suspend pagedir is allocated before final copy, therefore it&n;   must be freed after resume &n;&n;   Warning: this is evil. There are actually two pagedirs at time of&n;   resume. One is &quot;pagedir_save&quot;, which is empty frame allocated at&n;   time of suspend, that must be freed. Second is &quot;pagedir_nosave&quot;, &n;   allocated at time of resume, that travels through memory not to&n;   collide with anything.&n;&n;   Warning: this is even more evil than it seems. Pagedirs this file&n;   talks about are completely different from page directories used by&n;   MMU hardware.&n; */
DECL|variable|__nosavedata
id|suspend_pagedir_t
op_star
id|pagedir_nosave
id|__nosavedata
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|pagedir_save
r_static
id|suspend_pagedir_t
op_star
id|pagedir_save
suffix:semicolon
DECL|variable|__nosavedata
r_static
r_int
id|pagedir_order
id|__nosavedata
op_assign
l_int|0
suffix:semicolon
DECL|struct|link
r_struct
id|link
(brace
DECL|member|dummy
r_char
id|dummy
(braket
id|PAGE_SIZE
op_minus
r_sizeof
(paren
id|swp_entry_t
)paren
)braket
suffix:semicolon
DECL|member|next
id|swp_entry_t
id|next
suffix:semicolon
)brace
suffix:semicolon
DECL|union|diskpage
r_union
id|diskpage
(brace
DECL|member|swh
r_union
id|swap_header
id|swh
suffix:semicolon
DECL|member|link
r_struct
id|link
id|link
suffix:semicolon
DECL|member|sh
r_struct
id|suspend_header
id|sh
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * XXX: We try to keep some more pages free so that I/O operations succeed&n; * without paging. Might this be more?&n; */
DECL|macro|PAGES_FOR_IO
mdefine_line|#define PAGES_FOR_IO&t;512
DECL|variable|name_suspend
r_static
r_const
r_char
id|name_suspend
(braket
)braket
op_assign
l_string|&quot;Suspend Machine: &quot;
suffix:semicolon
DECL|variable|name_resume
r_static
r_const
r_char
id|name_resume
(braket
)braket
op_assign
l_string|&quot;Resume Machine: &quot;
suffix:semicolon
multiline_comment|/*&n; * Debug&n; */
DECL|macro|DEBUG_DEFAULT
mdefine_line|#define&t;DEBUG_DEFAULT
DECL|macro|DEBUG_PROCESS
macro_line|#undef&t;DEBUG_PROCESS
DECL|macro|DEBUG_SLOW
macro_line|#undef&t;DEBUG_SLOW
DECL|macro|TEST_SWSUSP
mdefine_line|#define TEST_SWSUSP 0&t;&t;/* Set to 1 to reboot instead of halt machine after suspension */
macro_line|#ifdef DEBUG_DEFAULT
DECL|macro|PRINTK
macro_line|# define PRINTK(f, a...)&t;printk(f, ## a)
macro_line|#else
DECL|macro|PRINTK
macro_line|# define PRINTK(f, a...)       &t;do { } while(0)
macro_line|#endif
macro_line|#ifdef DEBUG_SLOW
DECL|macro|MDELAY
mdefine_line|#define MDELAY(a) mdelay(a)
macro_line|#else
DECL|macro|MDELAY
mdefine_line|#define MDELAY(a) do { } while(0)
macro_line|#endif
multiline_comment|/*&n; * Saving part...&n; */
DECL|function|fill_suspend_header
r_static
id|__inline__
r_int
id|fill_suspend_header
c_func
(paren
r_struct
id|suspend_header
op_star
id|sh
)paren
(brace
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|sh
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|sh
)paren
)paren
suffix:semicolon
id|sh-&gt;version_code
op_assign
id|LINUX_VERSION_CODE
suffix:semicolon
id|sh-&gt;num_physpages
op_assign
id|num_physpages
suffix:semicolon
id|strncpy
c_func
(paren
id|sh-&gt;machine
comma
id|system_utsname.machine
comma
l_int|8
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|sh-&gt;version
comma
id|system_utsname.version
comma
l_int|20
)paren
suffix:semicolon
multiline_comment|/* FIXME: Is this bogus? --RR */
id|sh-&gt;num_cpus
op_assign
id|num_online_cpus
c_func
(paren
)paren
suffix:semicolon
id|sh-&gt;page_size
op_assign
id|PAGE_SIZE
suffix:semicolon
id|sh-&gt;suspend_pagedir
op_assign
id|pagedir_nosave
suffix:semicolon
id|BUG_ON
(paren
id|pagedir_save
op_ne
id|pagedir_nosave
)paren
suffix:semicolon
id|sh-&gt;num_pbes
op_assign
id|nr_copy_pages
suffix:semicolon
multiline_comment|/* TODO: needed? mounted fs&squot; last mounted date comparison&n;&t; * [so they haven&squot;t been mounted since last suspend.&n;&t; * Maybe it isn&squot;t.] [we&squot;d need to do this for _all_ fs-es]&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We memorize in swapfile_used what swap devices are used for suspension */
DECL|macro|SWAPFILE_UNUSED
mdefine_line|#define SWAPFILE_UNUSED    0
DECL|macro|SWAPFILE_SUSPEND
mdefine_line|#define SWAPFILE_SUSPEND   1&t;/* This is the suspending device */
DECL|macro|SWAPFILE_IGNORED
mdefine_line|#define SWAPFILE_IGNORED   2&t;/* Those are other swap devices ignored for suspension */
DECL|variable|swapfile_used
r_static
r_int
r_int
id|swapfile_used
(braket
id|MAX_SWAPFILES
)braket
suffix:semicolon
DECL|variable|root_swap
r_static
r_int
r_int
id|root_swap
suffix:semicolon
DECL|macro|MARK_SWAP_SUSPEND
mdefine_line|#define MARK_SWAP_SUSPEND 0
DECL|macro|MARK_SWAP_RESUME
mdefine_line|#define MARK_SWAP_RESUME 2
DECL|function|mark_swapfiles
r_static
r_void
id|mark_swapfiles
c_func
(paren
id|swp_entry_t
id|prev
comma
r_int
id|mode
)paren
(brace
id|swp_entry_t
id|entry
suffix:semicolon
r_union
id|diskpage
op_star
id|cur
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_if
c_cond
(paren
id|root_swap
op_eq
l_int|0xFFFF
)paren
multiline_comment|/* ignored */
r_return
suffix:semicolon
id|page
op_assign
id|alloc_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
id|panic
c_func
(paren
l_string|&quot;Out of memory in mark_swapfiles&quot;
)paren
suffix:semicolon
id|cur
op_assign
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* XXX: this is dirty hack to get first page of swap file */
id|entry
op_assign
id|swp_entry
c_func
(paren
id|root_swap
comma
l_int|0
)paren
suffix:semicolon
id|rw_swap_page_sync
c_func
(paren
id|READ
comma
id|entry
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|MARK_SWAP_RESUME
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;S1&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|2
)paren
)paren
id|memcpy
c_func
(paren
id|cur-&gt;swh.magic.magic
comma
l_string|&quot;SWAP-SPACE&quot;
comma
l_int|10
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;S2&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|2
)paren
)paren
id|memcpy
c_func
(paren
id|cur-&gt;swh.magic.magic
comma
l_string|&quot;SWAPSPACE2&quot;
comma
l_int|10
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%sUnable to find suspended-data signature (%.10s - misspelled?&bslash;n&quot;
comma
id|name_resume
comma
id|cur-&gt;swh.magic.magic
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;SWAP-SPACE&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|10
)paren
)paren
)paren
id|memcpy
c_func
(paren
id|cur-&gt;swh.magic.magic
comma
l_string|&quot;S1SUSP....&quot;
comma
l_int|10
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;SWAPSPACE2&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|10
)paren
)paren
)paren
id|memcpy
c_func
(paren
id|cur-&gt;swh.magic.magic
comma
l_string|&quot;S2SUSP....&quot;
comma
l_int|10
)paren
suffix:semicolon
r_else
id|panic
c_func
(paren
l_string|&quot;&bslash;nSwapspace is not swapspace (%.10s)&bslash;n&quot;
comma
id|cur-&gt;swh.magic.magic
)paren
suffix:semicolon
id|cur-&gt;link.next
op_assign
id|prev
suffix:semicolon
multiline_comment|/* prev is the first/last swap page of the resume area */
multiline_comment|/* link.next lies *no more* in last 4/8 bytes of magic */
)brace
id|rw_swap_page_sync
c_func
(paren
id|WRITE
comma
id|entry
comma
id|page
)paren
suffix:semicolon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|function|read_swapfiles
r_static
r_void
id|read_swapfiles
c_func
(paren
r_void
)paren
multiline_comment|/* This is called before saving image */
(brace
r_int
id|i
comma
id|len
suffix:semicolon
r_char
id|buff
(braket
r_sizeof
(paren
id|resume_file
)paren
)braket
comma
op_star
id|sname
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|resume_file
)paren
suffix:semicolon
id|root_swap
op_assign
l_int|0xFFFF
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SWAPFILES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|swap_info
(braket
id|i
)braket
dot
id|flags
op_eq
l_int|0
)paren
(brace
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_UNUSED
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;resume= option should be used to set suspend device&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root_swap
op_eq
l_int|0xFFFF
)paren
(brace
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_SUSPEND
suffix:semicolon
id|root_swap
op_assign
id|i
suffix:semicolon
)brace
r_else
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_IGNORED
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we ignore all swap devices that are not the resume_file */
id|sname
op_assign
id|d_path
c_func
(paren
id|swap_info
(braket
id|i
)braket
dot
id|swap_file-&gt;f_dentry
comma
id|swap_info
(braket
id|i
)braket
dot
id|swap_file-&gt;f_vfsmnt
comma
id|buff
comma
r_sizeof
(paren
id|buff
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|sname
comma
id|resume_file
)paren
)paren
(brace
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_SUSPEND
suffix:semicolon
id|root_swap
op_assign
id|i
suffix:semicolon
)brace
r_else
(brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;Resume: device %s (%x != %x) ignored&bslash;n&quot;
comma
id|swap_info
(braket
id|i
)braket
dot
id|swap_file-&gt;d_name.name
comma
id|swap_info
(braket
id|i
)braket
dot
id|swap_device
comma
id|resume_device
)paren
suffix:semicolon
macro_line|#endif
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_IGNORED
suffix:semicolon
)brace
)brace
)brace
)brace
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|lock_swapdevices
r_static
r_void
id|lock_swapdevices
c_func
(paren
r_void
)paren
multiline_comment|/* This is called after saving image so modification&n;&t;&t;&t;&t;      will be lost after resume... and that&squot;s what we want. */
(brace
r_int
id|i
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SWAPFILES
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|swapfile_used
(braket
id|i
)braket
op_eq
id|SWAPFILE_IGNORED
)paren
(brace
id|swap_info
(braket
id|i
)braket
dot
id|flags
op_xor_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/* we make the device unusable. A new call to&n;&t;&t;&t;&t;&t;&t;       lock_swapdevices can unlock the devices. */
)brace
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *    write_suspend_image - Write entire image to disk.&n; *&n; *    After writing suspend signature to the disk, suspend may no&n; *    longer fail: we have ready-to-run image in swap, and rollback&n; *    would happen on next reboot -- corrupting data.&n; *&n; *    Note: The buffer we allocate to use to write the suspend header is&n; *    not freed; its not needed since the system is going down anyway&n; *    (plus it causes an oops and I&squot;m lazy^H^H^H^Htoo busy).&n; */
DECL|function|write_suspend_image
r_static
r_int
id|write_suspend_image
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|swp_entry_t
id|entry
comma
id|prev
op_assign
(brace
l_int|0
)brace
suffix:semicolon
r_int
id|nr_pgdir_pages
op_assign
id|SUSPEND_PD_PAGES
c_func
(paren
id|nr_copy_pages
)paren
suffix:semicolon
r_union
id|diskpage
op_star
id|cur
comma
op_star
id|buffer
op_assign
(paren
r_union
id|diskpage
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Writing data to swap (%d pages): &quot;
comma
id|nr_copy_pages
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_copy_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_mod
l_int|100
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry
op_assign
id|get_swap_page
c_func
(paren
)paren
)paren
dot
id|val
)paren
id|panic
c_func
(paren
l_string|&quot;&bslash;nNot enough swapspace when writing data&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|swapfile_used
(braket
id|swp_type
c_func
(paren
id|entry
)paren
)braket
op_ne
id|SWAPFILE_SUSPEND
)paren
id|panic
c_func
(paren
l_string|&quot;&bslash;nPage %d: not enough swapspace on suspend device&quot;
comma
id|i
)paren
suffix:semicolon
id|address
op_assign
(paren
id|pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|address
suffix:semicolon
id|page
op_assign
id|virt_to_page
c_func
(paren
id|address
)paren
suffix:semicolon
id|rw_swap_page_sync
c_func
(paren
id|WRITE
comma
id|entry
comma
id|page
)paren
suffix:semicolon
(paren
id|pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|swap_address
op_assign
id|entry
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;|&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Writing pagedir (%d pages): &quot;
comma
id|nr_pgdir_pages
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_pgdir_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cur
op_assign
(paren
r_union
id|diskpage
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|pagedir_nosave
)paren
op_plus
id|i
suffix:semicolon
id|BUG_ON
(paren
(paren
r_char
op_star
)paren
id|cur
op_ne
(paren
(paren
(paren
r_char
op_star
)paren
id|pagedir_nosave
)paren
op_plus
id|i
op_star
id|PAGE_SIZE
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry
op_assign
id|get_swap_page
c_func
(paren
)paren
)paren
dot
id|val
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Not enough swapspace when writing pgdir&bslash;n&quot;
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Don&squot;t know how to recover&quot;
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|buffer
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_if
c_cond
(paren
id|swapfile_used
(braket
id|swp_type
c_func
(paren
id|entry
)paren
)braket
op_ne
id|SWAPFILE_SUSPEND
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;&bslash;nNot enough swapspace for pagedir on suspend device&quot;
)paren
suffix:semicolon
)brace
id|BUG_ON
(paren
r_sizeof
(paren
id|swp_entry_t
)paren
op_ne
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|BUG_ON
(paren
id|PAGE_SIZE
op_mod
r_sizeof
(paren
r_struct
id|pbe
)paren
)paren
suffix:semicolon
id|cur-&gt;link.next
op_assign
id|prev
suffix:semicolon
id|page
op_assign
id|virt_to_page
c_func
(paren
(paren
r_int
r_int
)paren
id|cur
)paren
suffix:semicolon
id|rw_swap_page_sync
c_func
(paren
id|WRITE
comma
id|entry
comma
id|page
)paren
suffix:semicolon
id|prev
op_assign
id|entry
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;H&quot;
)paren
suffix:semicolon
id|BUG_ON
(paren
r_sizeof
(paren
r_struct
id|suspend_header
)paren
OG
id|PAGE_SIZE
op_minus
r_sizeof
(paren
id|swp_entry_t
)paren
)paren
suffix:semicolon
id|BUG_ON
(paren
r_sizeof
(paren
r_union
id|diskpage
)paren
op_ne
id|PAGE_SIZE
)paren
suffix:semicolon
id|BUG_ON
(paren
r_sizeof
(paren
r_struct
id|link
)paren
op_ne
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry
op_assign
id|get_swap_page
c_func
(paren
)paren
)paren
dot
id|val
)paren
id|panic
c_func
(paren
l_string|&quot;&bslash;nNot enough swapspace when writing header&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|swapfile_used
(braket
id|swp_type
c_func
(paren
id|entry
)paren
)braket
op_ne
id|SWAPFILE_SUSPEND
)paren
id|panic
c_func
(paren
l_string|&quot;&bslash;nNot enough swapspace for header on suspend device&quot;
)paren
suffix:semicolon
id|cur
op_assign
(paren
r_void
op_star
)paren
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|fill_suspend_header
c_func
(paren
op_amp
id|cur-&gt;sh
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Not a BUG_ON(): we want fill_suspend_header to be called, always */
id|cur-&gt;link.next
op_assign
id|prev
suffix:semicolon
id|page
op_assign
id|virt_to_page
c_func
(paren
(paren
r_int
r_int
)paren
id|cur
)paren
suffix:semicolon
id|rw_swap_page_sync
c_func
(paren
id|WRITE
comma
id|entry
comma
id|page
)paren
suffix:semicolon
id|prev
op_assign
id|entry
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;S&quot;
)paren
suffix:semicolon
id|mark_swapfiles
c_func
(paren
id|prev
comma
id|MARK_SWAP_SUSPEND
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;|&bslash;n&quot;
)paren
suffix:semicolon
id|MDELAY
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|struct|highmem_page
r_struct
id|highmem_page
(brace
DECL|member|data
r_char
op_star
id|data
suffix:semicolon
DECL|member|page
r_struct
id|page
op_star
id|page
suffix:semicolon
DECL|member|next
r_struct
id|highmem_page
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|highmem_copy
r_struct
id|highmem_page
op_star
id|highmem_copy
op_assign
l_int|NULL
suffix:semicolon
DECL|function|save_highmem_zone
r_static
r_void
id|save_highmem_zone
c_func
(paren
r_struct
id|zone
op_star
id|zone
)paren
(brace
r_int
r_int
id|zone_pfn
suffix:semicolon
r_for
c_loop
(paren
id|zone_pfn
op_assign
l_int|0
suffix:semicolon
id|zone_pfn
OL
id|zone-&gt;spanned_pages
suffix:semicolon
op_increment
id|zone_pfn
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_struct
id|highmem_page
op_star
id|save
suffix:semicolon
r_void
op_star
id|kaddr
suffix:semicolon
r_int
r_int
id|pfn
op_assign
id|zone_pfn
op_plus
id|zone-&gt;zone_start_pfn
suffix:semicolon
r_int
id|chunk_size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pfn
op_mod
l_int|200
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pfn_valid
c_func
(paren
id|pfn
)paren
)paren
r_continue
suffix:semicolon
id|page
op_assign
id|pfn_to_page
c_func
(paren
id|pfn
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This condition results from rvmalloc() sans vmalloc_32()&n;&t;&t; * and architectural memory reservations. This should be&n;&t;&t; * corrected eventually when the cases giving rise to this&n;&t;&t; * are better understood.&n;&t;&t; */
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|page
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;highmem reserved page?!&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|chunk_size
op_assign
id|is_head_of_free_region
c_func
(paren
id|page
)paren
)paren
)paren
(brace
id|pfn
op_add_assign
id|chunk_size
op_minus
l_int|1
suffix:semicolon
id|zone_pfn
op_add_assign
id|chunk_size
op_minus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|save
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|highmem_page
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|save
)paren
id|panic
c_func
(paren
l_string|&quot;Not enough memory&quot;
)paren
suffix:semicolon
id|save-&gt;next
op_assign
id|highmem_copy
suffix:semicolon
id|save-&gt;page
op_assign
id|page
suffix:semicolon
id|save-&gt;data
op_assign
(paren
r_void
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|save-&gt;data
)paren
id|panic
c_func
(paren
l_string|&quot;Not enough memory&quot;
)paren
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|save-&gt;data
comma
id|kaddr
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|highmem_copy
op_assign
id|save
suffix:semicolon
)brace
)brace
DECL|function|save_highmem
r_static
r_void
id|save_highmem
c_func
(paren
r_void
)paren
(brace
r_struct
id|zone
op_star
id|zone
suffix:semicolon
id|for_each_zone
c_func
(paren
id|zone
)paren
(brace
r_if
c_cond
(paren
id|is_highmem
c_func
(paren
id|zone
)paren
)paren
id|save_highmem_zone
c_func
(paren
id|zone
)paren
suffix:semicolon
)brace
)brace
DECL|function|restore_highmem
r_static
r_int
id|restore_highmem
c_func
(paren
r_void
)paren
(brace
r_while
c_loop
(paren
id|highmem_copy
)paren
(brace
r_struct
id|highmem_page
op_star
id|save
op_assign
id|highmem_copy
suffix:semicolon
r_void
op_star
id|kaddr
suffix:semicolon
id|highmem_copy
op_assign
id|save-&gt;next
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|save-&gt;page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|kaddr
comma
id|save-&gt;data
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
)paren
id|save-&gt;data
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|save
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pfn_is_nosave
r_static
r_int
id|pfn_is_nosave
c_func
(paren
r_int
r_int
id|pfn
)paren
(brace
r_int
r_int
id|nosave_begin_pfn
op_assign
id|__pa
c_func
(paren
op_amp
id|__nosave_begin
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_int
r_int
id|nosave_end_pfn
op_assign
id|PAGE_ALIGN
c_func
(paren
id|__pa
c_func
(paren
op_amp
id|__nosave_end
)paren
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_return
(paren
id|pfn
op_ge
id|nosave_begin_pfn
)paren
op_logical_and
(paren
id|pfn
OL
id|nosave_end_pfn
)paren
suffix:semicolon
)brace
multiline_comment|/* if *pagedir_p != NULL it also copies the counted pages */
DECL|function|count_and_copy_zone
r_static
r_int
id|count_and_copy_zone
c_func
(paren
r_struct
id|zone
op_star
id|zone
comma
r_struct
id|pbe
op_star
op_star
id|pagedir_p
)paren
(brace
r_int
r_int
id|zone_pfn
comma
id|chunk_size
comma
id|nr_copy_pages
op_assign
l_int|0
suffix:semicolon
r_struct
id|pbe
op_star
id|pbe
op_assign
op_star
id|pagedir_p
suffix:semicolon
r_for
c_loop
(paren
id|zone_pfn
op_assign
l_int|0
suffix:semicolon
id|zone_pfn
OL
id|zone-&gt;spanned_pages
suffix:semicolon
op_increment
id|zone_pfn
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|pfn
op_assign
id|zone_pfn
op_plus
id|zone-&gt;zone_start_pfn
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pfn
op_mod
l_int|200
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pfn_valid
c_func
(paren
id|pfn
)paren
)paren
r_continue
suffix:semicolon
id|page
op_assign
id|pfn_to_page
c_func
(paren
id|pfn
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|PageReserved
c_func
(paren
id|page
)paren
op_logical_and
id|PageNosave
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageNosave
c_func
(paren
id|page
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|page
)paren
op_logical_and
id|pfn_is_nosave
c_func
(paren
id|pfn
)paren
)paren
(brace
id|PRINTK
c_func
(paren
l_string|&quot;[nosave pfn 0x%lx]&quot;
comma
id|pfn
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|chunk_size
op_assign
id|is_head_of_free_region
c_func
(paren
id|page
)paren
)paren
)paren
(brace
id|pfn
op_add_assign
id|chunk_size
op_minus
l_int|1
suffix:semicolon
id|zone_pfn
op_add_assign
id|chunk_size
op_minus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|nr_copy_pages
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pbe
)paren
r_continue
suffix:semicolon
id|pbe-&gt;orig_address
op_assign
(paren
r_int
)paren
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
id|copy_page
c_func
(paren
(paren
r_void
op_star
)paren
id|pbe-&gt;address
comma
(paren
r_void
op_star
)paren
id|pbe-&gt;orig_address
)paren
suffix:semicolon
id|pbe
op_increment
suffix:semicolon
)brace
op_star
id|pagedir_p
op_assign
id|pbe
suffix:semicolon
r_return
id|nr_copy_pages
suffix:semicolon
)brace
DECL|function|count_and_copy_data_pages
r_static
r_int
id|count_and_copy_data_pages
c_func
(paren
r_struct
id|pbe
op_star
id|pagedir_p
)paren
(brace
r_int
id|nr_copy_pages
op_assign
l_int|0
suffix:semicolon
r_struct
id|zone
op_star
id|zone
suffix:semicolon
id|for_each_zone
c_func
(paren
id|zone
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_highmem
c_func
(paren
id|zone
)paren
)paren
id|nr_copy_pages
op_add_assign
id|count_and_copy_zone
c_func
(paren
id|zone
comma
op_amp
id|pagedir_p
)paren
suffix:semicolon
)brace
r_return
id|nr_copy_pages
suffix:semicolon
)brace
DECL|function|free_suspend_pagedir_zone
r_static
r_void
id|free_suspend_pagedir_zone
c_func
(paren
r_struct
id|zone
op_star
id|zone
comma
r_int
r_int
id|pagedir
)paren
(brace
r_int
r_int
id|zone_pfn
comma
id|pagedir_end
comma
id|pagedir_pfn
comma
id|pagedir_end_pfn
suffix:semicolon
id|pagedir_end
op_assign
id|pagedir
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|pagedir_order
)paren
suffix:semicolon
id|pagedir_pfn
op_assign
id|__pa
c_func
(paren
id|pagedir
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|pagedir_end_pfn
op_assign
id|__pa
c_func
(paren
id|pagedir_end
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_for
c_loop
(paren
id|zone_pfn
op_assign
l_int|0
suffix:semicolon
id|zone_pfn
OL
id|zone-&gt;spanned_pages
suffix:semicolon
op_increment
id|zone_pfn
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|pfn
op_assign
id|zone_pfn
op_plus
id|zone-&gt;zone_start_pfn
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pfn_valid
c_func
(paren
id|pfn
)paren
)paren
r_continue
suffix:semicolon
id|page
op_assign
id|pfn_to_page
c_func
(paren
id|pfn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TestClearPageNosave
c_func
(paren
id|page
)paren
)paren
r_continue
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pfn
op_ge
id|pagedir_pfn
op_logical_and
id|pfn
OL
id|pagedir_end_pfn
)paren
r_continue
suffix:semicolon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
DECL|function|free_suspend_pagedir
r_static
r_void
id|free_suspend_pagedir
c_func
(paren
r_int
r_int
id|this_pagedir
)paren
(brace
r_struct
id|zone
op_star
id|zone
suffix:semicolon
id|for_each_zone
c_func
(paren
id|zone
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_highmem
c_func
(paren
id|zone
)paren
)paren
id|free_suspend_pagedir_zone
c_func
(paren
id|zone
comma
id|this_pagedir
)paren
suffix:semicolon
)brace
id|free_pages
c_func
(paren
id|this_pagedir
comma
id|pagedir_order
)paren
suffix:semicolon
)brace
DECL|function|create_suspend_pagedir
r_static
id|suspend_pagedir_t
op_star
id|create_suspend_pagedir
c_func
(paren
r_int
id|nr_copy_pages
)paren
(brace
r_int
id|i
suffix:semicolon
id|suspend_pagedir_t
op_star
id|pagedir
suffix:semicolon
r_struct
id|pbe
op_star
id|p
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|pagedir_order
op_assign
id|get_bitmask_order
c_func
(paren
id|SUSPEND_PD_PAGES
c_func
(paren
id|nr_copy_pages
)paren
)paren
suffix:semicolon
id|p
op_assign
id|pagedir
op_assign
(paren
id|suspend_pagedir_t
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
op_or
id|__GFP_COLD
comma
id|pagedir_order
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagedir
)paren
r_return
l_int|NULL
suffix:semicolon
id|page
op_assign
id|virt_to_page
c_func
(paren
id|pagedir
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1
op_lshift
id|pagedir_order
suffix:semicolon
id|i
op_increment
)paren
(brace
id|SetPageNosave
c_func
(paren
id|page
op_increment
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|nr_copy_pages
op_decrement
)paren
(brace
id|p-&gt;address
op_assign
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
op_or
id|__GFP_COLD
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;address
)paren
(brace
id|free_suspend_pagedir
c_func
(paren
(paren
r_int
r_int
)paren
id|pagedir
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|SetPageNosave
c_func
(paren
id|virt_to_page
c_func
(paren
id|p-&gt;address
)paren
)paren
suffix:semicolon
id|p-&gt;orig_address
op_assign
l_int|0
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
r_return
id|pagedir
suffix:semicolon
)brace
DECL|function|prepare_suspend_processes
r_static
r_int
id|prepare_suspend_processes
c_func
(paren
r_void
)paren
(brace
id|sys_sync
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Syncing needs pdflushd, so do it before stopping processes */
r_if
c_cond
(paren
id|freeze_processes
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Suspend failed: Not all processes stopped!&bslash;n&quot;
)paren
suffix:semicolon
id|thaw_processes
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to free as much memory as possible, but do not OOM-kill anyone&n; *&n; * Notice: all userland should be stopped at this point, or livelock is possible.&n; */
DECL|function|free_some_memory
r_static
r_void
id|free_some_memory
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Freeing memory: &quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|shrink_all_memory
c_func
(paren
l_int|10000
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;|&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|suspend_prepare_image
r_static
r_int
id|suspend_prepare_image
c_func
(paren
r_void
)paren
(brace
r_struct
id|sysinfo
id|i
suffix:semicolon
r_int
r_int
id|nr_needed_pages
op_assign
l_int|0
suffix:semicolon
id|pagedir_nosave
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;/critical section: Handling highmem&quot;
)paren
suffix:semicolon
id|save_highmem
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, counting pages to copy&quot;
)paren
suffix:semicolon
id|drain_local_pages
c_func
(paren
)paren
suffix:semicolon
id|nr_copy_pages
op_assign
id|count_and_copy_data_pages
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|nr_needed_pages
op_assign
id|nr_copy_pages
op_plus
id|PAGES_FOR_IO
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; (pages needed: %d+%d=%d free: %d)&bslash;n&quot;
comma
id|nr_copy_pages
comma
id|PAGES_FOR_IO
comma
id|nr_needed_pages
comma
id|nr_free_pages
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_free_pages
c_func
(paren
)paren
OL
id|nr_needed_pages
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%sCouldn&squot;t get enough free pages, on %d pages short&bslash;n&quot;
comma
id|name_suspend
comma
id|nr_needed_pages
op_minus
id|nr_free_pages
c_func
(paren
)paren
)paren
suffix:semicolon
id|root_swap
op_assign
l_int|0xFFFF
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|si_swapinfo
c_func
(paren
op_amp
id|i
)paren
suffix:semicolon
multiline_comment|/* FIXME: si_swapinfo(&amp;i) returns all swap devices information.&n;&t;&t;&t;&t;   We should only consider resume_device. */
r_if
c_cond
(paren
id|i.freeswap
OL
id|nr_needed_pages
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%sThere&squot;s not enough swap space available, on %ld pages short&bslash;n&quot;
comma
id|name_suspend
comma
id|nr_needed_pages
op_minus
id|i.freeswap
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|PRINTK
c_func
(paren
l_string|&quot;Alloc pagedir&bslash;n&quot;
)paren
suffix:semicolon
id|pagedir_save
op_assign
id|pagedir_nosave
op_assign
id|create_suspend_pagedir
c_func
(paren
id|nr_copy_pages
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagedir_nosave
)paren
(brace
multiline_comment|/* Shouldn&squot;t happen */
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%sCouldn&squot;t allocate enough pages&bslash;n&quot;
comma
id|name_suspend
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Really should not happen&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|nr_copy_pages_check
op_assign
id|nr_copy_pages
suffix:semicolon
id|pagedir_order_check
op_assign
id|pagedir_order
suffix:semicolon
id|drain_local_pages
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* During allocating of suspend pagedir, new cold pages may appear. Kill them */
r_if
c_cond
(paren
id|nr_copy_pages
op_ne
id|count_and_copy_data_pages
c_func
(paren
id|pagedir_nosave
)paren
)paren
multiline_comment|/* copy */
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * End of critical section. From now on, we can write to memory,&n;&t; * but we should not touch disk. This specially means we must _not_&n;&t; * touch swap space! Except we must write out our image of course.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;critical section/: done (%d pages copied)&bslash;n&quot;
comma
id|nr_copy_pages
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|suspend_save_image
r_static
r_void
id|suspend_save_image
c_func
(paren
r_void
)paren
(brace
id|device_resume
c_func
(paren
)paren
suffix:semicolon
id|lock_swapdevices
c_func
(paren
)paren
suffix:semicolon
id|write_suspend_image
c_func
(paren
)paren
suffix:semicolon
id|lock_swapdevices
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* This will unlock ignored swap devices since writing is finished */
multiline_comment|/* It is important _NOT_ to umount filesystems at this point. We want&n;&t; * them synced (in case something goes wrong) but we DO not want to mark&n;&t; * filesystem clean: it is not. (And it does not matter, if we resume&n;&t; * correctly, we&squot;ll mark system clean, anyway.)&n;&t; */
)brace
DECL|function|suspend_power_down
r_static
r_void
id|suspend_power_down
c_func
(paren
r_void
)paren
(brace
r_extern
r_int
id|C_A_D
suffix:semicolon
id|C_A_D
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;%s%s Trying to power down.&bslash;n&quot;
comma
id|name_suspend
comma
id|TEST_SWSUSP
ques
c_cond
l_string|&quot;Disable TEST_SWSUSP. NOT &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_VT
id|PRINTK
c_func
(paren
id|KERN_EMERG
l_string|&quot;shift_state: %04x&bslash;n&quot;
comma
id|shift_state
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TEST_SWSUSP
op_xor
(paren
op_logical_neg
op_logical_neg
(paren
id|shift_state
op_amp
(paren
l_int|1
op_lshift
id|KG_CTRL
)paren
)paren
)paren
)paren
id|machine_restart
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_else
macro_line|#endif
(brace
id|device_shutdown
c_func
(paren
)paren
suffix:semicolon
id|machine_power_off
c_func
(paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;%sProbably not capable for powerdown. System halted.&bslash;n&quot;
comma
id|name_suspend
)paren
suffix:semicolon
id|machine_halt
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
multiline_comment|/*&n; * Magic happens here&n; */
DECL|function|do_magic_resume_1
id|asmlinkage
r_void
id|do_magic_resume_1
c_func
(paren
r_void
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|suspend_pagedir_lock
)paren
suffix:semicolon
multiline_comment|/* Done to disable interrupts */
id|device_power_down
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;Waiting for DMAs to settle down...&bslash;n&quot;
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* We do not want some readahead with DMA to corrupt our memory, right?&n;&t;&t;&t;   Do it with disabled interrupts for best effect. That way, if some&n;&t;&t;&t;   driver scheduled DMA, we have good chance for DMA to finish ;-). */
)brace
DECL|function|do_magic_resume_2
id|asmlinkage
r_void
id|do_magic_resume_2
c_func
(paren
r_void
)paren
(brace
id|BUG_ON
(paren
id|nr_copy_pages_check
op_ne
id|nr_copy_pages
)paren
suffix:semicolon
id|BUG_ON
(paren
id|pagedir_order_check
op_ne
id|pagedir_order
)paren
suffix:semicolon
id|__flush_tlb_global
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Even mappings of &quot;global&quot; things (vmalloc) need to be fixed */
id|PRINTK
c_func
(paren
l_string|&quot;Freeing prev allocated pagedir&bslash;n&quot;
)paren
suffix:semicolon
id|free_suspend_pagedir
c_func
(paren
(paren
r_int
r_int
)paren
id|pagedir_save
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Restoring highmem&bslash;n&quot;
)paren
suffix:semicolon
id|restore_highmem
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;done, devices&bslash;n&quot;
)paren
suffix:semicolon
id|device_power_up
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|suspend_pagedir_lock
)paren
suffix:semicolon
id|device_resume
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Fixme: this is too late; we should do this ASAP to avoid &quot;infinite reboots&quot; problem */
id|PRINTK
c_func
(paren
l_string|&quot;Fixing swap signatures... &quot;
)paren
suffix:semicolon
id|mark_swapfiles
c_func
(paren
(paren
(paren
id|swp_entry_t
)paren
(brace
l_int|0
)brace
)paren
comma
id|MARK_SWAP_RESUME
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;ok&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef SUSPEND_CONSOLE
id|acquire_console_sem
c_func
(paren
)paren
suffix:semicolon
id|update_screen
c_func
(paren
id|fg_console
)paren
suffix:semicolon
id|release_console_sem
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* do_magic() is implemented in arch/?/kernel/suspend_asm.S, and basically does:&n;&n;&t;if (!resume) {&n;&t;&t;do_magic_suspend_1();&n;&t;&t;save_processor_state();&n;&t;&t;SAVE_REGISTERS&n;&t;&t;do_magic_suspend_2();&n;&t;&t;return;&n;&t;}&n;&t;GO_TO_SWAPPER_PAGE_TABLES&n;&t;do_magic_resume_1();&n;&t;COPY_PAGES_BACK&n;&t;RESTORE_REGISTERS&n;&t;restore_processor_state();&n;&t;do_magic_resume_2();&n;&n; */
DECL|function|do_magic_suspend_1
id|asmlinkage
r_void
id|do_magic_suspend_1
c_func
(paren
r_void
)paren
(brace
id|mb
c_func
(paren
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|in_atomic
c_func
(paren
)paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|suspend_pagedir_lock
)paren
suffix:semicolon
)brace
DECL|function|do_magic_suspend_2
id|asmlinkage
r_void
id|do_magic_suspend_2
c_func
(paren
r_void
)paren
(brace
r_int
id|is_problem
suffix:semicolon
id|read_swapfiles
c_func
(paren
)paren
suffix:semicolon
id|device_power_down
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|is_problem
op_assign
id|suspend_prepare_image
c_func
(paren
)paren
suffix:semicolon
id|device_power_up
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|suspend_pagedir_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_problem
)paren
(brace
id|kernel_fpu_end
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* save_processor_state() does kernel_fpu_begin, and we need to revert it in order to pass in_atomic() checks */
id|BUG_ON
c_func
(paren
id|in_atomic
c_func
(paren
)paren
)paren
suffix:semicolon
id|suspend_save_image
c_func
(paren
)paren
suffix:semicolon
id|suspend_power_down
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: if suspend_power_down is commented out, console is lost after few suspends ?! */
)brace
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;%sSuspend failed, trying to recover...&bslash;n&quot;
comma
id|name_suspend
)paren
suffix:semicolon
id|MDELAY
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* So user can wait and report us messages if armageddon comes :-) */
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|suspend_pagedir_lock
)paren
suffix:semicolon
multiline_comment|/* Done to disable interrupts */
id|mdelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|pagedir_nosave
comma
id|pagedir_order
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|suspend_pagedir_lock
)paren
suffix:semicolon
id|device_resume
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;Fixing swap signatures... &quot;
)paren
suffix:semicolon
id|mark_swapfiles
c_func
(paren
(paren
(paren
id|swp_entry_t
)paren
(brace
l_int|0
)brace
)paren
comma
id|MARK_SWAP_RESUME
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;ok&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is main interface to the outside world. It needs to be&n; * called from process context.&n; */
DECL|function|software_suspend
r_int
id|software_suspend
c_func
(paren
r_void
)paren
(brace
r_int
id|res
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|software_suspend_enabled
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|software_suspend_enabled
op_assign
l_int|0
suffix:semicolon
id|might_sleep
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arch_prepare_suspend
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%sArchitecture failed to prepare&bslash;n&quot;
comma
id|name_suspend
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pm_prepare_console
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;%sCan&squot;t allocate a console... proceeding&bslash;n&quot;
comma
id|name_suspend
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prepare_suspend_processes
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* At this point, all user processes and &quot;dangerous&quot;&n;                   kernel threads are stopped. Free some memory, as we&n;                   need half of memory free. */
id|free_some_memory
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Save state of all device drivers, and stop them. */
r_if
c_cond
(paren
(paren
id|res
op_assign
id|device_suspend
c_func
(paren
l_int|4
)paren
)paren
op_eq
l_int|0
)paren
multiline_comment|/* If stopping device drivers worked, we proceed basically into&n;&t;&t;&t; * suspend_save_image.&n;&t;&t;&t; *&n;&t;&t;&t; * do_magic(0) returns after system is resumed.&n;&t;&t;&t; *&n;&t;&t;&t; * do_magic() copies all &quot;used&quot; memory to &quot;free&quot; memory, then&n;&t;&t;&t; * unsuspends all device drivers, and writes memory to disk&n;&t;&t;&t; * using normal kernel mechanism.&n;&t;&t;&t; */
id|do_magic
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|thaw_processes
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|res
op_assign
op_minus
id|EBUSY
suffix:semicolon
id|software_suspend_enabled
op_assign
l_int|1
suffix:semicolon
id|MDELAY
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|pm_restore_console
c_func
(paren
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/* More restore stuff */
multiline_comment|/* FIXME: Why not memcpy(to, from, 1&lt;&lt;pagedir_order*PAGE_SIZE)? */
DECL|function|copy_pagedir
r_static
r_void
id|copy_pagedir
c_func
(paren
id|suspend_pagedir_t
op_star
id|to
comma
id|suspend_pagedir_t
op_star
id|from
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|topointer
op_assign
(paren
r_char
op_star
)paren
id|to
comma
op_star
id|frompointer
op_assign
(paren
r_char
op_star
)paren
id|from
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1
op_lshift
id|pagedir_order
suffix:semicolon
id|i
op_increment
)paren
(brace
id|copy_page
c_func
(paren
id|topointer
comma
id|frompointer
)paren
suffix:semicolon
id|topointer
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|frompointer
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
DECL|macro|does_collide
mdefine_line|#define does_collide(addr) does_collide_order(pagedir_nosave, addr, 0)
multiline_comment|/*&n; * Returns true if given address/order collides with any orig_address &n; */
DECL|function|does_collide_order
r_static
r_int
id|does_collide_order
c_func
(paren
id|suspend_pagedir_t
op_star
id|pagedir
comma
r_int
r_int
id|addr
comma
r_int
id|order
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|addre
op_assign
id|addr
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_copy_pages
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|pagedir
op_plus
id|i
)paren
op_member_access_from_pointer
id|orig_address
op_ge
id|addr
op_logical_and
(paren
id|pagedir
op_plus
id|i
)paren
op_member_access_from_pointer
id|orig_address
OL
id|addre
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We check here that pagedir &amp; pages it points to won&squot;t collide with pages&n; * where we&squot;re going to restore from the loaded pages later&n; */
DECL|function|check_pagedir
r_static
r_int
id|check_pagedir
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_copy_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_do
(brace
id|addr
op_assign
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|does_collide
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
(paren
id|pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|address
op_assign
id|addr
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|relocate_pagedir
r_static
r_int
id|relocate_pagedir
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * We have to avoid recursion (not to overflow kernel stack),&n;&t; * and that&squot;s why code looks pretty cryptic &n;&t; */
id|suspend_pagedir_t
op_star
id|new_pagedir
comma
op_star
id|old_pagedir
op_assign
id|pagedir_nosave
suffix:semicolon
r_void
op_star
op_star
id|eaten_memory
op_assign
l_int|NULL
suffix:semicolon
r_void
op_star
op_star
id|c
op_assign
id|eaten_memory
comma
op_star
id|m
comma
op_star
id|f
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Relocating pagedir&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|does_collide_order
c_func
(paren
id|old_pagedir
comma
(paren
r_int
r_int
)paren
id|old_pagedir
comma
id|pagedir_order
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;not necessary&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|m
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|pagedir_order
)paren
)paren
)paren
(brace
id|memset
c_func
(paren
id|m
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|does_collide_order
c_func
(paren
id|old_pagedir
comma
(paren
r_int
r_int
)paren
id|m
comma
id|pagedir_order
)paren
)paren
r_break
suffix:semicolon
id|eaten_memory
op_assign
id|m
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
op_star
id|eaten_memory
op_assign
id|c
suffix:semicolon
id|c
op_assign
id|eaten_memory
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|m
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|pagedir_nosave
op_assign
id|new_pagedir
op_assign
id|m
suffix:semicolon
id|copy_pagedir
c_func
(paren
id|new_pagedir
comma
id|old_pagedir
)paren
suffix:semicolon
id|c
op_assign
id|eaten_memory
suffix:semicolon
r_while
c_loop
(paren
id|c
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;:&quot;
)paren
suffix:semicolon
id|f
op_assign
op_star
id|c
suffix:semicolon
id|c
op_assign
op_star
id|c
suffix:semicolon
r_if
c_cond
(paren
id|f
)paren
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|f
comma
id|pagedir_order
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;|&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Sanity check if this image makes sense with this kernel/swap context&n; * I really don&squot;t think that it&squot;s foolproof but more than nothing..&n; */
DECL|function|sanity_check_failed
r_static
r_int
id|sanity_check_failed
c_func
(paren
r_char
op_star
id|reason
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s%s&bslash;n&quot;
comma
id|name_resume
comma
id|reason
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
DECL|function|sanity_check
r_static
r_int
id|sanity_check
c_func
(paren
r_struct
id|suspend_header
op_star
id|sh
)paren
(brace
r_if
c_cond
(paren
id|sh-&gt;version_code
op_ne
id|LINUX_VERSION_CODE
)paren
r_return
id|sanity_check_failed
c_func
(paren
l_string|&quot;Incorrect kernel version&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh-&gt;num_physpages
op_ne
id|num_physpages
)paren
r_return
id|sanity_check_failed
c_func
(paren
l_string|&quot;Incorrect memory size&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|sh-&gt;machine
comma
id|system_utsname.machine
comma
l_int|8
)paren
)paren
r_return
id|sanity_check_failed
c_func
(paren
l_string|&quot;Incorrect machine type&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|sh-&gt;version
comma
id|system_utsname.version
comma
l_int|20
)paren
)paren
r_return
id|sanity_check_failed
c_func
(paren
l_string|&quot;Incorrect version&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh-&gt;num_cpus
op_ne
id|num_online_cpus
c_func
(paren
)paren
)paren
r_return
id|sanity_check_failed
c_func
(paren
l_string|&quot;Incorrect number of cpus&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sh-&gt;page_size
op_ne
id|PAGE_SIZE
)paren
r_return
id|sanity_check_failed
c_func
(paren
l_string|&quot;Incorrect PAGE_SIZE&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bdev_read_page
r_static
r_int
id|bdev_read_page
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
r_int
id|pos
comma
r_void
op_star
id|buf
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|BUG_ON
(paren
id|pos
op_mod
id|PAGE_SIZE
)paren
suffix:semicolon
id|bh
op_assign
id|__bread
c_func
(paren
id|bdev
comma
id|pos
op_div
id|PAGE_SIZE
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
op_logical_or
(paren
op_logical_neg
id|bh-&gt;b_data
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|buf
comma
id|bh-&gt;b_data
comma
id|PAGE_SIZE
)paren
suffix:semicolon
multiline_comment|/* FIXME: may need kmap() */
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bdev_write_page
r_static
r_int
id|bdev_write_page
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
r_int
id|pos
comma
r_void
op_star
id|buf
)paren
(brace
macro_line|#if 0
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|BUG_ON
(paren
id|pos
op_mod
id|PAGE_SIZE
)paren
suffix:semicolon
id|bh
op_assign
id|__bread
c_func
(paren
id|bdev
comma
id|pos
op_div
id|PAGE_SIZE
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
op_logical_or
(paren
op_logical_neg
id|bh-&gt;b_data
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|bh-&gt;b_data
comma
id|buf
comma
id|PAGE_SIZE
)paren
suffix:semicolon
multiline_comment|/* FIXME: may need kmap() */
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|generic_make_request
c_func
(paren
id|WRITE
comma
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%sWarning %s: Fixing swap signatures unsuccessful...&bslash;n&quot;
comma
id|name_resume
comma
id|resume_file
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%sWarning %s: Fixing swap signatures unimplemented...&bslash;n&quot;
comma
id|name_resume
comma
id|resume_file
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_extern
id|dev_t
id|__init
id|name_to_dev_t
c_func
(paren
r_const
r_char
op_star
id|line
)paren
suffix:semicolon
DECL|function|__read_suspend_image
r_static
r_int
id|__init
id|__read_suspend_image
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
r_union
id|diskpage
op_star
id|cur
comma
r_int
id|noresume
)paren
(brace
id|swp_entry_t
id|next
suffix:semicolon
r_int
id|i
comma
id|nr_pgdir_pages
suffix:semicolon
DECL|macro|PREPARENEXT
mdefine_line|#define PREPARENEXT &bslash;&n;&t;{&t;next = cur-&gt;link.next; &bslash;&n;&t;&t;next.val = swp_offset(next) * PAGE_SIZE; &bslash;&n;        }
r_if
c_cond
(paren
id|bdev_read_page
c_func
(paren
id|bdev
comma
l_int|0
comma
id|cur
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;SWAP-SPACE&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|10
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;SWAPSPACE2&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|10
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%sThis is normal swap space&bslash;n&quot;
comma
id|name_resume
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|PREPARENEXT
suffix:semicolon
multiline_comment|/* We have to read next position before we overwrite it */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;S1&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|2
)paren
)paren
id|memcpy
c_func
(paren
id|cur-&gt;swh.magic.magic
comma
l_string|&quot;SWAP-SPACE&quot;
comma
l_int|10
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;S2&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|2
)paren
)paren
id|memcpy
c_func
(paren
id|cur-&gt;swh.magic.magic
comma
l_string|&quot;SWAPSPACE2&quot;
comma
l_int|10
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|noresume
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;%sUnable to find suspended-data signature (%.10s - misspelled?&bslash;n&quot;
comma
id|name_resume
comma
id|cur-&gt;swh.magic.magic
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|noresume
)paren
(brace
multiline_comment|/* We don&squot;t do a sanity check here: we want to restore the swap&n;&t;&t;   whatever version of kernel made the suspend image;&n;&t;&t;   We need to write swap, but swap is *not* enabled so&n;&t;&t;   we must write the device directly */
id|printk
c_func
(paren
l_string|&quot;%s: Fixing swap signatures %s...&bslash;n&quot;
comma
id|name_resume
comma
id|resume_file
)paren
suffix:semicolon
id|bdev_write_page
c_func
(paren
id|bdev
comma
l_int|0
comma
id|cur
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%sSignature found, resuming&bslash;n&quot;
comma
id|name_resume
)paren
suffix:semicolon
id|MDELAY
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdev_read_page
c_func
(paren
id|bdev
comma
id|next.val
comma
id|cur
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|sanity_check
c_func
(paren
op_amp
id|cur-&gt;sh
)paren
)paren
multiline_comment|/* Is this same machine? */
r_return
op_minus
id|EPERM
suffix:semicolon
id|PREPARENEXT
suffix:semicolon
id|pagedir_save
op_assign
id|cur-&gt;sh.suspend_pagedir
suffix:semicolon
id|nr_copy_pages
op_assign
id|cur-&gt;sh.num_pbes
suffix:semicolon
id|nr_pgdir_pages
op_assign
id|SUSPEND_PD_PAGES
c_func
(paren
id|nr_copy_pages
)paren
suffix:semicolon
id|pagedir_order
op_assign
id|get_bitmask_order
c_func
(paren
id|nr_pgdir_pages
)paren
suffix:semicolon
id|pagedir_nosave
op_assign
(paren
id|suspend_pagedir_t
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|pagedir_order
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagedir_nosave
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|PRINTK
c_func
(paren
l_string|&quot;%sReading pagedir, &quot;
comma
id|name_resume
)paren
suffix:semicolon
multiline_comment|/* We get pages in reverse order of saving! */
r_for
c_loop
(paren
id|i
op_assign
id|nr_pgdir_pages
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|BUG_ON
(paren
op_logical_neg
id|next.val
)paren
suffix:semicolon
id|cur
op_assign
(paren
r_union
id|diskpage
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|pagedir_nosave
)paren
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|bdev_read_page
c_func
(paren
id|bdev
comma
id|next.val
comma
id|cur
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|PREPARENEXT
suffix:semicolon
)brace
id|BUG_ON
(paren
id|next.val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|relocate_pagedir
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|check_pagedir
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Reading image data (%d pages): &quot;
comma
id|nr_copy_pages
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_copy_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
id|swp_entry_t
id|swap_address
op_assign
(paren
id|pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|swap_address
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_mod
l_int|100
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
multiline_comment|/* You do not need to check for overlaps...&n;&t;&t;   ... check_pagedir already did this work */
r_if
c_cond
(paren
id|bdev_read_page
c_func
(paren
id|bdev
comma
id|swp_offset
c_func
(paren
id|swap_address
)paren
op_star
id|PAGE_SIZE
comma
(paren
r_char
op_star
)paren
(paren
(paren
id|pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|address
)paren
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;|&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_suspend_image
r_static
r_int
id|read_suspend_image
c_func
(paren
r_const
r_char
op_star
id|specialfile
comma
r_int
id|noresume
)paren
(brace
r_union
id|diskpage
op_star
id|cur
suffix:semicolon
r_int
r_int
id|scratch_page
op_assign
l_int|0
suffix:semicolon
r_int
id|error
suffix:semicolon
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|resume_device
op_assign
id|name_to_dev_t
c_func
(paren
id|specialfile
)paren
suffix:semicolon
id|scratch_page
op_assign
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
id|cur
op_assign
(paren
r_void
op_star
)paren
id|scratch_page
suffix:semicolon
r_if
c_cond
(paren
id|cur
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Resuming from device %s&bslash;n&quot;
comma
id|__bdevname
c_func
(paren
id|resume_device
comma
id|b
)paren
)paren
suffix:semicolon
id|bdev
op_assign
id|open_by_devnum
c_func
(paren
id|resume_device
comma
id|FMODE_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|bdev
)paren
)paren
(brace
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|bdev
)paren
suffix:semicolon
)brace
r_else
(brace
id|set_blocksize
c_func
(paren
id|bdev
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|error
op_assign
id|__read_suspend_image
c_func
(paren
id|bdev
comma
id|cur
comma
id|noresume
)paren
suffix:semicolon
id|blkdev_put
c_func
(paren
id|bdev
)paren
suffix:semicolon
)brace
)brace
r_else
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|scratch_page
)paren
id|free_page
c_func
(paren
id|scratch_page
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|error
)paren
(brace
r_case
l_int|0
suffix:colon
id|PRINTK
c_func
(paren
l_string|&quot;Reading resume file was successful&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EINVAL
suffix:colon
r_break
suffix:semicolon
r_case
op_minus
id|EIO
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%sI/O error&bslash;n&quot;
comma
id|name_resume
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ENOENT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s%s: No such file or directory&bslash;n&quot;
comma
id|name_resume
comma
id|specialfile
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ENOMEM
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%sNot enough memory&bslash;n&quot;
comma
id|name_resume
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%sError %d resuming&bslash;n&quot;
comma
id|name_resume
comma
id|error
)paren
suffix:semicolon
)brace
id|MDELAY
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;software_resume - Resume from a saved image.&n; *&n; *&t;Called as a late_initcall (so all devices are discovered and &n; *&t;initialized), we call swsusp to see if we have a saved image or not.&n; *&t;If so, we quiesce devices, then restore the saved image. We will &n; *&t;return above (in pm_suspend_disk() ) if everything goes well. &n; *&t;Otherwise, we fail gracefully and return to the normally &n; *&t;scheduled program.&n; *&n; */
DECL|function|software_resume
r_static
r_int
id|__init
id|software_resume
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|num_online_cpus
c_func
(paren
)paren
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Software Suspend has malfunctioning SMP support. Disabled :(&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* We enable the possibility of machine suspend */
id|software_suspend_enabled
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|resume_status
)paren
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|name_resume
)paren
suffix:semicolon
r_if
c_cond
(paren
id|resume_status
op_eq
id|NORESUME
)paren
(brace
r_if
c_cond
(paren
id|resume_file
(braket
l_int|0
)braket
)paren
(brace
id|read_suspend_image
c_func
(paren
id|resume_file
comma
l_int|1
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;disabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|MDELAY
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pm_prepare_console
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;swsusp: Can&squot;t allocate a console... proceeding&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|resume_file
(braket
l_int|0
)braket
op_logical_and
id|resume_status
op_eq
id|RESUME_SPECIFIED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;suspension device unspecified&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;resuming from %s&bslash;n&quot;
comma
id|resume_file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_suspend_image
c_func
(paren
id|resume_file
comma
l_int|0
)paren
)paren
r_goto
id|read_failure
suffix:semicolon
id|device_suspend
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|do_magic
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;This never returns&quot;
)paren
suffix:semicolon
id|read_failure
suffix:colon
id|pm_restore_console
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|software_resume
id|late_initcall
c_func
(paren
id|software_resume
)paren
suffix:semicolon
DECL|function|resume_setup
r_static
r_int
id|__init
id|resume_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_if
c_cond
(paren
id|resume_status
op_eq
id|NORESUME
)paren
r_return
l_int|1
suffix:semicolon
id|strncpy
c_func
(paren
id|resume_file
comma
id|str
comma
l_int|255
)paren
suffix:semicolon
id|resume_status
op_assign
id|RESUME_SPECIFIED
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|noresume_setup
r_static
r_int
id|__init
id|noresume_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|resume_status
op_assign
id|NORESUME
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;noresume&quot;
comma
id|noresume_setup
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;resume=&quot;
comma
id|resume_setup
)paren
suffix:semicolon
DECL|variable|software_suspend
id|EXPORT_SYMBOL
c_func
(paren
id|software_suspend
)paren
suffix:semicolon
DECL|variable|software_suspend_enabled
id|EXPORT_SYMBOL
c_func
(paren
id|software_suspend_enabled
)paren
suffix:semicolon
eof
