multiline_comment|/*&n; * linux/kernel/power/swsusp.c&n; *&n; * This file is to realize architecture-independent&n; * machine suspend feature using pretty near only high-level routines&n; *&n; * Copyright (C) 1998-2001 Gabor Kuti &lt;seasons@fornax.hu&gt;&n; * Copyright (C) 1998,2001-2004 Pavel Machek &lt;pavel@suse.cz&gt;&n; *&n; * This file is released under the GPLv2.&n; *&n; * I&squot;d like to thank the following people for their work:&n; * &n; * Pavel Machek &lt;pavel@ucw.cz&gt;:&n; * Modifications, defectiveness pointing, being with me at the very beginning,&n; * suspend to swap space, stop all tasks. Port to 2.4.18-ac and 2.5.17.&n; *&n; * Steve Doddi &lt;dirk@loth.demon.co.uk&gt;: &n; * Support the possibility of hardware state restoring.&n; *&n; * Raph &lt;grey.havens@earthling.net&gt;:&n; * Support for preserving states of network devices and virtual console&n; * (including X and svgatextmode)&n; *&n; * Kurt Garloff &lt;garloff@suse.de&gt;:&n; * Straightened the critical function in order to prevent compilers from&n; * playing tricks with local variables.&n; *&n; * Andreas Mohr &lt;a.mohr@mailto.de&gt;&n; *&n; * Alex Badea &lt;vampire@go.ro&gt;:&n; * Fixed runaway init&n; *&n; * More state savers are welcome. Especially for the scsi layer...&n; *&n; * For TODOs,FIXMEs also look in Documentation/power/swsusp.txt&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/utsname.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/vt_kern.h&gt;
macro_line|#include &lt;linux/kbd_kern.h&gt;
macro_line|#include &lt;linux/keyboard.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/pm.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/swapops.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/syscalls.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/tlbflush.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;power.h&quot;
multiline_comment|/* References to section boundaries */
r_extern
r_const
r_void
id|__nosave_begin
comma
id|__nosave_end
suffix:semicolon
multiline_comment|/* Variables to be preserved over suspend */
DECL|variable|nr_copy_pages_check
r_static
r_int
id|nr_copy_pages_check
suffix:semicolon
r_extern
r_char
id|resume_file
(braket
)braket
suffix:semicolon
multiline_comment|/* Local variables that should not be affected by save */
DECL|variable|__nosavedata
r_int
r_int
id|nr_copy_pages
id|__nosavedata
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Suspend pagedir is allocated before final copy, therefore it&n;   must be freed after resume &n;&n;   Warning: this is evil. There are actually two pagedirs at time of&n;   resume. One is &quot;pagedir_save&quot;, which is empty frame allocated at&n;   time of suspend, that must be freed. Second is &quot;pagedir_nosave&quot;, &n;   allocated at time of resume, that travels through memory not to&n;   collide with anything.&n;&n;   Warning: this is even more evil than it seems. Pagedirs this file&n;   talks about are completely different from page directories used by&n;   MMU hardware.&n; */
DECL|variable|__nosavedata
id|suspend_pagedir_t
op_star
id|pagedir_nosave
id|__nosavedata
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|pagedir_save
r_static
id|suspend_pagedir_t
op_star
id|pagedir_save
suffix:semicolon
DECL|variable|__nosavedata
r_static
r_int
id|pagedir_order
id|__nosavedata
op_assign
l_int|0
suffix:semicolon
DECL|macro|SWSUSP_SIG
mdefine_line|#define SWSUSP_SIG&t;&quot;S1SUSPEND&quot;
DECL|struct|swsusp_header
r_static
r_struct
id|swsusp_header
(brace
DECL|member|reserved
r_char
id|reserved
(braket
id|PAGE_SIZE
op_minus
l_int|20
op_minus
r_sizeof
(paren
id|swp_entry_t
)paren
)braket
suffix:semicolon
DECL|member|swsusp_info
id|swp_entry_t
id|swsusp_info
suffix:semicolon
DECL|member|orig_sig
r_char
id|orig_sig
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|sig
r_char
id|sig
(braket
l_int|10
)braket
suffix:semicolon
DECL|variable|swsusp_header
)brace
id|__attribute__
c_func
(paren
(paren
id|packed
comma
id|aligned
c_func
(paren
id|PAGE_SIZE
)paren
)paren
)paren
id|swsusp_header
suffix:semicolon
DECL|variable|swsusp_info
r_static
r_struct
id|swsusp_info
id|swsusp_info
suffix:semicolon
multiline_comment|/*&n; * XXX: We try to keep some more pages free so that I/O operations succeed&n; * without paging. Might this be more?&n; */
DECL|macro|PAGES_FOR_IO
mdefine_line|#define PAGES_FOR_IO&t;512
multiline_comment|/*&n; * Saving part...&n; */
multiline_comment|/* We memorize in swapfile_used what swap devices are used for suspension */
DECL|macro|SWAPFILE_UNUSED
mdefine_line|#define SWAPFILE_UNUSED    0
DECL|macro|SWAPFILE_SUSPEND
mdefine_line|#define SWAPFILE_SUSPEND   1&t;/* This is the suspending device */
DECL|macro|SWAPFILE_IGNORED
mdefine_line|#define SWAPFILE_IGNORED   2&t;/* Those are other swap devices ignored for suspension */
DECL|variable|swapfile_used
r_static
r_int
r_int
id|swapfile_used
(braket
id|MAX_SWAPFILES
)braket
suffix:semicolon
DECL|variable|root_swap
r_static
r_int
r_int
id|root_swap
suffix:semicolon
DECL|function|mark_swapfiles
r_static
r_int
id|mark_swapfiles
c_func
(paren
id|swp_entry_t
id|prev
)paren
(brace
r_int
id|error
suffix:semicolon
id|rw_swap_page_sync
c_func
(paren
id|READ
comma
id|swp_entry
c_func
(paren
id|root_swap
comma
l_int|0
)paren
comma
id|virt_to_page
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|swsusp_header
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;SWAP-SPACE&quot;
comma
id|swsusp_header.sig
comma
l_int|10
)paren
op_logical_or
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;SWAPSPACE2&quot;
comma
id|swsusp_header.sig
comma
l_int|10
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|swsusp_header.orig_sig
comma
id|swsusp_header.sig
comma
l_int|10
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|swsusp_header.sig
comma
id|SWSUSP_SIG
comma
l_int|10
)paren
suffix:semicolon
id|swsusp_header.swsusp_info
op_assign
id|prev
suffix:semicolon
id|error
op_assign
id|rw_swap_page_sync
c_func
(paren
id|WRITE
comma
id|swp_entry
c_func
(paren
id|root_swap
comma
l_int|0
)paren
comma
id|virt_to_page
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|swsusp_header
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pr_debug
c_func
(paren
l_string|&quot;swsusp: Partition is not swap space.&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Check whether the swap device is the specified resume&n; * device, irrespective of whether they are specified by&n; * identical names.&n; *&n; * (Thus, device inode aliasing is allowed.  You can say /dev/hda4&n; * instead of /dev/ide/host0/bus0/target0/lun0/part4 [if using devfs]&n; * and they&squot;ll be considered the same device.  This is *necessary* for&n; * devfs, since the resume code can only recognize the form /dev/hda4,&n; * but the suspend code would see the long name.)&n; */
DECL|function|is_resume_device
r_static
r_int
id|is_resume_device
c_func
(paren
r_const
r_struct
id|swap_info_struct
op_star
id|swap_info
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|swap_info-&gt;swap_file
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_return
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
id|swsusp_resume_device
op_eq
id|MKDEV
c_func
(paren
id|imajor
c_func
(paren
id|inode
)paren
comma
id|iminor
c_func
(paren
id|inode
)paren
)paren
suffix:semicolon
)brace
DECL|function|swsusp_swap_check
r_static
r_int
id|swsusp_swap_check
c_func
(paren
r_void
)paren
multiline_comment|/* This is called before saving image */
(brace
r_int
id|i
comma
id|len
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|resume_file
)paren
suffix:semicolon
id|root_swap
op_assign
l_int|0xFFFF
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SWAPFILES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|swap_info
(braket
id|i
)braket
dot
id|flags
op_eq
l_int|0
)paren
(brace
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_UNUSED
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;resume= option should be used to set suspend device&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root_swap
op_eq
l_int|0xFFFF
)paren
(brace
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_SUSPEND
suffix:semicolon
id|root_swap
op_assign
id|i
suffix:semicolon
)brace
r_else
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_IGNORED
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we ignore all swap devices that are not the resume_file */
r_if
c_cond
(paren
id|is_resume_device
c_func
(paren
op_amp
id|swap_info
(braket
id|i
)braket
)paren
)paren
(brace
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_SUSPEND
suffix:semicolon
id|root_swap
op_assign
id|i
suffix:semicolon
)brace
r_else
(brace
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_IGNORED
suffix:semicolon
)brace
)brace
)brace
)brace
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
id|root_swap
op_ne
l_int|0xffff
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/**&n; * This is called after saving image so modification&n; * will be lost after resume... and that&squot;s what we want.&n; * we make the device unusable. A new call to&n; * lock_swapdevices can unlock the devices. &n; */
DECL|function|lock_swapdevices
r_static
r_void
id|lock_swapdevices
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SWAPFILES
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|swapfile_used
(braket
id|i
)braket
op_eq
id|SWAPFILE_IGNORED
)paren
(brace
id|swap_info
(braket
id|i
)braket
dot
id|flags
op_xor_assign
l_int|0xFF
suffix:semicolon
)brace
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;write_swap_page - Write one page to a fresh swap location.&n; *&t;@addr:&t;Address we&squot;re writing.&n; *&t;@loc:&t;Place to store the entry we used.&n; *&n; *&t;Allocate a new swap entry and &squot;sync&squot; it. Note we discard -EIO&n; *&t;errors. That is an artifact left over from swsusp. It did not &n; *&t;check the return of rw_swap_page_sync() at all, since most pages&n; *&t;written back to swap would return -EIO.&n; *&t;This is a partial improvement, since we will at least return other&n; *&t;errors, though we need to eventually fix the damn code.&n; */
DECL|function|write_page
r_static
r_int
id|write_page
c_func
(paren
r_int
r_int
id|addr
comma
id|swp_entry_t
op_star
id|loc
)paren
(brace
id|swp_entry_t
id|entry
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|entry
op_assign
id|get_swap_page
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|swp_offset
c_func
(paren
id|entry
)paren
op_logical_and
id|swapfile_used
(braket
id|swp_type
c_func
(paren
id|entry
)paren
)braket
op_eq
id|SWAPFILE_SUSPEND
)paren
(brace
id|error
op_assign
id|rw_swap_page_sync
c_func
(paren
id|WRITE
comma
id|entry
comma
id|virt_to_page
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|EIO
)paren
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
op_star
id|loc
op_assign
id|entry
suffix:semicolon
)brace
r_else
id|error
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;data_free - Free the swap entries used by the saved image.&n; *&n; *&t;Walk the list of used swap entries and free each one. &n; *&t;This is only used for cleanup when suspend fails.&n; */
DECL|function|data_free
r_static
r_void
id|data_free
c_func
(paren
r_void
)paren
(brace
id|swp_entry_t
id|entry
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_copy_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
id|entry
op_assign
(paren
id|pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|swap_address
suffix:semicolon
r_if
c_cond
(paren
id|entry.val
)paren
id|swap_free
c_func
(paren
id|entry
)paren
suffix:semicolon
r_else
r_break
suffix:semicolon
(paren
id|pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|swap_address
op_assign
(paren
id|swp_entry_t
)paren
(brace
l_int|0
)brace
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;data_write - Write saved image to swap.&n; *&n; *&t;Walk the list of pages in the image and sync each one to swap.&n; */
DECL|function|data_write
r_static
r_int
id|data_write
c_func
(paren
r_void
)paren
(brace
r_int
id|error
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|mod
op_assign
id|nr_copy_pages
op_div
l_int|100
suffix:semicolon
r_struct
id|pbe
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mod
)paren
id|mod
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Writing data to swap (%d pages)...     &quot;
comma
id|nr_copy_pages
)paren
suffix:semicolon
id|for_each_pbe
c_func
(paren
id|p
comma
id|pagedir_nosave
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_mod
id|mod
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;b&bslash;b&bslash;b&bslash;b%3d%%&quot;
comma
id|i
op_div
id|mod
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|write_page
c_func
(paren
id|p-&gt;address
comma
op_amp
(paren
id|p-&gt;swap_address
)paren
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;b&bslash;b&bslash;b&bslash;bdone&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|dump_info
r_static
r_void
id|dump_info
c_func
(paren
r_void
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot; swsusp: Version: %u&bslash;n&quot;
comma
id|swsusp_info.version_code
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot; swsusp: Num Pages: %ld&bslash;n&quot;
comma
id|swsusp_info.num_physpages
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot; swsusp: UTS Sys: %s&bslash;n&quot;
comma
id|swsusp_info.uts.sysname
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot; swsusp: UTS Node: %s&bslash;n&quot;
comma
id|swsusp_info.uts.nodename
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot; swsusp: UTS Release: %s&bslash;n&quot;
comma
id|swsusp_info.uts.release
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot; swsusp: UTS Version: %s&bslash;n&quot;
comma
id|swsusp_info.uts.version
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot; swsusp: UTS Machine: %s&bslash;n&quot;
comma
id|swsusp_info.uts.machine
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot; swsusp: UTS Domain: %s&bslash;n&quot;
comma
id|swsusp_info.uts.domainname
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot; swsusp: CPUs: %d&bslash;n&quot;
comma
id|swsusp_info.cpus
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot; swsusp: Image: %ld Pages&bslash;n&quot;
comma
id|swsusp_info.image_pages
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot; swsusp: Pagedir: %ld Pages&bslash;n&quot;
comma
id|swsusp_info.pagedir_pages
)paren
suffix:semicolon
)brace
DECL|function|init_header
r_static
r_void
id|init_header
c_func
(paren
r_void
)paren
(brace
id|memset
c_func
(paren
op_amp
id|swsusp_info
comma
l_int|0
comma
r_sizeof
(paren
id|swsusp_info
)paren
)paren
suffix:semicolon
id|swsusp_info.version_code
op_assign
id|LINUX_VERSION_CODE
suffix:semicolon
id|swsusp_info.num_physpages
op_assign
id|num_physpages
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|swsusp_info.uts
comma
op_amp
id|system_utsname
comma
r_sizeof
(paren
id|system_utsname
)paren
)paren
suffix:semicolon
id|swsusp_info.suspend_pagedir
op_assign
id|pagedir_nosave
suffix:semicolon
id|swsusp_info.cpus
op_assign
id|num_online_cpus
c_func
(paren
)paren
suffix:semicolon
id|swsusp_info.image_pages
op_assign
id|nr_copy_pages
suffix:semicolon
)brace
DECL|function|close_swap
r_static
r_int
id|close_swap
c_func
(paren
r_void
)paren
(brace
id|swp_entry_t
id|entry
suffix:semicolon
r_int
id|error
suffix:semicolon
id|dump_info
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|write_page
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|swsusp_info
comma
op_amp
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;S&quot;
)paren
suffix:semicolon
id|error
op_assign
id|mark_swapfiles
c_func
(paren
id|entry
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;|&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;free_pagedir_entries - Free pages used by the page directory.&n; *&n; *&t;This is used during suspend for error recovery.&n; */
DECL|function|free_pagedir_entries
r_static
r_void
id|free_pagedir_entries
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|swsusp_info.pagedir_pages
suffix:semicolon
id|i
op_increment
)paren
id|swap_free
c_func
(paren
id|swsusp_info.pagedir
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;write_pagedir - Write the array of pages holding the page directory.&n; *&t;@last:&t;Last swap entry we write (needed for header).&n; */
DECL|function|write_pagedir
r_static
r_int
id|write_pagedir
c_func
(paren
r_void
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|n
op_assign
l_int|0
suffix:semicolon
r_struct
id|pbe
op_star
id|pbe
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Writing pagedir...&quot;
)paren
suffix:semicolon
id|for_each_pb_page
c_func
(paren
id|pbe
comma
id|pagedir_nosave
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|write_page
c_func
(paren
(paren
r_int
r_int
)paren
id|pbe
comma
op_amp
id|swsusp_info.pagedir
(braket
id|n
op_increment
)braket
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
)brace
id|swsusp_info.pagedir_pages
op_assign
id|n
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;done (%u pages)&bslash;n&quot;
comma
id|n
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;write_suspend_image - Write entire image and metadata.&n; *&n; */
DECL|function|write_suspend_image
r_static
r_int
id|write_suspend_image
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
id|init_header
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|data_write
c_func
(paren
)paren
)paren
)paren
r_goto
id|FreeData
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|write_pagedir
c_func
(paren
)paren
)paren
)paren
r_goto
id|FreePagedir
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|close_swap
c_func
(paren
)paren
)paren
)paren
r_goto
id|FreePagedir
suffix:semicolon
id|Done
suffix:colon
r_return
id|error
suffix:semicolon
id|FreePagedir
suffix:colon
id|free_pagedir_entries
c_func
(paren
)paren
suffix:semicolon
id|FreeData
suffix:colon
id|data_free
c_func
(paren
)paren
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_HIGHMEM
DECL|struct|highmem_page
r_struct
id|highmem_page
(brace
DECL|member|data
r_char
op_star
id|data
suffix:semicolon
DECL|member|page
r_struct
id|page
op_star
id|page
suffix:semicolon
DECL|member|next
r_struct
id|highmem_page
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|highmem_copy
r_static
r_struct
id|highmem_page
op_star
id|highmem_copy
suffix:semicolon
DECL|function|save_highmem_zone
r_static
r_int
id|save_highmem_zone
c_func
(paren
r_struct
id|zone
op_star
id|zone
)paren
(brace
r_int
r_int
id|zone_pfn
suffix:semicolon
id|mark_free_pages
c_func
(paren
id|zone
)paren
suffix:semicolon
r_for
c_loop
(paren
id|zone_pfn
op_assign
l_int|0
suffix:semicolon
id|zone_pfn
OL
id|zone-&gt;spanned_pages
suffix:semicolon
op_increment
id|zone_pfn
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_struct
id|highmem_page
op_star
id|save
suffix:semicolon
r_void
op_star
id|kaddr
suffix:semicolon
r_int
r_int
id|pfn
op_assign
id|zone_pfn
op_plus
id|zone-&gt;zone_start_pfn
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pfn
op_mod
l_int|1000
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pfn_valid
c_func
(paren
id|pfn
)paren
)paren
r_continue
suffix:semicolon
id|page
op_assign
id|pfn_to_page
c_func
(paren
id|pfn
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This condition results from rvmalloc() sans vmalloc_32()&n;&t;&t; * and architectural memory reservations. This should be&n;&t;&t; * corrected eventually when the cases giving rise to this&n;&t;&t; * are better understood.&n;&t;&t; */
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|page
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;highmem reserved page?!&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
id|PageNosave
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageNosaveFree
c_func
(paren
id|page
)paren
)paren
r_continue
suffix:semicolon
id|save
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|highmem_page
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|save
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|save-&gt;next
op_assign
id|highmem_copy
suffix:semicolon
id|save-&gt;page
op_assign
id|page
suffix:semicolon
id|save-&gt;data
op_assign
(paren
r_void
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|save-&gt;data
)paren
(brace
id|kfree
c_func
(paren
id|save
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|save-&gt;data
comma
id|kaddr
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|highmem_copy
op_assign
id|save
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_HIGHMEM */
DECL|function|save_highmem
r_static
r_int
id|save_highmem
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_HIGHMEM
r_struct
id|zone
op_star
id|zone
suffix:semicolon
r_int
id|res
op_assign
l_int|0
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;swsusp: Saving Highmem&bslash;n&quot;
)paren
suffix:semicolon
id|for_each_zone
c_func
(paren
id|zone
)paren
(brace
r_if
c_cond
(paren
id|is_highmem
c_func
(paren
id|zone
)paren
)paren
id|res
op_assign
id|save_highmem_zone
c_func
(paren
id|zone
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
r_return
id|res
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|restore_highmem
r_static
r_int
id|restore_highmem
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_HIGHMEM
id|printk
c_func
(paren
l_string|&quot;swsusp: Restoring Highmem&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|highmem_copy
)paren
(brace
r_struct
id|highmem_page
op_star
id|save
op_assign
id|highmem_copy
suffix:semicolon
r_void
op_star
id|kaddr
suffix:semicolon
id|highmem_copy
op_assign
id|save-&gt;next
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|save-&gt;page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|kaddr
comma
id|save-&gt;data
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
)paren
id|save-&gt;data
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|save
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pfn_is_nosave
r_static
r_int
id|pfn_is_nosave
c_func
(paren
r_int
r_int
id|pfn
)paren
(brace
r_int
r_int
id|nosave_begin_pfn
op_assign
id|__pa
c_func
(paren
op_amp
id|__nosave_begin
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_int
r_int
id|nosave_end_pfn
op_assign
id|PAGE_ALIGN
c_func
(paren
id|__pa
c_func
(paren
op_amp
id|__nosave_end
)paren
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_return
(paren
id|pfn
op_ge
id|nosave_begin_pfn
)paren
op_logical_and
(paren
id|pfn
OL
id|nosave_end_pfn
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;saveable - Determine whether a page should be cloned or not.&n; *&t;@pfn:&t;The page&n; *&n; *&t;We save a page if it&squot;s Reserved, and not in the range of pages&n; *&t;statically defined as &squot;unsaveable&squot;, or if it isn&squot;t reserved, and&n; *&t;isn&squot;t part of a free chunk of pages.&n; */
DECL|function|saveable
r_static
r_int
id|saveable
c_func
(paren
r_struct
id|zone
op_star
id|zone
comma
r_int
r_int
op_star
id|zone_pfn
)paren
(brace
r_int
r_int
id|pfn
op_assign
op_star
id|zone_pfn
op_plus
id|zone-&gt;zone_start_pfn
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pfn_valid
c_func
(paren
id|pfn
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|page
op_assign
id|pfn_to_page
c_func
(paren
id|pfn
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|PageReserved
c_func
(paren
id|page
)paren
op_logical_and
id|PageNosave
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageNosave
c_func
(paren
id|page
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|page
)paren
op_logical_and
id|pfn_is_nosave
c_func
(paren
id|pfn
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;[nosave pfn 0x%lx]&quot;
comma
id|pfn
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PageNosaveFree
c_func
(paren
id|page
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|count_data_pages
r_static
r_void
id|count_data_pages
c_func
(paren
r_void
)paren
(brace
r_struct
id|zone
op_star
id|zone
suffix:semicolon
r_int
r_int
id|zone_pfn
suffix:semicolon
id|nr_copy_pages
op_assign
l_int|0
suffix:semicolon
id|for_each_zone
c_func
(paren
id|zone
)paren
(brace
r_if
c_cond
(paren
id|is_highmem
c_func
(paren
id|zone
)paren
)paren
r_continue
suffix:semicolon
id|mark_free_pages
c_func
(paren
id|zone
)paren
suffix:semicolon
r_for
c_loop
(paren
id|zone_pfn
op_assign
l_int|0
suffix:semicolon
id|zone_pfn
OL
id|zone-&gt;spanned_pages
suffix:semicolon
op_increment
id|zone_pfn
)paren
id|nr_copy_pages
op_add_assign
id|saveable
c_func
(paren
id|zone
comma
op_amp
id|zone_pfn
)paren
suffix:semicolon
)brace
)brace
DECL|function|copy_data_pages
r_static
r_void
id|copy_data_pages
c_func
(paren
r_void
)paren
(brace
r_struct
id|zone
op_star
id|zone
suffix:semicolon
r_int
r_int
id|zone_pfn
suffix:semicolon
r_struct
id|pbe
op_star
id|pbe
op_assign
id|pagedir_nosave
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;copy_data_pages(): pages to copy: %d&bslash;n&quot;
comma
id|nr_copy_pages
)paren
suffix:semicolon
id|for_each_zone
c_func
(paren
id|zone
)paren
(brace
r_if
c_cond
(paren
id|is_highmem
c_func
(paren
id|zone
)paren
)paren
r_continue
suffix:semicolon
id|mark_free_pages
c_func
(paren
id|zone
)paren
suffix:semicolon
r_for
c_loop
(paren
id|zone_pfn
op_assign
l_int|0
suffix:semicolon
id|zone_pfn
OL
id|zone-&gt;spanned_pages
suffix:semicolon
op_increment
id|zone_pfn
)paren
(brace
r_if
c_cond
(paren
id|saveable
c_func
(paren
id|zone
comma
op_amp
id|zone_pfn
)paren
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
id|page
op_assign
id|pfn_to_page
c_func
(paren
id|zone_pfn
op_plus
id|zone-&gt;zone_start_pfn
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|pbe
)paren
suffix:semicolon
id|pbe-&gt;orig_address
op_assign
(paren
r_int
)paren
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* copy_page is not usable for copying task structs. */
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|pbe-&gt;address
comma
(paren
r_void
op_star
)paren
id|pbe-&gt;orig_address
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|pbe
op_assign
id|pbe-&gt;next
suffix:semicolon
)brace
)brace
)brace
id|BUG_ON
c_func
(paren
id|pbe
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;calc_nr - Determine the number of pages needed for a pbe list.&n; */
DECL|function|calc_nr
r_static
r_int
id|calc_nr
c_func
(paren
r_int
id|nr_copy
)paren
(brace
r_int
id|extra
op_assign
l_int|0
suffix:semicolon
r_int
id|mod
op_assign
op_logical_neg
op_logical_neg
(paren
id|nr_copy
op_mod
id|PBES_PER_PAGE
)paren
suffix:semicolon
r_int
id|diff
op_assign
(paren
id|nr_copy
op_div
id|PBES_PER_PAGE
)paren
op_plus
id|mod
suffix:semicolon
r_do
(brace
id|extra
op_add_assign
id|diff
suffix:semicolon
id|nr_copy
op_add_assign
id|diff
suffix:semicolon
id|mod
op_assign
op_logical_neg
op_logical_neg
(paren
id|nr_copy
op_mod
id|PBES_PER_PAGE
)paren
suffix:semicolon
id|diff
op_assign
(paren
id|nr_copy
op_div
id|PBES_PER_PAGE
)paren
op_plus
id|mod
op_minus
id|extra
suffix:semicolon
)brace
r_while
c_loop
(paren
id|diff
OG
l_int|0
)paren
suffix:semicolon
r_return
id|nr_copy
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;free_pagedir - free pages allocated with alloc_pagedir()&n; */
DECL|function|free_pagedir
r_static
r_inline
r_void
id|free_pagedir
c_func
(paren
r_struct
id|pbe
op_star
id|pblist
)paren
(brace
r_struct
id|pbe
op_star
id|pbe
suffix:semicolon
r_while
c_loop
(paren
id|pblist
)paren
(brace
id|pbe
op_assign
(paren
id|pblist
op_plus
id|PB_PAGE_SKIP
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|pblist
)paren
suffix:semicolon
id|pblist
op_assign
id|pbe
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;fill_pb_page - Create a list of PBEs on a given memory page&n; */
DECL|function|fill_pb_page
r_static
r_inline
r_void
id|fill_pb_page
c_func
(paren
r_struct
id|pbe
op_star
id|pbpage
)paren
(brace
r_struct
id|pbe
op_star
id|p
suffix:semicolon
id|p
op_assign
id|pbpage
suffix:semicolon
id|pbpage
op_add_assign
id|PB_PAGE_SKIP
suffix:semicolon
r_do
id|p-&gt;next
op_assign
id|p
op_plus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_increment
id|p
OL
id|pbpage
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;create_pbe_list - Create a list of PBEs on top of a given chain&n; *&t;of memory pages allocated with alloc_pagedir()&n; */
DECL|function|create_pbe_list
r_static
r_void
id|create_pbe_list
c_func
(paren
r_struct
id|pbe
op_star
id|pblist
comma
r_int
id|nr_pages
)paren
(brace
r_struct
id|pbe
op_star
id|pbpage
comma
op_star
id|p
suffix:semicolon
r_int
id|num
op_assign
id|PBES_PER_PAGE
suffix:semicolon
id|for_each_pb_page
(paren
id|pbpage
comma
id|pblist
)paren
(brace
r_if
c_cond
(paren
id|num
op_ge
id|nr_pages
)paren
r_break
suffix:semicolon
id|fill_pb_page
c_func
(paren
id|pbpage
)paren
suffix:semicolon
id|num
op_add_assign
id|PBES_PER_PAGE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pbpage
)paren
(brace
r_for
c_loop
(paren
id|num
op_sub_assign
id|PBES_PER_PAGE
op_minus
l_int|1
comma
id|p
op_assign
id|pbpage
suffix:semicolon
id|num
OL
id|nr_pages
suffix:semicolon
id|p
op_increment
comma
id|num
op_increment
)paren
id|p-&gt;next
op_assign
id|p
op_plus
l_int|1
suffix:semicolon
id|p-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
id|pr_debug
c_func
(paren
l_string|&quot;create_pbe_list(): initialized %d PBEs&bslash;n&quot;
comma
id|num
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;alloc_pagedir - Allocate the page directory.&n; *&n; *&t;First, determine exactly how many pages we need and&n; *&t;allocate them.&n; *&n; *&t;We arrange the pages in a chain: each page is an array of PBES_PER_PAGE&n; *&t;struct pbe elements (pbes) and the last element in the page points&n; *&t;to the next page.&n; *&n; *&t;On each page we set up a list of struct_pbe elements.&n; */
DECL|function|alloc_pagedir
r_static
r_struct
id|pbe
op_star
id|alloc_pagedir
c_func
(paren
r_int
id|nr_pages
)paren
(brace
r_int
id|num
suffix:semicolon
r_struct
id|pbe
op_star
id|pblist
comma
op_star
id|pbe
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr_pages
)paren
r_return
l_int|NULL
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;alloc_pagedir(): nr_pages = %d&bslash;n&quot;
comma
id|nr_pages
)paren
suffix:semicolon
id|pblist
op_assign
(paren
r_struct
id|pbe
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
op_or
id|__GFP_COLD
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pbe
op_assign
id|pblist
comma
id|num
op_assign
id|PBES_PER_PAGE
suffix:semicolon
id|pbe
op_logical_and
id|num
OL
id|nr_pages
suffix:semicolon
id|pbe
op_assign
id|pbe-&gt;next
comma
id|num
op_add_assign
id|PBES_PER_PAGE
)paren
(brace
id|pbe
op_add_assign
id|PB_PAGE_SKIP
suffix:semicolon
id|pbe-&gt;next
op_assign
(paren
r_struct
id|pbe
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
op_or
id|__GFP_COLD
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pbe
)paren
(brace
multiline_comment|/* get_zeroed_page() failed */
id|free_pagedir
c_func
(paren
id|pblist
)paren
suffix:semicolon
id|pblist
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|pblist
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;free_image_pages - Free pages allocated for snapshot&n; */
DECL|function|free_image_pages
r_static
r_void
id|free_image_pages
c_func
(paren
r_void
)paren
(brace
r_struct
id|pbe
op_star
id|p
suffix:semicolon
id|for_each_pbe
c_func
(paren
id|p
comma
id|pagedir_save
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;address
)paren
(brace
id|ClearPageNosave
c_func
(paren
id|virt_to_page
c_func
(paren
id|p-&gt;address
)paren
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|p-&gt;address
)paren
suffix:semicolon
id|p-&gt;address
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**&n; *&t;alloc_image_pages - Allocate pages for the snapshot.&n; */
DECL|function|alloc_image_pages
r_static
r_int
id|alloc_image_pages
c_func
(paren
r_void
)paren
(brace
r_struct
id|pbe
op_star
id|p
suffix:semicolon
id|for_each_pbe
c_func
(paren
id|p
comma
id|pagedir_save
)paren
(brace
id|p-&gt;address
op_assign
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
op_or
id|__GFP_COLD
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;address
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|SetPageNosave
c_func
(paren
id|virt_to_page
c_func
(paren
id|p-&gt;address
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|swsusp_free
r_void
id|swsusp_free
c_func
(paren
r_void
)paren
(brace
id|BUG_ON
c_func
(paren
id|PageNosave
c_func
(paren
id|virt_to_page
c_func
(paren
id|pagedir_save
)paren
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|PageNosaveFree
c_func
(paren
id|virt_to_page
c_func
(paren
id|pagedir_save
)paren
)paren
)paren
suffix:semicolon
id|free_image_pages
c_func
(paren
)paren
suffix:semicolon
id|free_pagedir
c_func
(paren
id|pagedir_save
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;enough_free_mem - Make sure we enough free memory to snapshot.&n; *&n; *&t;Returns TRUE or FALSE after checking the number of available &n; *&t;free pages.&n; */
DECL|function|enough_free_mem
r_static
r_int
id|enough_free_mem
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|nr_free_pages
c_func
(paren
)paren
OL
(paren
id|nr_copy_pages
op_plus
id|PAGES_FOR_IO
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;swsusp: Not enough free pages: Have %d&bslash;n&quot;
comma
id|nr_free_pages
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;enough_swap - Make sure we have enough swap to save the image.&n; *&n; *&t;Returns TRUE or FALSE after checking the total amount of swap &n; *&t;space avaiable.&n; *&n; *&t;FIXME: si_swapinfo(&amp;i) returns all swap devices information.&n; *&t;We should only consider resume_device. &n; */
DECL|function|enough_swap
r_static
r_int
id|enough_swap
c_func
(paren
r_void
)paren
(brace
r_struct
id|sysinfo
id|i
suffix:semicolon
id|si_swapinfo
c_func
(paren
op_amp
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i.freeswap
OL
(paren
id|nr_copy_pages
op_plus
id|PAGES_FOR_IO
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;swsusp: Not enough swap. Need %ld&bslash;n&quot;
comma
id|i.freeswap
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|swsusp_alloc
r_static
r_int
id|swsusp_alloc
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;suspend: (pages needed: %d + %d free: %d)&bslash;n&quot;
comma
id|nr_copy_pages
comma
id|PAGES_FOR_IO
comma
id|nr_free_pages
c_func
(paren
)paren
)paren
suffix:semicolon
id|pagedir_nosave
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|enough_free_mem
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|enough_swap
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENOSPC
suffix:semicolon
id|nr_copy_pages
op_assign
id|calc_nr
c_func
(paren
id|nr_copy_pages
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pagedir_save
op_assign
id|alloc_pagedir
c_func
(paren
id|nr_copy_pages
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;suspend: Allocating pagedir failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|create_pbe_list
c_func
(paren
id|pagedir_save
comma
id|nr_copy_pages
)paren
suffix:semicolon
id|pagedir_nosave
op_assign
id|pagedir_save
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|alloc_image_pages
c_func
(paren
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;suspend: Allocating image pages failed.&bslash;n&quot;
)paren
suffix:semicolon
id|swsusp_free
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|nr_copy_pages_check
op_assign
id|nr_copy_pages
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|suspend_prepare_image
r_static
r_int
id|suspend_prepare_image
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;swsusp: critical section: &bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|save_highmem
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Suspend machine: Not enough free pages for highmem&bslash;n&quot;
)paren
suffix:semicolon
id|restore_highmem
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|drain_local_pages
c_func
(paren
)paren
suffix:semicolon
id|count_data_pages
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;swsusp: Need to copy %u pages&bslash;n&quot;
comma
id|nr_copy_pages
)paren
suffix:semicolon
id|error
op_assign
id|swsusp_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* During allocating of suspend pagedir, new cold pages may appear. &n;&t; * Kill them.&n;&t; */
id|drain_local_pages
c_func
(paren
)paren
suffix:semicolon
id|copy_data_pages
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * End of critical section. From now on, we can write to memory,&n;&t; * but we should not touch disk. This specially means we must _not_&n;&t; * touch swap space! Except we must write out our image of course.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;swsusp: critical section/: done (%d pages copied)&bslash;n&quot;
comma
id|nr_copy_pages
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* It is important _NOT_ to umount filesystems at this point. We want&n; * them synced (in case something goes wrong) but we DO not want to mark&n; * filesystem clean: it is not. (And it does not matter, if we resume&n; * correctly, we&squot;ll mark system clean, anyway.)&n; */
DECL|function|swsusp_write
r_int
id|swsusp_write
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
id|device_resume
c_func
(paren
)paren
suffix:semicolon
id|lock_swapdevices
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|write_suspend_image
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* This will unlock ignored swap devices since writing is finished */
id|lock_swapdevices
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_extern
id|asmlinkage
r_int
id|swsusp_arch_suspend
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|swsusp_arch_resume
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|swsusp_save
id|asmlinkage
r_int
id|swsusp_save
c_func
(paren
r_void
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|swsusp_swap_check
c_func
(paren
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swsusp: FATAL: cannot find swap device, try &quot;
l_string|&quot;swapon -a!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_return
id|suspend_prepare_image
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|swsusp_suspend
r_int
id|swsusp_suspend
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|arch_prepare_suspend
c_func
(paren
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* At this point, device_suspend() has been called, but *not*&n;&t; * device_power_down(). We *must* device_power_down() now.&n;&t; * Otherwise, drivers for some devices (e.g. interrupt controllers)&n;&t; * become desynchronized with the actual state of the hardware&n;&t; * at resume time, and evil weirdness ensues.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|device_power_down
c_func
(paren
id|PMSG_FREEZE
)paren
)paren
)paren
(brace
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|save_processor_state
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|swsusp_arch_suspend
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Restore control flow magically appears here */
id|restore_processor_state
c_func
(paren
)paren
suffix:semicolon
id|restore_highmem
c_func
(paren
)paren
suffix:semicolon
id|device_power_up
c_func
(paren
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|swsusp_restore
id|asmlinkage
r_int
id|swsusp_restore
c_func
(paren
r_void
)paren
(brace
id|BUG_ON
(paren
id|nr_copy_pages_check
op_ne
id|nr_copy_pages
)paren
suffix:semicolon
multiline_comment|/* Even mappings of &quot;global&quot; things (vmalloc) need to be fixed */
id|__flush_tlb_global
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|swsusp_resume
r_int
id|swsusp_resume
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|device_power_down
c_func
(paren
id|PMSG_FREEZE
)paren
suffix:semicolon
multiline_comment|/* We&squot;ll ignore saved state, but this gets preempt count (etc) right */
id|save_processor_state
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|swsusp_arch_resume
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Code below is only ever reached in case of failure. Otherwise&n;&t; * execution continues at place where swsusp_arch_suspend was called&n;         */
id|BUG_ON
c_func
(paren
op_logical_neg
id|error
)paren
suffix:semicolon
id|restore_processor_state
c_func
(paren
)paren
suffix:semicolon
id|restore_highmem
c_func
(paren
)paren
suffix:semicolon
id|device_power_up
c_func
(paren
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* More restore stuff */
multiline_comment|/*&n; * Returns true if given address/order collides with any orig_address &n; */
DECL|function|does_collide_order
r_static
r_int
id|does_collide_order
c_func
(paren
r_int
r_int
id|addr
comma
r_int
id|order
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
l_int|1
op_lshift
id|order
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|PageNosaveFree
c_func
(paren
id|virt_to_page
c_func
(paren
id|addr
op_plus
id|i
op_star
id|PAGE_SIZE
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;On resume, for storing the PBE list and the image,&n; *&t;we can only use memory pages that do not conflict with the pages&n; *&t;which had been used before suspend.&n; *&n; *&t;We don&squot;t know which pages are usable until we allocate them.&n; *&n; *&t;Allocated but unusable (ie eaten) memory pages are linked together&n; *&t;to create a list, so that we can free them easily&n; *&n; *&t;We could have used a type other than (void *)&n; *&t;for this purpose, but ...&n; */
DECL|variable|eaten_memory
r_static
r_void
op_star
op_star
id|eaten_memory
op_assign
l_int|NULL
suffix:semicolon
DECL|function|eat_page
r_static
r_inline
r_void
id|eat_page
c_func
(paren
r_void
op_star
id|page
)paren
(brace
r_void
op_star
op_star
id|c
suffix:semicolon
id|c
op_assign
id|eaten_memory
suffix:semicolon
id|eaten_memory
op_assign
id|page
suffix:semicolon
op_star
id|eaten_memory
op_assign
id|c
suffix:semicolon
)brace
DECL|function|get_usable_page
r_static
r_int
r_int
id|get_usable_page
c_func
(paren
r_int
id|gfp_mask
)paren
(brace
r_int
r_int
id|m
suffix:semicolon
id|m
op_assign
id|get_zeroed_page
c_func
(paren
id|gfp_mask
)paren
suffix:semicolon
r_while
c_loop
(paren
id|does_collide_order
c_func
(paren
id|m
comma
l_int|0
)paren
)paren
(brace
id|eat_page
c_func
(paren
(paren
r_void
op_star
)paren
id|m
)paren
suffix:semicolon
id|m
op_assign
id|get_zeroed_page
c_func
(paren
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|m
)paren
r_break
suffix:semicolon
)brace
r_return
id|m
suffix:semicolon
)brace
DECL|function|free_eaten_memory
r_static
r_void
id|free_eaten_memory
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|m
suffix:semicolon
r_void
op_star
op_star
id|c
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|c
op_assign
id|eaten_memory
suffix:semicolon
r_while
c_loop
(paren
id|c
)paren
(brace
id|m
op_assign
(paren
r_int
r_int
)paren
id|c
suffix:semicolon
id|c
op_assign
op_star
id|c
suffix:semicolon
id|free_page
c_func
(paren
id|m
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|eaten_memory
op_assign
l_int|NULL
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;swsusp: %d unused pages freed&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;check_pagedir - We ensure here that pages that the PBEs point to&n; *&t;won&squot;t collide with pages where we&squot;re going to restore from the loaded&n; *&t;pages later&n; */
DECL|function|check_pagedir
r_static
r_int
id|check_pagedir
c_func
(paren
r_struct
id|pbe
op_star
id|pblist
)paren
(brace
r_struct
id|pbe
op_star
id|p
suffix:semicolon
multiline_comment|/* This is necessary, so that we can free allocated pages&n;&t; * in case of failure&n;&t; */
id|for_each_pbe
(paren
id|p
comma
id|pblist
)paren
id|p-&gt;address
op_assign
l_int|0UL
suffix:semicolon
id|for_each_pbe
(paren
id|p
comma
id|pblist
)paren
(brace
id|p-&gt;address
op_assign
id|get_usable_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;address
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;swsusp_pagedir_relocate - It is possible, that some memory pages&n; *&t;occupied by the list of PBEs collide with pages where we&squot;re going to&n; *&t;restore from the loaded pages later.  We relocate them here.&n; */
DECL|function|swsusp_pagedir_relocate
r_static
r_struct
id|pbe
op_star
id|swsusp_pagedir_relocate
c_func
(paren
r_struct
id|pbe
op_star
id|pblist
)paren
(brace
r_struct
id|zone
op_star
id|zone
suffix:semicolon
r_int
r_int
id|zone_pfn
suffix:semicolon
r_struct
id|pbe
op_star
id|pbpage
comma
op_star
id|tail
comma
op_star
id|p
suffix:semicolon
r_void
op_star
id|m
suffix:semicolon
r_int
id|rel
op_assign
l_int|0
comma
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pblist
)paren
multiline_comment|/* a sanity check */
r_return
l_int|NULL
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;swsusp: Relocating pagedir (%lu pages to check)&bslash;n&quot;
comma
id|swsusp_info.pagedir_pages
)paren
suffix:semicolon
multiline_comment|/* Set page flags */
id|for_each_zone
c_func
(paren
id|zone
)paren
(brace
r_for
c_loop
(paren
id|zone_pfn
op_assign
l_int|0
suffix:semicolon
id|zone_pfn
OL
id|zone-&gt;spanned_pages
suffix:semicolon
op_increment
id|zone_pfn
)paren
id|SetPageNosaveFree
c_func
(paren
id|pfn_to_page
c_func
(paren
id|zone_pfn
op_plus
id|zone-&gt;zone_start_pfn
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Clear orig addresses */
id|for_each_pbe
(paren
id|p
comma
id|pblist
)paren
id|ClearPageNosaveFree
c_func
(paren
id|virt_to_page
c_func
(paren
id|p-&gt;orig_address
)paren
)paren
suffix:semicolon
id|tail
op_assign
id|pblist
op_plus
id|PB_PAGE_SKIP
suffix:semicolon
multiline_comment|/* Relocate colliding pages */
id|for_each_pb_page
(paren
id|pbpage
comma
id|pblist
)paren
(brace
r_if
c_cond
(paren
id|does_collide_order
c_func
(paren
(paren
r_int
r_int
)paren
id|pbpage
comma
l_int|0
)paren
)paren
(brace
id|m
op_assign
(paren
r_void
op_star
)paren
id|get_usable_page
c_func
(paren
id|GFP_ATOMIC
op_or
id|__GFP_COLD
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|m
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|m
comma
(paren
r_void
op_star
)paren
id|pbpage
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pbpage
op_eq
id|pblist
)paren
id|pblist
op_assign
(paren
r_struct
id|pbe
op_star
)paren
id|m
suffix:semicolon
r_else
id|tail-&gt;next
op_assign
(paren
r_struct
id|pbe
op_star
)paren
id|m
suffix:semicolon
id|eat_page
c_func
(paren
(paren
r_void
op_star
)paren
id|pbpage
)paren
suffix:semicolon
id|pbpage
op_assign
(paren
r_struct
id|pbe
op_star
)paren
id|m
suffix:semicolon
multiline_comment|/* We have to link the PBEs again */
r_for
c_loop
(paren
id|p
op_assign
id|pbpage
suffix:semicolon
id|p
OL
id|pbpage
op_plus
id|PB_PAGE_SKIP
suffix:semicolon
id|p
op_increment
)paren
r_if
c_cond
(paren
id|p-&gt;next
)paren
multiline_comment|/* needed to save the end */
id|p-&gt;next
op_assign
id|p
op_plus
l_int|1
suffix:semicolon
id|rel
op_increment
suffix:semicolon
)brace
id|tail
op_assign
id|pbpage
op_plus
id|PB_PAGE_SKIP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nswsusp: Out of memory&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|free_pagedir
c_func
(paren
id|pblist
)paren
suffix:semicolon
id|free_eaten_memory
c_func
(paren
)paren
suffix:semicolon
id|pblist
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;swsusp: Relocated %d pages&bslash;n&quot;
comma
id|rel
)paren
suffix:semicolon
r_return
id|pblist
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;Using bio to read from swap.&n; *&t;This code requires a bit more work than just using buffer heads&n; *&t;but, it is the recommended way for 2.5/2.6.&n; *&t;The following are to signal the beginning and end of I/O. Bios&n; *&t;finish asynchronously, while we want them to happen synchronously.&n; *&t;A simple atomic_t, and a wait loop take care of this problem.&n; */
DECL|variable|io_done
r_static
id|atomic_t
id|io_done
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|function|end_io
r_static
r_int
id|end_io
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|num
comma
r_int
id|err
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;I/O error reading memory image&quot;
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|io_done
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|resume_bdev
r_static
r_struct
id|block_device
op_star
id|resume_bdev
suffix:semicolon
multiline_comment|/**&n; *&t;submit - submit BIO request.&n; *&t;@rw:&t;READ or WRITE.&n; *&t;@off&t;physical offset of page.&n; *&t;@page:&t;page we&squot;re reading or writing.&n; *&n; *&t;Straight from the textbook - allocate and initialize the bio.&n; *&t;If we&squot;re writing, make sure the page is marked as dirty.&n; *&t;Then submit it and wait.&n; */
DECL|function|submit
r_static
r_int
id|submit
c_func
(paren
r_int
id|rw
comma
id|pgoff_t
id|page_off
comma
r_void
op_star
id|page
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|GFP_ATOMIC
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|page_off
op_star
(paren
id|PAGE_SIZE
op_rshift
l_int|9
)paren
suffix:semicolon
id|bio_get
c_func
(paren
id|bio
)paren
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|resume_bdev
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|end_io
suffix:semicolon
r_if
c_cond
(paren
id|bio_add_page
c_func
(paren
id|bio
comma
id|virt_to_page
c_func
(paren
id|page
)paren
comma
id|PAGE_SIZE
comma
l_int|0
)paren
OL
id|PAGE_SIZE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;swsusp: ERROR: adding page to bio at %ld&bslash;n&quot;
comma
id|page_off
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rw
op_eq
id|WRITE
)paren
id|bio_set_pages_dirty
c_func
(paren
id|bio
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|io_done
comma
l_int|1
)paren
suffix:semicolon
id|submit_bio
c_func
(paren
id|rw
op_or
(paren
l_int|1
op_lshift
id|BIO_RW_SYNC
)paren
comma
id|bio
)paren
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|io_done
)paren
)paren
id|yield
c_func
(paren
)paren
suffix:semicolon
id|Done
suffix:colon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|bio_read_page
r_static
r_int
id|bio_read_page
c_func
(paren
id|pgoff_t
id|page_off
comma
r_void
op_star
id|page
)paren
(brace
r_return
id|submit
c_func
(paren
id|READ
comma
id|page_off
comma
id|page
)paren
suffix:semicolon
)brace
DECL|function|bio_write_page
r_static
r_int
id|bio_write_page
c_func
(paren
id|pgoff_t
id|page_off
comma
r_void
op_star
id|page
)paren
(brace
r_return
id|submit
c_func
(paren
id|WRITE
comma
id|page_off
comma
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Sanity check if this image makes sense with this kernel/swap context&n; * I really don&squot;t think that it&squot;s foolproof but more than nothing..&n; */
DECL|function|sanity_check
r_static
r_const
r_char
op_star
id|sanity_check
c_func
(paren
r_void
)paren
(brace
id|dump_info
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|swsusp_info.version_code
op_ne
id|LINUX_VERSION_CODE
)paren
(brace
r_return
l_string|&quot;kernel version&quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|swsusp_info.num_physpages
op_ne
id|num_physpages
)paren
(brace
r_return
l_string|&quot;memory size&quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|swsusp_info.uts.sysname
comma
id|system_utsname.sysname
)paren
)paren
r_return
l_string|&quot;system type&quot;
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|swsusp_info.uts.release
comma
id|system_utsname.release
)paren
)paren
r_return
l_string|&quot;kernel release&quot;
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|swsusp_info.uts.version
comma
id|system_utsname.version
)paren
)paren
r_return
l_string|&quot;version&quot;
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|swsusp_info.uts.machine
comma
id|system_utsname.machine
)paren
)paren
r_return
l_string|&quot;machine&quot;
suffix:semicolon
r_if
c_cond
(paren
id|swsusp_info.cpus
op_ne
id|num_online_cpus
c_func
(paren
)paren
)paren
(brace
r_return
l_string|&quot;number of cpus&quot;
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|check_header
r_static
r_int
id|check_header
c_func
(paren
r_void
)paren
(brace
r_const
r_char
op_star
id|reason
op_assign
l_int|NULL
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|bio_read_page
c_func
(paren
id|swp_offset
c_func
(paren
id|swsusp_header.swsusp_info
)paren
comma
op_amp
id|swsusp_info
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* Is this same machine? */
r_if
c_cond
(paren
(paren
id|reason
op_assign
id|sanity_check
c_func
(paren
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;swsusp: Resume mismatch: %s&bslash;n&quot;
comma
id|reason
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|nr_copy_pages
op_assign
id|swsusp_info.image_pages
suffix:semicolon
id|pagedir_order
op_assign
id|get_bitmask_order
c_func
(paren
id|SUSPEND_PD_PAGES
c_func
(paren
id|nr_copy_pages
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|check_sig
r_static
r_int
id|check_sig
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|swsusp_header
comma
l_int|0
comma
r_sizeof
(paren
id|swsusp_header
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|bio_read_page
c_func
(paren
l_int|0
comma
op_amp
id|swsusp_header
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|SWSUSP_SIG
comma
id|swsusp_header.sig
comma
l_int|10
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|swsusp_header.sig
comma
id|swsusp_header.orig_sig
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Reset swap signature now.&n;&t;&t; */
id|error
op_assign
id|bio_write_page
c_func
(paren
l_int|0
comma
op_amp
id|swsusp_header
)paren
suffix:semicolon
)brace
r_else
(brace
id|pr_debug
c_func
(paren
id|KERN_ERR
l_string|&quot;swsusp: Suspend partition has wrong signature?&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|pr_debug
c_func
(paren
l_string|&quot;swsusp: Signature found, resuming&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;data_read - Read image pages from swap.&n; *&n; *&t;You do not need to check for overlaps, check_pagedir()&n; *&t;already did that.&n; */
DECL|function|data_read
r_static
r_int
id|data_read
c_func
(paren
r_struct
id|pbe
op_star
id|pblist
)paren
(brace
r_struct
id|pbe
op_star
id|p
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|mod
op_assign
id|swsusp_info.image_pages
op_div
l_int|100
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mod
)paren
id|mod
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;swsusp: Reading image data (%lu pages):     &quot;
comma
id|swsusp_info.image_pages
)paren
suffix:semicolon
id|for_each_pbe
(paren
id|p
comma
id|pblist
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_mod
id|mod
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;b&bslash;b&bslash;b&bslash;b%3d%%&quot;
comma
id|i
op_div
id|mod
)paren
suffix:semicolon
id|error
op_assign
id|bio_read_page
c_func
(paren
id|swp_offset
c_func
(paren
id|p-&gt;swap_address
)paren
comma
(paren
r_void
op_star
)paren
id|p-&gt;address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;b&bslash;b&bslash;b&bslash;bdone&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_extern
id|dev_t
id|name_to_dev_t
c_func
(paren
r_const
r_char
op_star
id|line
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;read_pagedir - Read page backup list pages from swap&n; */
DECL|function|read_pagedir
r_static
r_int
id|read_pagedir
c_func
(paren
r_struct
id|pbe
op_star
id|pblist
)paren
(brace
r_struct
id|pbe
op_star
id|pbpage
comma
op_star
id|p
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pblist
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;swsusp: Reading pagedir (%lu pages)&bslash;n&quot;
comma
id|swsusp_info.pagedir_pages
)paren
suffix:semicolon
id|for_each_pb_page
(paren
id|pbpage
comma
id|pblist
)paren
(brace
r_int
r_int
id|offset
op_assign
id|swp_offset
c_func
(paren
id|swsusp_info.pagedir
(braket
id|i
op_increment
)braket
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|offset
)paren
(brace
id|p
op_assign
(paren
id|pbpage
op_plus
id|PB_PAGE_SKIP
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|error
op_assign
id|bio_read_page
c_func
(paren
id|offset
comma
(paren
r_void
op_star
)paren
id|pbpage
)paren
suffix:semicolon
(paren
id|pbpage
op_plus
id|PB_PAGE_SKIP
)paren
op_member_access_from_pointer
id|next
op_assign
id|p
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|pblist
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|i
op_ne
id|swsusp_info.pagedir_pages
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|check_suspend_image
r_static
r_int
id|check_suspend_image
c_func
(paren
r_void
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|check_sig
c_func
(paren
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|check_header
c_func
(paren
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_suspend_image
r_static
r_int
id|read_suspend_image
c_func
(paren
r_void
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_struct
id|pbe
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_assign
id|alloc_pagedir
c_func
(paren
id|nr_copy_pages
)paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|read_pagedir
c_func
(paren
id|p
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|create_pbe_list
c_func
(paren
id|p
comma
id|nr_copy_pages
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pagedir_nosave
op_assign
id|swsusp_pagedir_relocate
c_func
(paren
id|p
)paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Allocate memory for the image and read the data from swap */
id|error
op_assign
id|check_pagedir
c_func
(paren
id|pagedir_nosave
)paren
suffix:semicolon
id|free_eaten_memory
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|data_read
c_func
(paren
id|pagedir_nosave
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/* We fail cleanly */
id|for_each_pbe
(paren
id|p
comma
id|pagedir_nosave
)paren
r_if
c_cond
(paren
id|p-&gt;address
)paren
(brace
id|free_page
c_func
(paren
id|p-&gt;address
)paren
suffix:semicolon
id|p-&gt;address
op_assign
l_int|0UL
suffix:semicolon
)brace
id|free_pagedir
c_func
(paren
id|pagedir_nosave
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *      swsusp_check - Check for saved image in swap&n; */
DECL|function|swsusp_check
r_int
id|swsusp_check
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|swsusp_resume_device
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strlen
c_func
(paren
id|resume_file
)paren
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|swsusp_resume_device
op_assign
id|name_to_dev_t
c_func
(paren
id|resume_file
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;swsusp: Resume From Partition %s&bslash;n&quot;
comma
id|resume_file
)paren
suffix:semicolon
)brace
r_else
(brace
id|pr_debug
c_func
(paren
l_string|&quot;swsusp: Resume From Partition %d:%d&bslash;n&quot;
comma
id|MAJOR
c_func
(paren
id|swsusp_resume_device
)paren
comma
id|MINOR
c_func
(paren
id|swsusp_resume_device
)paren
)paren
suffix:semicolon
)brace
id|resume_bdev
op_assign
id|open_by_devnum
c_func
(paren
id|swsusp_resume_device
comma
id|FMODE_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|resume_bdev
)paren
)paren
(brace
id|set_blocksize
c_func
(paren
id|resume_bdev
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|error
op_assign
id|check_suspend_image
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|blkdev_put
c_func
(paren
id|resume_bdev
)paren
suffix:semicolon
)brace
r_else
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|resume_bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|pr_debug
c_func
(paren
l_string|&quot;swsusp: resume file found&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|pr_debug
c_func
(paren
l_string|&quot;swsusp: Error %d check for resume file&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;swsusp_read - Read saved image from swap.&n; */
DECL|function|swsusp_read
r_int
id|swsusp_read
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|resume_bdev
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;swsusp: block device not initialised&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|resume_bdev
)paren
suffix:semicolon
)brace
id|error
op_assign
id|read_suspend_image
c_func
(paren
)paren
suffix:semicolon
id|blkdev_put
c_func
(paren
id|resume_bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|pr_debug
c_func
(paren
l_string|&quot;swsusp: Reading resume file was successful&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|pr_debug
c_func
(paren
l_string|&quot;swsusp: Error %d resuming&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;swsusp_close - close swap device.&n; */
DECL|function|swsusp_close
r_void
id|swsusp_close
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|resume_bdev
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;swsusp: block device not initialised&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|blkdev_put
c_func
(paren
id|resume_bdev
)paren
suffix:semicolon
)brace
eof
