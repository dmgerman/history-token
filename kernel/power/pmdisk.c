multiline_comment|/*&n; * kernel/power/pmdisk.c - Suspend-to-disk implmentation&n; *&n; * This STD implementation is initially derived from swsusp (suspend-to-swap).&n; * The original copyright on that was: &n; *&n; * Copyright (C) 1998-2001 Gabor Kuti &lt;seasons@fornax.hu&gt;&n; * Copyright (C) 1998,2001,2002 Pavel Machek &lt;pavel@suse.cz&gt;&n; *&n; * The additional parts are: &n; * &n; * Copyright (C) 2003 Patrick Mochel&n; * Copyright (C) 2003 Open Source Development Lab&n; * &n; * This file is released under the GPLv2. &n; *&n; * For more information, please see the text files in Documentation/power/&n; *&n; */
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/swapops.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &quot;power.h&quot;
r_extern
r_int
id|pmdisk_arch_suspend
c_func
(paren
r_int
id|resume
)paren
suffix:semicolon
DECL|macro|__ADDRESS
mdefine_line|#define __ADDRESS(x)  ((unsigned long) phys_to_virt(x))
DECL|macro|ADDRESS
mdefine_line|#define ADDRESS(x) __ADDRESS((x) &lt;&lt; PAGE_SHIFT)
DECL|macro|ADDRESS2
mdefine_line|#define ADDRESS2(x) __ADDRESS(__pa(x))&t;&t;/* Needed for x86-64 where some pages are in memory twice */
multiline_comment|/* References to section boundaries */
r_extern
r_char
id|__nosave_begin
comma
id|__nosave_end
suffix:semicolon
r_extern
r_int
id|is_head_of_free_region
c_func
(paren
r_struct
id|page
op_star
)paren
suffix:semicolon
multiline_comment|/* Variables to be preserved over suspend */
DECL|variable|pagedir_order_check
r_static
r_int
id|pagedir_order_check
suffix:semicolon
DECL|variable|nr_copy_pages_check
r_static
r_int
id|nr_copy_pages_check
suffix:semicolon
multiline_comment|/* For resume= kernel option */
DECL|variable|resume_file
r_static
r_char
id|resume_file
(braket
l_int|256
)braket
op_assign
id|CONFIG_PM_DISK_PARTITION
suffix:semicolon
DECL|variable|resume_device
r_static
id|dev_t
id|resume_device
suffix:semicolon
multiline_comment|/* Local variables that should not be affected by save */
DECL|variable|__nosavedata
r_int
r_int
id|pmdisk_pages
id|__nosavedata
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Suspend pagedir is allocated before final copy, therefore it&n;   must be freed after resume &n;&n;   Warning: this is evil. There are actually two pagedirs at time of&n;   resume. One is &quot;pagedir_save&quot;, which is empty frame allocated at&n;   time of suspend, that must be freed. Second is &quot;pagedir_nosave&quot;, &n;   allocated at time of resume, that travels through memory not to&n;   collide with anything.&n; */
DECL|variable|__nosavedata
id|suspend_pagedir_t
op_star
id|pm_pagedir_nosave
id|__nosavedata
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|pagedir_save
r_static
id|suspend_pagedir_t
op_star
id|pagedir_save
suffix:semicolon
DECL|variable|__nosavedata
r_static
r_int
id|pagedir_order
id|__nosavedata
op_assign
l_int|0
suffix:semicolon
DECL|struct|pmdisk_info
r_struct
id|pmdisk_info
(brace
DECL|member|uts
r_struct
id|new_utsname
id|uts
suffix:semicolon
DECL|member|version_code
id|u32
id|version_code
suffix:semicolon
DECL|member|num_physpages
r_int
r_int
id|num_physpages
suffix:semicolon
DECL|member|cpus
r_int
id|cpus
suffix:semicolon
DECL|member|image_pages
r_int
r_int
id|image_pages
suffix:semicolon
DECL|member|pagedir_pages
r_int
r_int
id|pagedir_pages
suffix:semicolon
DECL|member|pagedir
id|swp_entry_t
id|pagedir
(braket
l_int|768
)braket
suffix:semicolon
DECL|variable|pmdisk_info
)brace
id|__attribute__
c_func
(paren
(paren
id|aligned
c_func
(paren
id|PAGE_SIZE
)paren
)paren
)paren
id|pmdisk_info
suffix:semicolon
DECL|macro|PMDISK_SIG
mdefine_line|#define PMDISK_SIG&t;&quot;pmdisk-swap1&quot;
DECL|struct|pmdisk_header
r_struct
id|pmdisk_header
(brace
DECL|member|reserved
r_char
id|reserved
(braket
id|PAGE_SIZE
op_minus
l_int|20
op_minus
r_sizeof
(paren
id|swp_entry_t
)paren
)braket
suffix:semicolon
DECL|member|pmdisk_info
id|swp_entry_t
id|pmdisk_info
suffix:semicolon
DECL|member|orig_sig
r_char
id|orig_sig
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|sig
r_char
id|sig
(braket
l_int|10
)braket
suffix:semicolon
DECL|variable|pmdisk_header
)brace
id|__attribute__
c_func
(paren
(paren
id|packed
comma
id|aligned
c_func
(paren
id|PAGE_SIZE
)paren
)paren
)paren
id|pmdisk_header
suffix:semicolon
multiline_comment|/*&n; * XXX: We try to keep some more pages free so that I/O operations succeed&n; * without paging. Might this be more?&n; */
DECL|macro|PAGES_FOR_IO
mdefine_line|#define PAGES_FOR_IO&t;512
multiline_comment|/*&n; * Saving part...&n; */
multiline_comment|/* We memorize in swapfile_used what swap devices are used for suspension */
DECL|macro|SWAPFILE_UNUSED
mdefine_line|#define SWAPFILE_UNUSED    0
DECL|macro|SWAPFILE_SUSPEND
mdefine_line|#define SWAPFILE_SUSPEND   1&t;/* This is the suspending device */
DECL|macro|SWAPFILE_IGNORED
mdefine_line|#define SWAPFILE_IGNORED   2&t;/* Those are other swap devices ignored for suspension */
DECL|variable|swapfile_used
r_static
r_int
r_int
id|swapfile_used
(braket
id|MAX_SWAPFILES
)braket
suffix:semicolon
DECL|variable|root_swap
r_static
r_int
r_int
id|root_swap
suffix:semicolon
DECL|function|mark_swapfiles
r_static
r_int
id|mark_swapfiles
c_func
(paren
id|swp_entry_t
id|prev
)paren
(brace
r_int
id|error
suffix:semicolon
id|rw_swap_page_sync
c_func
(paren
id|READ
comma
id|swp_entry
c_func
(paren
id|root_swap
comma
l_int|0
)paren
comma
id|virt_to_page
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|pmdisk_header
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;SWAP-SPACE&quot;
comma
id|pmdisk_header.sig
comma
l_int|10
)paren
op_logical_or
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;SWAPSPACE2&quot;
comma
id|pmdisk_header.sig
comma
l_int|10
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|pmdisk_header.orig_sig
comma
id|pmdisk_header.sig
comma
l_int|10
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|pmdisk_header.sig
comma
id|PMDISK_SIG
comma
l_int|10
)paren
suffix:semicolon
id|pmdisk_header.pmdisk_info
op_assign
id|prev
suffix:semicolon
id|error
op_assign
id|rw_swap_page_sync
c_func
(paren
id|WRITE
comma
id|swp_entry
c_func
(paren
id|root_swap
comma
l_int|0
)paren
comma
id|virt_to_page
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|pmdisk_header
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: Partition is not swap space.&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|read_swapfiles
r_static
r_int
id|read_swapfiles
c_func
(paren
r_void
)paren
multiline_comment|/* This is called before saving image */
(brace
r_int
id|i
comma
id|len
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|resume_file
)paren
suffix:semicolon
id|root_swap
op_assign
l_int|0xFFFF
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SWAPFILES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|swap_info
(braket
id|i
)braket
dot
id|flags
op_eq
l_int|0
)paren
(brace
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_UNUSED
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: Default resume partition not set.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root_swap
op_eq
l_int|0xFFFF
)paren
(brace
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_SUSPEND
suffix:semicolon
id|root_swap
op_assign
id|i
suffix:semicolon
)brace
r_else
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_IGNORED
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we ignore all swap devices that are not the resume_file */
r_if
c_cond
(paren
l_int|1
)paren
(brace
singleline_comment|// FIXME&t;&t;&t;&t;if(resume_device == swap_info[i].swap_device) {
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_SUSPEND
suffix:semicolon
id|root_swap
op_assign
id|i
suffix:semicolon
)brace
r_else
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_IGNORED
suffix:semicolon
)brace
)brace
)brace
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
id|root_swap
op_ne
l_int|0xffff
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* This is called after saving image so modification&n;   will be lost after resume... and that&squot;s what we want. */
DECL|function|lock_swapdevices
r_static
r_void
id|lock_swapdevices
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SWAPFILES
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|swapfile_used
(braket
id|i
)braket
op_eq
id|SWAPFILE_IGNORED
)paren
(brace
id|swap_info
(braket
id|i
)braket
dot
id|flags
op_xor_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/* we make the device unusable. A new call to&n;&t;&t;&t;&t;&t;&t;       lock_swapdevices can unlock the devices. */
)brace
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;write_swap_page - Write one page to a fresh swap location.&n; *&t;@addr:&t;Address we&squot;re writing.&n; *&t;@loc:&t;Place to store the entry we used.&n; *&n; *&t;Allocate a new swap entry and &squot;sync&squot; it. Note we discard -EIO&n; *&t;errors. That is an artifact left over from swsusp. It did not &n; *&t;check the return of rw_swap_page_sync() at all, since most pages&n; *&t;written back to swap would return -EIO.&n; *&t;This is a partial improvement, since we will at least return other&n; *&t;errors, though we need to eventually fix the damn code.&n; */
DECL|function|write_swap_page
r_static
r_int
id|write_swap_page
c_func
(paren
r_int
r_int
id|addr
comma
id|swp_entry_t
op_star
id|loc
)paren
(brace
id|swp_entry_t
id|entry
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|entry
op_assign
id|get_swap_page
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|swp_offset
c_func
(paren
id|entry
)paren
op_logical_and
id|swapfile_used
(braket
id|swp_type
c_func
(paren
id|entry
)paren
)braket
op_eq
id|SWAPFILE_SUSPEND
)paren
(brace
id|error
op_assign
id|rw_swap_page_sync
c_func
(paren
id|WRITE
comma
id|entry
comma
id|virt_to_page
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|EIO
)paren
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
op_star
id|loc
op_assign
id|entry
suffix:semicolon
)brace
r_else
id|error
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;free_data - Free the swap entries used by the saved image.&n; *&n; *&t;Walk the list of used swap entries and free each one. &n; */
DECL|function|free_data
r_static
r_void
id|free_data
c_func
(paren
r_void
)paren
(brace
id|swp_entry_t
id|entry
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmdisk_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
id|entry
op_assign
(paren
id|pm_pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|swap_address
suffix:semicolon
r_if
c_cond
(paren
id|entry.val
)paren
id|swap_free
c_func
(paren
id|entry
)paren
suffix:semicolon
r_else
r_break
suffix:semicolon
(paren
id|pm_pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|swap_address
op_assign
(paren
id|swp_entry_t
)paren
(brace
l_int|0
)brace
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;write_data - Write saved image to swap.&n; *&n; *&t;Walk the list of pages in the image and sync each one to swap.&n; */
DECL|function|write_data
r_static
r_int
id|write_data
c_func
(paren
r_void
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Writing data to swap (%d pages): &quot;
comma
id|pmdisk_pages
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmdisk_pages
op_logical_and
op_logical_neg
id|error
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_mod
l_int|100
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
id|error
op_assign
id|write_swap_page
c_func
(paren
(paren
id|pm_pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|address
comma
op_amp
(paren
(paren
id|pm_pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|swap_address
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; %d Pages done.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;free_pagedir - Free pages used by the page directory.&n; */
DECL|function|free_pagedir_entries
r_static
r_void
id|free_pagedir_entries
c_func
(paren
r_void
)paren
(brace
r_int
id|num
op_assign
id|pmdisk_info.pagedir_pages
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
id|swap_free
c_func
(paren
id|pmdisk_info.pagedir
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;write_pagedir - Write the array of pages holding the page directory.&n; *&t;@last:&t;Last swap entry we write (needed for header).&n; */
DECL|function|write_pagedir
r_static
r_int
id|write_pagedir
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|addr
op_assign
(paren
r_int
r_int
)paren
id|pm_pagedir_nosave
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|n
op_assign
id|SUSPEND_PD_PAGES
c_func
(paren
id|pmdisk_pages
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|pmdisk_info.pagedir_pages
op_assign
id|n
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Writing pagedir (%d pages)&bslash;n&quot;
comma
id|n
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
op_logical_and
op_logical_neg
id|error
suffix:semicolon
id|i
op_increment
comma
id|addr
op_add_assign
id|PAGE_SIZE
)paren
id|error
op_assign
id|write_swap_page
c_func
(paren
id|addr
comma
op_amp
id|pmdisk_info.pagedir
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
DECL|function|dump_pmdisk_info
r_static
r_void
id|dump_pmdisk_info
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; pmdisk: Version: %u&bslash;n&quot;
comma
id|pmdisk_info.version_code
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; pmdisk: Num Pages: %ld&bslash;n&quot;
comma
id|pmdisk_info.num_physpages
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; pmdisk: UTS Sys: %s&bslash;n&quot;
comma
id|pmdisk_info.uts.sysname
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; pmdisk: UTS Node: %s&bslash;n&quot;
comma
id|pmdisk_info.uts.nodename
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; pmdisk: UTS Release: %s&bslash;n&quot;
comma
id|pmdisk_info.uts.release
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; pmdisk: UTS Version: %s&bslash;n&quot;
comma
id|pmdisk_info.uts.version
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; pmdisk: UTS Machine: %s&bslash;n&quot;
comma
id|pmdisk_info.uts.machine
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; pmdisk: UTS Domain: %s&bslash;n&quot;
comma
id|pmdisk_info.uts.domainname
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; pmdisk: CPUs: %d&bslash;n&quot;
comma
id|pmdisk_info.cpus
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; pmdisk: Image: %ld Pages&bslash;n&quot;
comma
id|pmdisk_info.image_pages
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; pmdisk: Pagedir: %ld Pages&bslash;n&quot;
comma
id|pmdisk_info.pagedir_pages
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|function|dump_pmdisk_info
r_static
r_void
id|dump_pmdisk_info
c_func
(paren
r_void
)paren
(brace
)brace
macro_line|#endif
DECL|function|init_header
r_static
r_void
id|init_header
c_func
(paren
r_void
)paren
(brace
id|memset
c_func
(paren
op_amp
id|pmdisk_info
comma
l_int|0
comma
r_sizeof
(paren
id|pmdisk_info
)paren
)paren
suffix:semicolon
id|pmdisk_info.version_code
op_assign
id|LINUX_VERSION_CODE
suffix:semicolon
id|pmdisk_info.num_physpages
op_assign
id|num_physpages
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|pmdisk_info.uts
comma
op_amp
id|system_utsname
comma
r_sizeof
(paren
id|system_utsname
)paren
)paren
suffix:semicolon
id|pmdisk_info.cpus
op_assign
id|num_online_cpus
c_func
(paren
)paren
suffix:semicolon
id|pmdisk_info.image_pages
op_assign
id|pmdisk_pages
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;write_header - Fill and write the suspend header.&n; *&t;@entry:&t;Location of the last swap entry used.&n; *&n; *&t;Allocate a page, fill header, write header. &n; *&n; *&t;@entry is the location of the last pagedir entry written on &n; *&t;entrance. On exit, it contains the location of the header. &n; */
DECL|function|write_header
r_static
r_int
id|write_header
c_func
(paren
id|swp_entry_t
op_star
id|entry
)paren
(brace
id|dump_pmdisk_info
c_func
(paren
)paren
suffix:semicolon
r_return
id|write_swap_page
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|pmdisk_info
comma
id|entry
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;write_suspend_image - Write entire image and metadata.&n; *&n; */
DECL|function|write_suspend_image
r_static
r_int
id|write_suspend_image
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
id|swp_entry_t
id|prev
op_assign
(brace
l_int|0
)brace
suffix:semicolon
id|init_header
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|write_data
c_func
(paren
)paren
)paren
)paren
r_goto
id|FreeData
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|write_pagedir
c_func
(paren
)paren
)paren
)paren
r_goto
id|FreePagedir
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|write_header
c_func
(paren
op_amp
id|prev
)paren
)paren
)paren
r_goto
id|FreePagedir
suffix:semicolon
id|error
op_assign
id|mark_swapfiles
c_func
(paren
id|prev
)paren
suffix:semicolon
id|Done
suffix:colon
r_return
id|error
suffix:semicolon
id|FreePagedir
suffix:colon
id|free_pagedir_entries
c_func
(paren
)paren
suffix:semicolon
id|FreeData
suffix:colon
id|free_data
c_func
(paren
)paren
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;saveable - Determine whether a page should be cloned or not.&n; *&t;@pfn:&t;The page&n; *&n; *&t;We save a page if it&squot;s Reserved, and not in the range of pages&n; *&t;statically defined as &squot;unsaveable&squot;, or if it isn&squot;t reserved, and&n; *&t;isn&squot;t part of a free chunk of pages.&n; *&t;If it is part of a free chunk, we update @pfn to point to the last &n; *&t;page of the chunk.&n; */
DECL|function|saveable
r_static
r_int
id|saveable
c_func
(paren
r_int
r_int
op_star
id|pfn
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|pfn_to_page
c_func
(paren
op_star
id|pfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageNosave
c_func
(paren
id|page
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageReserved
c_func
(paren
id|page
)paren
)paren
(brace
r_int
id|chunk_size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|chunk_size
op_assign
id|is_head_of_free_region
c_func
(paren
id|page
)paren
)paren
)paren
(brace
op_star
id|pfn
op_add_assign
id|chunk_size
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|page
)paren
)paren
(brace
multiline_comment|/* Just copy whole code segment. &n;&t;&t; * Hopefully it is not that big.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ADDRESS
c_func
(paren
op_star
id|pfn
)paren
op_ge
(paren
r_int
r_int
)paren
id|ADDRESS2
c_func
(paren
op_amp
id|__nosave_begin
)paren
)paren
op_logical_and
(paren
id|ADDRESS
c_func
(paren
op_star
id|pfn
)paren
OL
(paren
r_int
r_int
)paren
id|ADDRESS2
c_func
(paren
op_amp
id|__nosave_end
)paren
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;[nosave %lx]&bslash;n&quot;
comma
id|ADDRESS
c_func
(paren
op_star
id|pfn
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Hmm, perhaps copying all reserved pages is not &n;&t;&t; * too healthy as they may contain &n;&t;&t; * critical bios data? &n;&t;&t; */
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;count_pages - Determine size of page directory.&n; *&t;&n; *&t;Iterate over all the pages in the system and tally the number&n; *&t;we need to clone.&n; */
DECL|function|count_pages
r_static
r_void
id|count_pages
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|pfn
suffix:semicolon
r_int
id|n
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|pfn
op_assign
l_int|0
suffix:semicolon
id|pfn
OL
id|max_pfn
suffix:semicolon
id|pfn
op_increment
)paren
(brace
r_if
c_cond
(paren
id|saveable
c_func
(paren
op_amp
id|pfn
)paren
)paren
id|n
op_increment
suffix:semicolon
)brace
id|pmdisk_pages
op_assign
id|n
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;copy_pages - Atmoically snapshot memory.&n; *&n; *&t;Iterate over all the pages in the system and copy each one &n; *&t;into its corresponding location in the pagedir.&n; *&t;We rely on the fact that the number of pages that we&squot;re snap-&n; *&t;shotting hasn&squot;t changed since we counted them. &n; */
DECL|function|copy_pages
r_static
r_void
id|copy_pages
c_func
(paren
r_void
)paren
(brace
r_struct
id|pbe
op_star
id|p
op_assign
id|pagedir_save
suffix:semicolon
r_int
r_int
id|pfn
suffix:semicolon
r_int
id|n
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|pfn
op_assign
l_int|0
suffix:semicolon
id|pfn
OL
id|max_pfn
suffix:semicolon
id|pfn
op_increment
)paren
(brace
r_if
c_cond
(paren
id|saveable
c_func
(paren
op_amp
id|pfn
)paren
)paren
(brace
id|n
op_increment
suffix:semicolon
id|p-&gt;orig_address
op_assign
id|ADDRESS
c_func
(paren
id|pfn
)paren
suffix:semicolon
id|copy_page
c_func
(paren
(paren
r_void
op_star
)paren
id|p-&gt;address
comma
(paren
r_void
op_star
)paren
id|p-&gt;orig_address
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
)brace
id|BUG_ON
c_func
(paren
id|n
op_ne
id|pmdisk_pages
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;free_image_pages - Free each page allocated for snapshot.&n; */
DECL|function|free_image_pages
r_static
r_void
id|free_image_pages
c_func
(paren
r_void
)paren
(brace
r_struct
id|pbe
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|p
op_assign
id|pagedir_save
suffix:semicolon
id|i
OL
id|pmdisk_pages
suffix:semicolon
id|i
op_increment
comma
id|p
op_increment
)paren
(brace
id|ClearPageNosave
c_func
(paren
id|virt_to_page
c_func
(paren
id|p-&gt;address
)paren
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|p-&gt;address
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;free_pagedir - Free the page directory.&n; */
DECL|function|free_pagedir
r_static
r_void
id|free_pagedir
c_func
(paren
r_void
)paren
(brace
id|free_image_pages
c_func
(paren
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|pagedir_save
comma
id|pagedir_order
)paren
suffix:semicolon
)brace
DECL|function|calc_order
r_static
r_void
id|calc_order
c_func
(paren
r_void
)paren
(brace
r_int
id|diff
suffix:semicolon
r_int
id|order
suffix:semicolon
id|order
op_assign
id|get_bitmask_order
c_func
(paren
id|SUSPEND_PD_PAGES
c_func
(paren
id|pmdisk_pages
)paren
)paren
suffix:semicolon
id|pmdisk_pages
op_add_assign
l_int|1
op_lshift
id|order
suffix:semicolon
r_do
(brace
id|diff
op_assign
id|get_bitmask_order
c_func
(paren
id|SUSPEND_PD_PAGES
c_func
(paren
id|pmdisk_pages
)paren
)paren
op_minus
id|order
suffix:semicolon
r_if
c_cond
(paren
id|diff
)paren
(brace
id|order
op_add_assign
id|diff
suffix:semicolon
id|pmdisk_pages
op_add_assign
l_int|1
op_lshift
id|diff
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|diff
)paren
(brace
suffix:semicolon
)brace
id|pagedir_order
op_assign
id|order
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;alloc_pagedir - Allocate the page directory.&n; *&n; *&t;First, determine exactly how many contiguous pages we need, &n; *&t;allocate them, then mark each &squot;unsavable&squot;.&n; */
DECL|function|alloc_pagedir
r_static
r_int
id|alloc_pagedir
c_func
(paren
r_void
)paren
(brace
id|calc_order
c_func
(paren
)paren
suffix:semicolon
id|pagedir_save
op_assign
(paren
id|suspend_pagedir_t
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
op_or
id|__GFP_COLD
comma
id|pagedir_order
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagedir_save
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|pagedir_save
comma
l_int|0
comma
(paren
l_int|1
op_lshift
id|pagedir_order
)paren
op_star
id|PAGE_SIZE
)paren
suffix:semicolon
id|pm_pagedir_nosave
op_assign
id|pagedir_save
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;alloc_image_pages - Allocate pages for the snapshot.&n; *&n; */
DECL|function|alloc_image_pages
r_static
r_int
id|alloc_image_pages
c_func
(paren
r_void
)paren
(brace
r_struct
id|pbe
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|p
op_assign
id|pagedir_save
suffix:semicolon
id|i
OL
id|pmdisk_pages
suffix:semicolon
id|i
op_increment
comma
id|p
op_increment
)paren
(brace
id|p-&gt;address
op_assign
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
op_or
id|__GFP_COLD
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;address
)paren
(brace
r_goto
id|Error
suffix:semicolon
)brace
id|SetPageNosave
c_func
(paren
id|virt_to_page
c_func
(paren
id|p-&gt;address
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|Error
suffix:colon
r_do
(brace
r_if
c_cond
(paren
id|p-&gt;address
)paren
id|free_page
c_func
(paren
id|p-&gt;address
)paren
suffix:semicolon
id|p-&gt;address
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|p
op_decrement
OG
id|pagedir_save
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;enough_free_mem - Make sure we enough free memory to snapshot.&n; *&n; *&t;Returns TRUE or FALSE after checking the number of available &n; *&t;free pages.&n; */
DECL|function|enough_free_mem
r_static
r_int
id|enough_free_mem
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|nr_free_pages
c_func
(paren
)paren
OL
(paren
id|pmdisk_pages
op_plus
id|PAGES_FOR_IO
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: Not enough free pages: Have %d&bslash;n&quot;
comma
id|nr_free_pages
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;enough_swap - Make sure we have enough swap to save the image.&n; *&n; *&t;Returns TRUE or FALSE after checking the total amount of swap &n; *&t;space avaiable.&n; *&n; *&t;FIXME: si_swapinfo(&amp;i) returns all swap devices information.&n; *&t;We should only consider resume_device. &n; */
DECL|function|enough_swap
r_static
r_int
id|enough_swap
c_func
(paren
r_void
)paren
(brace
r_struct
id|sysinfo
id|i
suffix:semicolon
id|si_swapinfo
c_func
(paren
op_amp
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i.freeswap
OL
(paren
id|pmdisk_pages
op_plus
id|PAGES_FOR_IO
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: Not enough swap. Need %ld&bslash;n&quot;
comma
id|i.freeswap
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;pmdisk_suspend - Atomically snapshot the system.&n; *&n; *&t;This must be called with interrupts disabled, to prevent the &n; *&t;system changing at all from underneath us. &n; *&n; *&t;To do this, we count the number of pages in the system that we &n; *&t;need to save; make sure&t;we have enough memory and swap to clone&n; *&t;the pages and save them in swap, allocate the space to hold them,&n; *&t;and then snapshot them all.&n; */
DECL|function|pmdisk_suspend
r_int
id|pmdisk_suspend
c_func
(paren
r_void
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|read_swapfiles
c_func
(paren
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|drain_local_pages
c_func
(paren
)paren
suffix:semicolon
id|pm_pagedir_nosave
op_assign
l_int|NULL
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: Counting pages to copy.&bslash;n&quot;
)paren
suffix:semicolon
id|count_pages
c_func
(paren
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: (pages needed: %d + %d free: %d)&bslash;n&quot;
comma
id|pmdisk_pages
comma
id|PAGES_FOR_IO
comma
id|nr_free_pages
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|enough_free_mem
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|enough_swap
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENOSPC
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|alloc_pagedir
c_func
(paren
)paren
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: Allocating pagedir failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|alloc_image_pages
c_func
(paren
)paren
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: Allocating image pages failed.&bslash;n&quot;
)paren
suffix:semicolon
id|free_pagedir
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|nr_copy_pages_check
op_assign
id|pmdisk_pages
suffix:semicolon
id|pagedir_order_check
op_assign
id|pagedir_order
suffix:semicolon
multiline_comment|/* During allocating of suspend pagedir, new cold pages may appear. &n;&t; * Kill them &n;&t; */
id|drain_local_pages
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* copy */
id|copy_pages
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * End of critical section. From now on, we can write to memory,&n;&t; * but we should not touch disk. This specially means we must _not_&n;&t; * touch swap space! Except we must write out our image of course.&n;&t; */
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: %d pages copied&bslash;n&quot;
comma
id|pmdisk_pages
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;suspend_save_image - Prepare and write saved image to swap.&n; *&n; *&t;IRQs are re-enabled here so we can resume devices and safely write&n; *&t;to the swap devices. We disable them again before we leave.&n; *&n; *&t;The second lock_swapdevices() will unlock ignored swap devices since&n; *&t;writing is finished.&n; *&t;It is important _NOT_ to umount filesystems at this point. We want&n; *&t;them synced (in case something goes wrong) but we DO not want to mark&n; *&t;filesystem clean: it is not. (And it does not matter, if we resume&n; *&t;correctly, we&squot;ll mark system clean, anyway.)&n; */
DECL|function|suspend_save_image
r_static
r_int
id|suspend_save_image
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
id|device_resume
c_func
(paren
)paren
suffix:semicolon
id|lock_swapdevices
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|write_suspend_image
c_func
(paren
)paren
suffix:semicolon
id|lock_swapdevices
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Magic happens here&n; */
DECL|function|pmdisk_resume
r_int
id|pmdisk_resume
c_func
(paren
r_void
)paren
(brace
id|BUG_ON
(paren
id|nr_copy_pages_check
op_ne
id|pmdisk_pages
)paren
suffix:semicolon
id|BUG_ON
(paren
id|pagedir_order_check
op_ne
id|pagedir_order
)paren
suffix:semicolon
multiline_comment|/* Even mappings of &quot;global&quot; things (vmalloc) need to be fixed */
id|__flush_tlb_global
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* pmdisk_arch_suspend() is implemented in arch/?/power/pmdisk.S,&n;   and basically does:&n;&n;&t;if (!resume) {&n;&t;&t;save_processor_state();&n;&t;&t;SAVE_REGISTERS&n;&t;&t;return pmdisk_suspend();&n;&t;}&n;&t;GO_TO_SWAPPER_PAGE_TABLES&n;&t;COPY_PAGES_BACK&n;&t;RESTORE_REGISTERS&n;&t;restore_processor_state();&n;&t;return pmdisk_resume();&n;&n; */
multiline_comment|/* More restore stuff */
multiline_comment|/* FIXME: Why not memcpy(to, from, 1&lt;&lt;pagedir_order*PAGE_SIZE)? */
DECL|function|copy_pagedir
r_static
r_void
id|__init
id|copy_pagedir
c_func
(paren
id|suspend_pagedir_t
op_star
id|to
comma
id|suspend_pagedir_t
op_star
id|from
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|topointer
op_assign
(paren
r_char
op_star
)paren
id|to
comma
op_star
id|frompointer
op_assign
(paren
r_char
op_star
)paren
id|from
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1
op_lshift
id|pagedir_order
suffix:semicolon
id|i
op_increment
)paren
(brace
id|copy_page
c_func
(paren
id|topointer
comma
id|frompointer
)paren
suffix:semicolon
id|topointer
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|frompointer
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
DECL|macro|does_collide
mdefine_line|#define does_collide(addr) does_collide_order(pm_pagedir_nosave, addr, 0)
multiline_comment|/*&n; * Returns true if given address/order collides with any orig_address &n; */
DECL|function|does_collide_order
r_static
r_int
id|__init
id|does_collide_order
c_func
(paren
id|suspend_pagedir_t
op_star
id|pagedir
comma
r_int
r_int
id|addr
comma
r_int
id|order
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|addre
op_assign
id|addr
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmdisk_pages
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|pagedir
op_plus
id|i
)paren
op_member_access_from_pointer
id|orig_address
op_ge
id|addr
op_logical_and
(paren
id|pagedir
op_plus
id|i
)paren
op_member_access_from_pointer
id|orig_address
OL
id|addre
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We check here that pagedir &amp; pages it points to won&squot;t collide with pages&n; * where we&squot;re going to restore from the loaded pages later&n; */
DECL|function|check_pagedir
r_static
r_int
id|__init
id|check_pagedir
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmdisk_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_do
(brace
id|addr
op_assign
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|does_collide
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
(paren
id|pm_pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|address
op_assign
id|addr
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|relocate_pagedir
r_static
r_int
id|__init
id|relocate_pagedir
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * We have to avoid recursion (not to overflow kernel stack),&n;&t; * and that&squot;s why code looks pretty cryptic &n;&t; */
id|suspend_pagedir_t
op_star
id|new_pagedir
comma
op_star
id|old_pagedir
op_assign
id|pm_pagedir_nosave
suffix:semicolon
r_void
op_star
op_star
id|eaten_memory
op_assign
l_int|NULL
suffix:semicolon
r_void
op_star
op_star
id|c
op_assign
id|eaten_memory
comma
op_star
id|m
comma
op_star
id|f
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: Relocating pagedir&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|does_collide_order
c_func
(paren
id|old_pagedir
comma
(paren
r_int
r_int
)paren
id|old_pagedir
comma
id|pagedir_order
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: Relocation not necessary&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|m
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|pagedir_order
)paren
)paren
)paren
(brace
id|memset
c_func
(paren
id|m
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|does_collide_order
c_func
(paren
id|old_pagedir
comma
(paren
r_int
r_int
)paren
id|m
comma
id|pagedir_order
)paren
)paren
r_break
suffix:semicolon
id|eaten_memory
op_assign
id|m
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
op_star
id|eaten_memory
op_assign
id|c
suffix:semicolon
id|c
op_assign
id|eaten_memory
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|m
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|pm_pagedir_nosave
op_assign
id|new_pagedir
op_assign
id|m
suffix:semicolon
id|copy_pagedir
c_func
(paren
id|new_pagedir
comma
id|old_pagedir
)paren
suffix:semicolon
id|c
op_assign
id|eaten_memory
suffix:semicolon
r_while
c_loop
(paren
id|c
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;:&quot;
)paren
suffix:semicolon
id|f
op_assign
op_star
id|c
suffix:semicolon
id|c
op_assign
op_star
id|c
suffix:semicolon
r_if
c_cond
(paren
id|f
)paren
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|f
comma
id|pagedir_order
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;|&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|resume_bdev
r_static
r_struct
id|block_device
op_star
id|resume_bdev
suffix:semicolon
multiline_comment|/**&n; *&t;Using bio to read from swap.&n; *&t;This code requires a bit more work than just using buffer heads&n; *&t;but, it is the recommended way for 2.5/2.6.&n; *&t;The following are to signal the beginning and end of I/O. Bios&n; *&t;finish asynchronously, while we want them to happen synchronously.&n; *&t;A simple atomic_t, and a wait loop take care of this problem.&n; */
DECL|variable|io_done
r_static
id|atomic_t
id|io_done
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|function|start_io
r_static
r_void
id|start_io
c_func
(paren
r_void
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|io_done
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|end_io
r_static
r_int
id|end_io
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|num
comma
r_int
id|err
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|io_done
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|wait_io
r_static
r_void
id|wait_io
c_func
(paren
r_void
)paren
(brace
id|blk_run_queues
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|io_done
)paren
)paren
(brace
id|io_schedule
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;submit - submit BIO request.&n; *&t;@rw:&t;READ or WRITE.&n; *&t;@off&t;physical offset of page.&n; *&t;@page:&t;page we&squot;re reading or writing.&n; *&n; *&t;Straight from the textbook - allocate and initialize the bio.&n; *&t;If we&squot;re writing, make sure the page is marked as dirty.&n; *&t;Then submit it and wait.&n; */
DECL|function|submit
r_static
r_int
id|submit
c_func
(paren
r_int
id|rw
comma
id|pgoff_t
id|page_off
comma
r_void
op_star
id|page
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|GFP_ATOMIC
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|page_off
op_star
(paren
id|PAGE_SIZE
op_rshift
l_int|9
)paren
suffix:semicolon
id|bio_get
c_func
(paren
id|bio
)paren
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|resume_bdev
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|end_io
suffix:semicolon
r_if
c_cond
(paren
id|bio_add_page
c_func
(paren
id|bio
comma
id|virt_to_page
c_func
(paren
id|page
)paren
comma
id|PAGE_SIZE
comma
l_int|0
)paren
OL
id|PAGE_SIZE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pmdisk: ERROR: adding page to bio at %ld&bslash;n&quot;
comma
id|page_off
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rw
op_eq
id|WRITE
)paren
id|bio_set_pages_dirty
c_func
(paren
id|bio
)paren
suffix:semicolon
id|start_io
c_func
(paren
)paren
suffix:semicolon
id|submit_bio
c_func
(paren
id|rw
comma
id|bio
)paren
suffix:semicolon
id|wait_io
c_func
(paren
)paren
suffix:semicolon
id|Done
suffix:colon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_static
r_int
DECL|function|read_page
id|read_page
c_func
(paren
id|pgoff_t
id|page_off
comma
r_void
op_star
id|page
)paren
(brace
r_return
id|submit
c_func
(paren
id|READ
comma
id|page_off
comma
id|page
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|write_page
id|write_page
c_func
(paren
id|pgoff_t
id|page_off
comma
r_void
op_star
id|page
)paren
(brace
r_return
id|submit
c_func
(paren
id|WRITE
comma
id|page_off
comma
id|page
)paren
suffix:semicolon
)brace
r_extern
id|dev_t
id|__init
id|name_to_dev_t
c_func
(paren
r_const
r_char
op_star
id|line
)paren
suffix:semicolon
DECL|function|check_sig
r_static
r_int
id|__init
id|check_sig
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|pmdisk_header
comma
l_int|0
comma
r_sizeof
(paren
id|pmdisk_header
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|read_page
c_func
(paren
l_int|0
comma
op_amp
id|pmdisk_header
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|PMDISK_SIG
comma
id|pmdisk_header.sig
comma
l_int|10
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|pmdisk_header.sig
comma
id|pmdisk_header.orig_sig
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Reset swap signature now.&n;&t;&t; */
id|error
op_assign
id|write_page
c_func
(paren
l_int|0
comma
op_amp
id|pmdisk_header
)paren
suffix:semicolon
)brace
r_else
(brace
id|pr_debug
c_func
(paren
id|KERN_ERR
l_string|&quot;pmdisk: Invalid partition type.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: Signature found, resuming&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Sanity check if this image makes sense with this kernel/swap context&n; * I really don&squot;t think that it&squot;s foolproof but more than nothing..&n; */
DECL|function|sanity_check
r_static
r_const
r_char
op_star
id|__init
id|sanity_check
c_func
(paren
r_void
)paren
(brace
id|dump_pmdisk_info
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmdisk_info.version_code
op_ne
id|LINUX_VERSION_CODE
)paren
(brace
r_return
l_string|&quot;kernel version&quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pmdisk_info.num_physpages
op_ne
id|num_physpages
)paren
(brace
r_return
l_string|&quot;memory size&quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|pmdisk_info.uts.sysname
comma
id|system_utsname.sysname
)paren
)paren
r_return
l_string|&quot;system type&quot;
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|pmdisk_info.uts.release
comma
id|system_utsname.release
)paren
)paren
r_return
l_string|&quot;kernel release&quot;
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|pmdisk_info.uts.version
comma
id|system_utsname.version
)paren
)paren
r_return
l_string|&quot;version&quot;
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|pmdisk_info.uts.machine
comma
id|system_utsname.machine
)paren
)paren
r_return
l_string|&quot;machine&quot;
suffix:semicolon
r_if
c_cond
(paren
id|pmdisk_info.cpus
op_ne
id|num_online_cpus
c_func
(paren
)paren
)paren
(brace
r_return
l_string|&quot;number of cpus&quot;
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|check_header
r_static
r_int
id|__init
id|check_header
c_func
(paren
r_void
)paren
(brace
r_const
r_char
op_star
id|reason
op_assign
l_int|NULL
suffix:semicolon
r_int
id|error
suffix:semicolon
id|init_header
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|read_page
c_func
(paren
id|swp_offset
c_func
(paren
id|pmdisk_header.pmdisk_info
)paren
comma
op_amp
id|pmdisk_info
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* Is this same machine? */
r_if
c_cond
(paren
(paren
id|reason
op_assign
id|sanity_check
c_func
(paren
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;pmdisk: Resume mismatch: %s&bslash;n&quot;
comma
id|reason
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|pmdisk_pages
op_assign
id|pmdisk_info.image_pages
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|read_pagedir
r_static
r_int
id|__init
id|read_pagedir
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_int
id|i
comma
id|n
op_assign
id|pmdisk_info.pagedir_pages
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|pagedir_order
op_assign
id|get_bitmask_order
c_func
(paren
id|n
)paren
suffix:semicolon
id|addr
op_assign
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|pagedir_order
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|pm_pagedir_nosave
op_assign
(paren
r_struct
id|pbe
op_star
)paren
id|addr
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: Reading pagedir (%d Pages)&bslash;n&quot;
comma
id|n
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
op_logical_and
op_logical_neg
id|error
suffix:semicolon
id|i
op_increment
comma
id|addr
op_add_assign
id|PAGE_SIZE
)paren
(brace
r_int
r_int
id|offset
op_assign
id|swp_offset
c_func
(paren
id|pmdisk_info.pagedir
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
)paren
id|error
op_assign
id|read_page
c_func
(paren
id|offset
comma
(paren
r_void
op_star
)paren
id|addr
)paren
suffix:semicolon
r_else
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|pm_pagedir_nosave
comma
id|pagedir_order
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;read_image_data - Read image pages from swap.&n; *&n; *&t;You do not need to check for overlaps, check_pagedir()&n; *&t;already did that.&n; */
DECL|function|read_image_data
r_static
r_int
id|__init
id|read_image_data
c_func
(paren
r_void
)paren
(brace
r_struct
id|pbe
op_star
id|p
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Reading image data (%d pages): &quot;
comma
id|pmdisk_pages
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|p
op_assign
id|pm_pagedir_nosave
suffix:semicolon
id|i
OL
id|pmdisk_pages
op_logical_and
op_logical_neg
id|error
suffix:semicolon
id|i
op_increment
comma
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_mod
l_int|100
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
id|error
op_assign
id|read_page
c_func
(paren
id|swp_offset
c_func
(paren
id|p-&gt;swap_address
)paren
comma
(paren
r_void
op_star
)paren
id|p-&gt;address
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; %d done.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|read_suspend_image
r_static
r_int
id|__init
id|read_suspend_image
c_func
(paren
r_void
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|check_sig
c_func
(paren
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|check_header
c_func
(paren
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|read_pagedir
c_func
(paren
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|relocate_pagedir
c_func
(paren
)paren
)paren
)paren
r_goto
id|FreePagedir
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|check_pagedir
c_func
(paren
)paren
)paren
)paren
r_goto
id|FreePagedir
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|read_image_data
c_func
(paren
)paren
)paren
)paren
r_goto
id|FreePagedir
suffix:semicolon
id|Done
suffix:colon
r_return
id|error
suffix:semicolon
id|FreePagedir
suffix:colon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|pm_pagedir_nosave
comma
id|pagedir_order
)paren
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;pmdisk_save - Snapshot memory&n; */
DECL|function|pmdisk_save
r_int
id|pmdisk_save
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
macro_line|#if defined (CONFIG_HIGHMEM) || defined (CONFIG_DISCONTIGMEM)
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: not supported with high- or discontig-mem.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|error
op_assign
id|arch_prepare_suspend
c_func
(paren
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|save_processor_state
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|pmdisk_arch_suspend
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|restore_processor_state
c_func
(paren
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;pmdisk_write - Write saved memory image to swap.&n; *&n; *&t;pmdisk_arch_suspend(0) returns after system is resumed.&n; *&n; *&t;pmdisk_arch_suspend() copies all &quot;used&quot; memory to &quot;free&quot; memory,&n; *&t;then unsuspends all device drivers, and writes memory to disk&n; *&t;using normal kernel mechanism.&n; */
DECL|function|pmdisk_write
r_int
id|pmdisk_write
c_func
(paren
r_void
)paren
(brace
r_return
id|suspend_save_image
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;pmdisk_read - Read saved image from swap.&n; */
DECL|function|pmdisk_read
r_int
id|__init
id|pmdisk_read
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strlen
c_func
(paren
id|resume_file
)paren
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|resume_device
op_assign
id|name_to_dev_t
c_func
(paren
id|resume_file
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: Resume From Partition: %s&bslash;n&quot;
comma
id|resume_file
)paren
suffix:semicolon
id|resume_bdev
op_assign
id|open_by_devnum
c_func
(paren
id|resume_device
comma
id|FMODE_READ
comma
id|BDEV_RAW
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|resume_bdev
)paren
)paren
(brace
id|set_blocksize
c_func
(paren
id|resume_bdev
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|error
op_assign
id|read_suspend_image
c_func
(paren
)paren
suffix:semicolon
id|blkdev_put
c_func
(paren
id|resume_bdev
comma
id|BDEV_RAW
)paren
suffix:semicolon
)brace
r_else
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|resume_bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|pr_debug
c_func
(paren
l_string|&quot;Reading resume file was successful&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: Error %d resuming&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;pmdisk_restore - Replace running kernel with saved image.&n; */
DECL|function|pmdisk_restore
r_int
id|__init
id|pmdisk_restore
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|save_processor_state
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|pmdisk_arch_suspend
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|restore_processor_state
c_func
(paren
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;pmdisk_free - Free memory allocated to hold snapshot.&n; */
DECL|function|pmdisk_free
r_int
id|pmdisk_free
c_func
(paren
r_void
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;Freeing prev allocated pagedir&bslash;n&quot;
)paren
suffix:semicolon
id|free_pagedir
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pmdisk_setup
r_static
r_int
id|__init
id|pmdisk_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|str
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;off&quot;
)paren
)paren
id|resume_file
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_else
id|strncpy
c_func
(paren
id|resume_file
comma
id|str
comma
l_int|255
)paren
suffix:semicolon
)brace
r_else
id|resume_file
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;pmdisk=&quot;
comma
id|pmdisk_setup
)paren
suffix:semicolon
eof
