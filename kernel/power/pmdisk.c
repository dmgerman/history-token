multiline_comment|/*&n; * kernel/power/pmdisk.c - Suspend-to-disk implmentation&n; *&n; * This STD implementation is initially derived from swsusp (suspend-to-swap).&n; * The original copyright on that was: &n; *&n; * Copyright (C) 1998-2001 Gabor Kuti &lt;seasons@fornax.hu&gt;&n; * Copyright (C) 1998,2001,2002 Pavel Machek &lt;pavel@suse.cz&gt;&n; *&n; * The additional parts are: &n; * &n; * Copyright (C) 2003 Patrick Mochel&n; * Copyright (C) 2003 Open Source Development Lab&n; * &n; * This file is released under the GPLv2. &n; *&n; * For more information, please see the text files in Documentation/power/&n; *&n; */
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/swapops.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &quot;power.h&quot;
r_extern
r_int
id|pmdisk_arch_suspend
c_func
(paren
r_int
id|resume
)paren
suffix:semicolon
DECL|macro|__ADDRESS
mdefine_line|#define __ADDRESS(x)  ((unsigned long) phys_to_virt(x))
DECL|macro|ADDRESS
mdefine_line|#define ADDRESS(x) __ADDRESS((x) &lt;&lt; PAGE_SHIFT)
DECL|macro|ADDRESS2
mdefine_line|#define ADDRESS2(x) __ADDRESS(__pa(x))&t;&t;/* Needed for x86-64 where some pages are in memory twice */
multiline_comment|/* References to section boundaries */
r_extern
r_char
id|__nosave_begin
comma
id|__nosave_end
suffix:semicolon
r_extern
r_int
id|is_head_of_free_region
c_func
(paren
r_struct
id|page
op_star
)paren
suffix:semicolon
multiline_comment|/* Variables to be preserved over suspend */
DECL|variable|pagedir_order_check
r_static
r_int
id|pagedir_order_check
suffix:semicolon
DECL|variable|nr_copy_pages_check
r_static
r_int
id|nr_copy_pages_check
suffix:semicolon
multiline_comment|/* For resume= kernel option */
DECL|variable|resume_file
r_static
r_char
id|resume_file
(braket
l_int|256
)braket
op_assign
id|CONFIG_PM_DISK_PARTITION
suffix:semicolon
DECL|variable|resume_device
r_static
id|dev_t
id|resume_device
suffix:semicolon
multiline_comment|/* Local variables that should not be affected by save */
DECL|variable|__nosavedata
r_int
r_int
id|pmdisk_pages
id|__nosavedata
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Suspend pagedir is allocated before final copy, therefore it&n;   must be freed after resume &n;&n;   Warning: this is evil. There are actually two pagedirs at time of&n;   resume. One is &quot;pagedir_save&quot;, which is empty frame allocated at&n;   time of suspend, that must be freed. Second is &quot;pagedir_nosave&quot;, &n;   allocated at time of resume, that travels through memory not to&n;   collide with anything.&n; */
DECL|variable|__nosavedata
id|suspend_pagedir_t
op_star
id|pm_pagedir_nosave
id|__nosavedata
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|pagedir_save
r_static
id|suspend_pagedir_t
op_star
id|pagedir_save
suffix:semicolon
DECL|variable|__nosavedata
r_static
r_int
id|pagedir_order
id|__nosavedata
op_assign
l_int|0
suffix:semicolon
DECL|struct|link
r_struct
id|link
(brace
DECL|member|dummy
r_char
id|dummy
(braket
id|PAGE_SIZE
op_minus
r_sizeof
(paren
id|swp_entry_t
)paren
)braket
suffix:semicolon
DECL|member|next
id|swp_entry_t
id|next
suffix:semicolon
)brace
suffix:semicolon
DECL|union|diskpage
r_union
id|diskpage
(brace
DECL|member|swh
r_union
id|swap_header
id|swh
suffix:semicolon
DECL|member|link
r_struct
id|link
id|link
suffix:semicolon
DECL|member|sh
r_struct
id|suspend_header
id|sh
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * XXX: We try to keep some more pages free so that I/O operations succeed&n; * without paging. Might this be more?&n; */
DECL|macro|PAGES_FOR_IO
mdefine_line|#define PAGES_FOR_IO&t;512
DECL|variable|name_suspend
r_static
r_const
r_char
id|name_suspend
(braket
)braket
op_assign
l_string|&quot;Suspend Machine: &quot;
suffix:semicolon
DECL|variable|name_resume
r_static
r_const
r_char
id|name_resume
(braket
)braket
op_assign
l_string|&quot;Resume Machine: &quot;
suffix:semicolon
multiline_comment|/*&n; * Saving part...&n; */
DECL|function|fill_suspend_header
r_static
id|__inline__
r_int
id|fill_suspend_header
c_func
(paren
r_struct
id|suspend_header
op_star
id|sh
)paren
(brace
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|sh
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|sh
)paren
)paren
suffix:semicolon
id|sh-&gt;version_code
op_assign
id|LINUX_VERSION_CODE
suffix:semicolon
id|sh-&gt;num_physpages
op_assign
id|num_physpages
suffix:semicolon
id|strncpy
c_func
(paren
id|sh-&gt;machine
comma
id|system_utsname.machine
comma
l_int|8
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|sh-&gt;version
comma
id|system_utsname.version
comma
l_int|20
)paren
suffix:semicolon
multiline_comment|/* FIXME: Is this bogus? --RR */
id|sh-&gt;num_cpus
op_assign
id|num_online_cpus
c_func
(paren
)paren
suffix:semicolon
id|sh-&gt;page_size
op_assign
id|PAGE_SIZE
suffix:semicolon
id|sh-&gt;suspend_pagedir
op_assign
id|pm_pagedir_nosave
suffix:semicolon
id|BUG_ON
(paren
id|pagedir_save
op_ne
id|pm_pagedir_nosave
)paren
suffix:semicolon
id|sh-&gt;num_pbes
op_assign
id|pmdisk_pages
suffix:semicolon
multiline_comment|/* TODO: needed? mounted fs&squot; last mounted date comparison&n;&t; * [so they haven&squot;t been mounted since last suspend.&n;&t; * Maybe it isn&squot;t.] [we&squot;d need to do this for _all_ fs-es]&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We memorize in swapfile_used what swap devices are used for suspension */
DECL|macro|SWAPFILE_UNUSED
mdefine_line|#define SWAPFILE_UNUSED    0
DECL|macro|SWAPFILE_SUSPEND
mdefine_line|#define SWAPFILE_SUSPEND   1&t;/* This is the suspending device */
DECL|macro|SWAPFILE_IGNORED
mdefine_line|#define SWAPFILE_IGNORED   2&t;/* Those are other swap devices ignored for suspension */
DECL|variable|swapfile_used
r_static
r_int
r_int
id|swapfile_used
(braket
id|MAX_SWAPFILES
)braket
suffix:semicolon
DECL|variable|root_swap
r_static
r_int
r_int
id|root_swap
suffix:semicolon
DECL|function|mark_swapfiles
r_static
r_int
id|mark_swapfiles
c_func
(paren
id|swp_entry_t
id|prev
)paren
(brace
id|swp_entry_t
id|entry
suffix:semicolon
r_union
id|diskpage
op_star
id|cur
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_if
c_cond
(paren
id|root_swap
op_eq
l_int|0xFFFF
)paren
multiline_comment|/* ignored */
r_return
op_minus
id|EINVAL
suffix:semicolon
id|page
op_assign
id|alloc_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|cur
op_assign
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* XXX: this is dirty hack to get first page of swap file */
id|entry
op_assign
id|swp_entry
c_func
(paren
id|root_swap
comma
l_int|0
)paren
suffix:semicolon
id|rw_swap_page_sync
c_func
(paren
id|READ
comma
id|entry
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;SWAP-SPACE&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|10
)paren
)paren
)paren
id|memcpy
c_func
(paren
id|cur-&gt;swh.magic.magic
comma
l_string|&quot;S1SUSP....&quot;
comma
l_int|10
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;SWAPSPACE2&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|10
)paren
)paren
)paren
id|memcpy
c_func
(paren
id|cur-&gt;swh.magic.magic
comma
l_string|&quot;S2SUSP....&quot;
comma
l_int|10
)paren
suffix:semicolon
r_else
(brace
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: Partition is not swap space.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* prev is the first/last swap page of the resume area */
id|cur-&gt;link.next
op_assign
id|prev
suffix:semicolon
multiline_comment|/* link.next lies *no more* in last 4/8 bytes of magic */
id|rw_swap_page_sync
c_func
(paren
id|WRITE
comma
id|entry
comma
id|page
)paren
suffix:semicolon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_swapfiles
r_static
r_void
id|read_swapfiles
c_func
(paren
r_void
)paren
multiline_comment|/* This is called before saving image */
(brace
r_int
id|i
comma
id|len
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|resume_file
)paren
suffix:semicolon
id|root_swap
op_assign
l_int|0xFFFF
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SWAPFILES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|swap_info
(braket
id|i
)braket
dot
id|flags
op_eq
l_int|0
)paren
(brace
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_UNUSED
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: Default resume partition not set.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root_swap
op_eq
l_int|0xFFFF
)paren
(brace
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_SUSPEND
suffix:semicolon
id|root_swap
op_assign
id|i
suffix:semicolon
)brace
r_else
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_IGNORED
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we ignore all swap devices that are not the resume_file */
r_if
c_cond
(paren
l_int|1
)paren
(brace
singleline_comment|// FIXME&t;&t;&t;&t;if(resume_device == swap_info[i].swap_device) {
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_SUSPEND
suffix:semicolon
id|root_swap
op_assign
id|i
suffix:semicolon
)brace
r_else
id|swapfile_used
(braket
id|i
)braket
op_assign
id|SWAPFILE_IGNORED
suffix:semicolon
)brace
)brace
)brace
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* This is called after saving image so modification&n;   will be lost after resume... and that&squot;s what we want. */
DECL|function|lock_swapdevices
r_static
r_void
id|lock_swapdevices
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|swap_list_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SWAPFILES
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|swapfile_used
(braket
id|i
)braket
op_eq
id|SWAPFILE_IGNORED
)paren
(brace
id|swap_info
(braket
id|i
)braket
dot
id|flags
op_xor_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/* we make the device unusable. A new call to&n;&t;&t;&t;&t;&t;&t;       lock_swapdevices can unlock the devices. */
)brace
id|swap_list_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|write_suspend_image
r_static
r_int
id|write_suspend_image
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|swp_entry_t
id|entry
comma
id|prev
op_assign
(brace
l_int|0
)brace
suffix:semicolon
r_int
id|nr_pgdir_pages
op_assign
id|SUSPEND_PD_PAGES
c_func
(paren
id|pmdisk_pages
)paren
suffix:semicolon
r_union
id|diskpage
op_star
id|cur
comma
op_star
id|buffer
op_assign
(paren
r_union
id|diskpage
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Writing data to swap (%d pages): &quot;
comma
id|pmdisk_pages
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmdisk_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_mod
l_int|100
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry
op_assign
id|get_swap_page
c_func
(paren
)paren
)paren
dot
id|val
)paren
id|panic
c_func
(paren
l_string|&quot;&bslash;nNot enough swapspace when writing data&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|swapfile_used
(braket
id|swp_type
c_func
(paren
id|entry
)paren
)braket
op_ne
id|SWAPFILE_SUSPEND
)paren
id|panic
c_func
(paren
l_string|&quot;&bslash;nPage %d: not enough swapspace on suspend device&quot;
comma
id|i
)paren
suffix:semicolon
id|address
op_assign
(paren
id|pm_pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|address
suffix:semicolon
id|page
op_assign
id|virt_to_page
c_func
(paren
id|address
)paren
suffix:semicolon
id|rw_swap_page_sync
c_func
(paren
id|WRITE
comma
id|entry
comma
id|page
)paren
suffix:semicolon
(paren
id|pm_pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|swap_address
op_assign
id|entry
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;|&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Writing pagedir (%d pages): &quot;
comma
id|nr_pgdir_pages
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_pgdir_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cur
op_assign
(paren
r_union
id|diskpage
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|pm_pagedir_nosave
)paren
op_plus
id|i
suffix:semicolon
id|BUG_ON
(paren
(paren
r_char
op_star
)paren
id|cur
op_ne
(paren
(paren
(paren
r_char
op_star
)paren
id|pm_pagedir_nosave
)paren
op_plus
id|i
op_star
id|PAGE_SIZE
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry
op_assign
id|get_swap_page
c_func
(paren
)paren
)paren
dot
id|val
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Not enough swapspace when writing pgdir&bslash;n&quot;
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Don&squot;t know how to recover&quot;
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|buffer
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_if
c_cond
(paren
id|swapfile_used
(braket
id|swp_type
c_func
(paren
id|entry
)paren
)braket
op_ne
id|SWAPFILE_SUSPEND
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;&bslash;nNot enough swapspace for pagedir on suspend device&quot;
)paren
suffix:semicolon
)brace
id|BUG_ON
(paren
r_sizeof
(paren
id|swp_entry_t
)paren
op_ne
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|BUG_ON
(paren
id|PAGE_SIZE
op_mod
r_sizeof
(paren
r_struct
id|pbe
)paren
)paren
suffix:semicolon
id|cur-&gt;link.next
op_assign
id|prev
suffix:semicolon
id|page
op_assign
id|virt_to_page
c_func
(paren
(paren
r_int
r_int
)paren
id|cur
)paren
suffix:semicolon
id|rw_swap_page_sync
c_func
(paren
id|WRITE
comma
id|entry
comma
id|page
)paren
suffix:semicolon
id|prev
op_assign
id|entry
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;H&quot;
)paren
suffix:semicolon
id|BUG_ON
(paren
r_sizeof
(paren
r_struct
id|suspend_header
)paren
OG
id|PAGE_SIZE
op_minus
r_sizeof
(paren
id|swp_entry_t
)paren
)paren
suffix:semicolon
id|BUG_ON
(paren
r_sizeof
(paren
r_union
id|diskpage
)paren
op_ne
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry
op_assign
id|get_swap_page
c_func
(paren
)paren
)paren
dot
id|val
)paren
id|panic
c_func
(paren
l_string|&quot;&bslash;nNot enough swapspace when writing header&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|swapfile_used
(braket
id|swp_type
c_func
(paren
id|entry
)paren
)braket
op_ne
id|SWAPFILE_SUSPEND
)paren
id|panic
c_func
(paren
l_string|&quot;&bslash;nNot enough swapspace for header on suspend device&quot;
)paren
suffix:semicolon
id|cur
op_assign
(paren
r_void
op_star
)paren
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|fill_suspend_header
c_func
(paren
op_amp
id|cur-&gt;sh
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;&bslash;nOut of memory while writing header&quot;
)paren
suffix:semicolon
id|cur-&gt;link.next
op_assign
id|prev
suffix:semicolon
id|page
op_assign
id|virt_to_page
c_func
(paren
(paren
r_int
r_int
)paren
id|cur
)paren
suffix:semicolon
id|rw_swap_page_sync
c_func
(paren
id|WRITE
comma
id|entry
comma
id|page
)paren
suffix:semicolon
id|prev
op_assign
id|entry
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;S&quot;
)paren
suffix:semicolon
id|mark_swapfiles
c_func
(paren
id|prev
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;|&bslash;n&quot;
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|buffer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if pagedir_p != NULL it also copies the counted pages */
DECL|function|count_and_copy_data_pages
r_static
r_int
id|count_and_copy_data_pages
c_func
(paren
r_struct
id|pbe
op_star
id|pagedir_p
)paren
(brace
r_int
id|chunk_size
suffix:semicolon
r_int
id|nr_copy_pages
op_assign
l_int|0
suffix:semicolon
r_int
id|pfn
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|BUG_ON
(paren
id|max_pfn
op_ne
id|num_physpages
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pfn
op_assign
l_int|0
suffix:semicolon
id|pfn
OL
id|max_pfn
suffix:semicolon
id|pfn
op_increment
)paren
(brace
id|page
op_assign
id|pfn_to_page
c_func
(paren
id|pfn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageReserved
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
id|PageNosave
c_func
(paren
id|page
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|chunk_size
op_assign
id|is_head_of_free_region
c_func
(paren
id|page
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|pfn
op_add_assign
id|chunk_size
op_minus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|page
)paren
)paren
(brace
id|BUG_ON
(paren
id|PageNosave
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Just copy whole code segment. Hopefully it is not that big.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|ADDRESS
c_func
(paren
id|pfn
)paren
op_ge
(paren
r_int
r_int
)paren
id|ADDRESS2
c_func
(paren
op_amp
id|__nosave_begin
)paren
)paren
op_logical_and
(paren
id|ADDRESS
c_func
(paren
id|pfn
)paren
OL
(paren
r_int
r_int
)paren
id|ADDRESS2
c_func
(paren
op_amp
id|__nosave_end
)paren
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;[nosave %lx]&quot;
comma
id|ADDRESS
c_func
(paren
id|pfn
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Hmm, perhaps copying all reserved pages is not too healthy as they may contain &n;&t;&t;&t;   critical bios data? */
)brace
r_else
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|nr_copy_pages
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pagedir_p
)paren
(brace
id|pagedir_p-&gt;orig_address
op_assign
id|ADDRESS
c_func
(paren
id|pfn
)paren
suffix:semicolon
id|copy_page
c_func
(paren
(paren
r_void
op_star
)paren
id|pagedir_p-&gt;address
comma
(paren
r_void
op_star
)paren
id|pagedir_p-&gt;orig_address
)paren
suffix:semicolon
id|pagedir_p
op_increment
suffix:semicolon
)brace
)brace
r_return
id|nr_copy_pages
suffix:semicolon
)brace
DECL|function|free_suspend_pagedir
r_static
r_void
id|free_suspend_pagedir
c_func
(paren
r_int
r_int
id|this_pagedir
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|pfn
suffix:semicolon
r_int
r_int
id|this_pagedir_end
op_assign
id|this_pagedir
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|pagedir_order
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pfn
op_assign
l_int|0
suffix:semicolon
id|pfn
OL
id|num_physpages
suffix:semicolon
id|pfn
op_increment
)paren
(brace
id|page
op_assign
id|pfn_to_page
c_func
(paren
id|pfn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TestClearPageNosave
c_func
(paren
id|page
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ADDRESS
c_func
(paren
id|pfn
)paren
op_ge
id|this_pagedir
op_logical_and
id|ADDRESS
c_func
(paren
id|pfn
)paren
OL
id|this_pagedir_end
)paren
r_continue
suffix:semicolon
multiline_comment|/* old pagedir gets freed in one */
id|free_page
c_func
(paren
id|ADDRESS
c_func
(paren
id|pfn
)paren
)paren
suffix:semicolon
)brace
id|free_pages
c_func
(paren
id|this_pagedir
comma
id|pagedir_order
)paren
suffix:semicolon
)brace
DECL|function|create_suspend_pagedir
r_static
id|suspend_pagedir_t
op_star
id|create_suspend_pagedir
c_func
(paren
r_int
id|nr_copy_pages
)paren
(brace
r_int
id|i
suffix:semicolon
id|suspend_pagedir_t
op_star
id|pagedir
suffix:semicolon
r_struct
id|pbe
op_star
id|p
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|pagedir_order
op_assign
id|get_bitmask_order
c_func
(paren
id|SUSPEND_PD_PAGES
c_func
(paren
id|nr_copy_pages
)paren
)paren
suffix:semicolon
id|p
op_assign
id|pagedir
op_assign
(paren
id|suspend_pagedir_t
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
op_or
id|__GFP_COLD
comma
id|pagedir_order
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagedir
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|page
op_assign
id|virt_to_page
c_func
(paren
id|pagedir
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1
op_lshift
id|pagedir_order
suffix:semicolon
id|i
op_increment
)paren
(brace
id|SetPageNosave
c_func
(paren
id|page
op_increment
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|nr_copy_pages
op_decrement
)paren
(brace
id|p-&gt;address
op_assign
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
op_or
id|__GFP_COLD
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;address
)paren
(brace
id|free_suspend_pagedir
c_func
(paren
(paren
r_int
r_int
)paren
id|pagedir
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|SetPageNosave
c_func
(paren
id|virt_to_page
c_func
(paren
id|p-&gt;address
)paren
)paren
suffix:semicolon
id|p-&gt;orig_address
op_assign
l_int|0
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
r_return
id|pagedir
suffix:semicolon
)brace
DECL|function|pmdisk_suspend
r_int
id|pmdisk_suspend
c_func
(paren
r_void
)paren
(brace
r_struct
id|sysinfo
id|i
suffix:semicolon
r_int
r_int
id|nr_needed_pages
op_assign
l_int|0
suffix:semicolon
id|read_swapfiles
c_func
(paren
)paren
suffix:semicolon
id|drain_local_pages
c_func
(paren
)paren
suffix:semicolon
id|pm_pagedir_nosave
op_assign
l_int|NULL
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: /critical section: Counting pages to copy.&bslash;n&quot;
)paren
suffix:semicolon
id|pmdisk_pages
op_assign
id|count_and_copy_data_pages
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|nr_needed_pages
op_assign
id|pmdisk_pages
op_plus
id|PAGES_FOR_IO
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: (pages needed: %d+%d=%d free: %d)&bslash;n&quot;
comma
id|pmdisk_pages
comma
id|PAGES_FOR_IO
comma
id|nr_needed_pages
comma
id|nr_free_pages
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_free_pages
c_func
(paren
)paren
OL
id|nr_needed_pages
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: Not enough free pages: Need %d, Have %d&bslash;n&quot;
comma
id|nr_needed_pages
comma
id|nr_free_pages
c_func
(paren
)paren
)paren
suffix:semicolon
id|root_swap
op_assign
l_int|0xFFFF
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|si_swapinfo
c_func
(paren
op_amp
id|i
)paren
suffix:semicolon
multiline_comment|/* FIXME: si_swapinfo(&amp;i) returns all swap devices information.&n;&t;&t;&t;&t;   We should only consider resume_device. */
r_if
c_cond
(paren
id|i.freeswap
OL
id|nr_needed_pages
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: Not enough swap space. Need %d, Have %d&bslash;n&quot;
comma
id|nr_needed_pages
comma
id|i.freeswap
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
id|pr_debug
c_func
(paren
l_string|&quot;Alloc pagedir&bslash;n&quot;
)paren
suffix:semicolon
id|pagedir_save
op_assign
id|pm_pagedir_nosave
op_assign
id|create_suspend_pagedir
c_func
(paren
id|pmdisk_pages
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pm_pagedir_nosave
)paren
(brace
multiline_comment|/* Shouldn&squot;t happen */
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: Couldn&squot;t allocate pagedir&bslash;n&quot;
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;pmdisk: Couldn&squot;t allocate pagedir&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|nr_copy_pages_check
op_assign
id|pmdisk_pages
suffix:semicolon
id|pagedir_order_check
op_assign
id|pagedir_order
suffix:semicolon
id|drain_local_pages
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* During allocating of suspend pagedir, new cold pages may appear. Kill them */
r_if
c_cond
(paren
id|pmdisk_pages
op_ne
id|count_and_copy_data_pages
c_func
(paren
id|pm_pagedir_nosave
)paren
)paren
multiline_comment|/* copy */
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * End of critical section. From now on, we can write to memory,&n;&t; * but we should not touch disk. This specially means we must _not_&n;&t; * touch swap space! Except we must write out our image of course.&n;&t; */
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: critical section/: done (%d pages copied)&bslash;n&quot;
comma
id|pmdisk_pages
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;suspend_save_image - Prepare and write saved image to swap.&n; *&n; *&t;IRQs are re-enabled here so we can resume devices and safely write&n; *&t;to the swap devices. We disable them again before we leave.&n; *&n; *&t;The second lock_swapdevices() will unlock ignored swap devices since&n; *&t;writing is finished.&n; *&t;It is important _NOT_ to umount filesystems at this point. We want&n; *&t;them synced (in case something goes wrong) but we DO not want to mark&n; *&t;filesystem clean: it is not. (And it does not matter, if we resume&n; *&t;correctly, we&squot;ll mark system clean, anyway.)&n; */
DECL|function|suspend_save_image
r_static
r_int
id|suspend_save_image
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
id|device_resume
c_func
(paren
)paren
suffix:semicolon
id|lock_swapdevices
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|write_suspend_image
c_func
(paren
)paren
suffix:semicolon
id|lock_swapdevices
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Magic happens here&n; */
DECL|function|pmdisk_resume
r_int
id|pmdisk_resume
c_func
(paren
r_void
)paren
(brace
id|BUG_ON
(paren
id|nr_copy_pages_check
op_ne
id|pmdisk_pages
)paren
suffix:semicolon
id|BUG_ON
(paren
id|pagedir_order_check
op_ne
id|pagedir_order
)paren
suffix:semicolon
multiline_comment|/* Even mappings of &quot;global&quot; things (vmalloc) need to be fixed */
id|__flush_tlb_global
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* pmdisk_arch_suspend() is implemented in arch/?/power/pmdisk.S,&n;   and basically does:&n;&n;&t;if (!resume) {&n;&t;&t;save_processor_state();&n;&t;&t;SAVE_REGISTERS&n;&t;&t;return pmdisk_suspend();&n;&t;}&n;&t;GO_TO_SWAPPER_PAGE_TABLES&n;&t;COPY_PAGES_BACK&n;&t;RESTORE_REGISTERS&n;&t;restore_processor_state();&n;&t;return pmdisk_resume();&n;&n; */
multiline_comment|/* More restore stuff */
multiline_comment|/* FIXME: Why not memcpy(to, from, 1&lt;&lt;pagedir_order*PAGE_SIZE)? */
DECL|function|copy_pagedir
r_static
r_void
id|__init
id|copy_pagedir
c_func
(paren
id|suspend_pagedir_t
op_star
id|to
comma
id|suspend_pagedir_t
op_star
id|from
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|topointer
op_assign
(paren
r_char
op_star
)paren
id|to
comma
op_star
id|frompointer
op_assign
(paren
r_char
op_star
)paren
id|from
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1
op_lshift
id|pagedir_order
suffix:semicolon
id|i
op_increment
)paren
(brace
id|copy_page
c_func
(paren
id|topointer
comma
id|frompointer
)paren
suffix:semicolon
id|topointer
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|frompointer
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
DECL|macro|does_collide
mdefine_line|#define does_collide(addr) does_collide_order(pm_pagedir_nosave, addr, 0)
multiline_comment|/*&n; * Returns true if given address/order collides with any orig_address &n; */
DECL|function|does_collide_order
r_static
r_int
id|__init
id|does_collide_order
c_func
(paren
id|suspend_pagedir_t
op_star
id|pagedir
comma
r_int
r_int
id|addr
comma
r_int
id|order
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|addre
op_assign
id|addr
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmdisk_pages
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|pagedir
op_plus
id|i
)paren
op_member_access_from_pointer
id|orig_address
op_ge
id|addr
op_logical_and
(paren
id|pagedir
op_plus
id|i
)paren
op_member_access_from_pointer
id|orig_address
OL
id|addre
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We check here that pagedir &amp; pages it points to won&squot;t collide with pages&n; * where we&squot;re going to restore from the loaded pages later&n; */
DECL|function|check_pagedir
r_static
r_int
id|__init
id|check_pagedir
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmdisk_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_do
(brace
id|addr
op_assign
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|does_collide
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
(paren
id|pm_pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|address
op_assign
id|addr
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|relocate_pagedir
r_static
r_int
id|__init
id|relocate_pagedir
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * We have to avoid recursion (not to overflow kernel stack),&n;&t; * and that&squot;s why code looks pretty cryptic &n;&t; */
id|suspend_pagedir_t
op_star
id|new_pagedir
comma
op_star
id|old_pagedir
op_assign
id|pm_pagedir_nosave
suffix:semicolon
r_void
op_star
op_star
id|eaten_memory
op_assign
l_int|NULL
suffix:semicolon
r_void
op_star
op_star
id|c
op_assign
id|eaten_memory
comma
op_star
id|m
comma
op_star
id|f
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: Relocating pagedir&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|does_collide_order
c_func
(paren
id|old_pagedir
comma
(paren
r_int
r_int
)paren
id|old_pagedir
comma
id|pagedir_order
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: Relocation not necessary&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|m
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|pagedir_order
)paren
)paren
)paren
(brace
id|memset
c_func
(paren
id|m
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|does_collide_order
c_func
(paren
id|old_pagedir
comma
(paren
r_int
r_int
)paren
id|m
comma
id|pagedir_order
)paren
)paren
r_break
suffix:semicolon
id|eaten_memory
op_assign
id|m
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
op_star
id|eaten_memory
op_assign
id|c
suffix:semicolon
id|c
op_assign
id|eaten_memory
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|m
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|pm_pagedir_nosave
op_assign
id|new_pagedir
op_assign
id|m
suffix:semicolon
id|copy_pagedir
c_func
(paren
id|new_pagedir
comma
id|old_pagedir
)paren
suffix:semicolon
id|c
op_assign
id|eaten_memory
suffix:semicolon
r_while
c_loop
(paren
id|c
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;:&quot;
)paren
suffix:semicolon
id|f
op_assign
op_star
id|c
suffix:semicolon
id|c
op_assign
op_star
id|c
suffix:semicolon
r_if
c_cond
(paren
id|f
)paren
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|f
comma
id|pagedir_order
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;|&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Sanity check if this image makes sense with this kernel/swap context&n; * I really don&squot;t think that it&squot;s foolproof but more than nothing..&n; */
DECL|function|sanity_check_failed
r_static
r_int
id|__init
id|sanity_check_failed
c_func
(paren
r_char
op_star
id|reason
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;pmdisk: Resume mismatch: %s&bslash;n&quot;
comma
id|reason
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
DECL|function|sanity_check
r_static
r_int
id|__init
id|sanity_check
c_func
(paren
r_struct
id|suspend_header
op_star
id|sh
)paren
(brace
r_if
c_cond
(paren
id|sh-&gt;version_code
op_ne
id|LINUX_VERSION_CODE
)paren
(brace
r_return
id|sanity_check_failed
c_func
(paren
l_string|&quot;Incorrect kernel version&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sh-&gt;num_physpages
op_ne
id|num_physpages
)paren
(brace
r_return
id|sanity_check_failed
c_func
(paren
l_string|&quot;Incorrect memory size&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|sh-&gt;machine
comma
id|system_utsname.machine
comma
l_int|8
)paren
)paren
(brace
r_return
id|sanity_check_failed
c_func
(paren
l_string|&quot;Incorrect machine type&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|sh-&gt;version
comma
id|system_utsname.version
comma
l_int|20
)paren
)paren
(brace
r_return
id|sanity_check_failed
c_func
(paren
l_string|&quot;Incorrect version&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sh-&gt;num_cpus
op_ne
id|num_online_cpus
c_func
(paren
)paren
)paren
(brace
r_return
id|sanity_check_failed
c_func
(paren
l_string|&quot;Incorrect number of cpus&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sh-&gt;page_size
op_ne
id|PAGE_SIZE
)paren
(brace
r_return
id|sanity_check_failed
c_func
(paren
l_string|&quot;Incorrect PAGE_SIZE&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|resume_bdev
r_static
r_struct
id|block_device
op_star
id|resume_bdev
suffix:semicolon
multiline_comment|/**&n; *&t;Using bio to read from swap.&n; *&t;This code requires a bit more work than just using buffer heads&n; *&t;but, it is the recommended way for 2.5/2.6.&n; *&t;The following are to signal the beginning and end of I/O. Bios&n; *&t;finish asynchronously, while we want them to happen synchronously.&n; *&t;A simple atomic_t, and a wait loop take care of this problem.&n; */
DECL|variable|io_done
r_static
id|atomic_t
id|io_done
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|function|start_io
r_static
r_void
id|start_io
c_func
(paren
r_void
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|io_done
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|end_io
r_static
r_int
id|end_io
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|num
comma
r_int
id|err
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|io_done
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|wait_io
r_static
r_void
id|wait_io
c_func
(paren
r_void
)paren
(brace
id|blk_run_queues
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|io_done
)paren
)paren
(brace
id|io_schedule
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;submit - submit BIO request.&n; *&t;@rw:&t;READ or WRITE.&n; *&t;@off&t;physical offset of page.&n; *&t;@page:&t;page we&squot;re reading or writing.&n; *&n; *&t;Straight from the textbook - allocate and initialize the bio.&n; *&t;If we&squot;re writing, make sure the page is marked as dirty.&n; *&t;Then submit it and wait.&n; */
DECL|function|submit
r_static
r_int
id|submit
c_func
(paren
r_int
id|rw
comma
id|pgoff_t
id|page_off
comma
r_void
op_star
id|page
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|GFP_ATOMIC
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|page_off
op_star
(paren
id|PAGE_SIZE
op_rshift
l_int|9
)paren
suffix:semicolon
id|bio_get
c_func
(paren
id|bio
)paren
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|resume_bdev
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|end_io
suffix:semicolon
r_if
c_cond
(paren
id|bio_add_page
c_func
(paren
id|bio
comma
id|virt_to_page
c_func
(paren
id|page
)paren
comma
id|PAGE_SIZE
comma
l_int|0
)paren
OL
id|PAGE_SIZE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pmdisk: ERROR: adding page to bio at %ld&bslash;n&quot;
comma
id|page_off
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rw
op_eq
id|WRITE
)paren
id|bio_set_pages_dirty
c_func
(paren
id|bio
)paren
suffix:semicolon
id|start_io
c_func
(paren
)paren
suffix:semicolon
id|submit_bio
c_func
(paren
id|rw
comma
id|bio
)paren
suffix:semicolon
id|wait_io
c_func
(paren
)paren
suffix:semicolon
id|Done
suffix:colon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_static
r_int
DECL|function|read_page
id|read_page
c_func
(paren
id|pgoff_t
id|page_off
comma
r_void
op_star
id|page
)paren
(brace
r_return
id|submit
c_func
(paren
id|READ
comma
id|page_off
comma
id|page
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|write_page
id|write_page
c_func
(paren
id|pgoff_t
id|page_off
comma
r_void
op_star
id|page
)paren
(brace
r_return
id|submit
c_func
(paren
id|WRITE
comma
id|page_off
comma
id|page
)paren
suffix:semicolon
)brace
r_extern
id|dev_t
id|__init
id|name_to_dev_t
c_func
(paren
r_const
r_char
op_star
id|line
)paren
suffix:semicolon
DECL|macro|next_entry
mdefine_line|#define next_entry(diskpage)&t;diskpage-&gt;link.next
DECL|function|read_suspend_image
r_static
r_int
id|__init
id|read_suspend_image
c_func
(paren
r_void
)paren
(brace
id|swp_entry_t
id|next
suffix:semicolon
r_int
id|i
comma
id|nr_pgdir_pages
suffix:semicolon
r_union
id|diskpage
op_star
id|cur
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|cur
op_assign
(paren
r_union
id|diskpage
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cur
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|read_page
c_func
(paren
l_int|0
comma
id|cur
)paren
)paren
)paren
r_goto
id|Done
suffix:semicolon
multiline_comment|/*&n;&t; * We have to read next position before we overwrite it&n;&t; */
id|next
op_assign
id|next_entry
c_func
(paren
id|cur
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;S1&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|2
)paren
)paren
id|memcpy
c_func
(paren
id|cur-&gt;swh.magic.magic
comma
l_string|&quot;SWAP-SPACE&quot;
comma
l_int|10
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;S2&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|2
)paren
)paren
id|memcpy
c_func
(paren
id|cur-&gt;swh.magic.magic
comma
l_string|&quot;SWAPSPACE2&quot;
comma
l_int|10
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;SWAP-SPACE&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|10
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|memcmp
c_func
(paren
l_string|&quot;SWAPSPACE2&quot;
comma
id|cur-&gt;swh.magic.magic
comma
l_int|10
)paren
)paren
)paren
(brace
id|pr_debug
c_func
(paren
id|KERN_ERR
l_string|&quot;pmdisk: Partition is normal swap space&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_else
(brace
id|pr_debug
c_func
(paren
id|KERN_ERR
l_string|&quot;pmdisk: Invalid partition type.&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Reset swap signature now.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|write_page
c_func
(paren
l_int|0
comma
id|cur
)paren
)paren
)paren
r_goto
id|Done
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;%sSignature found, resuming&bslash;n&quot;
comma
id|name_resume
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|read_page
c_func
(paren
id|swp_offset
c_func
(paren
id|next
)paren
comma
id|cur
)paren
)paren
)paren
r_goto
id|Done
suffix:semicolon
multiline_comment|/* Is this same machine? */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|sanity_check
c_func
(paren
op_amp
id|cur-&gt;sh
)paren
)paren
)paren
r_goto
id|Done
suffix:semicolon
id|next
op_assign
id|next_entry
c_func
(paren
id|cur
)paren
suffix:semicolon
id|pagedir_save
op_assign
id|cur-&gt;sh.suspend_pagedir
suffix:semicolon
id|pmdisk_pages
op_assign
id|cur-&gt;sh.num_pbes
suffix:semicolon
id|nr_pgdir_pages
op_assign
id|SUSPEND_PD_PAGES
c_func
(paren
id|pmdisk_pages
)paren
suffix:semicolon
id|pagedir_order
op_assign
id|get_bitmask_order
c_func
(paren
id|nr_pgdir_pages
)paren
suffix:semicolon
id|pm_pagedir_nosave
op_assign
(paren
id|suspend_pagedir_t
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|pagedir_order
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pm_pagedir_nosave
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
id|pr_debug
c_func
(paren
l_string|&quot;%sReading pagedir, &quot;
comma
id|name_resume
)paren
suffix:semicolon
multiline_comment|/* We get pages in reverse order of saving! */
r_for
c_loop
(paren
id|i
op_assign
id|nr_pgdir_pages
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|BUG_ON
(paren
op_logical_neg
id|next.val
)paren
suffix:semicolon
id|cur
op_assign
(paren
r_union
id|diskpage
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|pm_pagedir_nosave
)paren
op_plus
id|i
suffix:semicolon
id|error
op_assign
id|read_page
c_func
(paren
id|swp_offset
c_func
(paren
id|next
)paren
comma
id|cur
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|FreePagedir
suffix:semicolon
id|next
op_assign
id|next_entry
c_func
(paren
id|cur
)paren
suffix:semicolon
)brace
id|BUG_ON
(paren
id|next.val
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|relocate_pagedir
c_func
(paren
)paren
)paren
)paren
r_goto
id|FreePagedir
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|check_pagedir
c_func
(paren
)paren
)paren
)paren
r_goto
id|FreePagedir
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Reading image data (%d pages): &quot;
comma
id|pmdisk_pages
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmdisk_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
id|swp_entry_t
id|swap_address
op_assign
(paren
id|pm_pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|swap_address
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_mod
l_int|100
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
multiline_comment|/* You do not need to check for overlaps...&n;&t;&t;   ... check_pagedir already did this work */
id|error
op_assign
id|read_page
c_func
(paren
id|swp_offset
c_func
(paren
id|swap_address
)paren
comma
(paren
r_char
op_star
)paren
(paren
(paren
id|pm_pagedir_nosave
op_plus
id|i
)paren
op_member_access_from_pointer
id|address
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|FreePagedir
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;|&bslash;n&quot;
)paren
suffix:semicolon
id|Done
suffix:colon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|cur
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
id|FreePagedir
suffix:colon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|pm_pagedir_nosave
comma
id|pagedir_order
)paren
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;pmdisk_save - Snapshot memory&n; */
DECL|function|pmdisk_save
r_int
id|pmdisk_save
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
macro_line|#if defined (CONFIG_HIGHMEM) || defined (CONFIG_DISCONTIGMEM)
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: not supported with high- or discontig-mem.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|error
op_assign
id|arch_prepare_suspend
c_func
(paren
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|pmdisk_arch_suspend
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;pmdisk_write - Write saved memory image to swap.&n; *&n; *&t;pmdisk_arch_suspend(0) returns after system is resumed.&n; *&n; *&t;pmdisk_arch_suspend() copies all &quot;used&quot; memory to &quot;free&quot; memory,&n; *&t;then unsuspends all device drivers, and writes memory to disk&n; *&t;using normal kernel mechanism.&n; */
DECL|function|pmdisk_write
r_int
id|pmdisk_write
c_func
(paren
r_void
)paren
(brace
r_return
id|suspend_save_image
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;pmdisk_read - Read saved image from swap.&n; */
DECL|function|pmdisk_read
r_int
id|__init
id|pmdisk_read
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strlen
c_func
(paren
id|resume_file
)paren
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|resume_device
op_assign
id|name_to_dev_t
c_func
(paren
id|resume_file
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;pmdisk: Resume From Partition: %s&bslash;n&quot;
comma
id|resume_file
)paren
suffix:semicolon
id|resume_bdev
op_assign
id|open_by_devnum
c_func
(paren
id|resume_device
comma
id|FMODE_READ
comma
id|BDEV_RAW
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|resume_bdev
)paren
)paren
(brace
id|set_blocksize
c_func
(paren
id|resume_bdev
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|error
op_assign
id|read_suspend_image
c_func
(paren
)paren
suffix:semicolon
id|blkdev_put
c_func
(paren
id|resume_bdev
comma
id|BDEV_RAW
)paren
suffix:semicolon
)brace
r_else
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|resume_bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|pr_debug
c_func
(paren
l_string|&quot;Reading resume file was successful&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|pr_debug
c_func
(paren
l_string|&quot;%sError %d resuming&bslash;n&quot;
comma
id|name_resume
comma
id|error
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;pmdisk_restore - Replace running kernel with saved image.&n; */
DECL|function|pmdisk_restore
r_int
id|__init
id|pmdisk_restore
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|pmdisk_arch_suspend
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;pmdisk_free - Free memory allocated to hold snapshot.&n; */
DECL|function|pmdisk_free
r_int
id|pmdisk_free
c_func
(paren
r_void
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;Freeing prev allocated pagedir&bslash;n&quot;
)paren
suffix:semicolon
id|free_suspend_pagedir
c_func
(paren
(paren
r_int
r_int
)paren
id|pagedir_save
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pmdisk_setup
r_static
r_int
id|__init
id|pmdisk_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|str
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;off&quot;
)paren
)paren
id|resume_file
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_else
id|strncpy
c_func
(paren
id|resume_file
comma
id|str
comma
l_int|255
)paren
suffix:semicolon
)brace
r_else
id|resume_file
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;pmdisk=&quot;
comma
id|pmdisk_setup
)paren
suffix:semicolon
eof
