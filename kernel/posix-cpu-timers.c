multiline_comment|/*&n; * Implement CPU time clocks for the POSIX clock interface.&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/posix-timers.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
DECL|function|check_clock
r_static
r_int
id|check_clock
c_func
(paren
id|clockid_t
id|which_clock
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_const
id|pid_t
id|pid
op_assign
id|CPUCLOCK_PID
c_func
(paren
id|which_clock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CPUCLOCK_WHICH
c_func
(paren
id|which_clock
)paren
op_ge
id|CPUCLOCK_MAX
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|pid
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|p
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
op_logical_or
(paren
id|CPUCLOCK_PERTHREAD
c_func
(paren
id|which_clock
)paren
ques
c_cond
id|p-&gt;tgid
op_ne
id|current-&gt;tgid
suffix:colon
id|p-&gt;tgid
op_ne
id|pid
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_static
r_inline
r_union
id|cpu_time_count
DECL|function|timespec_to_sample
id|timespec_to_sample
c_func
(paren
id|clockid_t
id|which_clock
comma
r_const
r_struct
id|timespec
op_star
id|tp
)paren
(brace
r_union
id|cpu_time_count
id|ret
suffix:semicolon
id|ret.sched
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* high half always zero when .cpu used */
r_if
c_cond
(paren
id|CPUCLOCK_WHICH
c_func
(paren
id|which_clock
)paren
op_eq
id|CPUCLOCK_SCHED
)paren
(brace
id|ret.sched
op_assign
id|tp-&gt;tv_sec
op_star
id|NSEC_PER_SEC
op_plus
id|tp-&gt;tv_nsec
suffix:semicolon
)brace
r_else
(brace
id|ret.cpu
op_assign
id|timespec_to_cputime
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sample_to_timespec
r_static
r_void
id|sample_to_timespec
c_func
(paren
id|clockid_t
id|which_clock
comma
r_union
id|cpu_time_count
id|cpu
comma
r_struct
id|timespec
op_star
id|tp
)paren
(brace
r_if
c_cond
(paren
id|CPUCLOCK_WHICH
c_func
(paren
id|which_clock
)paren
op_eq
id|CPUCLOCK_SCHED
)paren
(brace
id|tp-&gt;tv_sec
op_assign
id|div_long_long_rem
c_func
(paren
id|cpu.sched
comma
id|NSEC_PER_SEC
comma
op_amp
id|tp-&gt;tv_nsec
)paren
suffix:semicolon
)brace
r_else
(brace
id|cputime_to_timespec
c_func
(paren
id|cpu.cpu
comma
id|tp
)paren
suffix:semicolon
)brace
)brace
DECL|function|cpu_time_before
r_static
r_inline
r_int
id|cpu_time_before
c_func
(paren
id|clockid_t
id|which_clock
comma
r_union
id|cpu_time_count
id|now
comma
r_union
id|cpu_time_count
id|then
)paren
(brace
r_if
c_cond
(paren
id|CPUCLOCK_WHICH
c_func
(paren
id|which_clock
)paren
op_eq
id|CPUCLOCK_SCHED
)paren
(brace
r_return
id|now.sched
OL
id|then.sched
suffix:semicolon
)brace
r_else
(brace
r_return
id|cputime_lt
c_func
(paren
id|now.cpu
comma
id|then.cpu
)paren
suffix:semicolon
)brace
)brace
DECL|function|cpu_time_add
r_static
r_inline
r_void
id|cpu_time_add
c_func
(paren
id|clockid_t
id|which_clock
comma
r_union
id|cpu_time_count
op_star
id|acc
comma
r_union
id|cpu_time_count
id|val
)paren
(brace
r_if
c_cond
(paren
id|CPUCLOCK_WHICH
c_func
(paren
id|which_clock
)paren
op_eq
id|CPUCLOCK_SCHED
)paren
(brace
id|acc-&gt;sched
op_add_assign
id|val.sched
suffix:semicolon
)brace
r_else
(brace
id|acc-&gt;cpu
op_assign
id|cputime_add
c_func
(paren
id|acc-&gt;cpu
comma
id|val.cpu
)paren
suffix:semicolon
)brace
)brace
DECL|function|cpu_time_sub
r_static
r_inline
r_union
id|cpu_time_count
id|cpu_time_sub
c_func
(paren
id|clockid_t
id|which_clock
comma
r_union
id|cpu_time_count
id|a
comma
r_union
id|cpu_time_count
id|b
)paren
(brace
r_if
c_cond
(paren
id|CPUCLOCK_WHICH
c_func
(paren
id|which_clock
)paren
op_eq
id|CPUCLOCK_SCHED
)paren
(brace
id|a.sched
op_sub_assign
id|b.sched
suffix:semicolon
)brace
r_else
(brace
id|a.cpu
op_assign
id|cputime_sub
c_func
(paren
id|a.cpu
comma
id|b.cpu
)paren
suffix:semicolon
)brace
r_return
id|a
suffix:semicolon
)brace
multiline_comment|/*&n; * Update expiry time from increment, and increase overrun count,&n; * given the current clock sample.&n; */
DECL|function|bump_cpu_timer
r_static
r_inline
r_void
id|bump_cpu_timer
c_func
(paren
r_struct
id|k_itimer
op_star
id|timer
comma
r_union
id|cpu_time_count
id|now
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|timer-&gt;it.cpu.incr.sched
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|CPUCLOCK_WHICH
c_func
(paren
id|timer-&gt;it_clock
)paren
op_eq
id|CPUCLOCK_SCHED
)paren
(brace
r_int
r_int
r_int
id|delta
comma
id|incr
suffix:semicolon
r_if
c_cond
(paren
id|now.sched
OL
id|timer-&gt;it.cpu.expires.sched
)paren
r_return
suffix:semicolon
id|incr
op_assign
id|timer-&gt;it.cpu.incr.sched
suffix:semicolon
id|delta
op_assign
id|now.sched
op_plus
id|incr
op_minus
id|timer-&gt;it.cpu.expires.sched
suffix:semicolon
multiline_comment|/* Don&squot;t use (incr*2 &lt; delta), incr*2 might overflow. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|incr
OL
id|delta
op_minus
id|incr
suffix:semicolon
id|i
op_increment
)paren
id|incr
op_assign
id|incr
op_lshift
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|incr
op_rshift_assign
l_int|1
comma
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|delta
op_le
id|incr
)paren
r_continue
suffix:semicolon
id|timer-&gt;it.cpu.expires.sched
op_add_assign
id|incr
suffix:semicolon
id|timer-&gt;it_overrun
op_add_assign
l_int|1
op_lshift
id|i
suffix:semicolon
id|delta
op_sub_assign
id|incr
suffix:semicolon
)brace
)brace
r_else
(brace
id|cputime_t
id|delta
comma
id|incr
suffix:semicolon
r_if
c_cond
(paren
id|cputime_lt
c_func
(paren
id|now.cpu
comma
id|timer-&gt;it.cpu.expires.cpu
)paren
)paren
r_return
suffix:semicolon
id|incr
op_assign
id|timer-&gt;it.cpu.incr.cpu
suffix:semicolon
id|delta
op_assign
id|cputime_sub
c_func
(paren
id|cputime_add
c_func
(paren
id|now.cpu
comma
id|incr
)paren
comma
id|timer-&gt;it.cpu.expires.cpu
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t use (incr*2 &lt; delta), incr*2 might overflow. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|cputime_lt
c_func
(paren
id|incr
comma
id|cputime_sub
c_func
(paren
id|delta
comma
id|incr
)paren
)paren
suffix:semicolon
id|i
op_increment
)paren
id|incr
op_assign
id|cputime_add
c_func
(paren
id|incr
comma
id|incr
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|incr
op_assign
id|cputime_halve
c_func
(paren
id|incr
)paren
comma
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|cputime_le
c_func
(paren
id|delta
comma
id|incr
)paren
)paren
r_continue
suffix:semicolon
id|timer-&gt;it.cpu.expires.cpu
op_assign
id|cputime_add
c_func
(paren
id|timer-&gt;it.cpu.expires.cpu
comma
id|incr
)paren
suffix:semicolon
id|timer-&gt;it_overrun
op_add_assign
l_int|1
op_lshift
id|i
suffix:semicolon
id|delta
op_assign
id|cputime_sub
c_func
(paren
id|delta
comma
id|incr
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|prof_ticks
r_static
r_inline
id|cputime_t
id|prof_ticks
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_return
id|cputime_add
c_func
(paren
id|p-&gt;utime
comma
id|p-&gt;stime
)paren
suffix:semicolon
)brace
DECL|function|virt_ticks
r_static
r_inline
id|cputime_t
id|virt_ticks
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_return
id|p-&gt;utime
suffix:semicolon
)brace
DECL|function|sched_ns
r_static
r_inline
r_int
r_int
r_int
id|sched_ns
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_return
(paren
id|p
op_eq
id|current
)paren
ques
c_cond
id|current_sched_time
c_func
(paren
id|p
)paren
suffix:colon
id|p-&gt;sched_time
suffix:semicolon
)brace
DECL|function|posix_cpu_clock_getres
r_int
id|posix_cpu_clock_getres
c_func
(paren
id|clockid_t
id|which_clock
comma
r_struct
id|timespec
op_star
id|tp
)paren
(brace
r_int
id|error
op_assign
id|check_clock
c_func
(paren
id|which_clock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|tp-&gt;tv_sec
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;tv_nsec
op_assign
(paren
(paren
id|NSEC_PER_SEC
op_plus
id|HZ
op_minus
l_int|1
)paren
op_div
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CPUCLOCK_WHICH
c_func
(paren
id|which_clock
)paren
op_eq
id|CPUCLOCK_SCHED
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If sched_clock is using a cycle counter, we&n;&t;&t;&t; * don&squot;t have any idea of its true resolution&n;&t;&t;&t; * exported, but it is much more than 1s/HZ.&n;&t;&t;&t; */
id|tp-&gt;tv_nsec
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|posix_cpu_clock_set
r_int
id|posix_cpu_clock_set
c_func
(paren
id|clockid_t
id|which_clock
comma
r_const
r_struct
id|timespec
op_star
id|tp
)paren
(brace
multiline_comment|/*&n;&t; * You can never reset a CPU clock, but we check for other errors&n;&t; * in the call before failing with EPERM.&n;&t; */
r_int
id|error
op_assign
id|check_clock
c_func
(paren
id|which_clock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
(brace
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Sample a per-thread clock for the given task.&n; */
DECL|function|cpu_clock_sample
r_static
r_int
id|cpu_clock_sample
c_func
(paren
id|clockid_t
id|which_clock
comma
r_struct
id|task_struct
op_star
id|p
comma
r_union
id|cpu_time_count
op_star
id|cpu
)paren
(brace
r_switch
c_cond
(paren
id|CPUCLOCK_WHICH
c_func
(paren
id|which_clock
)paren
)paren
(brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|CPUCLOCK_PROF
suffix:colon
id|cpu-&gt;cpu
op_assign
id|prof_ticks
c_func
(paren
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPUCLOCK_VIRT
suffix:colon
id|cpu-&gt;cpu
op_assign
id|virt_ticks
c_func
(paren
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPUCLOCK_SCHED
suffix:colon
id|cpu-&gt;sched
op_assign
id|sched_ns
c_func
(paren
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Sample a process (thread group) clock for the given group_leader task.&n; * Must be called with tasklist_lock held for reading.&n; * Must be called with tasklist_lock held for reading, and p-&gt;sighand-&gt;siglock.&n; */
DECL|function|cpu_clock_sample_group_locked
r_static
r_int
id|cpu_clock_sample_group_locked
c_func
(paren
r_int
r_int
id|clock_idx
comma
r_struct
id|task_struct
op_star
id|p
comma
r_union
id|cpu_time_count
op_star
id|cpu
)paren
(brace
r_struct
id|task_struct
op_star
id|t
op_assign
id|p
suffix:semicolon
r_switch
c_cond
(paren
id|clock_idx
)paren
(brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|CPUCLOCK_PROF
suffix:colon
id|cpu-&gt;cpu
op_assign
id|cputime_add
c_func
(paren
id|p-&gt;signal-&gt;utime
comma
id|p-&gt;signal-&gt;stime
)paren
suffix:semicolon
r_do
(brace
id|cpu-&gt;cpu
op_assign
id|cputime_add
c_func
(paren
id|cpu-&gt;cpu
comma
id|prof_ticks
c_func
(paren
id|t
)paren
)paren
suffix:semicolon
id|t
op_assign
id|next_thread
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|t
op_ne
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPUCLOCK_VIRT
suffix:colon
id|cpu-&gt;cpu
op_assign
id|p-&gt;signal-&gt;utime
suffix:semicolon
r_do
(brace
id|cpu-&gt;cpu
op_assign
id|cputime_add
c_func
(paren
id|cpu-&gt;cpu
comma
id|virt_ticks
c_func
(paren
id|t
)paren
)paren
suffix:semicolon
id|t
op_assign
id|next_thread
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|t
op_ne
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPUCLOCK_SCHED
suffix:colon
id|cpu-&gt;sched
op_assign
id|p-&gt;signal-&gt;sched_time
suffix:semicolon
multiline_comment|/* Add in each other live thread.  */
r_while
c_loop
(paren
(paren
id|t
op_assign
id|next_thread
c_func
(paren
id|t
)paren
)paren
op_ne
id|p
)paren
(brace
id|cpu-&gt;sched
op_add_assign
id|t-&gt;sched_time
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;tgid
op_eq
id|current-&gt;tgid
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We&squot;re sampling ourselves, so include the&n;&t;&t;&t; * cycles not yet banked.  We still omit&n;&t;&t;&t; * other threads running on other CPUs,&n;&t;&t;&t; * so the total can always be behind as&n;&t;&t;&t; * much as max(nthreads-1,ncpus) * (NSEC_PER_SEC/HZ).&n;&t;&t;&t; */
id|cpu-&gt;sched
op_add_assign
id|current_sched_time
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
r_else
(brace
id|cpu-&gt;sched
op_add_assign
id|p-&gt;sched_time
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Sample a process (thread group) clock for the given group_leader task.&n; * Must be called with tasklist_lock held for reading.&n; */
DECL|function|cpu_clock_sample_group
r_static
r_int
id|cpu_clock_sample_group
c_func
(paren
id|clockid_t
id|which_clock
comma
r_struct
id|task_struct
op_star
id|p
comma
r_union
id|cpu_time_count
op_star
id|cpu
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|p-&gt;sighand-&gt;siglock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|cpu_clock_sample_group_locked
c_func
(paren
id|CPUCLOCK_WHICH
c_func
(paren
id|which_clock
)paren
comma
id|p
comma
id|cpu
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|p-&gt;sighand-&gt;siglock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|posix_cpu_clock_get
r_int
id|posix_cpu_clock_get
c_func
(paren
id|clockid_t
id|which_clock
comma
r_struct
id|timespec
op_star
id|tp
)paren
(brace
r_const
id|pid_t
id|pid
op_assign
id|CPUCLOCK_PID
c_func
(paren
id|which_clock
)paren
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_union
id|cpu_time_count
id|rtn
suffix:semicolon
r_if
c_cond
(paren
id|pid
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Special case constant value for our own clocks.&n;&t;&t; * We don&squot;t have to do any lookup to find ourselves.&n;&t;&t; */
r_if
c_cond
(paren
id|CPUCLOCK_PERTHREAD
c_func
(paren
id|which_clock
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Sampling just ourselves we can do with no locking.&n;&t;&t;&t; */
id|error
op_assign
id|cpu_clock_sample
c_func
(paren
id|which_clock
comma
id|current
comma
op_amp
id|rtn
)paren
suffix:semicolon
)brace
r_else
(brace
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|error
op_assign
id|cpu_clock_sample_group
c_func
(paren
id|which_clock
comma
id|current
comma
op_amp
id|rtn
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Find the given PID, and validate that the caller&n;&t;&t; * should be able to see it.&n;&t;&t; */
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|p
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
id|CPUCLOCK_PERTHREAD
c_func
(paren
id|which_clock
)paren
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;tgid
op_eq
id|current-&gt;tgid
)paren
(brace
id|error
op_assign
id|cpu_clock_sample
c_func
(paren
id|which_clock
comma
id|p
comma
op_amp
id|rtn
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|p-&gt;tgid
op_eq
id|pid
op_logical_and
id|p-&gt;signal
)paren
(brace
id|error
op_assign
id|cpu_clock_sample_group
c_func
(paren
id|which_clock
comma
id|p
comma
op_amp
id|rtn
)paren
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|sample_to_timespec
c_func
(paren
id|which_clock
comma
id|rtn
comma
id|tp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Validate the clockid_t for a new CPU-clock timer, and initialize the timer.&n; * This is called from sys_timer_create with the new timer already locked.&n; */
DECL|function|posix_cpu_timer_create
r_int
id|posix_cpu_timer_create
c_func
(paren
r_struct
id|k_itimer
op_star
id|new_timer
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_const
id|pid_t
id|pid
op_assign
id|CPUCLOCK_PID
c_func
(paren
id|new_timer-&gt;it_clock
)paren
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|CPUCLOCK_WHICH
c_func
(paren
id|new_timer-&gt;it_clock
)paren
op_ge
id|CPUCLOCK_MAX
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|new_timer-&gt;it.cpu.entry
)paren
suffix:semicolon
id|new_timer-&gt;it.cpu.incr.sched
op_assign
l_int|0
suffix:semicolon
id|new_timer-&gt;it.cpu.expires.sched
op_assign
l_int|0
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CPUCLOCK_PERTHREAD
c_func
(paren
id|new_timer-&gt;it_clock
)paren
)paren
(brace
r_if
c_cond
(paren
id|pid
op_eq
l_int|0
)paren
(brace
id|p
op_assign
id|current
suffix:semicolon
)brace
r_else
(brace
id|p
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_logical_and
id|p-&gt;tgid
op_ne
id|current-&gt;tgid
)paren
id|p
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|pid
op_eq
l_int|0
)paren
(brace
id|p
op_assign
id|current-&gt;group_leader
suffix:semicolon
)brace
r_else
(brace
id|p
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_logical_and
id|p-&gt;tgid
op_ne
id|pid
)paren
id|p
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|new_timer-&gt;it.cpu.task
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
id|get_task_struct
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Clean up a CPU-clock timer that is about to be destroyed.&n; * This is called from timer deletion with the timer already locked.&n; * If we return TIMER_RETRY, it&squot;s necessary to release the timer&squot;s lock&n; * and try again.  (This happens when the timer is in the middle of firing.)&n; */
DECL|function|posix_cpu_timer_del
r_int
id|posix_cpu_timer_del
c_func
(paren
r_struct
id|k_itimer
op_star
id|timer
)paren
(brace
r_struct
id|task_struct
op_star
id|p
op_assign
id|timer-&gt;it.cpu.task
suffix:semicolon
r_if
c_cond
(paren
id|timer-&gt;it.cpu.firing
)paren
r_return
id|TIMER_RETRY
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|p
op_eq
l_int|NULL
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|timer-&gt;it.cpu.entry
)paren
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|p-&gt;signal
op_eq
l_int|NULL
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We raced with the reaping of the task.&n;&t;&t;&t; * The deletion should have cleared us off the list.&n;&t;&t;&t; */
id|BUG_ON
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|timer-&gt;it.cpu.entry
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Take us off the task&squot;s timer list.&n;&t;&t;&t; */
id|spin_lock
c_func
(paren
op_amp
id|p-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|timer-&gt;it.cpu.entry
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|p-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
id|put_task_struct
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Clean out CPU timers still ticking when a thread exited.  The task&n; * pointer is cleared, and the expiry time is replaced with the residual&n; * time for later timer_gettime calls to return.&n; * This must be called with the siglock held.&n; */
DECL|function|cleanup_timers
r_static
r_void
id|cleanup_timers
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
id|cputime_t
id|utime
comma
id|cputime_t
id|stime
comma
r_int
r_int
r_int
id|sched_time
)paren
(brace
r_struct
id|cpu_timer_list
op_star
id|timer
comma
op_star
id|next
suffix:semicolon
id|cputime_t
id|ptime
op_assign
id|cputime_add
c_func
(paren
id|utime
comma
id|stime
)paren
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|timer
comma
id|next
comma
id|head
comma
id|entry
)paren
(brace
id|timer-&gt;task
op_assign
l_int|NULL
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|timer-&gt;entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cputime_lt
c_func
(paren
id|timer-&gt;expires.cpu
comma
id|ptime
)paren
)paren
(brace
id|timer-&gt;expires.cpu
op_assign
id|cputime_zero
suffix:semicolon
)brace
r_else
(brace
id|timer-&gt;expires.cpu
op_assign
id|cputime_sub
c_func
(paren
id|timer-&gt;expires.cpu
comma
id|ptime
)paren
suffix:semicolon
)brace
)brace
op_increment
id|head
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|timer
comma
id|next
comma
id|head
comma
id|entry
)paren
(brace
id|timer-&gt;task
op_assign
l_int|NULL
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|timer-&gt;entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cputime_lt
c_func
(paren
id|timer-&gt;expires.cpu
comma
id|utime
)paren
)paren
(brace
id|timer-&gt;expires.cpu
op_assign
id|cputime_zero
suffix:semicolon
)brace
r_else
(brace
id|timer-&gt;expires.cpu
op_assign
id|cputime_sub
c_func
(paren
id|timer-&gt;expires.cpu
comma
id|utime
)paren
suffix:semicolon
)brace
)brace
op_increment
id|head
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|timer
comma
id|next
comma
id|head
comma
id|entry
)paren
(brace
id|timer-&gt;task
op_assign
l_int|NULL
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|timer-&gt;entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer-&gt;expires.sched
OL
id|sched_time
)paren
(brace
id|timer-&gt;expires.sched
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|timer-&gt;expires.sched
op_sub_assign
id|sched_time
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * These are both called with the siglock held, when the current thread&n; * is being reaped.  When the final (leader) thread in the group is reaped,&n; * posix_cpu_timers_exit_group will be called after posix_cpu_timers_exit.&n; */
DECL|function|posix_cpu_timers_exit
r_void
id|posix_cpu_timers_exit
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
id|cleanup_timers
c_func
(paren
id|tsk-&gt;cpu_timers
comma
id|tsk-&gt;utime
comma
id|tsk-&gt;stime
comma
id|tsk-&gt;sched_time
)paren
suffix:semicolon
)brace
DECL|function|posix_cpu_timers_exit_group
r_void
id|posix_cpu_timers_exit_group
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
id|cleanup_timers
c_func
(paren
id|tsk-&gt;signal-&gt;cpu_timers
comma
id|cputime_add
c_func
(paren
id|tsk-&gt;utime
comma
id|tsk-&gt;signal-&gt;utime
)paren
comma
id|cputime_add
c_func
(paren
id|tsk-&gt;stime
comma
id|tsk-&gt;signal-&gt;stime
)paren
comma
id|tsk-&gt;sched_time
op_plus
id|tsk-&gt;signal-&gt;sched_time
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the expiry times of all the threads in the process so one of them&n; * will go off before the process cumulative expiry total is reached.&n; */
DECL|function|process_timer_rebalance
r_static
r_void
id|process_timer_rebalance
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
r_int
id|clock_idx
comma
r_union
id|cpu_time_count
id|expires
comma
r_union
id|cpu_time_count
id|val
)paren
(brace
id|cputime_t
id|ticks
comma
id|left
suffix:semicolon
r_int
r_int
r_int
id|ns
comma
id|nsleft
suffix:semicolon
r_struct
id|task_struct
op_star
id|t
op_assign
id|p
suffix:semicolon
r_int
r_int
id|nthreads
op_assign
id|atomic_read
c_func
(paren
op_amp
id|p-&gt;signal-&gt;live
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|clock_idx
)paren
(brace
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPUCLOCK_PROF
suffix:colon
id|left
op_assign
id|cputime_div
c_func
(paren
id|cputime_sub
c_func
(paren
id|expires.cpu
comma
id|val.cpu
)paren
comma
id|nthreads
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|unlikely
c_func
(paren
id|t-&gt;exit_state
)paren
)paren
(brace
id|ticks
op_assign
id|cputime_add
c_func
(paren
id|prof_ticks
c_func
(paren
id|t
)paren
comma
id|left
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cputime_eq
c_func
(paren
id|t-&gt;it_prof_expires
comma
id|cputime_zero
)paren
op_logical_or
id|cputime_gt
c_func
(paren
id|t-&gt;it_prof_expires
comma
id|ticks
)paren
)paren
(brace
id|t-&gt;it_prof_expires
op_assign
id|ticks
suffix:semicolon
)brace
)brace
id|t
op_assign
id|next_thread
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|t
op_ne
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPUCLOCK_VIRT
suffix:colon
id|left
op_assign
id|cputime_div
c_func
(paren
id|cputime_sub
c_func
(paren
id|expires.cpu
comma
id|val.cpu
)paren
comma
id|nthreads
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|unlikely
c_func
(paren
id|t-&gt;exit_state
)paren
)paren
(brace
id|ticks
op_assign
id|cputime_add
c_func
(paren
id|virt_ticks
c_func
(paren
id|t
)paren
comma
id|left
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cputime_eq
c_func
(paren
id|t-&gt;it_virt_expires
comma
id|cputime_zero
)paren
op_logical_or
id|cputime_gt
c_func
(paren
id|t-&gt;it_virt_expires
comma
id|ticks
)paren
)paren
(brace
id|t-&gt;it_virt_expires
op_assign
id|ticks
suffix:semicolon
)brace
)brace
id|t
op_assign
id|next_thread
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|t
op_ne
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPUCLOCK_SCHED
suffix:colon
id|nsleft
op_assign
id|expires.sched
op_minus
id|val.sched
suffix:semicolon
id|do_div
c_func
(paren
id|nsleft
comma
id|nthreads
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|unlikely
c_func
(paren
id|t-&gt;exit_state
)paren
)paren
(brace
id|ns
op_assign
id|t-&gt;sched_time
op_plus
id|nsleft
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;it_sched_expires
op_eq
l_int|0
op_logical_or
id|t-&gt;it_sched_expires
OG
id|ns
)paren
(brace
id|t-&gt;it_sched_expires
op_assign
id|ns
suffix:semicolon
)brace
)brace
id|t
op_assign
id|next_thread
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|t
op_ne
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|clear_dead_task
r_static
r_void
id|clear_dead_task
c_func
(paren
r_struct
id|k_itimer
op_star
id|timer
comma
r_union
id|cpu_time_count
id|now
)paren
(brace
multiline_comment|/*&n;&t; * That&squot;s all for this thread or process.&n;&t; * We leave our residual in expires to be reported.&n;&t; */
id|put_task_struct
c_func
(paren
id|timer-&gt;it.cpu.task
)paren
suffix:semicolon
id|timer-&gt;it.cpu.task
op_assign
l_int|NULL
suffix:semicolon
id|timer-&gt;it.cpu.expires
op_assign
id|cpu_time_sub
c_func
(paren
id|timer-&gt;it_clock
comma
id|timer-&gt;it.cpu.expires
comma
id|now
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert the timer on the appropriate list before any timers that&n; * expire later.  This must be called with the tasklist_lock held&n; * for reading, and interrupts disabled.&n; */
DECL|function|arm_timer
r_static
r_void
id|arm_timer
c_func
(paren
r_struct
id|k_itimer
op_star
id|timer
comma
r_union
id|cpu_time_count
id|now
)paren
(brace
r_struct
id|task_struct
op_star
id|p
op_assign
id|timer-&gt;it.cpu.task
suffix:semicolon
r_struct
id|list_head
op_star
id|head
comma
op_star
id|listpos
suffix:semicolon
r_struct
id|cpu_timer_list
op_star
r_const
id|nt
op_assign
op_amp
id|timer-&gt;it.cpu
suffix:semicolon
r_struct
id|cpu_timer_list
op_star
id|next
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|head
op_assign
(paren
id|CPUCLOCK_PERTHREAD
c_func
(paren
id|timer-&gt;it_clock
)paren
ques
c_cond
id|p-&gt;cpu_timers
suffix:colon
id|p-&gt;signal-&gt;cpu_timers
)paren
suffix:semicolon
id|head
op_add_assign
id|CPUCLOCK_WHICH
c_func
(paren
id|timer-&gt;it_clock
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|irqs_disabled
c_func
(paren
)paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|p-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
id|listpos
op_assign
id|head
suffix:semicolon
r_if
c_cond
(paren
id|CPUCLOCK_WHICH
c_func
(paren
id|timer-&gt;it_clock
)paren
op_eq
id|CPUCLOCK_SCHED
)paren
(brace
id|list_for_each_entry
c_func
(paren
id|next
comma
id|head
comma
id|entry
)paren
(brace
r_if
c_cond
(paren
id|next-&gt;expires.sched
OG
id|nt-&gt;expires.sched
)paren
(brace
id|listpos
op_assign
op_amp
id|next-&gt;entry
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|list_for_each_entry
c_func
(paren
id|next
comma
id|head
comma
id|entry
)paren
(brace
r_if
c_cond
(paren
id|cputime_gt
c_func
(paren
id|next-&gt;expires.cpu
comma
id|nt-&gt;expires.cpu
)paren
)paren
(brace
id|listpos
op_assign
op_amp
id|next-&gt;entry
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|list_add
c_func
(paren
op_amp
id|nt-&gt;entry
comma
id|listpos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|listpos
op_eq
id|head
)paren
(brace
multiline_comment|/*&n;&t;&t; * We are the new earliest-expiring timer.&n;&t;&t; * If we are a thread timer, there can always&n;&t;&t; * be a process timer telling us to stop earlier.&n;&t;&t; */
r_if
c_cond
(paren
id|CPUCLOCK_PERTHREAD
c_func
(paren
id|timer-&gt;it_clock
)paren
)paren
(brace
r_switch
c_cond
(paren
id|CPUCLOCK_WHICH
c_func
(paren
id|timer-&gt;it_clock
)paren
)paren
(brace
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_case
id|CPUCLOCK_PROF
suffix:colon
r_if
c_cond
(paren
id|cputime_eq
c_func
(paren
id|p-&gt;it_prof_expires
comma
id|cputime_zero
)paren
op_logical_or
id|cputime_gt
c_func
(paren
id|p-&gt;it_prof_expires
comma
id|nt-&gt;expires.cpu
)paren
)paren
id|p-&gt;it_prof_expires
op_assign
id|nt-&gt;expires.cpu
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPUCLOCK_VIRT
suffix:colon
r_if
c_cond
(paren
id|cputime_eq
c_func
(paren
id|p-&gt;it_virt_expires
comma
id|cputime_zero
)paren
op_logical_or
id|cputime_gt
c_func
(paren
id|p-&gt;it_virt_expires
comma
id|nt-&gt;expires.cpu
)paren
)paren
id|p-&gt;it_virt_expires
op_assign
id|nt-&gt;expires.cpu
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPUCLOCK_SCHED
suffix:colon
r_if
c_cond
(paren
id|p-&gt;it_sched_expires
op_eq
l_int|0
op_logical_or
id|p-&gt;it_sched_expires
OG
id|nt-&gt;expires.sched
)paren
id|p-&gt;it_sched_expires
op_assign
id|nt-&gt;expires.sched
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * For a process timer, we must balance&n;&t;&t;&t; * all the live threads&squot; expirations.&n;&t;&t;&t; */
r_switch
c_cond
(paren
id|CPUCLOCK_WHICH
c_func
(paren
id|timer-&gt;it_clock
)paren
)paren
(brace
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_case
id|CPUCLOCK_VIRT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|cputime_eq
c_func
(paren
id|p-&gt;signal-&gt;it_virt_expires
comma
id|cputime_zero
)paren
op_logical_and
id|cputime_lt
c_func
(paren
id|p-&gt;signal-&gt;it_virt_expires
comma
id|timer-&gt;it.cpu.expires.cpu
)paren
)paren
r_break
suffix:semicolon
r_goto
id|rebalance
suffix:semicolon
r_case
id|CPUCLOCK_PROF
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|cputime_eq
c_func
(paren
id|p-&gt;signal-&gt;it_prof_expires
comma
id|cputime_zero
)paren
op_logical_and
id|cputime_lt
c_func
(paren
id|p-&gt;signal-&gt;it_prof_expires
comma
id|timer-&gt;it.cpu.expires.cpu
)paren
)paren
r_break
suffix:semicolon
id|i
op_assign
id|p-&gt;signal-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_cur
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|RLIM_INFINITY
op_logical_and
id|i
op_le
id|cputime_to_secs
c_func
(paren
id|timer-&gt;it.cpu.expires.cpu
)paren
)paren
r_break
suffix:semicolon
r_goto
id|rebalance
suffix:semicolon
r_case
id|CPUCLOCK_SCHED
suffix:colon
id|rebalance
suffix:colon
id|process_timer_rebalance
c_func
(paren
id|timer-&gt;it.cpu.task
comma
id|CPUCLOCK_WHICH
c_func
(paren
id|timer-&gt;it_clock
)paren
comma
id|timer-&gt;it.cpu.expires
comma
id|now
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|p-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The timer is locked, fire it and arrange for its reload.&n; */
DECL|function|cpu_timer_fire
r_static
r_void
id|cpu_timer_fire
c_func
(paren
r_struct
id|k_itimer
op_star
id|timer
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|timer-&gt;sigq
op_eq
l_int|NULL
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * This a special case for clock_nanosleep,&n;&t;&t; * not a normal timer from sys_timer_create.&n;&t;&t; */
id|wake_up_process
c_func
(paren
id|timer-&gt;it_process
)paren
suffix:semicolon
id|timer-&gt;it.cpu.expires.sched
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|timer-&gt;it.cpu.incr.sched
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * One-shot timer.  Clear it as soon as it&squot;s fired.&n;&t;&t; */
id|posix_timer_event
c_func
(paren
id|timer
comma
l_int|0
)paren
suffix:semicolon
id|timer-&gt;it.cpu.expires.sched
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|posix_timer_event
c_func
(paren
id|timer
comma
op_increment
id|timer-&gt;it_requeue_pending
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * The signal did not get queued because the signal&n;&t;&t; * was ignored, so we won&squot;t get any callback to&n;&t;&t; * reload the timer.  But we need to keep it&n;&t;&t; * ticking in case the signal is deliverable next time.&n;&t;&t; */
id|posix_cpu_timer_schedule
c_func
(paren
id|timer
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Guts of sys_timer_settime for CPU timers.&n; * This is called with the timer locked and interrupts disabled.&n; * If we return TIMER_RETRY, it&squot;s necessary to release the timer&squot;s lock&n; * and try again.  (This happens when the timer is in the middle of firing.)&n; */
DECL|function|posix_cpu_timer_set
r_int
id|posix_cpu_timer_set
c_func
(paren
r_struct
id|k_itimer
op_star
id|timer
comma
r_int
id|flags
comma
r_struct
id|itimerspec
op_star
r_new
comma
r_struct
id|itimerspec
op_star
id|old
)paren
(brace
r_struct
id|task_struct
op_star
id|p
op_assign
id|timer-&gt;it.cpu.task
suffix:semicolon
r_union
id|cpu_time_count
id|old_expires
comma
id|new_expires
comma
id|val
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|p
op_eq
l_int|NULL
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Timer refers to a dead task&squot;s clock.&n;&t;&t; */
r_return
op_minus
id|ESRCH
suffix:semicolon
)brace
id|new_expires
op_assign
id|timespec_to_sample
c_func
(paren
id|timer-&gt;it_clock
comma
op_amp
r_new
op_member_access_from_pointer
id|it_value
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We need the tasklist_lock to protect against reaping that&n;&t; * clears p-&gt;signal.  If p has just been reaped, we can no&n;&t; * longer get any information about it at all.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|p-&gt;signal
op_eq
l_int|NULL
)paren
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|put_task_struct
c_func
(paren
id|p
)paren
suffix:semicolon
id|timer-&gt;it.cpu.task
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ESRCH
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Disarm any old timer after extracting its expiry time.&n;&t; */
id|BUG_ON
c_func
(paren
op_logical_neg
id|irqs_disabled
c_func
(paren
)paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|p-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
id|old_expires
op_assign
id|timer-&gt;it.cpu.expires
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|timer-&gt;it.cpu.entry
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|p-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We need to sample the current value to convert the new&n;&t; * value from to relative and absolute, and to convert the&n;&t; * old value from absolute to relative.  To set a process&n;&t; * timer, we need a sample to balance the thread expiry&n;&t; * times (in arm_timer).  With an absolute time, we must&n;&t; * check if it&squot;s already passed.  In short, we need a sample.&n;&t; */
r_if
c_cond
(paren
id|CPUCLOCK_PERTHREAD
c_func
(paren
id|timer-&gt;it_clock
)paren
)paren
(brace
id|cpu_clock_sample
c_func
(paren
id|timer-&gt;it_clock
comma
id|p
comma
op_amp
id|val
)paren
suffix:semicolon
)brace
r_else
(brace
id|cpu_clock_sample_group
c_func
(paren
id|timer-&gt;it_clock
comma
id|p
comma
op_amp
id|val
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old
)paren
(brace
r_if
c_cond
(paren
id|old_expires.sched
op_eq
l_int|0
)paren
(brace
id|old-&gt;it_value.tv_sec
op_assign
l_int|0
suffix:semicolon
id|old-&gt;it_value.tv_nsec
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Update the timer in case it has&n;&t;&t;&t; * overrun already.  If it has,&n;&t;&t;&t; * we&squot;ll report it as having overrun&n;&t;&t;&t; * and with the next reloaded timer&n;&t;&t;&t; * already ticking, though we are&n;&t;&t;&t; * swallowing that pending&n;&t;&t;&t; * notification here to install the&n;&t;&t;&t; * new setting.&n;&t;&t;&t; */
id|bump_cpu_timer
c_func
(paren
id|timer
comma
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_time_before
c_func
(paren
id|timer-&gt;it_clock
comma
id|val
comma
id|timer-&gt;it.cpu.expires
)paren
)paren
(brace
id|old_expires
op_assign
id|cpu_time_sub
c_func
(paren
id|timer-&gt;it_clock
comma
id|timer-&gt;it.cpu.expires
comma
id|val
)paren
suffix:semicolon
id|sample_to_timespec
c_func
(paren
id|timer-&gt;it_clock
comma
id|old_expires
comma
op_amp
id|old-&gt;it_value
)paren
suffix:semicolon
)brace
r_else
(brace
id|old-&gt;it_value.tv_nsec
op_assign
l_int|1
suffix:semicolon
id|old-&gt;it_value.tv_sec
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|timer-&gt;it.cpu.firing
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * We are colliding with the timer actually firing.&n;&t;&t; * Punt after filling in the timer&squot;s old value, and&n;&t;&t; * disable this firing since we are already reporting&n;&t;&t; * it as an overrun (thanks to bump_cpu_timer above).&n;&t;&t; */
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|timer-&gt;it.cpu.firing
op_assign
op_minus
l_int|1
suffix:semicolon
id|ret
op_assign
id|TIMER_RETRY
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_expires.sched
op_ne
l_int|0
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|TIMER_ABSTIME
)paren
)paren
(brace
id|cpu_time_add
c_func
(paren
id|timer-&gt;it_clock
comma
op_amp
id|new_expires
comma
id|val
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Install the new expiry time (or zero).&n;&t; * For a timer with no notification action, we don&squot;t actually&n;&t; * arm the timer (we&squot;ll just fake it for timer_gettime).&n;&t; */
id|timer-&gt;it.cpu.expires
op_assign
id|new_expires
suffix:semicolon
r_if
c_cond
(paren
id|new_expires.sched
op_ne
l_int|0
op_logical_and
(paren
id|timer-&gt;it_sigev_notify
op_amp
op_complement
id|SIGEV_THREAD_ID
)paren
op_ne
id|SIGEV_NONE
op_logical_and
id|cpu_time_before
c_func
(paren
id|timer-&gt;it_clock
comma
id|val
comma
id|new_expires
)paren
)paren
(brace
id|arm_timer
c_func
(paren
id|timer
comma
id|val
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Install the new reload setting, and&n;&t; * set up the signal and overrun bookkeeping.&n;&t; */
id|timer-&gt;it.cpu.incr
op_assign
id|timespec_to_sample
c_func
(paren
id|timer-&gt;it_clock
comma
op_amp
r_new
op_member_access_from_pointer
id|it_interval
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This acts as a modification timestamp for the timer,&n;&t; * so any automatic reload attempt will punt on seeing&n;&t; * that we have reset the timer manually.&n;&t; */
id|timer-&gt;it_requeue_pending
op_assign
(paren
id|timer-&gt;it_requeue_pending
op_plus
l_int|2
)paren
op_amp
op_complement
id|REQUEUE_PENDING
suffix:semicolon
id|timer-&gt;it_overrun_last
op_assign
l_int|0
suffix:semicolon
id|timer-&gt;it_overrun
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|new_expires.sched
op_ne
l_int|0
op_logical_and
(paren
id|timer-&gt;it_sigev_notify
op_amp
op_complement
id|SIGEV_THREAD_ID
)paren
op_ne
id|SIGEV_NONE
op_logical_and
op_logical_neg
id|cpu_time_before
c_func
(paren
id|timer-&gt;it_clock
comma
id|val
comma
id|new_expires
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * The designated time already passed, so we notify&n;&t;&t; * immediately, even if the thread never runs to&n;&t;&t; * accumulate more time on this clock.&n;&t;&t; */
id|cpu_timer_fire
c_func
(paren
id|timer
)paren
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|old
)paren
(brace
id|sample_to_timespec
c_func
(paren
id|timer-&gt;it_clock
comma
id|timer-&gt;it.cpu.incr
comma
op_amp
id|old-&gt;it_interval
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|posix_cpu_timer_get
r_void
id|posix_cpu_timer_get
c_func
(paren
r_struct
id|k_itimer
op_star
id|timer
comma
r_struct
id|itimerspec
op_star
id|itp
)paren
(brace
r_union
id|cpu_time_count
id|now
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
op_assign
id|timer-&gt;it.cpu.task
suffix:semicolon
r_int
id|clear_dead
suffix:semicolon
multiline_comment|/*&n;&t; * Easy part: convert the reload time.&n;&t; */
id|sample_to_timespec
c_func
(paren
id|timer-&gt;it_clock
comma
id|timer-&gt;it.cpu.incr
comma
op_amp
id|itp-&gt;it_interval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer-&gt;it.cpu.expires.sched
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Timer not armed at all.  */
id|itp-&gt;it_value.tv_sec
op_assign
id|itp-&gt;it_value.tv_nsec
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|p
op_eq
l_int|NULL
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * This task already died and the timer will never fire.&n;&t;&t; * In this case, expires is actually the dead value.&n;&t;&t; */
id|dead
suffix:colon
id|sample_to_timespec
c_func
(paren
id|timer-&gt;it_clock
comma
id|timer-&gt;it.cpu.expires
comma
op_amp
id|itp-&gt;it_value
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Sample the clock to take the difference with the expiry time.&n;&t; */
r_if
c_cond
(paren
id|CPUCLOCK_PERTHREAD
c_func
(paren
id|timer-&gt;it_clock
)paren
)paren
(brace
id|cpu_clock_sample
c_func
(paren
id|timer-&gt;it_clock
comma
id|p
comma
op_amp
id|now
)paren
suffix:semicolon
id|clear_dead
op_assign
id|p-&gt;exit_state
suffix:semicolon
)brace
r_else
(brace
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|p-&gt;signal
op_eq
l_int|NULL
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The process has been reaped.&n;&t;&t;&t; * We can&squot;t even collect a sample any more.&n;&t;&t;&t; * Call the timer disarmed, nothing else to do.&n;&t;&t;&t; */
id|put_task_struct
c_func
(paren
id|p
)paren
suffix:semicolon
id|timer-&gt;it.cpu.task
op_assign
l_int|NULL
suffix:semicolon
id|timer-&gt;it.cpu.expires.sched
op_assign
l_int|0
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_goto
id|dead
suffix:semicolon
)brace
r_else
(brace
id|cpu_clock_sample_group
c_func
(paren
id|timer-&gt;it_clock
comma
id|p
comma
op_amp
id|now
)paren
suffix:semicolon
id|clear_dead
op_assign
(paren
id|unlikely
c_func
(paren
id|p-&gt;exit_state
)paren
op_logical_and
id|thread_group_empty
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|timer-&gt;it_sigev_notify
op_amp
op_complement
id|SIGEV_THREAD_ID
)paren
op_eq
id|SIGEV_NONE
)paren
(brace
r_if
c_cond
(paren
id|timer-&gt;it.cpu.incr.sched
op_eq
l_int|0
op_logical_and
id|cpu_time_before
c_func
(paren
id|timer-&gt;it_clock
comma
id|timer-&gt;it.cpu.expires
comma
id|now
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Do-nothing timer expired and has no reload,&n;&t;&t;&t; * so it&squot;s as if it was never set.&n;&t;&t;&t; */
id|timer-&gt;it.cpu.expires.sched
op_assign
l_int|0
suffix:semicolon
id|itp-&gt;it_value.tv_sec
op_assign
id|itp-&gt;it_value.tv_nsec
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Account for any expirations and reloads that should&n;&t;&t; * have happened.&n;&t;&t; */
id|bump_cpu_timer
c_func
(paren
id|timer
comma
id|now
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|clear_dead
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * We&squot;ve noticed that the thread is dead, but&n;&t;&t; * not yet reaped.  Take this opportunity to&n;&t;&t; * drop our task ref.&n;&t;&t; */
id|clear_dead_task
c_func
(paren
id|timer
comma
id|now
)paren
suffix:semicolon
r_goto
id|dead
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cpu_time_before
c_func
(paren
id|timer-&gt;it_clock
comma
id|now
comma
id|timer-&gt;it.cpu.expires
)paren
)paren
(brace
id|sample_to_timespec
c_func
(paren
id|timer-&gt;it_clock
comma
id|cpu_time_sub
c_func
(paren
id|timer-&gt;it_clock
comma
id|timer-&gt;it.cpu.expires
comma
id|now
)paren
comma
op_amp
id|itp-&gt;it_value
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * The timer should have expired already, but the firing&n;&t;&t; * hasn&squot;t taken place yet.  Say it&squot;s just about to expire.&n;&t;&t; */
id|itp-&gt;it_value.tv_nsec
op_assign
l_int|1
suffix:semicolon
id|itp-&gt;it_value.tv_sec
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Check for any per-thread CPU timers that have fired and move them off&n; * the tsk-&gt;cpu_timers[N] list onto the firing list.  Here we update the&n; * tsk-&gt;it_*_expires values to reflect the remaining thread CPU timers.&n; */
DECL|function|check_thread_timers
r_static
r_void
id|check_thread_timers
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_struct
id|list_head
op_star
id|firing
)paren
(brace
r_struct
id|list_head
op_star
id|timers
op_assign
id|tsk-&gt;cpu_timers
suffix:semicolon
id|tsk-&gt;it_prof_expires
op_assign
id|cputime_zero
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|timers
)paren
)paren
(brace
r_struct
id|cpu_timer_list
op_star
id|t
op_assign
id|list_entry
c_func
(paren
id|timers-&gt;next
comma
r_struct
id|cpu_timer_list
comma
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cputime_lt
c_func
(paren
id|prof_ticks
c_func
(paren
id|tsk
)paren
comma
id|t-&gt;expires.cpu
)paren
)paren
(brace
id|tsk-&gt;it_prof_expires
op_assign
id|t-&gt;expires.cpu
suffix:semicolon
r_break
suffix:semicolon
)brace
id|t-&gt;firing
op_assign
l_int|1
suffix:semicolon
id|list_move_tail
c_func
(paren
op_amp
id|t-&gt;entry
comma
id|firing
)paren
suffix:semicolon
)brace
op_increment
id|timers
suffix:semicolon
id|tsk-&gt;it_virt_expires
op_assign
id|cputime_zero
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|timers
)paren
)paren
(brace
r_struct
id|cpu_timer_list
op_star
id|t
op_assign
id|list_entry
c_func
(paren
id|timers-&gt;next
comma
r_struct
id|cpu_timer_list
comma
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cputime_lt
c_func
(paren
id|virt_ticks
c_func
(paren
id|tsk
)paren
comma
id|t-&gt;expires.cpu
)paren
)paren
(brace
id|tsk-&gt;it_virt_expires
op_assign
id|t-&gt;expires.cpu
suffix:semicolon
r_break
suffix:semicolon
)brace
id|t-&gt;firing
op_assign
l_int|1
suffix:semicolon
id|list_move_tail
c_func
(paren
op_amp
id|t-&gt;entry
comma
id|firing
)paren
suffix:semicolon
)brace
op_increment
id|timers
suffix:semicolon
id|tsk-&gt;it_sched_expires
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|timers
)paren
)paren
(brace
r_struct
id|cpu_timer_list
op_star
id|t
op_assign
id|list_entry
c_func
(paren
id|timers-&gt;next
comma
r_struct
id|cpu_timer_list
comma
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tsk-&gt;sched_time
OL
id|t-&gt;expires.sched
)paren
(brace
id|tsk-&gt;it_sched_expires
op_assign
id|t-&gt;expires.sched
suffix:semicolon
r_break
suffix:semicolon
)brace
id|t-&gt;firing
op_assign
l_int|1
suffix:semicolon
id|list_move_tail
c_func
(paren
op_amp
id|t-&gt;entry
comma
id|firing
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Check for any per-thread CPU timers that have fired and move them&n; * off the tsk-&gt;*_timers list onto the firing list.  Per-thread timers&n; * have already been taken off.&n; */
DECL|function|check_process_timers
r_static
r_void
id|check_process_timers
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_struct
id|list_head
op_star
id|firing
)paren
(brace
r_struct
id|signal_struct
op_star
r_const
id|sig
op_assign
id|tsk-&gt;signal
suffix:semicolon
id|cputime_t
id|utime
comma
id|stime
comma
id|ptime
comma
id|virt_expires
comma
id|prof_expires
suffix:semicolon
r_int
r_int
r_int
id|sched_time
comma
id|sched_expires
suffix:semicolon
r_struct
id|task_struct
op_star
id|t
suffix:semicolon
r_struct
id|list_head
op_star
id|timers
op_assign
id|sig-&gt;cpu_timers
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t sample the current process CPU clocks if there are no timers.&n;&t; */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|timers
(braket
id|CPUCLOCK_PROF
)braket
)paren
op_logical_and
id|cputime_eq
c_func
(paren
id|sig-&gt;it_prof_expires
comma
id|cputime_zero
)paren
op_logical_and
id|sig-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_cur
op_eq
id|RLIM_INFINITY
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|timers
(braket
id|CPUCLOCK_VIRT
)braket
)paren
op_logical_and
id|cputime_eq
c_func
(paren
id|sig-&gt;it_virt_expires
comma
id|cputime_zero
)paren
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|timers
(braket
id|CPUCLOCK_SCHED
)braket
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Collect the current process totals.&n;&t; */
id|utime
op_assign
id|sig-&gt;utime
suffix:semicolon
id|stime
op_assign
id|sig-&gt;stime
suffix:semicolon
id|sched_time
op_assign
id|sig-&gt;sched_time
suffix:semicolon
id|t
op_assign
id|tsk
suffix:semicolon
r_do
(brace
id|utime
op_assign
id|cputime_add
c_func
(paren
id|utime
comma
id|t-&gt;utime
)paren
suffix:semicolon
id|stime
op_assign
id|cputime_add
c_func
(paren
id|stime
comma
id|t-&gt;stime
)paren
suffix:semicolon
id|sched_time
op_add_assign
id|t-&gt;sched_time
suffix:semicolon
id|t
op_assign
id|next_thread
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|t
op_ne
id|tsk
)paren
suffix:semicolon
id|ptime
op_assign
id|cputime_add
c_func
(paren
id|utime
comma
id|stime
)paren
suffix:semicolon
id|prof_expires
op_assign
id|cputime_zero
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|timers
)paren
)paren
(brace
r_struct
id|cpu_timer_list
op_star
id|t
op_assign
id|list_entry
c_func
(paren
id|timers-&gt;next
comma
r_struct
id|cpu_timer_list
comma
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cputime_lt
c_func
(paren
id|ptime
comma
id|t-&gt;expires.cpu
)paren
)paren
(brace
id|prof_expires
op_assign
id|t-&gt;expires.cpu
suffix:semicolon
r_break
suffix:semicolon
)brace
id|t-&gt;firing
op_assign
l_int|1
suffix:semicolon
id|list_move_tail
c_func
(paren
op_amp
id|t-&gt;entry
comma
id|firing
)paren
suffix:semicolon
)brace
op_increment
id|timers
suffix:semicolon
id|virt_expires
op_assign
id|cputime_zero
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|timers
)paren
)paren
(brace
r_struct
id|cpu_timer_list
op_star
id|t
op_assign
id|list_entry
c_func
(paren
id|timers-&gt;next
comma
r_struct
id|cpu_timer_list
comma
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cputime_lt
c_func
(paren
id|utime
comma
id|t-&gt;expires.cpu
)paren
)paren
(brace
id|virt_expires
op_assign
id|t-&gt;expires.cpu
suffix:semicolon
r_break
suffix:semicolon
)brace
id|t-&gt;firing
op_assign
l_int|1
suffix:semicolon
id|list_move_tail
c_func
(paren
op_amp
id|t-&gt;entry
comma
id|firing
)paren
suffix:semicolon
)brace
op_increment
id|timers
suffix:semicolon
id|sched_expires
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|timers
)paren
)paren
(brace
r_struct
id|cpu_timer_list
op_star
id|t
op_assign
id|list_entry
c_func
(paren
id|timers-&gt;next
comma
r_struct
id|cpu_timer_list
comma
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sched_time
OL
id|t-&gt;expires.sched
)paren
(brace
id|sched_expires
op_assign
id|t-&gt;expires.sched
suffix:semicolon
r_break
suffix:semicolon
)brace
id|t-&gt;firing
op_assign
l_int|1
suffix:semicolon
id|list_move_tail
c_func
(paren
op_amp
id|t-&gt;entry
comma
id|firing
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check for the special case process timers.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cputime_eq
c_func
(paren
id|sig-&gt;it_prof_expires
comma
id|cputime_zero
)paren
)paren
(brace
r_if
c_cond
(paren
id|cputime_ge
c_func
(paren
id|ptime
comma
id|sig-&gt;it_prof_expires
)paren
)paren
(brace
multiline_comment|/* ITIMER_PROF fires and reloads.  */
id|sig-&gt;it_prof_expires
op_assign
id|sig-&gt;it_prof_incr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cputime_eq
c_func
(paren
id|sig-&gt;it_prof_expires
comma
id|cputime_zero
)paren
)paren
(brace
id|sig-&gt;it_prof_expires
op_assign
id|cputime_add
c_func
(paren
id|sig-&gt;it_prof_expires
comma
id|ptime
)paren
suffix:semicolon
)brace
id|__group_send_sig_info
c_func
(paren
id|SIGPROF
comma
id|SEND_SIG_PRIV
comma
id|tsk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cputime_eq
c_func
(paren
id|sig-&gt;it_prof_expires
comma
id|cputime_zero
)paren
op_logical_and
(paren
id|cputime_eq
c_func
(paren
id|prof_expires
comma
id|cputime_zero
)paren
op_logical_or
id|cputime_lt
c_func
(paren
id|sig-&gt;it_prof_expires
comma
id|prof_expires
)paren
)paren
)paren
(brace
id|prof_expires
op_assign
id|sig-&gt;it_prof_expires
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|cputime_eq
c_func
(paren
id|sig-&gt;it_virt_expires
comma
id|cputime_zero
)paren
)paren
(brace
r_if
c_cond
(paren
id|cputime_ge
c_func
(paren
id|utime
comma
id|sig-&gt;it_virt_expires
)paren
)paren
(brace
multiline_comment|/* ITIMER_VIRTUAL fires and reloads.  */
id|sig-&gt;it_virt_expires
op_assign
id|sig-&gt;it_virt_incr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cputime_eq
c_func
(paren
id|sig-&gt;it_virt_expires
comma
id|cputime_zero
)paren
)paren
(brace
id|sig-&gt;it_virt_expires
op_assign
id|cputime_add
c_func
(paren
id|sig-&gt;it_virt_expires
comma
id|utime
)paren
suffix:semicolon
)brace
id|__group_send_sig_info
c_func
(paren
id|SIGVTALRM
comma
id|SEND_SIG_PRIV
comma
id|tsk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cputime_eq
c_func
(paren
id|sig-&gt;it_virt_expires
comma
id|cputime_zero
)paren
op_logical_and
(paren
id|cputime_eq
c_func
(paren
id|virt_expires
comma
id|cputime_zero
)paren
op_logical_or
id|cputime_lt
c_func
(paren
id|sig-&gt;it_virt_expires
comma
id|virt_expires
)paren
)paren
)paren
(brace
id|virt_expires
op_assign
id|sig-&gt;it_virt_expires
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sig-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_cur
op_ne
id|RLIM_INFINITY
)paren
(brace
r_int
r_int
id|psecs
op_assign
id|cputime_to_secs
c_func
(paren
id|ptime
)paren
suffix:semicolon
id|cputime_t
id|x
suffix:semicolon
r_if
c_cond
(paren
id|psecs
op_ge
id|sig-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_max
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * At the hard limit, we just die.&n;&t;&t;&t; * No need to calculate anything else now.&n;&t;&t;&t; */
id|__group_send_sig_info
c_func
(paren
id|SIGKILL
comma
id|SEND_SIG_PRIV
comma
id|tsk
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|psecs
op_ge
id|sig-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_cur
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * At the soft limit, send a SIGXCPU every second.&n;&t;&t;&t; */
id|__group_send_sig_info
c_func
(paren
id|SIGXCPU
comma
id|SEND_SIG_PRIV
comma
id|tsk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sig-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_cur
OL
id|sig-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_max
)paren
(brace
id|sig-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_cur
op_increment
suffix:semicolon
)brace
)brace
id|x
op_assign
id|secs_to_cputime
c_func
(paren
id|sig-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_cur
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cputime_eq
c_func
(paren
id|prof_expires
comma
id|cputime_zero
)paren
op_logical_or
id|cputime_lt
c_func
(paren
id|x
comma
id|prof_expires
)paren
)paren
(brace
id|prof_expires
op_assign
id|x
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|cputime_eq
c_func
(paren
id|prof_expires
comma
id|cputime_zero
)paren
op_logical_or
op_logical_neg
id|cputime_eq
c_func
(paren
id|virt_expires
comma
id|cputime_zero
)paren
op_logical_or
id|sched_expires
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Rebalance the threads&squot; expiry times for the remaining&n;&t;&t; * process CPU timers.&n;&t;&t; */
id|cputime_t
id|prof_left
comma
id|virt_left
comma
id|ticks
suffix:semicolon
r_int
r_int
r_int
id|sched_left
comma
id|sched
suffix:semicolon
r_const
r_int
r_int
id|nthreads
op_assign
id|atomic_read
c_func
(paren
op_amp
id|sig-&gt;live
)paren
suffix:semicolon
id|prof_left
op_assign
id|cputime_sub
c_func
(paren
id|prof_expires
comma
id|utime
)paren
suffix:semicolon
id|prof_left
op_assign
id|cputime_sub
c_func
(paren
id|prof_left
comma
id|stime
)paren
suffix:semicolon
id|prof_left
op_assign
id|cputime_div
c_func
(paren
id|prof_left
comma
id|nthreads
)paren
suffix:semicolon
id|virt_left
op_assign
id|cputime_sub
c_func
(paren
id|virt_expires
comma
id|utime
)paren
suffix:semicolon
id|virt_left
op_assign
id|cputime_div
c_func
(paren
id|virt_left
comma
id|nthreads
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sched_expires
)paren
(brace
id|sched_left
op_assign
id|sched_expires
op_minus
id|sched_time
suffix:semicolon
id|do_div
c_func
(paren
id|sched_left
comma
id|nthreads
)paren
suffix:semicolon
)brace
r_else
(brace
id|sched_left
op_assign
l_int|0
suffix:semicolon
)brace
id|t
op_assign
id|tsk
suffix:semicolon
r_do
(brace
id|ticks
op_assign
id|cputime_add
c_func
(paren
id|cputime_add
c_func
(paren
id|t-&gt;utime
comma
id|t-&gt;stime
)paren
comma
id|prof_left
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cputime_eq
c_func
(paren
id|prof_expires
comma
id|cputime_zero
)paren
op_logical_and
(paren
id|cputime_eq
c_func
(paren
id|t-&gt;it_prof_expires
comma
id|cputime_zero
)paren
op_logical_or
id|cputime_gt
c_func
(paren
id|t-&gt;it_prof_expires
comma
id|ticks
)paren
)paren
)paren
(brace
id|t-&gt;it_prof_expires
op_assign
id|ticks
suffix:semicolon
)brace
id|ticks
op_assign
id|cputime_add
c_func
(paren
id|t-&gt;utime
comma
id|virt_left
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cputime_eq
c_func
(paren
id|virt_expires
comma
id|cputime_zero
)paren
op_logical_and
(paren
id|cputime_eq
c_func
(paren
id|t-&gt;it_virt_expires
comma
id|cputime_zero
)paren
op_logical_or
id|cputime_gt
c_func
(paren
id|t-&gt;it_virt_expires
comma
id|ticks
)paren
)paren
)paren
(brace
id|t-&gt;it_virt_expires
op_assign
id|ticks
suffix:semicolon
)brace
id|sched
op_assign
id|t-&gt;sched_time
op_plus
id|sched_left
suffix:semicolon
r_if
c_cond
(paren
id|sched_expires
op_logical_and
(paren
id|t-&gt;it_sched_expires
op_eq
l_int|0
op_logical_or
id|t-&gt;it_sched_expires
OG
id|sched
)paren
)paren
(brace
id|t-&gt;it_sched_expires
op_assign
id|sched
suffix:semicolon
)brace
r_do
(brace
id|t
op_assign
id|next_thread
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|unlikely
c_func
(paren
id|t-&gt;exit_state
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|t
op_ne
id|tsk
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is called from the signal code (via do_schedule_next_timer)&n; * when the last timer signal was delivered and we have to reload the timer.&n; */
DECL|function|posix_cpu_timer_schedule
r_void
id|posix_cpu_timer_schedule
c_func
(paren
r_struct
id|k_itimer
op_star
id|timer
)paren
(brace
r_struct
id|task_struct
op_star
id|p
op_assign
id|timer-&gt;it.cpu.task
suffix:semicolon
r_union
id|cpu_time_count
id|now
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|p
op_eq
l_int|NULL
)paren
)paren
multiline_comment|/*&n;&t;&t; * The task was cleaned up already, no future firings.&n;&t;&t; */
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Fetch the current sample and update the timer&squot;s expiry time.&n;&t; */
r_if
c_cond
(paren
id|CPUCLOCK_PERTHREAD
c_func
(paren
id|timer-&gt;it_clock
)paren
)paren
(brace
id|cpu_clock_sample
c_func
(paren
id|timer-&gt;it_clock
comma
id|p
comma
op_amp
id|now
)paren
suffix:semicolon
id|bump_cpu_timer
c_func
(paren
id|timer
comma
id|now
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|p-&gt;exit_state
)paren
)paren
(brace
id|clear_dead_task
c_func
(paren
id|timer
comma
id|now
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
multiline_comment|/* arm_timer needs it.  */
)brace
r_else
(brace
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|p-&gt;signal
op_eq
l_int|NULL
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The process has been reaped.&n;&t;&t;&t; * We can&squot;t even collect a sample any more.&n;&t;&t;&t; */
id|put_task_struct
c_func
(paren
id|p
)paren
suffix:semicolon
id|timer-&gt;it.cpu.task
op_assign
id|p
op_assign
l_int|NULL
suffix:semicolon
id|timer-&gt;it.cpu.expires.sched
op_assign
l_int|0
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|p-&gt;exit_state
)paren
op_logical_and
id|thread_group_empty
c_func
(paren
id|p
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We&squot;ve noticed that the thread is dead, but&n;&t;&t;&t; * not yet reaped.  Take this opportunity to&n;&t;&t;&t; * drop our task ref.&n;&t;&t;&t; */
id|clear_dead_task
c_func
(paren
id|timer
comma
id|now
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cpu_clock_sample_group
c_func
(paren
id|timer-&gt;it_clock
comma
id|p
comma
op_amp
id|now
)paren
suffix:semicolon
id|bump_cpu_timer
c_func
(paren
id|timer
comma
id|now
)paren
suffix:semicolon
multiline_comment|/* Leave the tasklist_lock locked for the call below.  */
)brace
multiline_comment|/*&n;&t; * Now re-arm for the new expiry time.&n;&t; */
id|arm_timer
c_func
(paren
id|timer
comma
id|now
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called from the timer interrupt handler.  The irq handler has&n; * already updated our counts.  We need to check if any timers fire now.&n; * Interrupts are disabled.&n; */
DECL|function|run_posix_cpu_timers
r_void
id|run_posix_cpu_timers
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
id|LIST_HEAD
c_func
(paren
id|firing
)paren
suffix:semicolon
r_struct
id|k_itimer
op_star
id|timer
comma
op_star
id|next
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|irqs_disabled
c_func
(paren
)paren
)paren
suffix:semicolon
DECL|macro|UNEXPIRED
mdefine_line|#define UNEXPIRED(clock) &bslash;&n;&t;&t;(cputime_eq(tsk-&gt;it_##clock##_expires, cputime_zero) || &bslash;&n;&t;&t; cputime_lt(clock##_ticks(tsk), tsk-&gt;it_##clock##_expires))
r_if
c_cond
(paren
id|UNEXPIRED
c_func
(paren
id|prof
)paren
op_logical_and
id|UNEXPIRED
c_func
(paren
id|virt
)paren
op_logical_and
(paren
id|tsk-&gt;it_sched_expires
op_eq
l_int|0
op_logical_or
id|tsk-&gt;sched_time
OL
id|tsk-&gt;it_sched_expires
)paren
)paren
r_return
suffix:semicolon
DECL|macro|UNEXPIRED
macro_line|#undef&t;UNEXPIRED
id|BUG_ON
c_func
(paren
id|tsk-&gt;exit_state
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Double-check with locks held.&n;&t; */
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|tsk-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Here we take off tsk-&gt;cpu_timers[N] and tsk-&gt;signal-&gt;cpu_timers[N]&n;&t; * all the timers that are firing, and put them on the firing list.&n;&t; */
id|check_thread_timers
c_func
(paren
id|tsk
comma
op_amp
id|firing
)paren
suffix:semicolon
id|check_process_timers
c_func
(paren
id|tsk
comma
op_amp
id|firing
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We must release these locks before taking any timer&squot;s lock.&n;&t; * There is a potential race with timer deletion here, as the&n;&t; * siglock now protects our private firing list.  We have set&n;&t; * the firing flag in each timer, so that a deletion attempt&n;&t; * that gets the timer lock before we do will give it up and&n;&t; * spin until we&squot;ve taken care of that timer below.&n;&t; */
id|spin_unlock
c_func
(paren
op_amp
id|tsk-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now that all the timers on our list have the firing flag,&n;&t; * noone will touch their list entries but us.  We&squot;ll take&n;&t; * each timer&squot;s lock before clearing its firing flag, so no&n;&t; * timer call will interfere.&n;&t; */
id|list_for_each_entry_safe
c_func
(paren
id|timer
comma
id|next
comma
op_amp
id|firing
comma
id|it.cpu.entry
)paren
(brace
r_int
id|firing
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|timer-&gt;it_lock
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|timer-&gt;it.cpu.entry
)paren
suffix:semicolon
id|firing
op_assign
id|timer-&gt;it.cpu.firing
suffix:semicolon
id|timer-&gt;it.cpu.firing
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The firing flag is -1 if we collided with a reset&n;&t;&t; * of the timer, which already reported this&n;&t;&t; * almost-firing as an overrun.  So don&squot;t generate an event.&n;&t;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|firing
op_ge
l_int|0
)paren
)paren
(brace
id|cpu_timer_fire
c_func
(paren
id|timer
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|timer-&gt;it_lock
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Set one of the process-wide special case CPU timers.&n; * The tasklist_lock and tsk-&gt;sighand-&gt;siglock must be held by the caller.&n; * The oldval argument is null for the RLIMIT_CPU timer, where *newval is&n; * absolute; non-null for ITIMER_*, where *newval is relative and we update&n; * it to be absolute, *oldval is absolute and we update it to be relative.&n; */
DECL|function|set_process_cpu_timer
r_void
id|set_process_cpu_timer
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
r_int
id|clock_idx
comma
id|cputime_t
op_star
id|newval
comma
id|cputime_t
op_star
id|oldval
)paren
(brace
r_union
id|cpu_time_count
id|now
suffix:semicolon
r_struct
id|list_head
op_star
id|head
suffix:semicolon
id|BUG_ON
c_func
(paren
id|clock_idx
op_eq
id|CPUCLOCK_SCHED
)paren
suffix:semicolon
id|cpu_clock_sample_group_locked
c_func
(paren
id|clock_idx
comma
id|tsk
comma
op_amp
id|now
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldval
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cputime_eq
c_func
(paren
op_star
id|oldval
comma
id|cputime_zero
)paren
)paren
(brace
r_if
c_cond
(paren
id|cputime_le
c_func
(paren
op_star
id|oldval
comma
id|now.cpu
)paren
)paren
(brace
multiline_comment|/* Just about to fire. */
op_star
id|oldval
op_assign
id|jiffies_to_cputime
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|oldval
op_assign
id|cputime_sub
c_func
(paren
op_star
id|oldval
comma
id|now.cpu
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cputime_eq
c_func
(paren
op_star
id|newval
comma
id|cputime_zero
)paren
)paren
r_return
suffix:semicolon
op_star
id|newval
op_assign
id|cputime_add
c_func
(paren
op_star
id|newval
comma
id|now.cpu
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the RLIMIT_CPU timer will expire before the&n;&t;&t; * ITIMER_PROF timer, we have nothing else to do.&n;&t;&t; */
r_if
c_cond
(paren
id|tsk-&gt;signal-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_cur
OL
id|cputime_to_secs
c_func
(paren
op_star
id|newval
)paren
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check whether there are any process timers already set to fire&n;&t; * before this one.  If so, we don&squot;t have anything more to do.&n;&t; */
id|head
op_assign
op_amp
id|tsk-&gt;signal-&gt;cpu_timers
(braket
id|clock_idx
)braket
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|head
)paren
op_logical_or
id|cputime_ge
c_func
(paren
id|list_entry
c_func
(paren
id|head-&gt;next
comma
r_struct
id|cpu_timer_list
comma
id|entry
)paren
op_member_access_from_pointer
id|expires.cpu
comma
op_star
id|newval
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Rejigger each thread&squot;s expiry time so that one will&n;&t;&t; * notice before we hit the process-cumulative expiry time.&n;&t;&t; */
r_union
id|cpu_time_count
id|expires
op_assign
(brace
dot
id|sched
op_assign
l_int|0
)brace
suffix:semicolon
id|expires.cpu
op_assign
op_star
id|newval
suffix:semicolon
id|process_timer_rebalance
c_func
(paren
id|tsk
comma
id|clock_idx
comma
id|expires
comma
id|now
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
id|posix_cpu_clock_nanosleep_restart
c_func
(paren
r_struct
id|restart_block
op_star
)paren
suffix:semicolon
DECL|function|posix_cpu_nsleep
r_int
id|posix_cpu_nsleep
c_func
(paren
id|clockid_t
id|which_clock
comma
r_int
id|flags
comma
r_struct
id|timespec
op_star
id|rqtp
)paren
(brace
r_struct
id|restart_block
op_star
id|restart_block
op_assign
op_amp
id|current_thread_info
c_func
(paren
)paren
op_member_access_from_pointer
id|restart_block
suffix:semicolon
r_struct
id|k_itimer
id|timer
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Diagnose required errors first.&n;&t; */
r_if
c_cond
(paren
id|CPUCLOCK_PERTHREAD
c_func
(paren
id|which_clock
)paren
op_logical_and
(paren
id|CPUCLOCK_PID
c_func
(paren
id|which_clock
)paren
op_eq
l_int|0
op_logical_or
id|CPUCLOCK_PID
c_func
(paren
id|which_clock
)paren
op_eq
id|current-&gt;pid
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * Set up a temporary timer and then wait for it to go off.&n;&t; */
id|memset
c_func
(paren
op_amp
id|timer
comma
l_int|0
comma
r_sizeof
id|timer
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|timer.it_lock
)paren
suffix:semicolon
id|timer.it_clock
op_assign
id|which_clock
suffix:semicolon
id|timer.it_overrun
op_assign
op_minus
l_int|1
suffix:semicolon
id|error
op_assign
id|posix_cpu_timer_create
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|timer.it_process
op_assign
id|current
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_struct
id|timespec
id|__user
op_star
id|rmtp
suffix:semicolon
r_static
r_struct
id|itimerspec
id|zero_it
suffix:semicolon
r_struct
id|itimerspec
id|it
op_assign
(brace
dot
id|it_value
op_assign
op_star
id|rqtp
comma
dot
id|it_interval
op_assign
(brace
)brace
)brace
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|timer.it_lock
)paren
suffix:semicolon
id|error
op_assign
id|posix_cpu_timer_set
c_func
(paren
op_amp
id|timer
comma
id|flags
comma
op_amp
id|it
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|timer.it_lock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_if
c_cond
(paren
id|timer.it.cpu.expires.sched
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Our timer fired and was reset.&n;&t;&t;&t;&t; */
id|spin_unlock_irq
c_func
(paren
op_amp
id|timer.it_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Block until cpu_timer_fire (or a signal) wakes us.&n;&t;&t;&t; */
id|__set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|timer.it_lock
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|timer.it_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We were interrupted by a signal.&n;&t;&t; */
id|sample_to_timespec
c_func
(paren
id|which_clock
comma
id|timer.it.cpu.expires
comma
id|rqtp
)paren
suffix:semicolon
id|posix_cpu_timer_set
c_func
(paren
op_amp
id|timer
comma
l_int|0
comma
op_amp
id|zero_it
comma
op_amp
id|it
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|timer.it_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|it.it_value.tv_sec
op_or
id|it.it_value.tv_nsec
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * It actually did fire already.&n;&t;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Report back to the user the time still remaining.&n;&t;&t; */
id|rmtp
op_assign
(paren
r_struct
id|timespec
id|__user
op_star
)paren
id|restart_block-&gt;arg1
suffix:semicolon
r_if
c_cond
(paren
id|rmtp
op_ne
l_int|NULL
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|TIMER_ABSTIME
)paren
op_logical_and
id|copy_to_user
c_func
(paren
id|rmtp
comma
op_amp
id|it.it_value
comma
r_sizeof
op_star
id|rmtp
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|restart_block-&gt;fn
op_assign
id|posix_cpu_clock_nanosleep_restart
suffix:semicolon
multiline_comment|/* Caller already set restart_block-&gt;arg1 */
id|restart_block-&gt;arg0
op_assign
id|which_clock
suffix:semicolon
id|restart_block-&gt;arg2
op_assign
id|rqtp-&gt;tv_sec
suffix:semicolon
id|restart_block-&gt;arg3
op_assign
id|rqtp-&gt;tv_nsec
suffix:semicolon
id|error
op_assign
op_minus
id|ERESTART_RESTARTBLOCK
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
r_static
r_int
DECL|function|posix_cpu_clock_nanosleep_restart
id|posix_cpu_clock_nanosleep_restart
c_func
(paren
r_struct
id|restart_block
op_star
id|restart_block
)paren
(brace
id|clockid_t
id|which_clock
op_assign
id|restart_block-&gt;arg0
suffix:semicolon
r_struct
id|timespec
id|t
op_assign
(brace
dot
id|tv_sec
op_assign
id|restart_block-&gt;arg2
comma
dot
id|tv_nsec
op_assign
id|restart_block-&gt;arg3
)brace
suffix:semicolon
id|restart_block-&gt;fn
op_assign
id|do_no_restart_syscall
suffix:semicolon
r_return
id|posix_cpu_nsleep
c_func
(paren
id|which_clock
comma
id|TIMER_ABSTIME
comma
op_amp
id|t
)paren
suffix:semicolon
)brace
DECL|macro|PROCESS_CLOCK
mdefine_line|#define PROCESS_CLOCK&t;MAKE_PROCESS_CPUCLOCK(0, CPUCLOCK_SCHED)
DECL|macro|THREAD_CLOCK
mdefine_line|#define THREAD_CLOCK&t;MAKE_THREAD_CPUCLOCK(0, CPUCLOCK_SCHED)
DECL|function|process_cpu_clock_getres
r_static
r_int
id|process_cpu_clock_getres
c_func
(paren
id|clockid_t
id|which_clock
comma
r_struct
id|timespec
op_star
id|tp
)paren
(brace
r_return
id|posix_cpu_clock_getres
c_func
(paren
id|PROCESS_CLOCK
comma
id|tp
)paren
suffix:semicolon
)brace
DECL|function|process_cpu_clock_get
r_static
r_int
id|process_cpu_clock_get
c_func
(paren
id|clockid_t
id|which_clock
comma
r_struct
id|timespec
op_star
id|tp
)paren
(brace
r_return
id|posix_cpu_clock_get
c_func
(paren
id|PROCESS_CLOCK
comma
id|tp
)paren
suffix:semicolon
)brace
DECL|function|process_cpu_timer_create
r_static
r_int
id|process_cpu_timer_create
c_func
(paren
r_struct
id|k_itimer
op_star
id|timer
)paren
(brace
id|timer-&gt;it_clock
op_assign
id|PROCESS_CLOCK
suffix:semicolon
r_return
id|posix_cpu_timer_create
c_func
(paren
id|timer
)paren
suffix:semicolon
)brace
DECL|function|process_cpu_nsleep
r_static
r_int
id|process_cpu_nsleep
c_func
(paren
id|clockid_t
id|which_clock
comma
r_int
id|flags
comma
r_struct
id|timespec
op_star
id|rqtp
)paren
(brace
r_return
id|posix_cpu_nsleep
c_func
(paren
id|PROCESS_CLOCK
comma
id|flags
comma
id|rqtp
)paren
suffix:semicolon
)brace
DECL|function|thread_cpu_clock_getres
r_static
r_int
id|thread_cpu_clock_getres
c_func
(paren
id|clockid_t
id|which_clock
comma
r_struct
id|timespec
op_star
id|tp
)paren
(brace
r_return
id|posix_cpu_clock_getres
c_func
(paren
id|THREAD_CLOCK
comma
id|tp
)paren
suffix:semicolon
)brace
DECL|function|thread_cpu_clock_get
r_static
r_int
id|thread_cpu_clock_get
c_func
(paren
id|clockid_t
id|which_clock
comma
r_struct
id|timespec
op_star
id|tp
)paren
(brace
r_return
id|posix_cpu_clock_get
c_func
(paren
id|THREAD_CLOCK
comma
id|tp
)paren
suffix:semicolon
)brace
DECL|function|thread_cpu_timer_create
r_static
r_int
id|thread_cpu_timer_create
c_func
(paren
r_struct
id|k_itimer
op_star
id|timer
)paren
(brace
id|timer-&gt;it_clock
op_assign
id|THREAD_CLOCK
suffix:semicolon
r_return
id|posix_cpu_timer_create
c_func
(paren
id|timer
)paren
suffix:semicolon
)brace
DECL|function|thread_cpu_nsleep
r_static
r_int
id|thread_cpu_nsleep
c_func
(paren
id|clockid_t
id|which_clock
comma
r_int
id|flags
comma
r_struct
id|timespec
op_star
id|rqtp
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|init_posix_cpu_timers
r_static
id|__init
r_int
id|init_posix_cpu_timers
c_func
(paren
r_void
)paren
(brace
r_struct
id|k_clock
id|process
op_assign
(brace
dot
id|clock_getres
op_assign
id|process_cpu_clock_getres
comma
dot
id|clock_get
op_assign
id|process_cpu_clock_get
comma
dot
id|clock_set
op_assign
id|do_posix_clock_nosettime
comma
dot
id|timer_create
op_assign
id|process_cpu_timer_create
comma
dot
id|nsleep
op_assign
id|process_cpu_nsleep
comma
)brace
suffix:semicolon
r_struct
id|k_clock
id|thread
op_assign
(brace
dot
id|clock_getres
op_assign
id|thread_cpu_clock_getres
comma
dot
id|clock_get
op_assign
id|thread_cpu_clock_get
comma
dot
id|clock_set
op_assign
id|do_posix_clock_nosettime
comma
dot
id|timer_create
op_assign
id|thread_cpu_timer_create
comma
dot
id|nsleep
op_assign
id|thread_cpu_nsleep
comma
)brace
suffix:semicolon
id|register_posix_clock
c_func
(paren
id|CLOCK_PROCESS_CPUTIME_ID
comma
op_amp
id|process
)paren
suffix:semicolon
id|register_posix_clock
c_func
(paren
id|CLOCK_THREAD_CPUTIME_ID
comma
op_amp
id|thread
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|init_posix_cpu_timers
id|__initcall
c_func
(paren
id|init_posix_cpu_timers
)paren
suffix:semicolon
eof
