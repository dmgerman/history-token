multiline_comment|/*&n; * linux/kernel/irq/handle.c&n; *&n; * Copyright (C) 1992, 1998-2004 Linus Torvalds, Ingo Molnar&n; *&n; * This file contains the core interrupt handling code.&n; */
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &quot;internals.h&quot;
multiline_comment|/*&n; * Linux has a controller-independent interrupt architecture.&n; * Every controller has a &squot;controller-template&squot;, that is used&n; * by the main code to do the right thing. Each driver-visible&n; * interrupt source is transparently wired to the apropriate&n; * controller. Thus drivers need not be aware of the&n; * interrupt-controller.&n; *&n; * The code is designed to be easily extended with new/different&n; * interrupt controllers, without having to do assembly magic or&n; * having to touch the generic code.&n; *&n; * Controller mappings for all interrupt sources:&n; */
DECL|variable|__cacheline_aligned
id|irq_desc_t
id|irq_desc
(braket
id|NR_IRQS
)braket
id|__cacheline_aligned
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|NR_IRQS
op_minus
l_int|1
)braket
op_assign
(brace
dot
id|handler
op_assign
op_amp
id|no_irq_type
comma
dot
id|lock
op_assign
id|SPIN_LOCK_UNLOCKED
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * Generic &squot;no controller&squot; code&n; */
DECL|function|end_none
r_static
r_void
id|end_none
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
)brace
DECL|function|enable_none
r_static
r_void
id|enable_none
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
)brace
DECL|function|disable_none
r_static
r_void
id|disable_none
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
)brace
DECL|function|shutdown_none
r_static
r_void
id|shutdown_none
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
)brace
DECL|function|startup_none
r_static
r_int
r_int
id|startup_none
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ack_none
r_static
r_void
id|ack_none
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
multiline_comment|/*&n;&t; * &squot;what should we do if we get a hw irq event on an illegal vector&squot;.&n;&t; * each architecture has to answer this themself.&n;&t; */
id|ack_bad_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|variable|no_irq_type
r_struct
id|hw_interrupt_type
id|no_irq_type
op_assign
(brace
r_typename
suffix:colon
l_string|&quot;none&quot;
comma
id|startup
suffix:colon
id|startup_none
comma
id|shutdown
suffix:colon
id|shutdown_none
comma
id|enable
suffix:colon
id|enable_none
comma
id|disable
suffix:colon
id|disable_none
comma
id|ack
suffix:colon
id|ack_none
comma
id|end
suffix:colon
id|end_none
comma
id|set_affinity
suffix:colon
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n; * Special, empty irq handler:&n; */
DECL|function|no_action
id|irqreturn_t
id|no_action
c_func
(paren
r_int
id|cpl
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_return
id|IRQ_NONE
suffix:semicolon
)brace
multiline_comment|/*&n; * Exit an interrupt context. Process softirqs if needed and possible:&n; */
DECL|function|irq_exit
r_void
id|irq_exit
c_func
(paren
r_void
)paren
(brace
id|preempt_count
c_func
(paren
)paren
op_sub_assign
id|IRQ_EXIT_OFFSET
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in_interrupt
c_func
(paren
)paren
op_logical_and
id|local_softirq_pending
c_func
(paren
)paren
)paren
id|do_softirq
c_func
(paren
)paren
suffix:semicolon
id|preempt_enable_no_resched
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Have got an event to handle:&n; */
DECL|function|handle_IRQ_event
id|asmlinkage
r_int
id|handle_IRQ_event
c_func
(paren
r_int
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|irqaction
op_star
id|action
)paren
(brace
r_int
id|ret
comma
id|retval
op_assign
l_int|0
comma
id|status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|action-&gt;flags
op_amp
id|SA_INTERRUPT
)paren
)paren
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
id|ret
op_assign
id|action
op_member_access_from_pointer
id|handler
c_func
(paren
id|irq
comma
id|action-&gt;dev_id
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|IRQ_HANDLED
)paren
id|status
op_or_assign
id|action-&gt;flags
suffix:semicolon
id|retval
op_or_assign
id|ret
suffix:semicolon
id|action
op_assign
id|action-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|action
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|SA_SAMPLE_RANDOM
)paren
id|add_interrupt_randomness
c_func
(paren
id|irq
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * do_IRQ handles all normal device IRQ&squot;s (the special&n; * SMP cross-CPU interrupts have their own specific&n; * handlers).&n; */
DECL|function|__do_IRQ
id|asmlinkage
r_int
r_int
id|__do_IRQ
c_func
(paren
r_int
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|irq_desc_t
op_star
id|desc
op_assign
id|irq_desc
op_plus
id|irq
suffix:semicolon
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_int
r_int
id|status
suffix:semicolon
id|kstat_this_cpu.irqs
(braket
id|irq
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|desc-&gt;status
op_amp
id|IRQ_PER_CPU
)paren
(brace
id|irqreturn_t
id|action_ret
suffix:semicolon
multiline_comment|/*&n;&t;&t; * No locking required for CPU-local interrupts:&n;&t;&t; */
id|desc-&gt;handler
op_member_access_from_pointer
id|ack
c_func
(paren
id|irq
)paren
suffix:semicolon
id|action_ret
op_assign
id|handle_IRQ_event
c_func
(paren
id|irq
comma
id|regs
comma
id|desc-&gt;action
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|noirqdebug
)paren
id|note_interrupt
c_func
(paren
id|irq
comma
id|desc
comma
id|action_ret
)paren
suffix:semicolon
id|desc-&gt;handler
op_member_access_from_pointer
id|end
c_func
(paren
id|irq
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|desc-&gt;lock
)paren
suffix:semicolon
id|desc-&gt;handler
op_member_access_from_pointer
id|ack
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * REPLAY is when Linux resends an IRQ that was dropped earlier&n;&t; * WAITING is used by probe to mark irqs that are being tested&n;&t; */
id|status
op_assign
id|desc-&gt;status
op_amp
op_complement
(paren
id|IRQ_REPLAY
op_or
id|IRQ_WAITING
)paren
suffix:semicolon
id|status
op_or_assign
id|IRQ_PENDING
suffix:semicolon
multiline_comment|/* we _want_ to handle it */
multiline_comment|/*&n;&t; * If the IRQ is disabled for whatever reason, we cannot&n;&t; * use the action we have.&n;&t; */
id|action
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
(paren
id|status
op_amp
(paren
id|IRQ_DISABLED
op_or
id|IRQ_INPROGRESS
)paren
)paren
)paren
)paren
(brace
id|action
op_assign
id|desc-&gt;action
suffix:semicolon
id|status
op_and_assign
op_complement
id|IRQ_PENDING
suffix:semicolon
multiline_comment|/* we commit to handling */
id|status
op_or_assign
id|IRQ_INPROGRESS
suffix:semicolon
multiline_comment|/* we are handling it */
)brace
id|desc-&gt;status
op_assign
id|status
suffix:semicolon
multiline_comment|/*&n;&t; * If there is no IRQ handler or it was disabled, exit early.&n;&t; * Since we set PENDING, if another processor is handling&n;&t; * a different instance of this same irq, the other processor&n;&t; * will take care of it.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|action
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Edge triggered interrupts need to remember&n;&t; * pending events.&n;&t; * This applies to any hw interrupts that allow a second&n;&t; * instance of the same irq to arrive while we are in do_IRQ&n;&t; * or in the handler. But the code here only handles the _second_&n;&t; * instance of the irq, not the third or fourth. So it is mostly&n;&t; * useful for irq hardware that does not mask cleanly in an&n;&t; * SMP environment.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|irqreturn_t
id|action_ret
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|desc-&gt;lock
)paren
suffix:semicolon
id|action_ret
op_assign
id|handle_IRQ_event
c_func
(paren
id|irq
comma
id|regs
comma
id|action
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|desc-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|noirqdebug
)paren
id|note_interrupt
c_func
(paren
id|irq
comma
id|desc
comma
id|action_ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
(paren
id|desc-&gt;status
op_amp
id|IRQ_PENDING
)paren
)paren
)paren
r_break
suffix:semicolon
id|desc-&gt;status
op_and_assign
op_complement
id|IRQ_PENDING
suffix:semicolon
)brace
id|desc-&gt;status
op_and_assign
op_complement
id|IRQ_INPROGRESS
suffix:semicolon
id|out
suffix:colon
multiline_comment|/*&n;&t; * The -&gt;end() handler has to deal with interrupts which got&n;&t; * disabled while the handler was running.&n;&t; */
id|desc-&gt;handler
op_member_access_from_pointer
id|end
c_func
(paren
id|irq
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|desc-&gt;lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
eof
