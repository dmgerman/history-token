multiline_comment|/*&n; *  linux/kernel/fork.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
multiline_comment|/*&n; *  &squot;fork.c&squot; contains the help-routines for the &squot;fork&squot; system call&n; * (see also entry.S and others).&n; * Fork is rather simple, once you get the hang of it, but the memory&n; * management can be a bitch. See &squot;mm/memory.c&squot;: &squot;copy_page_range()&squot;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/namespace.h&gt;
macro_line|#include &lt;linux/personality.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/binfmts.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/security.h&gt;
macro_line|#include &lt;linux/jiffies.h&gt;
macro_line|#include &lt;linux/futex.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/mount.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/cacheflush.h&gt;
macro_line|#include &lt;asm/tlbflush.h&gt;
r_extern
r_int
id|copy_semundo
c_func
(paren
r_int
r_int
id|clone_flags
comma
r_struct
id|task_struct
op_star
id|tsk
)paren
suffix:semicolon
r_extern
r_void
id|exit_sem
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
suffix:semicolon
multiline_comment|/* The idle threads do not count..&n; * Protected by write_lock_irq(&amp;tasklist_lock)&n; */
DECL|variable|nr_threads
r_int
id|nr_threads
suffix:semicolon
DECL|variable|max_threads
r_int
id|max_threads
suffix:semicolon
DECL|variable|total_forks
r_int
r_int
id|total_forks
suffix:semicolon
multiline_comment|/* Handle normal Linux uptimes. */
id|DEFINE_PER_CPU
c_func
(paren
r_int
r_int
comma
id|process_counts
)paren
op_assign
l_int|0
suffix:semicolon
DECL|variable|__cacheline_aligned
id|rwlock_t
id|tasklist_lock
id|__cacheline_aligned
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* outer */
DECL|function|nr_processes
r_int
id|nr_processes
c_func
(paren
r_void
)paren
(brace
r_int
id|cpu
suffix:semicolon
r_int
id|total
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|cpu
op_assign
l_int|0
suffix:semicolon
id|cpu
OL
id|NR_CPUS
suffix:semicolon
id|cpu
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_online
c_func
(paren
id|cpu
)paren
)paren
id|total
op_add_assign
id|per_cpu
c_func
(paren
id|process_counts
comma
id|cpu
)paren
suffix:semicolon
)brace
r_return
id|total
suffix:semicolon
)brace
macro_line|#ifndef __HAVE_ARCH_TASK_STRUCT_ALLOCATOR
DECL|macro|alloc_task_struct
macro_line|# define alloc_task_struct()&t;kmem_cache_alloc(task_struct_cachep, GFP_KERNEL)
DECL|macro|free_task_struct
macro_line|# define free_task_struct(tsk)&t;kmem_cache_free(task_struct_cachep, (tsk))
DECL|variable|task_struct_cachep
r_static
id|kmem_cache_t
op_star
id|task_struct_cachep
suffix:semicolon
macro_line|#endif
DECL|function|free_task
r_static
r_void
id|free_task
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
id|free_thread_info
c_func
(paren
id|tsk-&gt;thread_info
)paren
suffix:semicolon
id|free_task_struct
c_func
(paren
id|tsk
)paren
suffix:semicolon
)brace
DECL|function|__put_task_struct
r_void
id|__put_task_struct
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
id|WARN_ON
c_func
(paren
op_logical_neg
(paren
id|tsk-&gt;state
op_amp
(paren
id|TASK_DEAD
op_or
id|TASK_ZOMBIE
)paren
)paren
)paren
suffix:semicolon
id|WARN_ON
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|tsk-&gt;usage
)paren
)paren
suffix:semicolon
id|WARN_ON
c_func
(paren
id|tsk
op_eq
id|current
)paren
suffix:semicolon
id|security_task_free
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|free_uid
c_func
(paren
id|tsk-&gt;user
)paren
suffix:semicolon
id|free_task
c_func
(paren
id|tsk
)paren
suffix:semicolon
)brace
DECL|function|add_wait_queue
r_void
id|add_wait_queue
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
id|wait_queue_t
op_star
id|wait
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|wait-&gt;flags
op_and_assign
op_complement
id|WQ_FLAG_EXCLUSIVE
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__add_wait_queue
c_func
(paren
id|q
comma
id|wait
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|add_wait_queue_exclusive
r_void
id|add_wait_queue_exclusive
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
id|wait_queue_t
op_star
id|wait
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|wait-&gt;flags
op_or_assign
id|WQ_FLAG_EXCLUSIVE
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__add_wait_queue_tail
c_func
(paren
id|q
comma
id|wait
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|remove_wait_queue
r_void
id|remove_wait_queue
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
id|wait_queue_t
op_star
id|wait
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__remove_wait_queue
c_func
(paren
id|q
comma
id|wait
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|prepare_to_wait
r_void
id|prepare_to_wait
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
id|wait_queue_t
op_star
id|wait
comma
r_int
id|state
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__set_current_state
c_func
(paren
id|state
)paren
suffix:semicolon
id|wait-&gt;flags
op_and_assign
op_complement
id|WQ_FLAG_EXCLUSIVE
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|wait-&gt;task_list
)paren
)paren
id|__add_wait_queue
c_func
(paren
id|q
comma
id|wait
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_void
DECL|function|prepare_to_wait_exclusive
id|prepare_to_wait_exclusive
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
id|wait_queue_t
op_star
id|wait
comma
r_int
id|state
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__set_current_state
c_func
(paren
id|state
)paren
suffix:semicolon
id|wait-&gt;flags
op_or_assign
id|WQ_FLAG_EXCLUSIVE
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|wait-&gt;task_list
)paren
)paren
id|__add_wait_queue_tail
c_func
(paren
id|q
comma
id|wait
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|finish_wait
r_void
id|finish_wait
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
id|wait_queue_t
op_star
id|wait
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|wait-&gt;task_list
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|wait-&gt;task_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|function|autoremove_wake_function
r_int
id|autoremove_wake_function
c_func
(paren
id|wait_queue_t
op_star
id|wait
comma
r_int
id|mode
comma
r_int
id|sync
)paren
(brace
r_int
id|ret
op_assign
id|default_wake_function
c_func
(paren
id|wait
comma
id|mode
comma
id|sync
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|list_del_init
c_func
(paren
op_amp
id|wait-&gt;task_list
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|fork_init
r_void
id|__init
id|fork_init
c_func
(paren
r_int
r_int
id|mempages
)paren
(brace
macro_line|#ifndef __HAVE_ARCH_TASK_STRUCT_ALLOCATOR
multiline_comment|/* create a slab on which task_structs can be allocated */
id|task_struct_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;task_struct&quot;
comma
r_sizeof
(paren
r_struct
id|task_struct
)paren
comma
l_int|0
comma
id|SLAB_MUST_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|task_struct_cachep
)paren
id|panic
c_func
(paren
l_string|&quot;fork_init(): cannot create task_struct SLAB cache&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * The default maximum number of threads is set to a safe&n;&t; * value: the thread structures can take up at most half&n;&t; * of memory.&n;&t; */
id|max_threads
op_assign
id|mempages
op_div
(paren
id|THREAD_SIZE
op_div
id|PAGE_SIZE
)paren
op_div
l_int|8
suffix:semicolon
multiline_comment|/*&n;&t; * we need to allow at least 20 threads to boot a system&n;&t; */
r_if
c_cond
(paren
id|max_threads
OL
l_int|20
)paren
(brace
id|max_threads
op_assign
l_int|20
suffix:semicolon
)brace
id|init_task.rlim
(braket
id|RLIMIT_NPROC
)braket
dot
id|rlim_cur
op_assign
id|max_threads
op_div
l_int|2
suffix:semicolon
id|init_task.rlim
(braket
id|RLIMIT_NPROC
)braket
dot
id|rlim_max
op_assign
id|max_threads
op_div
l_int|2
suffix:semicolon
)brace
DECL|function|dup_task_struct
r_static
r_struct
id|task_struct
op_star
id|dup_task_struct
c_func
(paren
r_struct
id|task_struct
op_star
id|orig
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
suffix:semicolon
r_struct
id|thread_info
op_star
id|ti
suffix:semicolon
id|prepare_to_copy
c_func
(paren
id|orig
)paren
suffix:semicolon
id|tsk
op_assign
id|alloc_task_struct
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tsk
)paren
r_return
l_int|NULL
suffix:semicolon
id|ti
op_assign
id|alloc_thread_info
c_func
(paren
id|tsk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ti
)paren
(brace
id|free_task_struct
c_func
(paren
id|tsk
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
op_star
id|ti
op_assign
op_star
id|orig-&gt;thread_info
suffix:semicolon
op_star
id|tsk
op_assign
op_star
id|orig
suffix:semicolon
id|tsk-&gt;thread_info
op_assign
id|ti
suffix:semicolon
id|ti-&gt;task
op_assign
id|tsk
suffix:semicolon
multiline_comment|/* One for us, one for whoever does the &quot;release_task()&quot; (usually parent) */
id|atomic_set
c_func
(paren
op_amp
id|tsk-&gt;usage
comma
l_int|2
)paren
suffix:semicolon
r_return
id|tsk
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MMU
DECL|function|dup_mmap
r_static
r_inline
r_int
id|dup_mmap
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|mm_struct
op_star
id|oldmm
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|mpnt
comma
op_star
id|tmp
comma
op_star
op_star
id|pprev
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
r_int
id|charge
op_assign
l_int|0
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|oldmm-&gt;mmap_sem
)paren
suffix:semicolon
id|flush_cache_mm
c_func
(paren
id|current-&gt;mm
)paren
suffix:semicolon
id|mm-&gt;locked_vm
op_assign
l_int|0
suffix:semicolon
id|mm-&gt;mmap
op_assign
l_int|NULL
suffix:semicolon
id|mm-&gt;mmap_cache
op_assign
l_int|NULL
suffix:semicolon
id|mm-&gt;free_area_cache
op_assign
id|TASK_UNMAPPED_BASE
suffix:semicolon
id|mm-&gt;map_count
op_assign
l_int|0
suffix:semicolon
id|mm-&gt;rss
op_assign
l_int|0
suffix:semicolon
id|mm-&gt;cpu_vm_mask
op_assign
l_int|0
suffix:semicolon
id|pprev
op_assign
op_amp
id|mm-&gt;mmap
suffix:semicolon
multiline_comment|/*&n;&t; * Add it to the mmlist after the parent.&n;&t; * Doing it this way means that we can order the list,&n;&t; * and fork() won&squot;t mess up the ordering significantly.&n;&t; * Add it first so that swapoff can see any swap entries.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|mmlist_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|mm-&gt;mmlist
comma
op_amp
id|current-&gt;mm-&gt;mmlist
)paren
suffix:semicolon
id|mmlist_nr
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mmlist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mpnt
op_assign
id|current-&gt;mm-&gt;mmap
suffix:semicolon
id|mpnt
suffix:semicolon
id|mpnt
op_assign
id|mpnt-&gt;vm_next
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
r_if
c_cond
(paren
id|mpnt-&gt;vm_flags
op_amp
id|VM_DONTCOPY
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mpnt-&gt;vm_flags
op_amp
id|VM_ACCOUNT
)paren
(brace
r_int
r_int
id|len
op_assign
(paren
id|mpnt-&gt;vm_end
op_minus
id|mpnt-&gt;vm_start
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|security_vm_enough_memory
c_func
(paren
id|len
)paren
)paren
r_goto
id|fail_nomem
suffix:semicolon
id|charge
op_add_assign
id|len
suffix:semicolon
)brace
id|tmp
op_assign
id|kmem_cache_alloc
c_func
(paren
id|vm_area_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
r_goto
id|fail_nomem
suffix:semicolon
op_star
id|tmp
op_assign
op_star
id|mpnt
suffix:semicolon
id|tmp-&gt;vm_flags
op_and_assign
op_complement
id|VM_LOCKED
suffix:semicolon
id|tmp-&gt;vm_mm
op_assign
id|mm
suffix:semicolon
id|tmp-&gt;vm_next
op_assign
l_int|NULL
suffix:semicolon
id|file
op_assign
id|tmp-&gt;vm_file
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|tmp-&gt;shared
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|get_file
c_func
(paren
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;vm_flags
op_amp
id|VM_DENYWRITE
)paren
id|atomic_dec
c_func
(paren
op_amp
id|inode-&gt;i_writecount
)paren
suffix:semicolon
multiline_comment|/* insert tmp into the share list, just after mpnt */
id|down
c_func
(paren
op_amp
id|inode-&gt;i_mapping-&gt;i_shared_sem
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|tmp-&gt;shared
comma
op_amp
id|mpnt-&gt;shared
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_mapping-&gt;i_shared_sem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Link in the new vma and copy the page table entries:&n;&t;&t; * link in first so that swapoff can see swap entries.&n;&t;&t; */
id|spin_lock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
op_star
id|pprev
op_assign
id|tmp
suffix:semicolon
id|pprev
op_assign
op_amp
id|tmp-&gt;vm_next
suffix:semicolon
id|mm-&gt;map_count
op_increment
suffix:semicolon
id|retval
op_assign
id|copy_page_range
c_func
(paren
id|mm
comma
id|current-&gt;mm
comma
id|tmp
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mm-&gt;page_table_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;vm_ops
op_logical_and
id|tmp-&gt;vm_ops-&gt;open
)paren
id|tmp-&gt;vm_ops
op_member_access_from_pointer
id|open
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|fail
suffix:semicolon
)brace
id|retval
op_assign
l_int|0
suffix:semicolon
id|build_mmap_rb
c_func
(paren
id|mm
)paren
suffix:semicolon
id|out
suffix:colon
id|flush_tlb_mm
c_func
(paren
id|current-&gt;mm
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|oldmm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
id|fail_nomem
suffix:colon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|fail
suffix:colon
id|vm_unacct_memory
c_func
(paren
id|charge
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|function|mm_alloc_pgd
r_static
r_inline
r_int
id|mm_alloc_pgd
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
id|mm-&gt;pgd
op_assign
id|pgd_alloc
c_func
(paren
id|mm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|mm-&gt;pgd
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mm_free_pgd
r_static
r_inline
r_void
id|mm_free_pgd
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
id|pgd_free
c_func
(paren
id|mm-&gt;pgd
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|dup_mmap
mdefine_line|#define dup_mmap(mm, oldmm)&t;(0)
DECL|macro|mm_alloc_pgd
mdefine_line|#define mm_alloc_pgd(mm)&t;(0)
DECL|macro|mm_free_pgd
mdefine_line|#define mm_free_pgd(mm)
macro_line|#endif /* CONFIG_MMU */
DECL|variable|__cacheline_aligned_in_smp
id|spinlock_t
id|mmlist_lock
id|__cacheline_aligned_in_smp
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|mmlist_nr
r_int
id|mmlist_nr
suffix:semicolon
DECL|macro|allocate_mm
mdefine_line|#define allocate_mm()&t;(kmem_cache_alloc(mm_cachep, SLAB_KERNEL))
DECL|macro|free_mm
mdefine_line|#define free_mm(mm)&t;(kmem_cache_free(mm_cachep, (mm)))
macro_line|#include &lt;linux/init_task.h&gt;
DECL|function|mm_init
r_static
r_struct
id|mm_struct
op_star
id|mm_init
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|mm-&gt;mm_users
comma
l_int|1
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|mm-&gt;mm_count
comma
l_int|1
)paren
suffix:semicolon
id|init_rwsem
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|mm-&gt;core_waiters
op_assign
l_int|0
suffix:semicolon
id|mm-&gt;page_table_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|mm-&gt;ioctx_list_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
id|mm-&gt;ioctx_list
op_assign
l_int|NULL
suffix:semicolon
id|mm-&gt;default_kioctx
op_assign
(paren
r_struct
id|kioctx
)paren
id|INIT_KIOCTX
c_func
(paren
id|mm-&gt;default_kioctx
comma
op_star
id|mm
)paren
suffix:semicolon
id|mm-&gt;free_area_cache
op_assign
id|TASK_UNMAPPED_BASE
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|mm_alloc_pgd
c_func
(paren
id|mm
)paren
)paren
)paren
(brace
id|mm-&gt;def_flags
op_assign
l_int|0
suffix:semicolon
r_return
id|mm
suffix:semicolon
)brace
id|free_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate and initialize an mm_struct.&n; */
DECL|function|mm_alloc
r_struct
id|mm_struct
op_star
id|mm_alloc
c_func
(paren
r_void
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
suffix:semicolon
id|mm
op_assign
id|allocate_mm
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mm
)paren
(brace
id|memset
c_func
(paren
id|mm
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|mm
)paren
)paren
suffix:semicolon
r_return
id|mm_init
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Called when the last reference to the mm&n; * is dropped: either by a lazy thread or by&n; * mmput. Free the page directory and the mm.&n; */
DECL|function|__mmdrop
r_inline
r_void
id|__mmdrop
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
id|BUG_ON
c_func
(paren
id|mm
op_eq
op_amp
id|init_mm
)paren
suffix:semicolon
id|mm_free_pgd
c_func
(paren
id|mm
)paren
suffix:semicolon
id|destroy_context
c_func
(paren
id|mm
)paren
suffix:semicolon
id|free_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Decrement the use count and release all resources for an mm.&n; */
DECL|function|mmput
r_void
id|mmput
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_lock
c_func
(paren
op_amp
id|mm-&gt;mm_users
comma
op_amp
id|mmlist_lock
)paren
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|mm-&gt;mmlist
)paren
suffix:semicolon
id|mmlist_nr
op_decrement
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mmlist_lock
)paren
suffix:semicolon
id|exit_aio
c_func
(paren
id|mm
)paren
suffix:semicolon
id|exit_mmap
c_func
(paren
id|mm
)paren
suffix:semicolon
id|mmdrop
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Please note the differences between mmput and mm_release.&n; * mmput is called whenever we stop holding onto a mm_struct,&n; * error success whatever.&n; *&n; * mm_release is called after a mm_struct has been removed&n; * from the current process.&n; *&n; * This difference is important for error handling, when we&n; * only half set up a mm_struct for a new process and need to restore&n; * the old one.  Because we mmput the new mm_struct before&n; * restoring the old one. . .&n; * Eric Biederman 10 January 1998&n; */
DECL|function|mm_release
r_void
id|mm_release
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|completion
op_star
id|vfork_done
op_assign
id|tsk-&gt;vfork_done
suffix:semicolon
multiline_comment|/* Get rid of any cached register state */
id|deactivate_mm
c_func
(paren
id|tsk
comma
id|mm
)paren
suffix:semicolon
multiline_comment|/* notify parent sleeping on vfork() */
r_if
c_cond
(paren
id|vfork_done
)paren
(brace
id|tsk-&gt;vfork_done
op_assign
l_int|NULL
suffix:semicolon
id|complete
c_func
(paren
id|vfork_done
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tsk-&gt;clear_child_tid
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
OG
l_int|1
)paren
(brace
id|u32
id|__user
op_star
id|tidptr
op_assign
id|tsk-&gt;clear_child_tid
suffix:semicolon
id|tsk-&gt;clear_child_tid
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We don&squot;t check the error code - if userspace has&n;&t;&t; * not set up a proper pointer then tough luck.&n;&t;&t; */
id|put_user
c_func
(paren
l_int|0
comma
id|tidptr
)paren
suffix:semicolon
id|sys_futex
c_func
(paren
id|tidptr
comma
id|FUTEX_WAKE
comma
l_int|1
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
DECL|function|copy_mm
r_static
r_int
id|copy_mm
c_func
(paren
r_int
r_int
id|clone_flags
comma
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
comma
op_star
id|oldmm
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|tsk-&gt;min_flt
op_assign
id|tsk-&gt;maj_flt
op_assign
l_int|0
suffix:semicolon
id|tsk-&gt;cmin_flt
op_assign
id|tsk-&gt;cmaj_flt
op_assign
l_int|0
suffix:semicolon
id|tsk-&gt;nswap
op_assign
id|tsk-&gt;cnswap
op_assign
l_int|0
suffix:semicolon
id|tsk-&gt;mm
op_assign
l_int|NULL
suffix:semicolon
id|tsk-&gt;active_mm
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Are we cloning a kernel thread?&n;&t; *&n;&t; * We need to steal a active VM for that..&n;&t; */
id|oldmm
op_assign
id|current-&gt;mm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|oldmm
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|clone_flags
op_amp
id|CLONE_VM
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|oldmm-&gt;mm_users
)paren
suffix:semicolon
id|mm
op_assign
id|oldmm
suffix:semicolon
multiline_comment|/*&n;&t;&t; * There are cases where the PTL is held to ensure no&n;&t;&t; * new threads start up in user mode using an mm, which&n;&t;&t; * allows optimizing out ipis; the tlb_gather_mmu code&n;&t;&t; * is an example.&n;&t;&t; */
id|spin_unlock_wait
c_func
(paren
op_amp
id|oldmm-&gt;page_table_lock
)paren
suffix:semicolon
r_goto
id|good_mm
suffix:semicolon
)brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|mm
op_assign
id|allocate_mm
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mm
)paren
r_goto
id|fail_nomem
suffix:semicolon
multiline_comment|/* Copy the current MM stuff.. */
id|memcpy
c_func
(paren
id|mm
comma
id|oldmm
comma
r_sizeof
(paren
op_star
id|mm
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mm_init
c_func
(paren
id|mm
)paren
)paren
r_goto
id|fail_nomem
suffix:semicolon
r_if
c_cond
(paren
id|init_new_context
c_func
(paren
id|tsk
comma
id|mm
)paren
)paren
r_goto
id|free_pt
suffix:semicolon
id|retval
op_assign
id|dup_mmap
c_func
(paren
id|mm
comma
id|oldmm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|free_pt
suffix:semicolon
id|good_mm
suffix:colon
id|tsk-&gt;mm
op_assign
id|mm
suffix:semicolon
id|tsk-&gt;active_mm
op_assign
id|mm
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|free_pt
suffix:colon
id|mmput
c_func
(paren
id|mm
)paren
suffix:semicolon
id|fail_nomem
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|__copy_fs_struct
r_static
r_inline
r_struct
id|fs_struct
op_star
id|__copy_fs_struct
c_func
(paren
r_struct
id|fs_struct
op_star
id|old
)paren
(brace
r_struct
id|fs_struct
op_star
id|fs
op_assign
id|kmem_cache_alloc
c_func
(paren
id|fs_cachep
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t need to lock fs - think why ;-) */
r_if
c_cond
(paren
id|fs
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|fs-&gt;count
comma
l_int|1
)paren
suffix:semicolon
id|fs-&gt;lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
id|fs-&gt;umask
op_assign
id|old-&gt;umask
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|old-&gt;lock
)paren
suffix:semicolon
id|fs-&gt;rootmnt
op_assign
id|mntget
c_func
(paren
id|old-&gt;rootmnt
)paren
suffix:semicolon
id|fs-&gt;root
op_assign
id|dget
c_func
(paren
id|old-&gt;root
)paren
suffix:semicolon
id|fs-&gt;pwdmnt
op_assign
id|mntget
c_func
(paren
id|old-&gt;pwdmnt
)paren
suffix:semicolon
id|fs-&gt;pwd
op_assign
id|dget
c_func
(paren
id|old-&gt;pwd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old-&gt;altroot
)paren
(brace
id|fs-&gt;altrootmnt
op_assign
id|mntget
c_func
(paren
id|old-&gt;altrootmnt
)paren
suffix:semicolon
id|fs-&gt;altroot
op_assign
id|dget
c_func
(paren
id|old-&gt;altroot
)paren
suffix:semicolon
)brace
r_else
(brace
id|fs-&gt;altrootmnt
op_assign
l_int|NULL
suffix:semicolon
id|fs-&gt;altroot
op_assign
l_int|NULL
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|old-&gt;lock
)paren
suffix:semicolon
)brace
r_return
id|fs
suffix:semicolon
)brace
DECL|function|copy_fs_struct
r_struct
id|fs_struct
op_star
id|copy_fs_struct
c_func
(paren
r_struct
id|fs_struct
op_star
id|old
)paren
(brace
r_return
id|__copy_fs_struct
c_func
(paren
id|old
)paren
suffix:semicolon
)brace
DECL|function|copy_fs
r_static
r_inline
r_int
id|copy_fs
c_func
(paren
r_int
r_int
id|clone_flags
comma
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_if
c_cond
(paren
id|clone_flags
op_amp
id|CLONE_FS
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|current-&gt;fs-&gt;count
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|tsk-&gt;fs
op_assign
id|__copy_fs_struct
c_func
(paren
id|current-&gt;fs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tsk-&gt;fs
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|count_open_files
r_static
r_int
id|count_open_files
c_func
(paren
r_struct
id|files_struct
op_star
id|files
comma
r_int
id|size
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Find the last open fd */
r_for
c_loop
(paren
id|i
op_assign
id|size
op_div
(paren
l_int|8
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|files-&gt;open_fds-&gt;fds_bits
(braket
op_decrement
id|i
)braket
)paren
r_break
suffix:semicolon
)brace
id|i
op_assign
(paren
id|i
op_plus
l_int|1
)paren
op_star
l_int|8
op_star
r_sizeof
(paren
r_int
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|copy_files
r_static
r_int
id|copy_files
c_func
(paren
r_int
r_int
id|clone_flags
comma
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_struct
id|files_struct
op_star
id|oldf
comma
op_star
id|newf
suffix:semicolon
r_struct
id|file
op_star
op_star
id|old_fds
comma
op_star
op_star
id|new_fds
suffix:semicolon
r_int
id|open_files
comma
id|nfds
comma
id|size
comma
id|i
comma
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * A background process may not have any files ...&n;&t; */
id|oldf
op_assign
id|current-&gt;files
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|oldf
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|clone_flags
op_amp
id|CLONE_FILES
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|oldf-&gt;count
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|tsk-&gt;files
op_assign
l_int|NULL
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|newf
op_assign
id|kmem_cache_alloc
c_func
(paren
id|files_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newf
)paren
r_goto
id|out
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|newf-&gt;count
comma
l_int|1
)paren
suffix:semicolon
id|newf-&gt;file_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|newf-&gt;next_fd
op_assign
l_int|0
suffix:semicolon
id|newf-&gt;max_fds
op_assign
id|NR_OPEN_DEFAULT
suffix:semicolon
id|newf-&gt;max_fdset
op_assign
id|__FD_SETSIZE
suffix:semicolon
id|newf-&gt;close_on_exec
op_assign
op_amp
id|newf-&gt;close_on_exec_init
suffix:semicolon
id|newf-&gt;open_fds
op_assign
op_amp
id|newf-&gt;open_fds_init
suffix:semicolon
id|newf-&gt;fd
op_assign
op_amp
id|newf-&gt;fd_array
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* We don&squot;t yet have the oldf readlock, but even if the old&n;           fdset gets grown now, we&squot;ll only copy up to &quot;size&quot; fds */
id|size
op_assign
id|oldf-&gt;max_fdset
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|__FD_SETSIZE
)paren
(brace
id|newf-&gt;max_fdset
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|newf-&gt;file_lock
)paren
suffix:semicolon
id|error
op_assign
id|expand_fdset
c_func
(paren
id|newf
comma
id|size
op_minus
l_int|1
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|newf-&gt;file_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out_release
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|oldf-&gt;file_lock
)paren
suffix:semicolon
id|open_files
op_assign
id|count_open_files
c_func
(paren
id|oldf
comma
id|size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check whether we need to allocate a larger fd array.&n;&t; * Note: we&squot;re not a clone task, so the open count won&squot;t&n;&t; * change.&n;&t; */
id|nfds
op_assign
id|NR_OPEN_DEFAULT
suffix:semicolon
r_if
c_cond
(paren
id|open_files
OG
id|nfds
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|oldf-&gt;file_lock
)paren
suffix:semicolon
id|newf-&gt;max_fds
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|newf-&gt;file_lock
)paren
suffix:semicolon
id|error
op_assign
id|expand_fd_array
c_func
(paren
id|newf
comma
id|open_files
op_minus
l_int|1
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|newf-&gt;file_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out_release
suffix:semicolon
id|nfds
op_assign
id|newf-&gt;max_fds
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|oldf-&gt;file_lock
)paren
suffix:semicolon
)brace
id|old_fds
op_assign
id|oldf-&gt;fd
suffix:semicolon
id|new_fds
op_assign
id|newf-&gt;fd
suffix:semicolon
id|memcpy
c_func
(paren
id|newf-&gt;open_fds-&gt;fds_bits
comma
id|oldf-&gt;open_fds-&gt;fds_bits
comma
id|open_files
op_div
l_int|8
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|newf-&gt;close_on_exec-&gt;fds_bits
comma
id|oldf-&gt;close_on_exec-&gt;fds_bits
comma
id|open_files
op_div
l_int|8
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|open_files
suffix:semicolon
id|i
op_ne
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_struct
id|file
op_star
id|f
op_assign
op_star
id|old_fds
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|f
)paren
id|get_file
c_func
(paren
id|f
)paren
suffix:semicolon
op_star
id|new_fds
op_increment
op_assign
id|f
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|oldf-&gt;file_lock
)paren
suffix:semicolon
multiline_comment|/* compute the remainder to be cleared */
id|size
op_assign
(paren
id|newf-&gt;max_fds
op_minus
id|open_files
)paren
op_star
r_sizeof
(paren
r_struct
id|file
op_star
)paren
suffix:semicolon
multiline_comment|/* This is long word aligned thus could use a optimized version */
id|memset
c_func
(paren
id|new_fds
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newf-&gt;max_fdset
OG
id|open_files
)paren
(brace
r_int
id|left
op_assign
(paren
id|newf-&gt;max_fdset
op_minus
id|open_files
)paren
op_div
l_int|8
suffix:semicolon
r_int
id|start
op_assign
id|open_files
op_div
(paren
l_int|8
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|newf-&gt;open_fds-&gt;fds_bits
(braket
id|start
)braket
comma
l_int|0
comma
id|left
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|newf-&gt;close_on_exec-&gt;fds_bits
(braket
id|start
)braket
comma
l_int|0
comma
id|left
)paren
suffix:semicolon
)brace
id|tsk-&gt;files
op_assign
id|newf
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
id|out_release
suffix:colon
id|free_fdset
(paren
id|newf-&gt;close_on_exec
comma
id|newf-&gt;max_fdset
)paren
suffix:semicolon
id|free_fdset
(paren
id|newf-&gt;open_fds
comma
id|newf-&gt;max_fdset
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|files_cachep
comma
id|newf
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|function|copy_sighand
r_static
r_inline
r_int
id|copy_sighand
c_func
(paren
r_int
r_int
id|clone_flags
comma
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_struct
id|sighand_struct
op_star
id|sig
suffix:semicolon
r_if
c_cond
(paren
id|clone_flags
op_amp
(paren
id|CLONE_SIGHAND
op_or
id|CLONE_THREAD
)paren
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|current-&gt;sighand-&gt;count
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sig
op_assign
id|kmem_cache_alloc
c_func
(paren
id|sighand_cachep
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|tsk-&gt;sighand
op_assign
id|sig
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sig
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|sig-&gt;siglock
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|sig-&gt;count
comma
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|sig-&gt;action
comma
id|current-&gt;sighand-&gt;action
comma
r_sizeof
(paren
id|sig-&gt;action
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|copy_signal
r_static
r_inline
r_int
id|copy_signal
c_func
(paren
r_int
r_int
id|clone_flags
comma
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_struct
id|signal_struct
op_star
id|sig
suffix:semicolon
r_if
c_cond
(paren
id|clone_flags
op_amp
id|CLONE_THREAD
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|current-&gt;signal-&gt;count
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sig
op_assign
id|kmem_cache_alloc
c_func
(paren
id|signal_cachep
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|tsk-&gt;signal
op_assign
id|sig
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sig
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|sig-&gt;count
comma
l_int|1
)paren
suffix:semicolon
id|sig-&gt;group_exit
op_assign
l_int|0
suffix:semicolon
id|sig-&gt;group_exit_code
op_assign
l_int|0
suffix:semicolon
id|sig-&gt;group_exit_task
op_assign
l_int|NULL
suffix:semicolon
id|sig-&gt;group_stop_count
op_assign
l_int|0
suffix:semicolon
id|sig-&gt;curr_target
op_assign
l_int|NULL
suffix:semicolon
id|init_sigpending
c_func
(paren
op_amp
id|sig-&gt;shared_pending
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|copy_flags
r_static
r_inline
r_void
id|copy_flags
c_func
(paren
r_int
r_int
id|clone_flags
comma
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_int
r_int
id|new_flags
op_assign
id|p-&gt;flags
suffix:semicolon
id|new_flags
op_and_assign
op_complement
id|PF_SUPERPRIV
suffix:semicolon
id|new_flags
op_or_assign
id|PF_FORKNOEXEC
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|clone_flags
op_amp
id|CLONE_PTRACE
)paren
)paren
id|p-&gt;ptrace
op_assign
l_int|0
suffix:semicolon
id|p-&gt;flags
op_assign
id|new_flags
suffix:semicolon
)brace
DECL|function|sys_set_tid_address
id|asmlinkage
r_int
id|sys_set_tid_address
c_func
(paren
r_int
id|__user
op_star
id|tidptr
)paren
(brace
id|current-&gt;clear_child_tid
op_assign
id|tidptr
suffix:semicolon
r_return
id|current-&gt;pid
suffix:semicolon
)brace
multiline_comment|/*&n; * This creates a new process as a copy of the old one,&n; * but does not actually start it yet.&n; *&n; * It copies the registers, and all the appropriate&n; * parts of the process environment (as per the clone&n; * flags). The actual kick-off is left to the caller.&n; */
DECL|function|copy_process
r_struct
id|task_struct
op_star
id|copy_process
c_func
(paren
r_int
r_int
id|clone_flags
comma
r_int
r_int
id|stack_start
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|stack_size
comma
r_int
id|__user
op_star
id|parent_tidptr
comma
r_int
id|__user
op_star
id|child_tidptr
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|clone_flags
op_amp
(paren
id|CLONE_NEWNS
op_or
id|CLONE_FS
)paren
)paren
op_eq
(paren
id|CLONE_NEWNS
op_or
id|CLONE_FS
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Thread groups must share signals as well, and detached threads&n;&t; * can only be started up within the thread group.&n;&t; */
r_if
c_cond
(paren
(paren
id|clone_flags
op_amp
id|CLONE_THREAD
)paren
op_logical_and
op_logical_neg
(paren
id|clone_flags
op_amp
id|CLONE_SIGHAND
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|clone_flags
op_amp
id|CLONE_DETACHED
)paren
op_logical_and
op_logical_neg
(paren
id|clone_flags
op_amp
id|CLONE_THREAD
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|retval
op_assign
id|security_task_create
c_func
(paren
id|clone_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|fork_out
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|p
op_assign
id|dup_task_struct
c_func
(paren
id|current
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_goto
id|fork_out
suffix:semicolon
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|p-&gt;user-&gt;processes
)paren
op_ge
id|p-&gt;rlim
(braket
id|RLIMIT_NPROC
)braket
dot
id|rlim_cur
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RESOURCE
)paren
)paren
r_goto
id|bad_fork_free
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|p-&gt;user-&gt;__count
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|p-&gt;user-&gt;processes
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If multiple threads are within copy_process(), then this check&n;&t; * triggers too late. This doesn&squot;t hurt, the check is only there&n;&t; * to stop root fork bombs.&n;&t; */
r_if
c_cond
(paren
id|nr_threads
op_ge
id|max_threads
)paren
r_goto
id|bad_fork_cleanup_count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|try_module_get
c_func
(paren
id|p-&gt;thread_info-&gt;exec_domain-&gt;module
)paren
)paren
r_goto
id|bad_fork_cleanup_count
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;binfmt
op_logical_and
op_logical_neg
id|try_module_get
c_func
(paren
id|p-&gt;binfmt-&gt;module
)paren
)paren
r_goto
id|bad_fork_cleanup_put_domain
suffix:semicolon
macro_line|#ifdef CONFIG_PREEMPT
multiline_comment|/*&n;&t; * schedule_tail drops this_rq()-&gt;lock so we compensate with a count&n;&t; * of 1.  Also, we want to start with kernel preemption disabled.&n;&t; */
id|p-&gt;thread_info-&gt;preempt_count
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|p-&gt;did_exec
op_assign
l_int|0
suffix:semicolon
id|p-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|copy_flags
c_func
(paren
id|clone_flags
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clone_flags
op_amp
id|CLONE_IDLETASK
)paren
id|p-&gt;pid
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|p-&gt;pid
op_assign
id|alloc_pidmap
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;pid
op_eq
op_minus
l_int|1
)paren
r_goto
id|bad_fork_cleanup
suffix:semicolon
)brace
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|clone_flags
op_amp
id|CLONE_PARENT_SETTID
)paren
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|p-&gt;pid
comma
id|parent_tidptr
)paren
)paren
r_goto
id|bad_fork_cleanup
suffix:semicolon
id|p-&gt;proc_dentry
op_assign
l_int|NULL
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|p-&gt;run_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|p-&gt;children
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|p-&gt;sibling
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|p-&gt;posix_timers
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|p-&gt;wait_chldexit
)paren
suffix:semicolon
id|p-&gt;vfork_done
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|p-&gt;alloc_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|p-&gt;switch_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|p-&gt;proc_lock
)paren
suffix:semicolon
id|clear_tsk_thread_flag
c_func
(paren
id|p
comma
id|TIF_SIGPENDING
)paren
suffix:semicolon
id|init_sigpending
c_func
(paren
op_amp
id|p-&gt;pending
)paren
suffix:semicolon
id|p-&gt;it_real_value
op_assign
id|p-&gt;it_virt_value
op_assign
id|p-&gt;it_prof_value
op_assign
l_int|0
suffix:semicolon
id|p-&gt;it_real_incr
op_assign
id|p-&gt;it_virt_incr
op_assign
id|p-&gt;it_prof_incr
op_assign
l_int|0
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|p-&gt;real_timer
)paren
suffix:semicolon
id|p-&gt;real_timer.data
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
id|p-&gt;leader
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* session leadership doesn&squot;t inherit */
id|p-&gt;tty_old_pgrp
op_assign
l_int|0
suffix:semicolon
id|p-&gt;utime
op_assign
id|p-&gt;stime
op_assign
l_int|0
suffix:semicolon
id|p-&gt;cutime
op_assign
id|p-&gt;cstime
op_assign
l_int|0
suffix:semicolon
id|p-&gt;array
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;lock_depth
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* -1 = no lock */
id|p-&gt;start_time
op_assign
id|get_jiffies_64
c_func
(paren
)paren
suffix:semicolon
id|p-&gt;security
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;io_context
op_assign
l_int|NULL
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|security_task_alloc
c_func
(paren
id|p
)paren
)paren
)paren
r_goto
id|bad_fork_cleanup
suffix:semicolon
multiline_comment|/* copy all the process information */
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|copy_semundo
c_func
(paren
id|clone_flags
comma
id|p
)paren
)paren
)paren
r_goto
id|bad_fork_cleanup_security
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|copy_files
c_func
(paren
id|clone_flags
comma
id|p
)paren
)paren
)paren
r_goto
id|bad_fork_cleanup_semundo
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|copy_fs
c_func
(paren
id|clone_flags
comma
id|p
)paren
)paren
)paren
r_goto
id|bad_fork_cleanup_files
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|copy_sighand
c_func
(paren
id|clone_flags
comma
id|p
)paren
)paren
)paren
r_goto
id|bad_fork_cleanup_fs
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|copy_signal
c_func
(paren
id|clone_flags
comma
id|p
)paren
)paren
)paren
r_goto
id|bad_fork_cleanup_sighand
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|copy_mm
c_func
(paren
id|clone_flags
comma
id|p
)paren
)paren
)paren
r_goto
id|bad_fork_cleanup_signal
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|copy_namespace
c_func
(paren
id|clone_flags
comma
id|p
)paren
)paren
)paren
r_goto
id|bad_fork_cleanup_mm
suffix:semicolon
id|retval
op_assign
id|copy_thread
c_func
(paren
l_int|0
comma
id|clone_flags
comma
id|stack_start
comma
id|stack_size
comma
id|p
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|bad_fork_cleanup_namespace
suffix:semicolon
id|p-&gt;set_child_tid
op_assign
(paren
id|clone_flags
op_amp
id|CLONE_CHILD_SETTID
)paren
ques
c_cond
id|child_tidptr
suffix:colon
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Clear TID on mm_release()?&n;&t; */
id|p-&gt;clear_child_tid
op_assign
(paren
id|clone_flags
op_amp
id|CLONE_CHILD_CLEARTID
)paren
ques
c_cond
id|child_tidptr
suffix:colon
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Syscall tracing should be turned off in the child regardless&n;&t; * of CLONE_PTRACE.&n;&t; */
id|clear_tsk_thread_flag
c_func
(paren
id|p
comma
id|TIF_SYSCALL_TRACE
)paren
suffix:semicolon
multiline_comment|/* Our parent execution domain becomes current domain&n;&t;   These must match for thread signalling to apply */
id|p-&gt;parent_exec_id
op_assign
id|p-&gt;self_exec_id
suffix:semicolon
multiline_comment|/* ok, now we should be set up.. */
r_if
c_cond
(paren
id|clone_flags
op_amp
id|CLONE_DETACHED
)paren
id|p-&gt;exit_signal
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
id|p-&gt;exit_signal
op_assign
id|clone_flags
op_amp
id|CSIGNAL
suffix:semicolon
id|p-&gt;pdeath_signal
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Share the timeslice between parent and child, thus the&n;&t; * total amount of pending timeslices in the system doesn&squot;t change,&n;&t; * resulting in more scheduling fairness.&n;&t; */
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|p-&gt;time_slice
op_assign
(paren
id|current-&gt;time_slice
op_plus
l_int|1
)paren
op_rshift
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * The remainder of the first timeslice might be recovered by&n;&t; * the parent if the child exits early enough.&n;&t; */
id|p-&gt;first_time_slice
op_assign
l_int|1
suffix:semicolon
id|current-&gt;time_slice
op_rshift_assign
l_int|1
suffix:semicolon
id|p-&gt;last_run
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;time_slice
)paren
(brace
multiline_comment|/*&n;&t; &t; * This case is rare, it happens when the parent has only&n;&t; &t; * a single jiffy left from its timeslice. Taking the&n;&t;&t; * runqueue lock is not a problem.&n;&t;&t; */
id|current-&gt;time_slice
op_assign
l_int|1
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
id|scheduler_tick
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, add it to the run-queues and make it&n;&t; * visible to the rest of the system.&n;&t; *&n;&t; * Let it rip!&n;&t; */
id|p-&gt;tgid
op_assign
id|p-&gt;pid
suffix:semicolon
id|p-&gt;group_leader
op_assign
id|p
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|p-&gt;ptrace_children
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|p-&gt;ptrace_list
)paren
suffix:semicolon
multiline_comment|/* Need tasklist lock for parent etc handling! */
id|write_lock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check for pending SIGKILL! The new thread should not be allowed&n;&t; * to slip out of an OOM kill. (or normal SIGKILL.)&n;&t; */
r_if
c_cond
(paren
id|sigismember
c_func
(paren
op_amp
id|current-&gt;pending.signal
comma
id|SIGKILL
)paren
)paren
(brace
id|write_unlock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINTR
suffix:semicolon
r_goto
id|bad_fork_cleanup_namespace
suffix:semicolon
)brace
multiline_comment|/* CLONE_PARENT re-uses the old parent */
r_if
c_cond
(paren
id|clone_flags
op_amp
id|CLONE_PARENT
)paren
id|p-&gt;real_parent
op_assign
id|current-&gt;real_parent
suffix:semicolon
r_else
id|p-&gt;real_parent
op_assign
id|current
suffix:semicolon
id|p-&gt;parent
op_assign
id|p-&gt;real_parent
suffix:semicolon
r_if
c_cond
(paren
id|clone_flags
op_amp
id|CLONE_THREAD
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|current-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Important: if an exit-all has been started then&n;&t;&t; * do not create this new thread - the whole thread&n;&t;&t; * group is supposed to exit anyway.&n;&t;&t; */
r_if
c_cond
(paren
id|current-&gt;signal-&gt;group_exit
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|current-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_goto
id|bad_fork_cleanup_namespace
suffix:semicolon
)brace
id|p-&gt;tgid
op_assign
id|current-&gt;tgid
suffix:semicolon
id|p-&gt;group_leader
op_assign
id|current-&gt;group_leader
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal-&gt;group_stop_count
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * There is an all-stop in progress for the group.&n;&t;&t;&t; * We ourselves will stop as soon as we check signals.&n;&t;&t;&t; * Make the new thread part of that group stop too.&n;&t;&t;&t; */
id|current-&gt;signal-&gt;group_stop_count
op_increment
suffix:semicolon
id|set_tsk_thread_flag
c_func
(paren
id|p
comma
id|TIF_SIGPENDING
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|current-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
)brace
id|SET_LINKS
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;ptrace
op_amp
id|PT_PTRACED
)paren
id|__ptrace_link
c_func
(paren
id|p
comma
id|current-&gt;parent
)paren
suffix:semicolon
id|attach_pid
c_func
(paren
id|p
comma
id|PIDTYPE_PID
comma
id|p-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thread_group_leader
c_func
(paren
id|p
)paren
)paren
(brace
id|attach_pid
c_func
(paren
id|p
comma
id|PIDTYPE_TGID
comma
id|p-&gt;tgid
)paren
suffix:semicolon
id|attach_pid
c_func
(paren
id|p
comma
id|PIDTYPE_PGID
comma
id|p-&gt;pgrp
)paren
suffix:semicolon
id|attach_pid
c_func
(paren
id|p
comma
id|PIDTYPE_SID
comma
id|p-&gt;session
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;pid
)paren
id|__get_cpu_var
c_func
(paren
id|process_counts
)paren
op_increment
suffix:semicolon
)brace
r_else
id|link_pid
c_func
(paren
id|p
comma
id|p-&gt;pids
op_plus
id|PIDTYPE_TGID
comma
op_amp
id|p-&gt;group_leader-&gt;pids
(braket
id|PIDTYPE_TGID
)braket
dot
id|pid
)paren
suffix:semicolon
id|nr_threads
op_increment
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
id|fork_out
suffix:colon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|ERR_PTR
c_func
(paren
id|retval
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
id|bad_fork_cleanup_namespace
suffix:colon
id|exit_namespace
c_func
(paren
id|p
)paren
suffix:semicolon
id|bad_fork_cleanup_mm
suffix:colon
id|exit_mm
c_func
(paren
id|p
)paren
suffix:semicolon
id|bad_fork_cleanup_signal
suffix:colon
id|exit_signal
c_func
(paren
id|p
)paren
suffix:semicolon
id|bad_fork_cleanup_sighand
suffix:colon
id|exit_sighand
c_func
(paren
id|p
)paren
suffix:semicolon
id|bad_fork_cleanup_fs
suffix:colon
id|exit_fs
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* blocking */
id|bad_fork_cleanup_files
suffix:colon
id|exit_files
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* blocking */
id|bad_fork_cleanup_semundo
suffix:colon
id|exit_sem
c_func
(paren
id|p
)paren
suffix:semicolon
id|bad_fork_cleanup_security
suffix:colon
id|security_task_free
c_func
(paren
id|p
)paren
suffix:semicolon
id|bad_fork_cleanup
suffix:colon
r_if
c_cond
(paren
id|p-&gt;pid
OG
l_int|0
)paren
id|free_pidmap
c_func
(paren
id|p-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;binfmt
)paren
id|module_put
c_func
(paren
id|p-&gt;binfmt-&gt;module
)paren
suffix:semicolon
id|bad_fork_cleanup_put_domain
suffix:colon
id|module_put
c_func
(paren
id|p-&gt;thread_info-&gt;exec_domain-&gt;module
)paren
suffix:semicolon
id|bad_fork_cleanup_count
suffix:colon
id|atomic_dec
c_func
(paren
op_amp
id|p-&gt;user-&gt;processes
)paren
suffix:semicolon
id|free_uid
c_func
(paren
id|p-&gt;user
)paren
suffix:semicolon
id|bad_fork_free
suffix:colon
id|free_task
c_func
(paren
id|p
)paren
suffix:semicolon
r_goto
id|fork_out
suffix:semicolon
)brace
DECL|function|fork_traceflag
r_static
r_inline
r_int
id|fork_traceflag
(paren
r_int
id|clone_flags
)paren
(brace
r_if
c_cond
(paren
id|clone_flags
op_amp
(paren
id|CLONE_UNTRACED
op_or
id|CLONE_IDLETASK
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|clone_flags
op_amp
id|CLONE_VFORK
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;ptrace
op_amp
id|PT_TRACE_VFORK
)paren
r_return
id|PTRACE_EVENT_VFORK
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|clone_flags
op_amp
id|CSIGNAL
)paren
op_ne
id|SIGCHLD
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;ptrace
op_amp
id|PT_TRACE_CLONE
)paren
r_return
id|PTRACE_EVENT_CLONE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|current-&gt;ptrace
op_amp
id|PT_TRACE_FORK
)paren
r_return
id|PTRACE_EVENT_FORK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Ok, this is the main fork-routine.&n; *&n; * It copies the process, and if successful kick-starts&n; * it and waits for it to finish using the VM if required.&n; */
DECL|function|do_fork
r_int
id|do_fork
c_func
(paren
r_int
r_int
id|clone_flags
comma
r_int
r_int
id|stack_start
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|stack_size
comma
r_int
id|__user
op_star
id|parent_tidptr
comma
r_int
id|__user
op_star
id|child_tidptr
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|trace
op_assign
l_int|0
suffix:semicolon
r_int
id|pid
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|current-&gt;ptrace
)paren
)paren
(brace
id|trace
op_assign
id|fork_traceflag
(paren
id|clone_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|trace
)paren
id|clone_flags
op_or_assign
id|CLONE_PTRACE
suffix:semicolon
)brace
id|p
op_assign
id|copy_process
c_func
(paren
id|clone_flags
comma
id|stack_start
comma
id|regs
comma
id|stack_size
comma
id|parent_tidptr
comma
id|child_tidptr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do this prior waking up the new thread - the thread pointer&n;&t; * might get invalid after that point, if the thread exits quickly.&n;&t; */
id|pid
op_assign
id|IS_ERR
c_func
(paren
id|p
)paren
ques
c_cond
id|PTR_ERR
c_func
(paren
id|p
)paren
suffix:colon
id|p-&gt;pid
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|p
)paren
)paren
(brace
r_struct
id|completion
id|vfork
suffix:semicolon
r_if
c_cond
(paren
id|clone_flags
op_amp
id|CLONE_VFORK
)paren
(brace
id|p-&gt;vfork_done
op_assign
op_amp
id|vfork
suffix:semicolon
id|init_completion
c_func
(paren
op_amp
id|vfork
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;ptrace
op_amp
id|PT_PTRACED
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We&squot;ll start up with an immediate SIGSTOP.&n;&t;&t;&t; */
id|sigaddset
c_func
(paren
op_amp
id|p-&gt;pending.signal
comma
id|SIGSTOP
)paren
suffix:semicolon
id|set_tsk_thread_flag
c_func
(paren
id|p
comma
id|TIF_SIGPENDING
)paren
suffix:semicolon
)brace
id|wake_up_forked_process
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* do this last */
op_increment
id|total_forks
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|trace
)paren
)paren
(brace
id|current-&gt;ptrace_message
op_assign
id|pid
suffix:semicolon
id|ptrace_notify
(paren
(paren
id|trace
op_lshift
l_int|8
)paren
op_or
id|SIGTRAP
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|clone_flags
op_amp
id|CLONE_VFORK
)paren
(brace
id|wait_for_completion
c_func
(paren
op_amp
id|vfork
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|current-&gt;ptrace
op_amp
id|PT_TRACE_VFORK_DONE
)paren
)paren
id|ptrace_notify
(paren
(paren
id|PTRACE_EVENT_VFORK_DONE
op_lshift
l_int|8
)paren
op_or
id|SIGTRAP
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/*&n;&t;&t;&t; * Let the child process run first, to avoid most of the&n;&t;&t;&t; * COW overhead when the child exec()s afterwards.&n;&t;&t;&t; */
id|set_need_resched
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|pid
suffix:semicolon
)brace
multiline_comment|/* SLAB cache for signal_struct structures (tsk-&gt;signal) */
DECL|variable|signal_cachep
id|kmem_cache_t
op_star
id|signal_cachep
suffix:semicolon
multiline_comment|/* SLAB cache for sighand_struct structures (tsk-&gt;sighand) */
DECL|variable|sighand_cachep
id|kmem_cache_t
op_star
id|sighand_cachep
suffix:semicolon
multiline_comment|/* SLAB cache for files_struct structures (tsk-&gt;files) */
DECL|variable|files_cachep
id|kmem_cache_t
op_star
id|files_cachep
suffix:semicolon
multiline_comment|/* SLAB cache for fs_struct structures (tsk-&gt;fs) */
DECL|variable|fs_cachep
id|kmem_cache_t
op_star
id|fs_cachep
suffix:semicolon
multiline_comment|/* SLAB cache for vm_area_struct structures */
DECL|variable|vm_area_cachep
id|kmem_cache_t
op_star
id|vm_area_cachep
suffix:semicolon
multiline_comment|/* SLAB cache for mm_struct structures (tsk-&gt;mm) */
DECL|variable|mm_cachep
id|kmem_cache_t
op_star
id|mm_cachep
suffix:semicolon
DECL|function|proc_caches_init
r_void
id|__init
id|proc_caches_init
c_func
(paren
r_void
)paren
(brace
id|sighand_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;sighand_cache&quot;
comma
r_sizeof
(paren
r_struct
id|sighand_struct
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sighand_cachep
)paren
id|panic
c_func
(paren
l_string|&quot;Cannot create sighand SLAB cache&quot;
)paren
suffix:semicolon
id|signal_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;signal_cache&quot;
comma
r_sizeof
(paren
r_struct
id|signal_struct
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|signal_cachep
)paren
id|panic
c_func
(paren
l_string|&quot;Cannot create signal SLAB cache&quot;
)paren
suffix:semicolon
id|files_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;files_cache&quot;
comma
r_sizeof
(paren
r_struct
id|files_struct
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|files_cachep
)paren
id|panic
c_func
(paren
l_string|&quot;Cannot create files SLAB cache&quot;
)paren
suffix:semicolon
id|fs_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;fs_cache&quot;
comma
r_sizeof
(paren
r_struct
id|fs_struct
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fs_cachep
)paren
id|panic
c_func
(paren
l_string|&quot;Cannot create fs_struct SLAB cache&quot;
)paren
suffix:semicolon
id|vm_area_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;vm_area_struct&quot;
comma
r_sizeof
(paren
r_struct
id|vm_area_struct
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vm_area_cachep
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;vma_init: Cannot alloc vm_area_struct SLAB cache&quot;
)paren
suffix:semicolon
)brace
id|mm_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;mm_struct&quot;
comma
r_sizeof
(paren
r_struct
id|mm_struct
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mm_cachep
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;vma_init: Cannot alloc mm_struct SLAB cache&quot;
)paren
suffix:semicolon
)brace
)brace
eof
